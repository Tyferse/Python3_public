# Программа для создания резервной копии указанных файлов v.1.0

import os
import time

# 1. Файлы и каталоги, которые необходимо скопировать,
# собираются в список.

print('Укажите путь к копируемым файлам (например, \\C:\\User '
      'или в двойных кавычках "\\C:\\Program files", '
      'если в файле есть пробелы),\n'
      'а когда закончите, напишите "---": ')

filer = []

'''
 Мы использовали модули os и time, предварительно импортировав их.
Далее мы указали файлы и каталоги для резервного копирования 
в списке filer.
'''

while True:
    fl = input('')
    if fl == '---':
        for f in filer:
            if f.startswith('C:\\'):
                pass
            else:
                filer.remove(f)
                
        break
        
    filer.append(fl)

# 2. Резервные копии должны храниться в основном каталоге резерва.
target_dir = 'D:\\Backup'

'''
 Каталог назначения – это каталог, 
в котором мы сохраняем все резервные копии, 
и он указывается в переменной target_dir.
'''

# 3. Файлы помещаются в zip-архив.
# 4. Именем для zip-архива служит текущая дата и время.
target = target_dir + os.sep + time.strftime('%Y%m%d%H%M%S') + '.zip'


'''
 Именем zip-архива, который мы создаём, будет текущая дата и время, 
которые генерируются при помощи функции time.strftime(). 
У него будет расширение .zip, 
и храниться он будет в каталоге target_dir.

 Обратите внимание на употребление переменной os.sep – 
она содержит разделитель пути для конкретной операционной системы, 
т.е. он будет '/' в GNU/Linux и Unix3, '\\' в Windows и ':' в Mac OS.
Использование os.sep вместо этих символов 
напрямую делает программу переносимой, 
и она сможет работать на всех этих операционных системах.

 Функция time.strftime() принимает в качестве аргумента
формат вывода времени, например, такой, как мы указали в программе выше. 
Символ формата %Y будет замещён годом и столетием. 
Символ %m будет замещён месяцем в форме числа от 01 до 12, и так далее.
'''

# 5. Используем команду "zip" для помещения файлов в zip-архив
zip_command = "\"C:\Program Files\\7-Zip\\7z.exe\" \
a -tzip -ssw -mx1 -r0 {0} {1}".format(target, ' '.join(filer))

'''
 Имя конечного zip-файла мы создаём при помощи оператора,
который соединяет строки, т.е. объединяет две строки и возвращает новую.
После этого мы создаём строку zip_command, которая содержит команду, 
которую мы намерены выполнить.

 За параметрами следует имя создаваемого zip-архива, 
за которым указывается список файлов 
и каталогов для резервного копирования. 
Мы превращаем список source в строку, 
используя уже знакомый нам метод join.
'''

# Запускаем создание резервной копии
print(zip_command)
print(os.system(zip_command))
if os.system(zip_command) == 0:
    print('Резервная копия успешно создана в', target)
else:
    print('Создание резервной копии НЕ УДАЛОСЬ')

'''
 Затем мы, наконец, выполняем команду при помощи функции os.system, 
которая запускает команду так, как будто она была запущена из системы, 
т.е. из командной оболочки. Она возвращает 0, 
если команда выполнена успешно, 
в противном случае она возвращает код ошибки.

 В зависимости от вывода команды, 
мы печатаем соответствующее сообщение о том, 
успешным было создание резервных копий или нет.
'''

# Исключения

"""
 Попытаемся считать что-либо от пользователя. Нажмите Сtrl-D
(или Ctrl+Z в Windows) и посмотрите, что произойдёт.

\>>> s = input('Введите что-нибудь --> ')
Введите что-нибудь -->
Traceback (most recent call last):
    File "<pyshell#2>", line 1, in <module>
        s = input('Введите что-нибудь --> ')
EOFError: EOF when reading a line
"""

try:
    text = input('Введите что-нибудь --> ')
except EOFError:
    print('Ну зачем вы сделали мне EOF?')
except KeyboardInterrupt:
    print('Вы отменили операцию.')
else:
    print('Вы ввели {0}'.format(text))


# Вызов исключений


class ShortInputException(Exception):
    """Пользовательский класс исключения."""
    def __init__(self, length, atleast):
        Exception.__init__(self)
        self.length = length
        self.atleast = atleast


try:
    text = input('Введите что-нибудь --> ')
    if len(text) < 3:
        raise ShortInputException(len(text), 3)
# Здесь может происходить обычная работа
except EOFError:
    print('Ну зачем вы сделали мне EOF?')
except ShortInputException as ex:
    print(('ShortInputException: Длина введённой строки -- {0}; '
          'ожидалось, как минимум, {1}').format(ex.length, ex.atleast))
else:
    print('Не было исключений.')

'''
 Здесь мы создаём наш собственный тип исключения. 
Этот новый тип исключения называется ShortInputException. 
Он содержит два поля: length, хранящее длину введённого текста,
и atleast, указывающее, 
какую минимальную длину текста ожидала программа.

 В пункте except мы указываем класс ошибки ShortInputException, 
который будет сохранён как переменная ex, 
содержащая соответствующий объект ошибки/исключения. 
Это аналогично параметрам и аргументам при вызове функции.
Внутри этого пункта except мы используем поля length 
и atleast объекта исключения 
для вывода необходимых сообщений пользователю.
'''

# Try .. Finally

'''
 Представим, что в программе происходит чтение файла 
и необходимо убедиться, что объект файла был корректно закрыт 
и что не возникло никакого исключения. 
Этого можно достичь с применением блока finally.
'''

import time


try:
    f1 = open('poem.txt')
    while True:  # наш обычный способ читать файлы
        line = f1.readline()
        if len(line) == 0:
            break
            
        print(line, end='')
        time.sleep(2)  # Пусть подождёт некоторое время
except KeyboardInterrupt:
    print('!! Вы отменили чтение файла.')
finally:
    f1.close()
    
print('(Очистка: Закрытие файла)')

'''
 Здесь мы производим обычные операции чтения из файла, 
но в данном случае добавляем двухсекундный сон 
после вывода каждой строки при помощи функции time.sleep, 
чтобы программа выполнялась медленно 
(ведь Python очень быстр от природы). 
Во время выполнения программы нажмите ctrl-d,
чтобы прервать/отменить выполнение программы.

 Пронаблюдайте, как при этом выдаётся исключение KeyboardInterrupt, 
и программа выходит. Однако, прежде чем программа выйдет, 
выполняется пункт finally, и файловый объект будет всегда закрыт.
'''

'''
 Оператор with
 
 За кулисами происходит следующее. Существует некий протокол, 
используемый оператором with. Он считывает объект, 
возвращаемый оператором open. Назовём его в данном случае «thefile».

 Перед запуском блока кода, содержащегося в нём, 
оператор with всегда вызывает функцию thefile.__enter__, 
а также всегда вызывает thefile.__exit__ 
после завершения выполнения этого блока кода.

 Так что код, который мы бы написали в блоке finally,
будет автоматически обработан методом __exit__. 
Это избавляет нас от необходимости повторно 
в явном виде указывать операторы try..finally.
'''

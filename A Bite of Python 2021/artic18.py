# Дополнительно

# Передача кортежей

"""
 Хотелось ли вам когда-нибудь,
чтобы функция возвращала не один результат, а два? Это возможно.
Всё, что для этого нужно, – использовать кортеж.

\>>> def get_error_details():
... return (2, 'описание ошибки No2')
...
\>>> errnum, errstr = get_error_details()
\>>> errnum
2
\>>> errstr
'описание ошибки No2'

 Чтобы интерпретировать результат как «(a, <всё остальное>)»,
нужно просто поставить звёздочку,
как это делалось для параметров функций:

\>>> a, *b = [1, 2, 3, 4]
\>>> a
1
\>>> b
[2, 3, 4]

 Это также подразумевает, что поменять местами два значения в Python
быстрее всего можно так:

\>>> a = 5; b = 8
\>>> a, b = b, a
\>>> a, b
(8, 5)
"""


# Специальные методы

'''
 Специальные методы служат для того, 
чтобы имитировать поведение встроенных типов данных. Например, 
всё, что потребуется для использования операции индексирования x[индекс]
применительно к своему классу 
(в таком виде, как это делалось для списков и кортежей), 
это реализовать метод __getitem__(). Кстати, 
именно этот метод Python использует для самого класса list!

Имя Описание
__init__(self, …) - Этот метод вызывается прямо перед тем, 
                как вновь созданный 
                объект возвращается для использования.
__del__(self)     - Вызывается перед уничтожением объекта
__str__(self)     - Вызывается при использовании 
                 функции print или str().
__lt__(self, other) - Вызывается, когда используется 
                    оператор «меньше» (<). Существуют и аналогичные 
                    методы для всех операторов (+, >, и т.д.)
__getitem__(self, key) - Вызывается при использовании 
                      оператора индексирования x[индекс]
__len__(self)     - Вызывается при обращении к встроенной функции len()
                    для объекта-последовательности.
'''


# lambda-формы

'''
 Ключевое слово lambda используется для создания функций 
и возврата их значения во время выполнения программы. 
lambda принимает параметр, за которым следует одно выражение, 
которое становится телом функции, 
а значение этого выражения возвращается новой функцией.
'''

points = [{'x': 2, 'y': 3}, {'x': 4, 'y': 1}]
points.sort(key=lambda i: i['y'])
print(points)

'''
 Обратите внимание на то, что метод sort класса list 
может принимать параметр key, определяющий способ сортировки списка 
(обычно мы думаем только о сортировке по возрастанию или по убыванию). 
В данном случае мы хотим провести сортировку по собственному принципу, 
для чего нам необходимо написать соответствующую функцию. 
Но вместо того, чтобы создавать отдельный блок def для описания функции, 
которая будет использоваться только в этом месте, 
мы применяем лямбда-выражение.
'''


# Генераторы списков

'''
 Генераторы списков служат для создания новых списков 
на основе существующих. Представьте, что имеется список чисел, 
на основе которого требуется получить новый список, 
состоящий из всех чисел, умноженных на 2, но только при условии,
что само число больше 2. 
Генераторы списков подходят для таких задач как нельзя лучше.
'''

listone = [2, 3, 4]
listtwo = [2*i for i in listone if i > 2]
print(listtwo)


# Передача кортежей и словарей в функции

'''
 Для получения параметров, переданных функции, 
в виде кортежа или словаря, существуют специальные приставки
«*» или «**» соответственно. Это особенно полезно в случаях, 
когда функция может принимать переменное число параметров.
'''


def powersum(power, *args):
    """Возвращает сумму аргументов, возведённых в указанную степень."""
    total = 0
    for i in args:
        total += pow(i, power)
        
    return total


print(powersum(2, 3, 4))

print(powersum(2, 10))

'''
 Поскольку перед переменной args указана приставка «*», 
все дополнительные аргументы, переданные функции,
сохранятся в args в виде кортежа. В случае использования приставки «**» 
все дополнительные параметры будут рассматриваться 
как пары ключ/значение в словаре.
'''


# exec и eval

'''
 Функция exec служит для выполнения команд Python, 
содержащихся в строке или файле, 
в отличие от самого текста программы. Например, 
во время выполнения программы можно сформировать строку, 
содержащую текст программы на Python, и запустить его при помощи exec:
'''

exec('print("Здравствуй, Мир!")')

'''
 Аналогично, функция eval позволяет вычислять 
корректные выражения Python,содержащиеся в строке. Вот простой пример.
'''

print(eval('2*9'))


# Операция assert

'''
 Оператор assert существует для того, чтобы указать, 
что нечто является истиной. Например, если требуется гарантировать,
что в списке будет хотя бы один элемент, и вызвать ошибку, 
если это не так, то оператор assert идеально подойдёт для такой задачи. 
Когда заявленное выражение ложно, вызывается ошибка AssertionError. 
Метод pop() возвращает последний элемент списка, 
одновременно удаляя его оттуда.
'''

mylist = ['item']
assert len(mylist) >= 1
print(mylist.pop(), mylist)

try:
    assert len(mylist) >= 1
except AssertionError:
    print('AssertionError')

'''
 Тем не менее, оператор assert следует использовать благоразумно.
В большинстве случаев гораздо лучше «отлавливать» исключения 
и либо решать соответствующую проблему автоматически,
либо выдавать пользователю сообщение об ошибке 
и завершать работу программы.
'''


# Функция repr

'''
 Функция repr используется для получения канонического 
строкового представления объекта. Любопытно, 
что в большинстве случаев eval(repr(object)) == object.
'''

i = ['item']
print(repr(i))

print(eval(repr(i)))

print(eval(repr(i)) == i)

'''
 По большому счёту, функция repr служит 
для получения печатаемого представления объекта. 
Определив метод __repr__ в собственном классе, можно указать, 
что он будет возвращать по вызову функции repr.
'''

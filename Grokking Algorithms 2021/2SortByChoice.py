# Сортировка выбором

"""
 Связанные списки

 При использовании связанного списка элементы могут размещаться где
угодно в памяти.

 В каждом элементе хранится адрес следующего элемента списка . Таким
образом, набор произвольных адресов памяти объединяется в цепочку.

Добавить новый элемент в связанный список проще простого:
просто разместите его по любому адресу памяти
и сохраните этот адрес в предыдущем элементе.

 Со связанными списками ничего перемещать в памяти не нужно.
Также сама собой решается другая проблема:
допустим, вы пришли в кино спятью друзьями.
Вы пытаетесь найти место на шестерых, но кинотеатр уже забит,
и найти шесть соседних мест невозможно. Допустим, в
ы пытаетесь найти для массива блок на 1ОООО элементов.
В памяти можно найти место для 1ОООО элементов, но только не смежное.
Для массива не хватает места! При хранении данных
в связанном списке вы фактически говорите: «Ладно, тогда садимся на
свободные места и смотрим кино». Если необходимое место есть в памяти,
вы сможете сохранить данные в связанном списке.
"""


'''
 Массивы

 С массивами дело обстоит совершенно иначе. Работая с массивом,
вы заранее знаете адрес каждого его элемента. Допустим, 
массив содержит пять элементов и вы знаете, 
что он начинается с адреса 00. По какому адресу хранится пятый элемент? 
Простейшая математика дает ответ: это адрес 04.
Массивы прекрасно подходят для чтения элементов в произвольных позициях, 
потому что обращение к любому элементу в массиве происходит мгновенно. 
В связанном списке элементы не хранятся рядом друг с другом, 
поэтому мгновенно определить позицию i-го элемента в памяти невозможно - 
нужно обратиться к первому элементу, 
чтобы получить адрес второго элемента, 
затем обратиться ко второму элементу для получения адреса третьего - 
и так далее, пока вы не доберетесь до i-го.
'''

'''
 Упражнения
 
2.1 Допустим, вы строите приложение для управления финансами.

 1. ПРОДУКТЫ
 2. КИНО
 3. ВЕЛОСИПЕДНЫЙ КЛУБ
 
 Ежедневно вы записываете все свои траты. В конце месяца вы анализируете
расходы и вычисляете, сколько денег было потрачено. При
работе с данными выполняется множество операций вставки и относительно
немного операций чтения. Какую структуру использовать - 
массив или список?
 Ответ: список
'''

'''
 Удаление

 В отличие от вставки удаление возможно всегда. Попытка вставки может
быть неудачной, если в памяти не осталось свободного места. С удалением
подобных проблем не бывает.

 Ниже приведены примеры времени выполнения основных операций с массивами
и связанными списками.

             МАССИВЫ  СПИСКИ
ЧТЕНИЕ       0(1)     O(n)
ВСТАВКАКА    0(n)     O(1)
УДAЛEHИE     О(n)     0(1)

 Какая структура данных используется чаще: массивы или списки? Очевидно, 
это зависит от конкретного сценария использования. 
Массивы чрезвычайно популярны из-за того, 
что они поддерживают произвольный доступ. 
Всего существуют два вида доступа: произвольный и последовательный. 
При последовательном доступе элементы читаются по одному,
начиная с первого. Связанные списки поддерживают 
только последовательный доступ. Если вы захотите прочитать 10-й элемент 
связанного списка, вам придется прочитать первые 9 элементов
и перейти по ссылкам к 10-му элементу. Я часто говорю, 
что массивы обладают более высокой скоростью чтения;
это объясняется тем, что они поддерживают произвольный доступ.
Многие реальные ситуации требуют произвольного доступа, 
поэтому массивы часто применяются на практике. 
Также массивы и списки используются для реализации 
других структур данных.
'''

'''
 Упражнения
 
 2.2 Допустим, вы пишете приложение для приема заказов 
от посетителей ресторана. Приложение должно хранить список заказов.
Официанты добавляют заказы в список, а повара читают заказы из списка 
и выполняют их. Заказы образуют очередь: официанты добавляют заказы
в конец очереди, а повар берет первый заказ из очереди 
и начинает готовить. Какую структуру данных вы бы использовали 
для реализации этой очереди: массив или связанный список?
 Ответ: связный список

 2.3 Проведем мысленный эксперимент. Допустим, 
Facebook хранит список имен пользователей. 
Когда кто-то пытается зайти на сайт Facebook, 
система пытается найти имя пользователя. 
Если имя входит в список имен зарегистрированных пользователей,
то вход разрешается. Пользователи приходят на Facebook достаточно часто,
поэтому поиск по списку имен пользователей будет выполняться часто.
Будем считать, что Facebook использует бинарный поиск 
для поиска в списке. Бинарному поиску необходим произвольный доступ - 
алгоритм должен мгновенно обратиться 
к среднему элементу текущей части списка. Зная это обстоятельство,
как бы вы реализовали список пользователей: 
в виде массива или в виде связанного списка?
 Ответ: массив

 2.4 Пользователи также довольно часто создают 
новые учетные записи на Facebook.  Предположим, 
вы решили использовать массив для хранения списка пользователей. 
Какими недостатками обладает массив для выполнения вставки? 
Допустим, вы используете бинарный поиск для нахождения учетных данных. 
Что произойдет при добавлении новых пользователей в массив?
Ответ: все предыдущие имена пользователей сместятся,
чтобы освободить место для нового пользователя

 2.5 В действительности Facebook не использует ни массив, н
и связанный список для хранения информации о пользователях. 
Рассмотрим гибридную структуру данных: массив связанных списков. 
Имеется массив из 26 элементов.
Каждый элемент содержит ссылку на связанный список. 
Например, первый элемент массива указывает на 
связанный список всех имен пользователей, начинающихся на букву «А». 
Второй элемент указывает на связанный список всех имен пользователей, 
начинающихся на букву «В», и т. д.

 Предположим, пользователь с именем "Adit в"
регистрируется на Facebook и вы хотите добавить его в список.
Вы обращаетесь к элементу 1 массива, 
находите связанный список элемента 1 и добавляете "Adit в" 
в конец списка. Теперь предположим, 
что зарегистрировать нужно пользователя "Zakhir н". 
Вы обращаетесь к элементу 26, 
который содержит связанный список всех имен, начинающихся с «Z~,
и проверяете, присутствует ли "Zakhir н" в этом списке.

 Теперь сравните эту гибридную структуру данных с массивами 
и связанными списками. Будет ли она быстрее 
или медленнее каждой исходной структуры при поиске и вставке?
Приводить "0-большое" не нужно, просто выберите одно из двух: 
быстрее или медленнее. 
 Ответ: быстрее 
'''

'''
 Сортировка выбором

 Вы хотите отсортировать список по убыванию счетчика воспроизведений, 
чтобы самые любимые исполнители стояли на первых местах. 
Как это сделать?

 Напомним, что время О(п) означает, что вы по одному разу обращаетесь 
к каждому элементу списка. Например, при простом поиске
по списку исполнителей каждый исполнитель будет проверен один раз.

 Чтобы найти исполнителя с наибольшим значением
счетчика воспроизведения, необходимо проверить каждый элемент в списке. 
Как вы уже видели, это делается за время О(п). Итак, имеется операция, 
выполняемая за время О( п ), и ее необходимо выполнить п раз :

 Все это требует времени О(п х п), или О(п2).
 
 Алгоритмы сортировки очень полезны.
Например, теперь вы можете отсортировать:

 имена в телефонной книге;
 даты путешествий;
 сообщения электронной почты (от новых к старым).
 
 Алгоритм сортировки выбором легко объясняется, но медленно работает.
Быстрая сортировка - эффективный алгоритм сортировки, 
который выполняется за время О(п log п).
'''


def findSmallest(arr):
    """Ищет наименьший элемент в массиве."""

    smallest = arr[0]
    smallest_index = 0

    for i in range(1, len(arr)):
        if arr[i] < smallest:
            smallest = arr[i]
            smallest_index = i
            
    return smallest_index


def selectionSort(arr):
    """Выполняет сортировку массива с выбором."""
    newArr = []
    for i in range(len(arr)):
        smallest = findSmallest(arr)
        newArr.append(arr.pop(smallest))
        
    return newArr


print(selectionSort([5, 3, 6, 2, 10]))


'''
 Память компьютера напоминает огромный шкаф с ящиками.
 
 Если вам потребуется сохранить набор элементов,
воспользуйтесь массивом или списком.
 
 В массиве все элементы хранятся в памяти рядом друг с другом.
 
 В списке элементы распределяются в произвольных местах памяти, 
при этом в одном элементе хранится адрес следующего элемента.

 Массивы обеспечивают быстрое чтение.
 
 Списки обеспечивают быструю вставку и выполнение.
 
 Все элементы массива должны быть однотипными (только целые числа, 
только вещественные числа и т. д.).
'''

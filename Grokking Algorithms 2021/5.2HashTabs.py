# Хэш-таблицы

"""
Коллизии

 Как я уже сказал, в большинстве языков существуют свои хеш-таблицы.
Вам не нужно знать, как написать собственную реализацию,
поэтому я не буду надолго останавливаться
на внутреннем строении хеш-таблиц  Но быстродействие-то важно всегда!
Чтобы понять быстродействие хештаблиц, необходимо сначала понять,
что такое коллизии. В следующих двух разделах рассматриваются коллизии
и быстродействие хеш-таблиц.

 Прежде всего, я немножко приукрасил действительность. Я сказал,
что хешфункция всегда отображает разные ключи
на разные позиции в массиве.

 На самом деле написать такую хеш-функцию почти невозможно.
Рассмотрим простой пример:
допустим, массив состоит всего из 33 ячеек.

 И хеш-функция очень простая:
элемент массива просто назначается по алфавитному признаку.

 Может быть, вы уже поняли суть проблемы.
Вы хотите поместить цену апельсинов в хеш.
Для этого выделяется первая ячейка.
После апельсинов в хеш заносится цена бананов.
Для бананов выделяется вторая ячейка.

 Пока все прекрасно! Но теперь в хеш нужно включить цену авокадо.
И для авокадо снова выделяется первая ячейка.

 О нет! Элемент уже занят апельсинами! Что же делать?
Такая ситуация называется коллизией:
двум ключам назначается один элемент массива. Возникает проблема:
если сохранить в этом элементе цену авокадо,
то она запишется на место цены апельсинов. И когда кто-нибудь спросит,
сколько стоят апельсины, вы вместо этого сообщите цену авокадо!
Коллизии - неприятная штука, и вам придется как-то разбираться с ними.
Существует много разных стратегий обработки коллизий.
Простейшая из них выглядит так:
если несколько ключей отображаются на один элемент,
в этом элементе создается связанный список.

 В этом примере и «апельсины»,
и «авокадо» отображаются на один элемент массива,
поэтому в элементе создается связанный список.
Если вам потребуется узнать цену бананов,
эта операция по-прежнему выполнится быстро.
Если потребуется узнать цену апельсинов, работа пойдет чуть медленнее.
Вам придется провести поиск по связанному списку,
чтобы найти в нем «апельсины». Если связанный список мал,
это не так страшно - поиск будет ограничен тремя
или четырьмя элементами. Но предположим,
что вы работаете в специализированной лавке,
в которой продаются только продукты на букву «а».

 Одну минуту! Вся хеш-таблица полностью пуста, кроме одной ячейки.
И эта ячейка содержит огромный связанный список!
Каждый элемент этой хеш-таблицы хранится в связанном списке.
Ситуация ничуть не лучше той,
когда все данные сразу хранятся в связанном списке.
Работа с данными замедляется.

 Из этого примера следуют два важных урока:

  выбор хеш-функции действительно важен. Хеш-функция,
отображающая все ключи на один элемент массива, никуда не годится.
В идеале хеш-функция должна распределять ключи равномерно по всему хешу;

  если связанные списки становятся слишком длинными,
работа с хеш- таблицей сильно замедляется.
Но они не станут слишком длинными при использовании хорошей хеш-функции!

 Хеш-функции играют важную роль. Хорошая хеш-функция
создает минимальное число коллизий. Как же выбрать хорошую хеш-функцию?
Об этом в следующем разделе!


 Быстродействие

 Глава началась с примера магазинчика. Вы хотели построить механизм,
который мгновенно выдает цены на продукты.
Что ж, хеш-таблицы работают очень быстро.

 В среднем хеш-таблицы выполняют любые операции за время 0(1).
Время О(1) называется постоянным.
Ранее примеры постоянного времени вам еще не встречались.
Оно не означает, что операции выполняются мгновенно;
просто время остается постоянным независимо от размера хеш-таблицы.
Например, вы знаете, что простой поиск выполняется за линейное время.

 Бинарный поиск работает быстрее - за логарифмическое время:
Поиск данных в хеш-таблице выполняется за постоянное время

 При любом размере хеш-таблицы - 1 элемент
или 1 миллиард элементов - выборка данных займет одинаковое время.
На самом деле вы уже сталкивались с постоянным временем:
получение элемента из массива выполняется за постоянное время.
От размера массива оно не зависит.
В среднем случае хеш-таблицы работают действительно быстро.

 В худшем случае все операции с хеш-таблицей выполняются за время О(п)
(линейное время), а это очень медленно.
Сравним хеш-таблицы с массивами и списками.

           Хэщ-таблицы      Хэщ-таблицы      Массивы   Связные списки
        (средний случай)   (худший случай)
Поиск          O(1)            O(n)            O(1)        O(n)
Вставка        O(1)            O(n)            O(n)        O(1)
Удаление       O(1)            O(n)            O(n)        O(1)


 Взгляните на средний случай для хеш-таблиц.
При поиске хеш-таблицы не уступают в скорости массивам
(получение значения по индексу).
А при вставке и удалении они так же быстры, как и связанные списки.
Получается, что они взяли лучшее от обеих структур!
Но в худшем случае хеш-таблицы медленно выполняют все эти операции,
поэтому очень важно избегать худшего случая быстродействия
при работе с хеш-таблицами.А для этого следует избегать коллизий.
Для предотвращения коллизий необходимы:

  низкий коэффициент заполнения;

  хорошая хеш-функция .


 Коэффициент заполнения

 Коэффициент заполнения хеш-таблицы вычисляется по простой формуле.

 количество элементов в хэш-таблице
 ----------------------------------
 общее количество эдементов

 Хеш-таблицы используют массив для хранения данных,
поэтому для вычисления коэффициента заполнения
можно подсчитать количество заполненных элементов в массиве.
Например, в следующей хеш-таблице коэффициент заполнения равен 2/5,
или 0,4.

 Предположим, в хеш-таблице нужно сохранить цены 100 товаров
и хештаблица состоит из 100 элементов.
В лучшем случае каждому товару будет выделен отдельный элемент.

 Коэффициент заполнения этой хеш-таблицы равен 1.
А если хеш-таблица состоит всего из 50 элементов?
Тогда ее коэффициент заполнения будет равен 2.
Выделить под каждый товар отдельный элемент
ни при каких условиях не удастся,
потому что элементов попросту не хватит!
Коэффициент заполнения больше 1 означает,
что количество товаров превышает количество элементов в массиве.

 С ростом коэффициента заполнения в хеш-таблицу
приходится добавлять новые элементы, то есть изменять ее размер.
Представим, что эта хештаблица приближается к заполнению.

 Хеш-таблицу необходимо расширить.
Расширение начинается с создания нового массива большего размера.
Обычно в таком случае создается массив вдвое большего размера.

 Теперь все эти элементы необходимо заново вставить
в новую хеш-таблицу функцией hash:

 Новая таблица имеет коэффициент заполнения 3/8. Гораздо лучше!
С меньшим коэффициентом загрузки число коллизий уменьшается,
и ваша таблица начинает работать более эффективно.
Хорошее приближенное правило: изменяйте размер хеш-таблицы,
когда коэффициент заполнения превышает 0,7.
Но ведь на изменение размеров уходит много времени, скажете вы,
и будете абсолютно правы! Да, изменение размеров требует
значительных затрат ресурсов, поэтому оно не должно происходить
слишком часто. В среднем хеш-таблицы работают
за время 0(1) даже с изменением размеров.


 Хорошая хеш-функция

 Хорошая хеш-функция должна обеспечивать
равномерное распределение значений в массиве.

 Плохая хеш-функция создает скопления и порождает множество коллизий.


Упражнения

 Очень важно, чтобы хеш-функции обеспечивали хорошее распределение.
  Они должны распределять значения как можно шире.
Худший случай - хеш-функция, которая отображает все значения
на одну позицию в хештаблице. Предположим, имеются четыре хеш-функции,
которые получают строки:

1. Первая функция возвращает « 1 » для любого входного значения.

2. Вторая функция возвращает длину строки в качестве индекса.

3. Третья функция возвращает первый символ строки в качестве индекса.
Таким образом, все строки, начинающиеся с «а»,
хешируются в одну позицию, все строки,
 начинающиеся с «Ь» - в другую и т. д.

4. Четвертая функция ставит в соответствие каждой букве простое число:
а= 2, Ь = 3, с= 5, d = 7, е = 11 и т. д.
Для строки хеш-функцией становится
остаток от деления суммы всех значений на размер хеша.
Например, если размер хеша равен 10,
то для строки «bag» будет вычислен индекс 3 + 2 + 17 % 10 = 22 % 10 = 2.

 В каком из этих примеров хеш-функции
будут обеспечивать хорошее распределение?
Считайте, что хеш-таблица содержит 10 элементов.

 5.5 Телефонная книга, в которой ключами являются имена,
а значениями - номера телефонов.
Задан следующий список имен: Estl1er, Ben, ВоЬ, Dan.
 Ответ: 3 и 4

 5.6 Связь размера батарейки с напряжением.
Размеры батареек: А, АА, ААА, АААА.
 Ответ: 2 и 4

 5.7 Связь названий книг с именами авторов.
Названия книг: «Maus», «Fun Ноmе», «Watchmen».
 Ответ: 2, 3 и 4


 Вам почти никогда не придется реализовать хеш-таблицу самостоятельно.
Язык программирования, который вы используете,
должен предоставить необходимую реализацию.
Вы можете пользоваться хеш-таблицами Python,
и при этом вам будет обеспечена производительность среднего случая:
постоянное время.

 Хеш-таблицы чрезвычайно полезны,
потому что они обеспечивают высокую скорость операций
и позволяют по-разному моделировать данные.
Возможно, вскоре выяснится,
что вы постоянно используете их в своей работе.

  Хеш-таблица создается объединением хеш-функции с массивом.

  Коллизии нежелательны.
Хеш-функция должна свести количество коллизий к минимуму.

  Хеш-таблицы обеспечивают очень быстрое выполнение поиска,
вставки и удаления.

  Хеш-таблицы хорошо подходят
для моделирования отношений между объектами.

  Как только коэффициент заполнения превышает 0,7,
пора изменять размер хеш-таблицы.

  Хеш-таблицы используются для кэширования данных
(например, на веб-серверах).

  Хеш-таблицы хорошо подходят для обнаружения дубликатов.
"""

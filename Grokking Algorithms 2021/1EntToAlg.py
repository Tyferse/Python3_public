# Знакомство с алгоритмами


# Бинарный поиcк

"""
 При бинарном поиске каждый раз исключается половина чисел

 При простом поиске может потребоваться 240 ООО попыток, если искомое
слово находится на самой последней позиции в книге. С каждым шагом
бинарного поиска количество слов сокращается вдвое , пока не останется
ТОЛЬКО ОДНО СЛОВО.

 Итак, бинарный поиск потребует 18 шагов - заметная разница! В общем
случае для списка из п элементов бинарный поиск выполняется за
log(2)n шагов, тогда как простой поиск будет выполнен зa п шагов.
"""


def binary_search(mass, *values):
    """
    Функция binary_search получает отсортированный массив и значение.
    Если значение присутствует в массиве,
    о функция возвращает его позицию.
    """

    d = {}

    for value in values:
        low = 0
        high = len(mass) - 1

        while low <= high:
            mid = int((low + high) / 2)
            guess = mass[mid]
            if guess < value:
                low = mid + 1
            elif guess > value:
                high = mid - 1
            else:
                d[value] = mid
                break

    if d == {}:
        return None
    else:
        return d


list1 = list(range(0, 400, 3))

print(binary_search(list1, 30, 349, 6))


'''
Упражнения

 1.1 Имеется отсортированный список из 128 имен, 
и вы ищете в нем значение методом бинарного поиска.
Какое максимальное количество проверок для этого может потребоваться?
 Ответ: log(128) = 7 => 7 попыток требуется.
 
1.2 Предположим, размер списка увеличился вдвое.
Как изменится максимальное количество проверок?
 Ответ: log(256) = 8 => требуется 8 попыток.
'''


# Время выполнения

'''
 Вернемся к бинарному поиску. Сколько времени сэкономит его применение?
В первом варианте мы последовательно проверяли каждое число,
одно за другим. Если список состоит из 100 чисел, может потребоваться до
100 попыток. Для списка из 4 миллиардов чисел потребуется 
до 4 миллиардов попыток. Таким образом, 
максимальное количество попыток совпадает с размером списка. 
Такое время выполнения называется линейным.

 С бинарным поиском дело обстоит иначе. 
Если список состоит из 100 эл е ментов, потребуется не более 7 попыток. 
Для списка из 4 миллиардов эле ментов потребуется не более 32 попыток.
Впечатляет, верно? Бинарный поиск выполняется за логарифмическое время.

Простой поиск

100 элементов = 100 попыток
4000000000 элементов = 4000000000 попыток

О(n)

Бинарный поиск

100 элементов = 7 попыток
4000000000 элементов = 32 попыток

О(log n)
'''

'''
 Специальная нотация "0-болъшое" описывает скорость работы алгоритма. 
Зачем вам это? Время от времени вам придется использовать 
чужие алгоритмы, а потому неплохо было бы понимать, 
насколько быстро или медленно они работают. В этом разделе я объясню,
что представляет собой "О-большое", 
и приведу список самых распространенных вариантов времени выполнения 
для некоторых алгоритмов.
'''


# Время выполнения алгоритмов растёт с разной скоростью

'''
                      Простой поиск  Бинарный поиск
       100 элементов  100мс          7 мс
     10000 элементов  10с            14 мс
1000000000 элементов  11 дней        30 мс

Другими словами, с увеличением количества элементов бинарный поиск
занимает чуть больше времени. А простой поиск займет гораздо больше
времени. Таким образом , с увеличением списка бинарный список внезапно
начинает работать гораздо быстрее простого.

«О-большое» описывает, насколько быстро работает алгоритм. Предположим, 
имеется список размера п. Простой поиск должен проверить каждый элемент,
поэтому ему придется выполнить п операций. 
Бремя выполнения « О-большое» имеет вид О(п). 
Постойте, но где же секунды? А их здесь нет - 
«О-большое>-> не сообщает скорость в секундах, 
а позволяет сравнить количество операций. Оно указывает,
насколько быстро возрастает время выполнения алгоритма.
'''

'''
«О-большое» определяет время выполнения в худшем случае

 Предположим, вы используете простой поиск 
для поиска фамилии в телефонной книге. Вы знаете, 
что простой поиск выполняется за время О(п), 
то есть в худшем случае вам придется просмотреть каждую без исключения
запись в телефонной книге. Но представьте, 
что искомая фамилия начинается на букву "А" 
и этот человек стоит на самом первом месте в вашей телефонной книге. 
В общем, вам не пришлось просматривать все записи -
вы нашли нужную фамилию с первой попытки. Отработал ли алгоритм
за время О(п)? А может, он занял время 0(1), потому что результат был
получен с первой попытки?

 Простой поиск все равно выполняется за время О(п) . Просто в данном
случае вы нашли нужное значение моментально; 
это лучший возможный случай. Однако "О-большое"
описывает худший возможный случай . Фактически вы утверждаете,  
что в худшем случае придется просмотреть 
каждую запись в телефонной книге по одному разу.  Это и есть время О(п). 
И это дает определенные гарантии - вы знаете, что простой поиск 
никогда не будет работать медленнее О(п).
'''

'''
Типичные примеры «О-большого»

Ниже перечислены пять разновидностей «О-большого», 
которые будут встречаться вам особенно часто, 
в порядке убывания скорости выполнения:

 O(log п ), или логарифмическое время. Пример: бинарный поиск.

 О(п), или линейное время. Пример: простой поиск.

 О(п * log п). Пример: эффективные алгоритмы сортировки 
(быстрая сортировка).

 О(п2 ). Пример: медленные алгоритмы сортировки (сортировка выбором).
 
 О(п!). Пример: очень медленные алгоритмы (задача о коммивояжере).
 
 
 Скорость алгоритмов измеряется не в секундах,
а в темпе роста количества операций.

 По сути формула описывает, насколько быстро возрастает 
время выполнения алгоритма с увеличением размера входных данных.

 Время выполнения алгоритмов выражается как «О-большое».

 Бремя выполнения O(log п) быстрее О(п), а с увеличением размера списка, 
в котором ищется значение, оно становится намного быстрее.
'''

'''
 Упражнения

 Приведите время выполнения «О-большое» 
для каждого из следующих сценариев.

 1.3 Известна фамилия, нужно найти номер в телефонной книге.
 Ответ: O(log n)
 1.4 Известен номер, нужно найти фамилию в телефонной книге. (Подсказка:
вам придется провести поиск по всей книге!)
 Ответ: O(n)
 1.5 Нужно прочитать телефоны всех людей в телефонной книге.
 Ответ: O(n)
 1.6 Нужно прочитать телефоны всех людей, фамилии которых начинаются
с буквы «А». (Вопрос с подвохом! В нем задействованы концепции,
которые более подробно рассматриваются в главе 4. Прочитайте ответ - 
скорее всего, он вас удивит!)
 Ответ: O(n)
'''


# Задача о коммивояжере

'''
 Коммивояжер хочет побывать в каждом из 5 городов так, чтобы при этом
проехать минимальное общее расстояние. Одно из возможных решений:
нужно перебрать все возможные комбинации порядка объезда городов.

 Все расстояния суммируются, после чего выбирается путь с кратчайшим
расстоянием. Для 5 городов можно создать 120 перестановок, 
поэтому решение задачи для 5 городов потребует 120 операций.
Для 6 городов количество операций увеличивается до 720 
(существуют 720 возможных перестановок). 
А для 7 городов потребуется уже 5040 операций!

 В общем случае для вычисления резу ль тата при п элементах потребуется
п! (п-факториал) операций. А значит, время выполнения составит О(п!)
(такое время называется факторuальным). При любом сколько-нибудь
серьезном размере списка количество операций будет просто огромным.
Скажем, если вы попытаетесь решить задачу для 100+ городов, 
сделать это вовремя не удастся - Солнце погаснет раньше.


 Бинарный поиск работает намного быстрее простого.
 
 Время выполнения O(log п) быстрее О(п), а с увеличением размера списка,
в котором ищется значение, оно становится намного быстрее.

 Скорость алгоритмов не измеряется в секундах.
 
 Время выполнения алгоритма описывается ростом количества операций.
 
 Время выполнения алгоритмов выражается как "О-большое".
'''

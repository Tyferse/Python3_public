# Динамическое программирование

"""
 Оптимизация туристического маршрута

 Представьте, что вы приехали в Лондон на выходные. У вас два дня,
а мест, которые хочется посетить, слишком много.
Побывать везде не получится, поэтому вы составляете список.

 Для каждой достопримечательности, которую вы захотите увидеть,
вы указываете, сколько времени займет осмотр
и насколько сильно вы хотите ее увидеть.
Сможете ли вы построить оптимальный туристический маршрут
на основании этого списка?

 Да это все та же задача о рюкзаке!
Вместо ограниченной емкости рюкзака - ограниченное время.
Вместо магнитофонов и ноутбуков - список мест,
которые вы хотите посетить. Нарисуйте таблицу
динамического программирования для списка, прежде чем двигаться дальше.

 Вот как должна выглядеть эта таблица:

 Вы изобразили ее правильно? Теперь заполните.
Какие достопримечательности вы выберете?
Ответ: Вестминстерское Аббатство, Национальная Галерея,
Собор Святого Павла.


 Взаимозависимые элементы

 Предположим, вы хотите посетить Париж и добавили в свой список
пару элементов.

 На их посещение потребуется много времени,
потому что сначала придется приехать из Лондона в Париж.
Переезд отнимает полдня. Если вы захотите посмотреть
все 3 достопримечательности, осмотр займет 4,5 дня. Стоп,
небольшая поправка. Вам не обязательно приезжать в Париж
ради каждой достопримечательности. После того как вы там окажетесь,
каждый последующий элемент займет всего один день. Следовательно,
потребуется 1 день на каждую достопримечательность + 1 день на переезды
= 3,5 дня, а не 4,5.

 Если вы положите Эйфелеву башню в свой «рюкзак~,
то Лувр станет "дешевле" - он займет всего 1 день вместо 1,5 дня.
Как смоделировать это обстоятельство в динамическом программировании?

 Никак. Динамическое программирование - мощный метод,
способный решать подзадачи и использовать полученные ответы
для решения большой задачи. Динамическое программирование работает
толъко в том случае, если каждая подзадача автономна,
то естъ не зависит от других подзадач. Из этого следует,
что учесть поездки в Париж в алгоритме динамического программирования
не удастся.


 Может ли оказаться, что решение требует более двух «nодрюкзаков»?

 Может оказаться, что в лучшем решении должны отбираться
больше двух элементов. В текущем варианте алгоритма объединяются
не более двух "подрюкзаков" - больше двух их не бывает.
Однако вполне возможно, что у этих "подрюкзаков"
будут собственные "подрюкзаки".


 Возможно ли, что при лучшем решении в рюкзаке остается пустое место?

 Да. Представьте, что вы можете также положить в рюкзак бриллиант.
Бриллиант очень крупный: он весит 3,5 фунта и стоит 1 миллион долларов -
намного больше, чем любые другие предметы. Безусловно,
нужно брать именно его! Но в рюкзаке остается еще пустое место
на О,5 фунта, и в нем ничего не поместится.


 Упражнения

 9.2 Предположим, что вы собираетесь в турпоход.
Емкость вашего рюкзака составляет 6 фунтов,
и вы можете взять предметы из следующего списка.
У каждого предмета имеется стоимость; чем она выше, тем важнее предмет:

  вода, 3 фунта, 1О;

  книга, 1 фунт, 3;

  еда, 2 фунта, 9;

  куртка, 2 фунта, 5;

  камера, 1 фунт, 6

 Как выглядит оптимальный набор предметов для похода?
 Ответ: вода, еда, камера.


 Самая длинная общая подстрока

 Мы рассмотрели одну задачу динамического программирования.
Какие выводы из нее можно сделать?

  Динамическое программирование применяется для оптимизации
 какой-либо характеристики при заданных ограничениях.
 В задаче о рюкзаке требуется максимизировать стоимость
 отобранных предметов с ограничениями по емкости рюкзака.

  Динамическое программирование работает только в ситуациях,
 в которых задача может быть разбита на автономные подзадачи,
 не зависящие друг от друга.

 Построить решение на базе динамического программирования
бывает непросто. В этом разделе мы сосредоточимся на этой теме.
Несколько общих рекомендаций:

  в каждом решении из области динамического программирования
 строится таблица;

  значения ячеек таблицы обычно соответствуют
 оптимизируемой характеристике. Для задачи о рюкзаке
 значения представляли общую стоимость товаров;

  каждая ячейка представляет подзадачу,
 поэтому вы должны подумать о том, как разбить задачу на подзадачи.
 Это поможет вам определиться с осями.

 Рассмотрим еще один пример. Допустим, вы открыли сайт dictionary.com.
Пользователь вводит слово, а сайт возвращает определение.
Но если пользователь ввел несуществующее слово, нужно предположить,
какое слово имелось в виду. Алекс ищет определение "fish".
но он случайно ввел "hish". Такого слова в словаре нет,
но зато у вас есть список похожих слов.

  Слова, похожие на "hish":

  fish

  vista

 (Это несерьезный пример, поэтому список ограничен всего двумя словами.
Вероятно, на практике такой список будет состоять из тысяч слов.)

 И так, Алекс ввел строку hish. Какое слово он хотел ввести
на самом деле: fish или vista?


 Построение таблицы

 Как должна выглядеть таблица для этой задачи?
Вы должны ответить на следующие вопросы.

  Какие значения должны содержаться в ячейках?

  Как разбить эту задачу на подзадачи?

  Каков смысл осей таблицы?

 В динамическом программировании вы пытаетесь максимизировать
некоторую характеристику. В данном случае ищется
самая длинная подстрока, общая в двух словах.
Какую общую подстроку содержат hish и fish? А как насчет hish и vista?
Именно это требуется вычислить.

 Как говорилось ранее, значения в ячейках обычно представляют
ту характеристику, которую вы пытаетесь оптимизировать. Вероятно,
в данном случае этой характеристикой будет число:
длина самой длинной подстроки, общей для двух строк.

 Как разделить эту задачу на подзадачи? Например,
можно заняться сравнением подстрок.
Вместо того чтобы сравнивать hish иfish,
можно сначала сравнить his и fis.
Каждая ячейка будет содержать длину самой длинной подстроки,
общей для двух подстрок. Такое решение также подсказывает,
что строками и столбцами таблицы, вероятно, будут два слова.
А значит, таблица будет выглядеть примерно так:


 Заполнение таблицы

 Сейчас вы уже достаточно хорошо представляете,
как должна выглядеть таблица.
По какой формуле заполняются ячейки таблицы?
Мы можем немного упростить свою задачу, потому что уже знаем решение -
у hish и fish имеется общая подстрока длины 3: ish.

 Однако этот факт ничего не говорит о том,
какая формула должна использоваться.
Программисты иногда шутят об использовании алгоритма Фейнмана.
Алгоритм Фейнмана, названный по имени известного физика
Ричарда Фейнмана, работает так:

  1. Записать формулировку задачи.

  2. Хорошенько подумать.

  3. Записать решение.

 Да, программисты - большие шутники! По правде говоря,
простого способа вычислить формулу для данного случая не существует.
Вам придется экспериментировать и искать работоспособное решение.
Иногда алгоритм предоставляет не точный рецепт, а основу,
на которую вы наращиваете свою идею.

Попробуйте предложить решение этой задачи самостоятельно.

 Чему равны другие значения? Вспомните,
что каждая ячейка содержит значение подзадачи.
Почему ячейка (3, 3) содержит значение 2?
Почему ячейка (3, 4) содержит значение О?

 Попытайтесь вывести формулу самостоятельно,
прежде чем продолжить читать.
Даже если вам не удастся получить правильный ответ,
мои объяснения покажутся вам намного более понятными.


 Решение

 Итоговая версия таблицы выглядит так:

 А это моя формула для заполнения ячеек:

  1. Если буквы не совпадают, значение равно 0.

  2. Если они совпадают, то значение равно значению ячейки
 наверху слева + 1.

 На псевдокоде эта формула реализуется так:

if word_a[i] == word_b[j]:                             Буквы совпадают
    cell[i][j] = cell[i-1][j-1] + 1                 Буквы не совпадают
else:
    cell[i][j] = 0

 Аналогичная таблица для строк hish и vista:

 Важный момент: в этой задаче окончательное решение
далеко не всегда находится в последней ячейке!
В задаче о рюкзаке последняя ячейка всегда содержит
окончательное решение. Но в задаче поиска самой длинной общей подстроки
решение определяется самым большим числом в таблице -
и это может быть не последняя, а какая-то другая ячейка.

 Вернемся к исходному вопросу: какая строка ближе к hish?
У строк hish и fish есть общая подстрока длиной в три буквы.
У hish и vista есть общая подстрока из двух букв. Скорее всего,
Алекс хотел ввести строку fish.


 Самая длинная общая подпоследовательность

 Предположим, Алекс ввел строку fosh. Какое слово он имел в виду:
fish или fоrt?

 Сравним строки по формуле самой длинной общей подстроки.

 Длина подстрок одинакова: две буквы! Hofosh при этом ближе кfish:

 Мы сравниваем самую длинную общую подстроку,
а на самом деле нужно сравнивать самую длинную
общую подпоследовательность: количество букв в последовательности,
общих для двух слов. Как вычислить самую длинную
общую подпоследовательность? Ниже приведена частично заполненная таблица
для fish и fosh.

 Сможете ли вы определить формулу для этой таблицы?
Самая длинная общая подпоследовательность
имеет много общего с самой длинной общей подстрокой,
и их формулы тоже очень похожи. Попробуйте решить задачу самостоятельно,
а я приведу ответ ниже.


Самая длинная общая подпоследовательность - решение

 Окончательная версия таблицы:

 А теперь моя формула для заполнения каждой ячейки:

  1. Если буквы не совпадают, выбрать общее значение
 для соседей наверху и слева
 (отличается от самой длинной оьщей подстроки).

  2. Если буквы совпадают, значение равно
 значению ячейки наверху слева + 1
 (как и в случае самой длинной общей подстроки).

 На псевдокоде эта формула реализуется так:

if word_a[i] == word_b[j]:                             Буквы совпадают
    cell[i][j] = cell[i-1][j-1] + 1
else:                                               Буквы не совпадают
    cell[i][j] = max(cell[i-1][j], cell[i][j-1])

 Поздравляю - вы справились! Безусловно,
это была одна из самых сложных глав в книге.
Находит ли динамическое программирование практическое применение?
Да, находит.

  Биологи используют самую длинную общую подпоследовательность
 для выявления сходства в цепях ДНК.
 По этой метрике можно судить о сходстве двух видов животных,
 двух заболеваний и т. д. Самая длинная общая подпоследовательность
 используется для поиска лекарства от рассеянного склероза.

  Вы когда - нибудь пользовались ключом diff
 (например, в команде git diff)? Этот ключ выводит информацию
 о различиях между двумя файлами, а для этого он использует
 динамическое программирование.

  Мы также упоминали о сходстве строк.
 Расстояние Левенштейна оценивает, насколько похожи две строки,
 а для его вычисления применяется динамическое программирование.
 Расстояние Левенштейна используется в самых разных областях,
 от проверки орфографии до выявления отправки пользователем данных,
 защищенных авторским правом.

  Вы когда - нибудь работали в приложении, поддерживающем перенос слов,
 например Microsoft Word? Как определить,
 где следует расставить переносы,
 чтобы длина строки оставалась более или менее постоянной?
 Динамическое программирование!


 Упражнения

 9.3 Нарисуйте и заполните таблицу для вычисления
самой длинной общей подстроки между строками blие и clues.
 Ответ:

    c l u e s
  b 0 0 0 0 0
  l 0 1 0 0 0
  u 0 0 2 0 0
  e 0 0 0 3 0


  Динамическое программирование применяется при оптимизации
 некоторой характеристики.

  Динамическое программирование работает только в ситуациях,
 в которых задача может быть разбита на автономные подзадачи.

  В каждом решении из области динамического программирования
 строится таблица.

  Значения ячеек таблицы обычно соответствуют
 оптимизируемой характеристике.

  Каждая ячейка представляет подзадачу,
 поэтому вы должны подумать о том, как разбить задачу на подзадачи.

  Не существует единой формулы для вычисления решений
 методом динамического программирования .
"""

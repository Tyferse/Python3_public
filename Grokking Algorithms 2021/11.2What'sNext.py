# Что дальше?

"""
 Фильтры Блума и Hyperloglog

 Представьте себя на месте сайта Reddit.
Когда пользователь публикует ссылку, нужно проверить,
публиковалась ли эта ссылка ранее. Истории,
которые еще не публиковались, считаются более ценными.

 Или представьте себя на месте поискового бота Google.
Обрабатывать вебстраницу нужно только в том случае,
если она еще не обрабатывалась ранее. Итак, нужно проверить,
обрабатывалась ли страница ранее.

 Или представьте себя на месте bit.ly - сервиса сокращения URL.
Пользователи не должны перенаправляться на вредоносные сайты.
У вас имеется набор URL-aдpecoв, которые считаются вредоносными.
Теперь нужно выяснить, не направляется ли пользователь
на URL-aдpec из этого набора.

 Во всех этих примерах возникает одна проблема.
Имеется очень большой набор данных.

 Появляется новый объект, и вы хотите узнать,
содержится ли он в существующем наборе.
Эта задача быстро решается при помощи хеша. Например, представьте,
что Google создает большой хеш,
ключами которого являются все обработанные страницы.

 Как узнать, обрабатывался ли сайт adit.io? Нужно заглянуть в хеш.

 У adit.io имеется свой ключ в хеше, а значит, адрес уже обрабатывался.
Среднее время обращения к элементам в хеш-таблице составляет 0(1).
Таким образом, вы узнали о том,
что страница adit.io уже проиндексирована за постоянное время. Неплохо!


 Фильтры Блума

 Для решения проблемы можно воспользоваться
вероятностными структурами данных, которые называются фильтрами Блума.
Они дают ответ, который может оказаться ложным,
но с большой вероятностью является правильным.
Вместо того чтобы обращаться к хешу, вы спрашиваете у фильтра Блума,
обрабатывался ли этот URL-aдpec ранее. Хеш-таблица даст точный ответ.
Фильтр Блума дает ответ, правильный с высокой вероятностью:

  возможны ложно-положительные срабатывания. Фильтр скажет:
 "этот сайт уже обрабатывался", хотя этого не было;

  ложно-отрицательные срабатывания исключены. Если фильтр утверждает,
 что сайт не обрабатывался, вы можете быть в этом уверены.

 Фильтры Блума хороши тем, что занимают очень мало места.
Хеш-таблице пришлось бы хранить все URL-aдpeca, обрабатываемые Google,
а фильтру Блума это не нужно. Фильтры Блума очень удобны тогда,
когда не нужно хранить точный ответ (как во всех приведенных примерах).
Например, Ьit.ly может сказать: "Мы полагаем,
что сайт может оказаться вредоносным, будьте особенно внимательны".


 HyperLog Log

 Примерно так же действует другой алгоритм,
который называется HyperLogLog. Предположим,
Google хочет подсчитать количество уникалъНЪLХ поисков,
выполненных пользователями. Или Amazon хочет подсчитать
количество уникальных предметов, просмотренных пользователями
за сегодняшний день. Для получения ответов на эти вопросы
потребуется очень много места! Так,
в примере с Google придется вести журнал
всех уникальных вариантов поиска. Когда пользователь что-то ищет,
вы сначала проверяете, присутствует ли условие в журнале, и если нет,
добавляете его. Даже для одного дня этот журнал получится гигантским.

 HyperLogLog аппроксимирует количество уникальных элементов в множестве.
Как и фильтры Блума, он не дает точного ответа,
но выдает достаточно близкий результат
с использованием малой части памяти,
которую обычно занимает такая задача.

 Если вы используете большие объемы данных
и вас устраивают приближенные ответы -
воспользуйтесь вероятностными алгоритмами!


 Алгоритмы SHA

 Помните процедуру хеширования из главы 5?
На всякий случай освежу вашу память: имеется ключ,
вы хотите поместить связанное с ним значение в массив.

 Элемент, в котором размещается значение, определяется хеш-функцией.

 Значение сохраняется в соответствующей позиции массива.

 Хеширование позволяет выполнять поиск с постоянным временем.
Когда вам потребуется узнать значение, связанное с ключом,
вы снова применяете хеш-функцию, и она за время 0(1) сообщает,
какую позицию следует проверить.

 Хеш-функция должна обеспечивать достаточно равномерное распреде ление.
Итак, хэш-функция получает строку и возвращает номер ячейки,
соответствующий этой строке.


 Сравнение файлов

 Одну из разновидностей хеш-функций составляет алгоритм SHA
(Secure Hash Algorithm). Он получает строку
и воз вращает хеш-код этой строки.

  "hello" = 2cf24db...

Возможно, терминология не настолько проста, нас кол ько хотел ось бы .
Алгоритм SHA - хеш - функция; эта функция генерирует хеш-код , который
представляет собой короткую строку. Хеш-функция для хеш-таблиц
преобразует строку в индекс мас сива, тогда ка к SHA преобразует строку
в другую строку.

 Для каждой строки алгоритм SHA генерирует свой уникальный хеш-код.

  "hello" = 2cf24db...

  "algorithm" = b1eb2ec...

  "password" = 5e88489...

 Алгоритм SHA позволяет определить, совпадают ли два файла.
Такая возможность особенно полезна для очень больших файлов. Допустим,
у вас имеется 4-гигабайтный файл и вы хотите проверить,
хранится ли у вашего друга точно такой же файл.
Вам не придется пересылать большой файл по электронной почте;
вместо этого можно вычислить хеш-коды SHA двух файлов и сравнить их.


 Проверка паролей

 Алгоритм SHA также может использоваться для сравнения строк
при отсутствии информации об исходной строке. Например,
только представьте, что сервис Gmail атакован хакерами!
Ваш пароль стал добычей злоумышленников? А вот и нет.
Google хранит не исходный пароль,
а только хеш-код пароля по алгоритму SHA! Когда вы вводите пароль,
Google хеширует его и сравнивает результат с хеш-кодом,
хранящимся в базе данных.

 Сравниваются только хеш-коды - хранить пароль не нужно!
Алгоритм SHA очень часто используются для хеширования паролей.
Хеширование является односторонним: вы можете получить хеш-код строки...

  abc123 -> 6ca13d

 ...но не сможете восстановить исходную строку по хеш-коду:

  ? <- 6ca13d

 Это означает, что даже если злоумышленник похитит хеш-коды SHA
с серверов Gmail, он не сможет по ним восстановить исходные пароли!
Пароль можно преобразовать в хеш, но не наоборот.

 Под термином SHA скрывается целое семейство алгоритмов: SHA-0, SHA-1,
SHA-2 и SHA-3. На момент написания книги в алгоритмах SHA-0 и SHA-1
были обнаружены слабости. Если вы применяете алгоритм SHA
для хеширования паролей, выбирайте SHA-2 или SHA-3.
В настоящее время "золотым стандартом" хеширования паролей
считается функция bcrypt (хотя идеальной защиты не бывает).


 Локально-чувствительное хеширование

 У хеширования SHA есть еще одна важная особенность:
оно является локально-нечувствuтельным. Предположим, имеется строка,
для которой генерируется хеш-код:

  dog = cd6357

 Если изменить в строке всего один символ,
а потом сгенерировать хеш заново, строка полностью изменяется!

  dot = e395da

 И это хорошо, потому что сравнение хешей
не позволит атакующему определить, насколько он близок к взлому пароля.

 Иногда требуется обратный результат:
локально-чувствительная функция хеширования.
Здесь на помощь приходит алгоритм Simhash.
При незначительном изменении строки Simhash генерирует хеш-код,
который почти не отличается от исходного.
Это позволяет сравнивать хеш-коды и определять,
насколько похожи две строки, - весьма полезная возможность!

  Google использует Simhash для выявления дубликатов
 в процессе индексирования.

  Преподаватель может использовать Simhash для обнаружения плагиата
 (копирования рефератов из Интернета).

  Scribd позволяет пользователям загружать документы или книги,
 чтобы они стали доступны для других пользователей. Но Scribd не хочет,
 чтобы пользователи размещали информацию, защищенную авторским правом!
 С помощью Simhash сайт может обнаружить,
 что отправленная информация похожа на книгу о Гарри Поттере,
 и при обнаружении сходства автоматически запретить ее размещение.

 Simhash используется для выявления сходства между фрагментами текста.


 Обмен ключами Диффи-Хеллмана

 Алгоритм Диффи-Хеллмана заслуживает упоминания, п
отому что он изящно решает давно известную задачу.
Как зашифровать сообщение так, чтобы его мог прочитать
только тот человек, которому адресовано сообщение?

 Проще всего определить подстановочный шифр: а= 1, Ь = 2 и т. д.
Если после этого я отправлю вам сообщение "4, 15, 7",
вы сможете преобразовать его в «d,o,g». Но чтобы эта схема сработала,
необходимо согласовать шифр между сторонами.
Договориться о шифре по электронной почте невозможно,
потому что злоумышленник может перехватить сообщение,
узнать шифр и расшифровать сообщения.
Даже если передать шифр при личной встрече,
злоумышленник может угадать шифр, если он достаточно прост. Значит,
шифр придется ежедневно менять.
Но тогда нам придется ежедневно проводить
личные встречи для изменения шифра!

 Даже если вам удастся ежедневно изменять шифр,
подобные простые шифры достаточно легко взламываются
методом грубой силы. Допустим, я вижу сообщение
"9,6,13,13, 16 24 ,1 6,19,13,5". Я предполагаю,
что при шифровании используется подстановка а = 1, Ь = 2 и т. д.

  9, 6, 13, 13, 16  24, 16, 19, 13, 5
  ^  ^  ^   ^   ^   ^   ^   ^   ^   ^
  i  f  m   m   p   x   p   s   m   e

 Бессмыслица. Пробуем а = 2, Ь = 3 и т. д.

  9, 6, 13, 13, 16  24, 16, 19, 13, 5
  ^  ^  ^   ^   ^   ^   ^   ^   ^   ^
  h  e  l   l   o   w   o   r   l   d

 Сработало! Подобные простые шифры взламываются достаточно легко.
Во Вторую мировую войну в Германии использовался
намного более сложный шифр, но и он был взломан.

 Алгоритм Диффи-Хеллмана решает обе проблемы:

  знание шифра обеими сторонами не обязательно. Следовательно,
 им не придется встречаться и согласовывать шифр;

  расшифровать зашифрованные сообщения чрезвычайно сложно.

 Алгоритм Диффи-Хеллмана использует два ключа: открытый и закрытый.
Открытый ключ известен обеим сторонам . Его можно опубликовать на сайте,
отправить электронной почтой друзьям и вообще сделать с ним все,
что вам заблагорассудится. Его не нужно скрывать.
Когда другая сторона захочет отправить вам сообщение,
она зашифрует его с применением открытого ключа.
Зашифрованное сообщение можно расшифровать только с закрытым ключом.
При условии, что вы являетесь единственным владельцем закрытого ключа,
никто другой расшифровать сообщение не сможет!

 Алгоритм Диффи-Хеллмана продолжает применяться на практике
вместе с его наследником RSA. Если вы интересуетесь криптографией,
алгоритм Диффи-Хеллмана станет хорошей отправной точкой:
он элегантен и не особо сложен.


 Линейное программирование

 Самое лучшее я приберег напоследок. Линейное программирование -
одна из самых интересных областей, которые мне известны.

 Линейное программирование используется
для максимизации некоторой характеристики при заданных ограничениях.
Предположим, ваша компания выпускает два продукта: рубашки и сумки.
На рубашку требуется 1 м ткани и 5 пуговиц.
На изготовление сумки необходимо 2 м ткани и 2 пуговицы.
У вас есть 11 м ткани и 20 пуговиц. Рубашка приносит прибыль $2,
а сумка - $3. Сколько рубашек и сумок следует изготовить
для получения максимальной прибыли?

 Здесь мы пытаемся максимизировать прибыль,
а ограничения определяют количество имеющихся материалов.

 Другой пример: вы политик, пытающийся получить
максимальное количество голосов. Исследования показали,
что на каждый голос жителя Сан-Франциско требуется примерно час работы
(маркетинг, исследования и т.д.), а на каждый голос жителя Чикаго -
1,5 часа. Вам нужны голоса как минимум 500 жителей Сан-Франциско
и как минимум 300 жителей Чикаго. В вашем распоряжении 50 дней.
Кроме того, затраты на жителя Сан-Франциско составляют $2,
а на жителя Чикаго - $1. Ваш бюджет составляет $1500.
Какое максимальное количество голосов вы сможете получить
(Сан-Франциско+ Чикаго)?

 На этот раз вы стремитесь к максимуму голосов
при ограничениях по времени и деньгам.

 Возможно, вы думаете: "в этой книге много говорилось
о вопросах оптимизации. Как они связаны с линейным программированием?"
Все алгоритмы, работающие с графами, могут быть реализованы
средствами линейного программирования. Линейное программирование -
намного более общая область,
а задачи с графами составляют ее подмножество.

 В линейном программировании используется симплекс-метод.
Этот алгоритм достаточно сложен, поэтому я не привожу его в книге.
Если вы интересуетесь задачами оптимизации,
поищите информацию о линейном программировании!


 Эпилог

 Надеюсь, этот краткий обзор показал,
как много вам еще предстоит узнать.
Я считаю, что лучший способ узнать что-то -
найти тему, которая вас интересует, и изучить ее. Надеюсь,
эта книга закладывает достаточно надежную основу для этого.
"""

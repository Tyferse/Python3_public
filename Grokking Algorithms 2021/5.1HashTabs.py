# Хэш-таблицы

"""
 Хеш-функции

 Хеш-функция представляет собой функцию, которая получает строку
и возвращает число:

 В научной терминологии говорят, что хеш-функция
"отображает строки на числа". Можно подумать,
что найти закономерности получения чисел
для подаваемых на вход строк невозможно.
Однако хеш-функция должна соответствовать некоторым требованиям:

  Она должна быть последовательной. Допустим,
вы передали ей строку «апельсины> и получили 4.
Это значит, что каждый раз в будущем,
передавая ей строку «апельсины», вы будете получать 4.
Без этого хештаблица бесполезна.

  Разным словам должны соответствовать разные числа.
Например, хешфункция, которая возвращает 1
для каждого полученного слова, никуда не годится.
В идеале каждое входное слово должно отображаться на свое число.

 Начнем с пустого массива:

 Все цены будут храниться в этом массиве;
передадим хеш-функции строку «апельсины~.

 Хеш-функция выдает значение «3».
Сохраним цену апельсинов в элементе массива с индексом 3.

 Добавим молоко. Передадим хеш-функции строку «молоко».

 Продолжайте действовать так,
и со временем весь массив будет заполнен ценами на товары.

 А теперь вы спрашиваете: сколько стоит авокадо?
Искать в массиве ничего не нужно,
просто передайте строку «авокадо» хеш-функции.

 Результат показывает, что значение хранится в элементе с индексом 4.
И оно, конечно, там и находится!

 Хеш-функция сообщает, где хранится цена,
и вам вообще не нужно ничего искать!
Такое решение работает, потому что:

  Хеш-функция неизменно связывает название с одним индексом.
 Каждый раз, когда она вызывается для строки «авокадо»,
 вы получаете обратно одно и то же число.
 При первом вызове этой функции вы узнаете,
 где следует сохранить цену авокадо,
 а при последующих вызовах она сообщает, где взять эту цену.

  Хеш-функция связывает разные строки с разными индексами.
 «Авокадо» связывается с индексом 4, а «молоко» - с индексом О.
 Для каждой строки находится отдельная позиция массива,
 в которой сохраняется цена этого товара.

  Хеш-функция знает размер массива
  и возвращает только действительные индексы.
 Таким образом, если длина массива равна 5 элементам,
 хеш-функция не вернет 100,
 потому что это значение не является действительным индексом в массиве.

 Поздравляю: вы создали «Мэгги»!
Свяжите воедино хеш-функцию и массив, и вы получите структуру данных,
которая называется хеш-таблицей.
Хеш-таблица станет первой изученной вами структурой данных,
с которой связана дополнительная логика.
Массивы и списки напрямую отображаются на адреса памяти,
но хеш-таблицы устроены более умно.
Они определяют место хранения элементов при помощи хе ш-функций.

 Вероятно, хеш-таблицы станут самой полезной из сложных структур данных,
с которыми вы познакомитесь. Они также известны под другими названиями:
«ассоциативны е массивы» , «словари», «отображения», «хешкарты»
или просто «хеши». Хеш-таблицы исключительно быстро работают!
Помните описание массивов и связанных списков из главы 2?
Обращениек элементу массива происходит мгновенно.
А хеш-табл ицы используют массивы для хранения данных,
поэтому при обращении к элементам они не уступают массивам.

 Скорее всего, вам никогда не придется заниматься
реализацией хеш-таблиц самостоятельно. В любом приличном языке
существует реализация хештаблиц. В Python тоже есть хеш-таблицы;
они называются словарями.
"""

book = {"apple": 0.67, "milk": 1.49, "avocado": 1.49}

# book - новая хеш-таблица. Добавим в book несколько цен:

print(book)

# Пока все просто! А теперь запросим цену авокадо:

print(book["avocado"])

'''
 Хеш-таблица состоит из ключей и значений. 
В хеше book имена продуктов являются ключами, а цены - значениями. 
Хеш-таблица связывает ключи со значениями.

 В следующем разделе приведены примеры, 
в которых хеш-таблицы приносят большую пользу.
 

 Упражнения

 Очень важно, чтобы хеш-функции были последовательными, 
то есть неизменно возвращали один и тот же результат 
для одинаковых входных данных.  Если это условие будет нарушено,
вы не сможете найти свой элемент после того, 
как он будет помещен в хеш-таблицу!

 Какие из следующих функций являются последовательными?
 
5.1 f(x) = 1
5.2 f(x) = rand()
5.3 f(x) = next_empty_slot()
5.4 f(x) = len(x)
 Ответ: последовательными функциями являются 1 и 4.
'''

'''
 Примеры использования

 Хеш-таблицы повсеместно применяются на практике. 
В этом разделе представлены некоторые примеры.
 
 
 Использование хеш-таблиц для поиска

 В вашем телефоне есть удобная встроенная телефонная книга.
С каждым именем связывается номер телефона.
 
Предположим, вы хотите построить такую телефонную книгу.
Имена людей в этой книге связываются с номерами.
Телефонная книга должна поддерживать следующие функции:

  добавление имени человека и номера телефона, связанного с этим именем;
  
  получение номера телефона, связанного с введенным именем.
  
 Такая задача идеально подходит для хеш-таблиц!
Хеш-таблицы отлично работают, когда вы хотите:
 
  создать связь, отображающую один объект на другой;
  
  найти значение в списке.
  
 Построить телефонную книгу, в общем-то, несложно.
Начните с создания новой хеш-таблицы:
'''

# Добавим в телефонную книгу несколько номеров:

phone_book = {"jenny": 8675309, "emergency": 911}

# Вот и все! Теперь предположим,
# что вы хотите найти номер телефона Дженни (jenпy).
# Просто передайте ключ хешу:

print(phone_book["jenny"])

'''
 А теперь представьте, что то же самое вам пришлось бы делать 
с массивом. Как бы вы это сделали? 
Хеш-таблицы упрощают моделирование отношений между объектами. 

 Хеш-таблицы используются для поиска соответствий 
в гораздо большем масштабе. Например, представьте, 
что вы хотите перейти на веб-сайт - допустим, http/ /adit.io. 
Ваш компьютер должен преобразовать символическое имя adit.io в IР-адрес.

  adit.io -> 17З.255.248.ss

 Для любого посещаемого веб-сайта его имя преобразуется в IР-адрес:
 
  google.com -> 74.125.239.133
  
  facebook.com -> 173.252.120.6
  
  scribd.com -> 23.235.47.175
  
 Связать символическое имя с IР-адресом? Идеальная задача для хештаблиц! 
Этот процесс называется преобразованием DNS.
Хеш-таблицы - всего лишь один из способов реализации 
этой функциональности.


 Исключение дубликатов

 Предположим, вы руководите избирательным участком. Естественно, 
каждый избиратель может проголосовать всего один раз. 
Как проверить, что он не голосовал ранее? 
Когда человек приходит голосовать, вы узнаете его полное имя, 
а затем проверяете по списку уже проголосовавших избирателей.

 Если имя входит в список, значит, 
этот человек уже проголосовал - гоните наглеца! 
В противном случае вы добавляете имя в список 
и разрешаете ему проголосовать. 
Теперь предположим, что желающих проголосовать много 
и список уже проголосовавших достаточно велик.

 Каждый раз, когда кто -то приходит голосовать, 
вы вынуждены просматривать этот гигантский список и проверять, 
голосовал он или нет. Однако существует более эффективное решение: 
воспользоваться хешем! Сначала создадим хеш для хранения информации 
об уже проголосовавших людях:
'''

vote = {}

# Когда кто-то приходит голосовать,
# проверьте, присутствует ли его имя  в хеше:

value = vote.get('Tom')

'''
 Функция get возвращает значение, 
если ключ "tom" присутствует в хештаблице. 
В противном случае возвращается None. 
С помощью этой функции можно проверить, 
голосовал избиратель ранее или нет!

 Код выглядит так:
'''

voted = {}


def check_voter(name) :
    if voted.get(name):
        print("kick them out!")
    else:
        voted[name] = True
        print("let them vote!")


# Давайте .протестируем его на нескольких примерах:

check_voter("tom")

check_voter("mike")

check_voter("mike")

'''
 Когда Том приходит на участок в первый раз, 
программа разрешает ему проголосовать. 
Потом приходит Майк, который тоже допускается к голосованию. 
Но потом Майк делает вторую попытку, 
и на этот раз у него ничего не получается.

 Если бы имена проголосовавших хранились в списке, 
то выполнение функции со временем замедлилось бы, 
потому что функции пришлось бы проводить простой поиск по всему списку. 
Но имена хранятся в хештаблице,
а хеш-таблица мгновенно сообщает, 
присутствует имя избирателя в списке или нет. 
Проверка дубликатов в хеш-таблице выполняется очень быстро.

 Использование хеш-таблицы как кэша
 
 Последний пример: кэширование. 
Если вы работаете над созданием веб-сайтов, вероятно, 
вы уже слышали о пользе кэширования. 
Общая идея кэширования такова:
допустим, вы заходите на сайт facebook.com:

1. Вы обращаетесь с запросом к серверу Facebook.

2. Сервер ненадолго задумывается, 
генерирует веб-страницу и отправляет ее вам.

3. Вы получаете веб-страницу.

 Представьте, что у вас есть племянница, 
которая пристает к вам с вопросами о планетах: 
«Сколько километров от Земли до Марса?», 
«А сколько километров до Луны?», 
«А до Юпитера?» Каждый раз вы вводите запрос в Google 
и сообщаете ей ответ. На это уходит пара минут. 
А теперь представьте, что она всегда спрашивает: 
«Сколько километров от Земли до Луны?»  Довольно быстро вы запоминаете, 
что Луна находится на расстоянии 384 400 километров от Земли.
Искать информацию в Google ненужно... 
вы просто запоминаете и выдаете ответ. 
Вот так работает механизм кэширования: сайт просто запоминает данные,
вместо того чтобы пересчитывать их заново.

 Если вы вошли на Facebook, то весь контент, который вы видите, 
адаптирован специально для вас. 
Каждый раз, когда вы заходите нa facebook.com, 
серверам приходится думать, какой контент вас интересует. 
Если же вы не ввели учетные данные на Facebook, 
то вы видите страницу входа. 
Все пользователи видят одну и ту же страницу входа. 
Facebook постоянно получает одинаковые запросы: 
"Я еще не вошел на сайт, выдайте мне домашнюю страницу". 
Сервер перестает выполнять лишнюю работу 
и генерировать домашнюю страницу снова и снова.
Вместо этого он запоминает, как выглядит домашняя страница, 
и отправляет ее вам.

 Такой механизм хранения называется кэшированием. 
Он обладает двумя преимуществами:
 
  вы получаете веб-страницу намного быстрее, как и в том случае, 
 когда вы запомнили расстояние от Земли до Луны. 
 Когда племянница в сле дующий раз задаст вопрос, 
 вам не придется гуг лить. Бы можете выдать ответ мгновенно;

  Facebook приходится выполнять меньше работы.
 
 Кэширование - стандартный способ ускорения работы. 
Все крупные вебсайты применяют кэширование. 
А кэшируемые данные хранятся в хеше!

 Facebook не просто кэширует домашнюю страницу. 
Также кэшируются страницы "0 нас", 
"Условия использования" и многие другие. Следовательно, 
необходимо создать связь URL-aдpeca страницы и данных страницы.

 Когда вы посещаете страницу на сайте Facebook,
сайт сначала проверяет, хранится л и страница в хеше
 
 Вот как это выглядит в коде:


cache = {}


def get_page(url):
    if cache.get(url):
        return cache[url]
    else:
        data = get_data_from_server(url)
        cache[url] = data
        return data


 Здесь сервер выполняет работу только в том случае, 
если URL не хранится в кэше. 
Однако перед тем, как возвращать данные, вы сохраняете их в кэше. 
Когда пользователь в следующий раз запросит тот же URL-aдpec, 
данные можно отправить из кэша 
(вместо того чтобы заставлять сервер выполнять работу).

 Хеши хорошо подходят для решения следующих задач:
 
  моделирование отношений между объектами;
  устранение дубликатов;
  кэширование/запоминание данных вместо выполнения работы на сервере.
'''

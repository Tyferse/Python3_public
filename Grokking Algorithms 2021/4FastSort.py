# Быстрая сортировка

"""
 «Разделяй и властвуй»

 Представьте, что вы фермер, владеющий земельным участком.
Вы хотите равномерно разделить землю
на одинаковые квадратные участки.
Участки должны быть настолько большими, насколько это возможно.

 Как определить наибольший размер квадрата для участка?
Воспользуйтесь стратегией «разделяй и властвуй~!
Алгоритмы на базе этой стратегии являются рекурсивными.

 Решение задачи методом «разделяй и властвуй ~ состоит из двух шагов:

 1. Сначала определяется базовый случай.
 Это должен быть простейший случай из всех возможных.

 2. Задача делится или сокращается до тех пор,
 пока не будет сведена к базовому случаю.

 А теперь воспользуемся стратегией "разделяй и властвуй"
для поиска решения этой задачи. Каков самый большой размер квадрата,
который может использоваться?

 Для начала нужно определить базовый случай. Самая простая ситуация -
если длина одной стороны кратна длине другой стороны.

 Предположим, длина одной стороны составляет 25 м, а длина другой 50 м.
В этом случае размер самого большого участка
составляет 25 м х 25 м,
и надел после деления будет состоять из двух участков .

 Теперь нужно вычислить рекурсивный случай.
Здесь-то вам на помощь и приходит стратегия "разделяй и властвуй".
В соответствии с ней при каждом рекурсивном вызове
задача должна сокращаться. Как сократить эту задачу?
Для начала разметим самые большие участки, которые можно использовать.

 В исходном наделе можно разместить два участка 640 х 640,
и еще останется место. Тут-то и наступает момент истины.
Нераспределенный остаток - это тоже надел земли,
который нужно разделить. Так почему бы не применить к нему
тот же алгоритм?

 Итак, мы начали с надела 1680 х 640,
который необходимо разделить на участки.
Но теперь разделить нужно меньший сегмент - 640 х 400.
Если вы найдете самый большой участок,
подходящий для этого размера, это будет самый большой участок,
подходящий для всей фермы.
Мы только что сократили задачу с размера 1680 х 640 до 640 х 400!

 Применим тот же алгоритм снова. Если начать с участка 640 х 400,
то размеры самого большого квадрата, который можно создать,
составляют 400 х 400 м.

 Остается меньший сегмент с размерами 400 х 240 м.
Отсекая поделенную часть, мы приходим к еще меньшему размеру сегмента,
240 Х 160 М. После очередного отсечения получается еще меньший сегмент.

 Эге, да мы пришли к базовому случаю: 160 кратно 80.
Если разбить этот сегмент на квадраты,
ничего лишнего не останется! Итак,
для исходного надела земли самый большой размер участка
будет равен 80 х 80 м.

 "Разделяй и властвуй" - не простой алгоритм,
который можно применить для решения задачи.
Скорее, это подход к решению задачи. Рассмотрим еще один пример.

 Имеется массив чисел.

 Нужно просуммировать все числа и вернуть сумму.
Сделать это в цикле совсем не сложно:
"""


def summ1(arr):
    total = 0
    for x in arr:
        total += x
        
    return total


print(summ1([1, 2, 3, 4]))


'''
 Но как сделать то же самое с использованием рекурсивной функции?

 Шаr 1: определить базовый случай. Как выглядит самый простой массив, 
который вы можете получить? 
Подумайте, как должен выглядеть простейший случай. 
Если у вас будет массив с О или 1 элементом, 
он суммируется достаточно просто.

 Шаr 2: каждый рекурсивный вызов 
должен приближать вас к пустому массиву. Как уменьшить размер задачи? 
Один из возможных способов:

sum([2, 4, 6]) = 12

2 + sum([4,6]) = 2 + 10 = 12

 В любом случае результат равен 12. 
Но во второй версии функции sum передается меньший массив. 
А это означает, что вы сократил и размер своей задачи!

СОВЕТ
 Когда вы пишете рекурсивную функцию, в которой задействован массив,
базовым случаем часто оказывается пустой массив 
или массив из одного элемента. Если вы не знаете, с чего начать, - 
начните с этого.
'''

'''
 Упражнения
 
 4.1 Напишите код для функции sum.
 
 4.2 Напишите рекурсивную функцию для подсчета элементов в списке.
'''


def summ2(arr):
    if arr is []:
        return 0
    elif len(arr) == 1:
        return arr[0]
    else:
        el = arr[0]
        del arr[0]
        return el + summ2(arr)


print(summ2([4, 3, 1, 37, 5, 89]))

'''
 4.3 Найдите наибольшее число в списке.
'''


def max2(lists):
    if len(lists) == 2:
        return lists[0] if lists[0] > lists[1] else lists[1]
    
    sub_max = max(lists[1:])
    return lists[0] if lists[0] > sub_max else sub_max


print(max2([3, 7, 34, 120, 432, 567, 1000]))

'''
 4.4 Помните бинарный поиск из главы 1? 
Он тоже относится к классу алгоритмов •разделяй и властвуй•. 
Сможете ли вы определить базовый 
и рекурсивный случай для бинарного поиска?
'''


def binary_search(arr, value):
    if len(arr) == 1:
        return arr[0]
    else:
        low = 0
        high = len(arr) - 1

        mid = int((low + high) / 2)
        guess = arr[mid]
        if guess < value:
            return binary_search(arr[mid + 1:high], value)
        elif guess > value:
            return binary_search(arr[low:mid - 1], value)
        else:
            return mid


print(binary_search(range(3, 567), 56))

'''
 Быстрая сортировка

 Быстрая сортировка относится к алгоритмам сортировки. 
Она работает намного быстрее сортировки выбором 
и часто применяется в реальных программах. Например,
в стандартную библиотеку С входит функция с именем qsort, 
реализующая быструю сортировку. 
Быстрая сортировка также основана на стратегии "разделяй и властвуй".
Воспользуемся быстрой сортировкой для упорядочения массива. 
Как выглядит самый простой массив, 
с которым может справиться алгоритм сортировки
(помните подсказку из предыдущего раздела)? 
Некоторые массивы вообще не нуждаются в сортировке.

 Пустые массивы и массивы, содержащие всего один элемент, 
станут базовым случаем. 
Такие массивы можно просто возвращать в исходном виде - 
сортировать ничего не нужно:
'''


def quick_sort(array):
    if len(array) < 2:
        return array


'''
 Теперь перейдем к массивам большего размера. 
Массив из двух элементов тоже сортируется без особых проблем.
А как насчет массива из трех элементов?

 Помните: мы используем стратегию «разделяй и властвуй». Следовательно,
массив должен разделяться до тех пор, 
пока мы не придем к базовому случаю. 
Алгоритм быстрой сортировки работает так: 
сначала в массиве выбирается элемент, который называется опорным.

 О том, как выбрать хороший опорный элемент, будет рассказано далее. 
А пока предположим, 
что опорным становится первый элемент массива. 
Теперь мы находим элементы, меньшие опорного, 
и элементы, большие опорного.

 Этот процесс называется разделением. Теперь у вас имеются:
 
 подмассив всех элементов, меньших опорного;
 
 опорный элемент;
 
 подмассив всех элементов, больших опорного.
 
 Два подмассива не отсортированы - 
они просто выделены из исходного массива.
Но если бы они были отсортированы,
то провести сортировку всего массива было бы несложно.

 Если бы подмассивы были отсортированы, 
то их можно было бы объединить в порядке 
"левый подмассив - опорный элемент - правый подмассив" 
и получить отсортированный массив. В нашем примере получается 
[10, 15] + [33] + [] = [10, 15, 33], то есть отсортированный массив.

 Как отсортировать подмассивы? 
Базовый случай быстрой сортировки уже знает,
как сортировать массивы из двух элементов (левый подмассив) 
и пустые массивы (правый подмассив). Следовательно, 
если применить алгоритм быстрой сортировки к двум подмассивам, 
а затем объединить результаты, получится отсортированный массив!

print(quick_sort([15, 10]) + [33] + quick_sort([]))

 Этот метод работает при любом опорном элементе. Допустим,
вместо 33 в качестве опорного был выбран элемент 15.

 Оба подмассива состоят из одного элемента, 
а вы уже умеете сортировать такие подмассивы. 
Получается, что вы умеете сортировать массивы из трех элементов.
Это делается так:

1. Выбрать опорный элемент.

2. Разделить массив на два подмассива: элементы, меньшие опорного,
и элементы, большие опорного.

3. Рекурсивно применить быструю сортировку к двум подмассивам. 

 Как насчет массива из четырех элементов?
 
 Предположим, опорным снова выбирается элемент 33.
Левый подмассив состоит из трех элементов. 
Вы уже знаете, как сортируется массив из трех элементов:
нужно рекурсивно применить к нему быструю сортировку.

 Следовательно, вы можете отсортировать массив из четырех элементов. 
А если вы можете отсортировать массив из четырех элементов,
то вы также можете отсортировать массив из пяти элементов. 
Почему? Допустим, имеется массив из пяти элементов.

 Все эти подмассивы содержат от О до 4 элементов. А вы уже знаете,
как отсортировать массив, содержащий от О до 4 элементов, 
с использованием быстрой сортировки! Таким образом,
независимо от выбора опорного элемента 
вы можете рекурсивно вызывать быструю сортировку для двух подмассиво.

 Например, предположим, что в качестве опорного выбирается элемент 3.
Вы применяете быструю сортировку к подмассивам.

 Подмассивы отсортированы, и теперь из них можно собрать 
отсортированный массив.  Решение работает даже в том случае, 
если выбрать в качестве опорного элемент 5:

 Итак, решение работает независимо от выбора опорного элемента.
Следовательно, вы можете отсортировать массив из пяти элементов.
По той же логике вы можете отсортировать 
массив из шести элементов и т. д.

 А вот как выглядит программный код быстрой сортировки:
'''


def quicksort(array):
    if len(array) < 2:
        return array
    else:
        pivot = array[0]
        less = [i for i in array[1:] if i <= pivot]

    greater = [i for i in array[1:] if i > pivot]

    return quicksort(less) + [pivot] + quicksort(greater)


print(quicksort([10, 5, 2, 3]))

'''
 Снова об «О-большом»

 Алгоритм быстрой сортировки уникален тем, 
что его скорость зависит от выбора опорного элемента.
Прежде чем рассматривать быструю сортировку, 
вспомним наиболее типичные варианты времени выполнения для "о-большое".

Бинарный поиск
         Простой поиск 
O(log(n))            Быстрая сортировка 
         O(n)                       Сортировка выбором 
                     O(n*log(n))                   Задача о коммивояжере
                                    O(n^2)                  
                                                   O(n!)
                                                                
 Для каждого времени выполнения также приведен пример алгоритма.
Возьмем алгоритм сортировки выбором, 
о котором вы узнали в главе 2. Он обладает временем О(п2 ), 
и это довольно медленный алгоритм.

 Другой алгоритм сортировки - так называемая сортировка слиянием - 
работает за время О(п log п). Намного быстрее! 
С быстрой сортировкой дело обстоит сложнее. 
В худшем случае быстрая сортировка работает за время О( п2 ).

 Ничуть не лучше сортировки выбором! Но это худший случай,
а в среднем быстрая сортировка выполняется за время О(п log п). 
Вероятно, вы спросите:

 что в данном случае понимается под ~худшим~ и ~средним~ случаем?
 
 если быстрая сортировка в среднем выполняется за время О(п log п), 
сортировка слиянием выполняется за время О(п log п) всегда,
то почему бы не использовать сортировку слиянием? Разве она не быстрее?
'''

'''
 Сортировка слиянием и быстрая сортировка

 Допустим, у вас имеется простая функция
для вывода каждого элемента в списке:
'''


def print_items(list1):
    for item in list1:
        print(item)


'''
 Эта функция последовательно перебирает все элементы списка 
и выводит их. Так как функция перебирает весь список,
она выполняется за время О(п). Теперь предположим,  
что вы изменили эту функцию и она делает секундную паузу перед выводом:
'''

from time import sleep


def print_items2(list1):
    for item in list1:
        sleep(1)
        print(item)


'''
 Перед выводом элемента функция делает паузу 
продолжительностью в 1 секунду. Предположим, 
вы выводите список из пяти элементов с использованием обеих функций:

 Обе функции проходят по списку один раз,
и обе выполняются за время О(п). Как вы думаете, 
какая из них работает быстрее?
Я думаю, print_items работает намного быстрее, 
потому что она не делает паузу перед выводом каждого элемента. 
Следовательно, даже при том, 
что обе функции имеют одинаковую скорость «О-большое~, 
реально print_items работает быстрее.
Когда вы используете «О-большое~ (например, О(п)),
в действительности это означает следующее:

              C*h
ФИКСИРОВАННЫЙ ^
ПРОМЕЖУТОК
ВРЕМЕНИ

 Здесь с - некоторый фиксированный промежуток времени 
для вашего алгоритма. Он называется константой. Например, 
время выполнения может составлять 10 милисекунд * п для 
print_items против 1 секунды * п для print_items2.

 Обычно константа игнорируется, 
потому что если два алгоритма имеют разное время «О-большое~,
она роли не играет. Для примера возьмем бинарный и простой поиск
Допустим, такие константы присутствуют в обоих алгоритмах.

10 мс * n      1 с * log(n)
простой       бинарный 
поиск          поиск

 Первая реакция: "ого! У простого поиска константа 
равна 10 миллисекундам, а у бинарного поиска - 1 секунда.
Простой поиск намного быстрее!" Теперь предположим, 
что поиск ведется по списку из 4 миллиардов элементов. 
Время будет таким:

ПPOCTOЙ ПОИСК    1Ф мс * 4 МИЛЛИАРДА = 463 дня
БИНАРНЫЙ ПОИСК     1 с * 32          = 32 СЕКУНДЫ

 Как видите, бинарный поиск все равно работает намного быстрее.
Константа ни на что не повлияла.

 Однако в некоторых случаях константа может иметь значение. 
Один из примеров такого рода - быстрая сортировка и сортировка слиянием.
У быстрой сортировки константа меньше, чем у сортировки слиянием, 
поэтому, несмотря на то Что оба алгоритма 
характеризуются временем О(п log п), 
быстрая сортировка работает быстрее. 
А на практике быстрая сортировка работает быстрее, 
потому что средний случай встречается намного чаще худшего.

 А теперь ответим на первый вопрос: 
как выглядит средний случай по сравнению с худшим?
'''

'''
 Средний и худший случай

 Быстродействие быстрой сортировки сильно зависит 
от выбора опорного элемента. Предположим, 
опорным всегда выбирается первый элемент,
а быстрая сортировка применяется к уже отсортированному массиву. 
Быстрая сортировка не проверяет, отсортирован входной массив или нет, 
и все равно пытается его отсортировать.

 Обратите внимание: на этот раз массив не разделяется на две половины.
Вместо этого один из двух подмассивов всегда пуст, 
так что стек вызовов получается очень длинным. Теперь предположим,
что в качестве опорного всегда выбирается средний элемент.
Посмотрим, как выглядит стек вызовов в этом случае.

 Стек намного короче! Массив каждый раз делится надвое, 
поэтому такое количество рекурсивных вызовов излишне. 
Вы быстрее добираетесь до базового случая, 
и стек вызовов получается более коротким.

 Первый из рассмотренных примеров описывает худший сценарий, 
а второй - лучший. В худшем случае размер стека описывается как О(п). 
В лучшем случае он составит O(log п).

 Теперь рассмотрим первый уровень стека. 
Один элемент выбирается опорным, 
а остальные элементы делятся на подмассивы.
Вы перебираете все восемь элементов массива, 
поэтому первая операция выполняется за время О(п). 
На этом уровне стека вызовов вы обратились ко всем восьми элементам.
Но на самом деле вы обращаетесь к О(п) элементам 
на каждом уровне стека вызовов!

 Даже если массив будет разделен другим способом, 
вы все равно каждый раз обращаетесь к О( п) элементам.
Итак, завершение каждого уровня требует времени О(п).

 В этом примере существуют O(log п) 
(с технической точки зрения правильнее сказать 
«высота стека вызовов равна O(log(n))» уровней.
А так как каждый уровень занимает время О(п), 
то весь алгоритм займет время О(п) * O(log п) = О(п log п). 
Это сценарий лучшего случая.

 В худшем случае существуют О(п) уровней, 
поэтому алгоритм займет время О(п) * О(п) = О(п^2).

 А теперь сюрприз: лучший случай также является средним. 
Если вы всегда будете выбирать опорным элементом 
случайный элемент в массиве, быстрая сортировка в среднем 
завершится за время О(п log п).  Это один из самых быстрых 
существующих алгоритмов сортировки, 
который заодно является хорошим примером 
стратегии «разделяй и властвуй».
'''

'''
 Упражнения
 
 Запишите «О -большое» для каждой из следующих операций ?
 
 4.5 Вывод значения каждого элемента массива.
 Ответ: O(n)
 4.6 Удвоение значения каждого элемента массива.
 Ответ: O(n)
 4.7 Удвоение значения только первого элемента массива.
 Ответ: O(1)
 4.8 Создание таблицы умножения для всех элементов массива. Например, 
если массив состоит из элементов [2, 3, 7, 8, 10], 
сначала каждый элемент умножается на 2, 
затем каждый элемент умножается на 3, затем на 7 и т. д.
 Ответ: O(n^2)
 
 Стратегия "разделяй и властвуй" омнована 
на разбиении задач на уменьшающиеся фрагменты.
Если вы используете стратегию «разделяй и властвуй» со списком, 
то базовым случаем, скорее всего, 
является пустой массив или массив из одного элемента.

 Если вы реализуете алгоритм быстрой сортировки,
выберите в качестве опорного случайный элемент. 
Среднее время выполнения быстрой сортировки составляет О(п log п)!

 Константы в «О-большом» иногда могут иметь значение. 
Именно по этой причине быстрая сортировка быстрее сортировки слиянием.

 При сравнении простой сортировки с бинарной константа 
почти никогда роли не играет, потому что O(log п) 
слишком сильно превосходит О(п) по скорости при большом размере списка.
'''

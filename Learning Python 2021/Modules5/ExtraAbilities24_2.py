"""
 Импортирование модулей по имени в виде строки

 Имя модуля в инструкции import или from является именем переменной.
Тем не менее иногда ваша программа будет получать имя модуля, который
следует импортировать, в виде строки во время выполнения (например,
в случае, когда пользователь выбирает имя модуля внутри графического
интерфейса). К сожалению, невозможно напрямую использовать инструкции
импорта для загрузки модуля, имя которого задано в виде строки, –
в этих инструкциях интерпретатор ожидает получить имя переменной,
а не строку. Например:

\>>> import “string”
  File “<stdin>”, line 1
import “string”
^
SyntaxError: invalid syntax

 Точно так же невозможно импортировать модуль, если просто присвоить
строку переменной:

x = “string”
import x

 Здесь интерпретатор попытается импортировать файл x.py,
а не модуль string - имя в инструкции import превращается
в имя переменной, которой присваивается объект загружаемого модуля,
и идентифицирует внешний файл буквально.

 Чтобы решить эту проблему, необходим специальный инструмент,
выполняющий динамически загрузку модулей, имена которых создаются
в виде времени выполнения. Обычно для этого конструируется строка
программного кода, содержащая инструкцию import, которая затем
передается встроенной функции exec для исполнения (в Python 2.6 exec –
это инструкция, но она может использоваться точно так же, как показано
здесь, – круглые скобки просто игнорируются интерпретатором):

\>>> modname = “string”
\>>> exec(“import “ + modname)
# Выполняется как строка программного кода
\>>> string   # Модуль был импортирован в пространство имен
<module ‘string’ from ‘c:\Python30\lib\string.py’>

 Функция exec (и родственная ей функция eval, используемая
для вычисления значений выражений) скомпилирует строку в код и передаст
его интерпретатору для исполнения. В языке Python компилятор байт-кода
доступен непосредственно во время выполнения, поэтому можно писать
программы, которые конструируют и выполняют другие программы, как в этом
случае. По умолчанию функция exec выполняет программный код в текущей
области видимости, но существует возможность передавать ей
необязательные словари пространств имен.

 Единственный настоящий недостаток функции exec состоит в том, что она
должна компилировать инструкцию import всякий раз, когда
она запускается, – если импортировать приходится достаточно часто,
программный код может работать немного быстрее при использовании
встроенной функции __import__, которая выполняет загрузку модуля,
получая его имя в виде строки. Результат получается тот же самый,
но функция __import__ возвращает объект модуля, поэтому его надо
присвоить переменной, чтобы сохранить:

\>>> modname = “string”
\>>> string = __import__(modname)
\>>> string
<module ‘string’ from ‘c:\Python30\lib\string.py’>


 Транзитивная перезагрузка модулей

 В главе 22 мы изучали возможность повторной загрузки модулей,
как способ ввести в действие изменения в программном коде без остановки
и перезапуска программы. Когда выполняется повторная загрузка модуля,
интерпретатор перезагружает только данный конкретный файл модуля –
он не выполняет повторную загрузку модулей, которые были импортированы
перезагружаемым модулем.

 Например, если выполняется перезагрузка некоторого модуля A,
и A импортирует модули B и C, перезагружен будет только модуль A,
но не B и C. Инструкции внутри модуля A, которые импортируют
модули B и C, будут перезапущены в процессе перезагрузки, но они просто
вернут объекты уже загруженных модулей B и C (предполагается,
что к этому моменту они уже были импортированы). Чтобы было более
понятно, ниже приводится пример содержимого файла A.py:

import B   # Эти модули не будут перезагружены вместе с A
import C   # Просто будут импортированы уже загруженные модули

% python
\>>> ...
\>>> from imp import reload
\>>> reload(A)

 Не следует полагаться на транзитивную перезагрузку модулей – лучше
несколько раз вызывайте функцию reload для непосредственного обновления
субкомпонентов. В крупных системах это может потребовать выполнить
значительный объем работы при тестировании в интерактивной оболочке.
При желании можно предусмотреть в программе автоматическую перезагрузку
ее компонентов, добавив вызовы reload в родительские модули, каким здесь
является A, но это усложнит реализацию модуля.

 Еще лучше было бы написать универсальный инструмент для транзитивной
перезагрузки модулей, сканируя содержимое атрибутов __dict__ модулей
и проверяя атрибут type в каждом элементе, чтобы отыскать
вложенные модули. Такие вспомогательные функции могут рекурсивно
вызывать сами себя и обходить произвольные цепочки импортирования.
Атрибут __dict__ модулей был представлен выше,
в разделе  «Модули – это объекты: метапрограммы», а функция type
была представлена в главе 9; от нас требуется лишь объединить
эти два инструмента.

 Например, модуль reloadall.py, в листинге ниже, содержит функцию
reload_all, автоматически выполняющую перезагрузку модуля, каждого
импортируемого им модуля и так далее, до самого конца каждой цепочки
импортирования. Она использует словарь, с помощью которого отыскивает
уже загруженные модули, рекурсию – для обхода цепочек импорта и модуль
types из стандартной библиотеки, в котором просто предопределены
значения атрибута type для всех встроенных типов. Словарь visited
применяется с целью избежать зацикливания в случае появления рекурсивных
или избыточных инструкций импортирования. Этот прием основан
на том факте, что объекты модулей могут играть роль ключей словаря
(как мы узнали в главе 5, множества также могут предложить подобную
возможность, если использовать метод visited.add(module)):
"""

"""
reloadall.py: транзитивная перезагрузка вложенных модулей
"""

import types
from importlib import reload  # требуется в версии 3.0


def status(module):
    print('reloading ' + module.__name__)


def transitive_reload(module, visited):
    if module not in visited:  # Пропустить повторные посещения
        status(module)  # Перезагрузить модуль
        reload(module)  # И посетить дочерние модули
        visited[module] = None

        for attrobj in module.__dict__.values():  # Для всех атрибутов
            if type(attrobj) == types.ModuleType:  # Рекурсия, если
                #                                              модуль
                transitive_reload(attrobj, visited)


def reload_all(*args):
    visited = {}
    for arg in args:
        if type(arg) == types.ModuleType:
            transitive_reload(arg, visited)


if __name__ == '__main__':
    # Тест: перезагрузить самого себя
    reload_all(__import__('ExtraAbilities24_2'))  # Должна перезагрузить
    # этот модуль и модуль types

"""
 Чтобы воспользоваться этой утилитой, импортируйте функцию reload_all
и передайте ей имя уже загруженного модуля (как если бы это была 
встроенная функция reload). Когда файл запускается как самостоятельная 
программа, его код самопроверки выполнит проверку самого модуля – 
он должен импортировать самого себя, потому что его собственное имя 
не будет определено в файле без инструкции импортирования
(этот программный код работает под управлением обеих версий Python,
3.0 и 2.6, и выводит одни и те же данные, благодаря тому,
что мы использовали операцию + конкатенации вместо запятой 
в инструкции print):

C:\misc> c:\Python30\python reloadall.py
reloading reloadall
reloading types

 Ниже приводится результат применения этого модуля, под управлением
Python 3.0, к некоторым модулям из стандартной библиотеки. Обратите
внимание, что модуль os импортируется модулем tkinter, при этом модуль 
tkinter импортирует модуль sys раньше, чем модуль os (если вы захотите
выполнить этот тест под управлением Python 2.6, замените имя tkinter
на Tkinter):
"""

import os
import tkinter

reload_all(os)

reload_all(tkinter)

"""
 А ниже приводится листинг сеанса, в котором демонстрируются различия
между обычной и транзитивной операциями перезагрузки, – изменения, 
выполненные в двух вложенных файлах, не вступят в силу после 
перезагрузки, если не использовать транзитивную утилиту:

import b   # a.py
X = 1

import c   # b.py
Y = 2

Z = 3      # c.py

C:\misc> C:\Python30\python
>>> import a
>>> a.X, a.b.Y, a.b.c.Z
(1, 2, 3)

# Здесь были изменены значения, присваиваемые переменным 
# во всех трех файлах

>>> from importlib import reload
>>> reload(a)              # Обычная функция reload перезагружает только
<module ‘a’ from ‘a.py’>   # указанный файл
>>> a.X, a.b.Y, a.b.c.Z
(111, 2, 3)
>>> from reloadall import reload_all
>>> reload_all(a)
reloading a
reloading b
reloading c
>>> a.X, a.b.Y, a.b.c.Z      # Вложенные модули также были перезагружены
(111, 222, 333)

 Я рекомендую поэкспериментировать с этим примером самостоятельно, чтобы
глубже вникнуть в смысл происходящего, – это еще один инструмент, 
доступный для импортирования, который вы можете добавить 
в свою собственную библиотеку.


 Концепции проектирования модулей
 
 Как и в случае с функциями, при проектировании модулей используются
свои правила: вам необходимо подумать о том, какие функции и в какие
модули будут входить, предусмотреть механизмы взаимодействия между
модулями и так далее. Все это станет более понятным, когда вы начнете
создавать крупные программы на языке Python, а пока ознакомьтесь 
с несколькими основными положениями:

  В языке Python вы всегда находитесь в модуле. Нет никакого способа
 написать программный код, который не находился бы в каком-нибудь 
 модуле. Фактически даже программный код, который вводится 
 в интерактивной оболочке, на самом деле относится к встроенному модулю 
 с именем __main__ – единственная уникальная особенность интерактивной 
 оболочки состоит в том, что программный код после выполнения сразу же
 удаляется, а результаты выражений выводятся автоматически.

  Минимизируйте взаимозависимость модулей: глобальные переменные.
 Как и функции, модули работают лучше, когда они написаны 
 как самостоятельные закрытые компоненты. Следуйте правилу: модули
 должны быть максимально независимы от глобальных имен в других модулях.

  Максимизируйте согласованность внутри модуля: общая цель. Уменьшить 
 взаимозависимость модулей можно за счет увеличения согласованности 
 отдельного модуля – если все компоненты модуля используются
 для достижения общей цели, маловероятно, что такой модуль будет 
 зависеть от внешних имен.

  Модули должны редко изменять переменные в других модулях. 
 Мы демонстрировали справедливость этого правила на примере программного
 кода в главе 17. Но будет совсем не лишним повторить его: использование
 глобальных переменных из других модулей (в конце концов, 
 это один из способов, каким клиенты импортируют службы) – совершенно 
 нормальное явление, тогда как внесение изменений в глобальные 
 переменные в других модулях служит признаком проблем с проектированием.
 Конечно, из этого правила есть исключения, но вы должны стремиться 
 обмениваться данными через такие механизмы, как аргументы 
 и возвращаемые значения функций, не прибегая к прямому изменению 
 переменных в других модулях. В противном случае глобальные значения
 могут попасть в зависимость от порядка выполнения инструкций 
 присваивания в других файлах, и такие модули будет сложнее понять 
 и приспособить к повторному использованию в других программах.

 Для иллюстрации на рис. приводится окружение, в котором действуют
модули. Модули содержат переменные, функции, классы и другие модули
(если импортируют их). В функциях имеются свои собственные локальные
переменные. С классами – еще одной разновидностью объектов, 
которые находятся в модулях, – вы познакомитесь в главе 25.


 Типичные проблемы при работе с модулями
 
 
 Порядок следования инструкций на верхнем уровне имеет значение
 
 Когда модуль впервые импортируется (или загружается повторно), 
интерпретатор выполняет инструкции в нем одну за другой, сверху вниз. 
Из этого следует несколько замечаний, касающихся опережающих ссылок 
на переменные, которые следует подчеркнуть особо:

  Инструкции программного кода на верхнем уровне в файле модуля 
 (не вложенные в функцию) выполняются, как только интерпретатор 
 достигает их в процессе импортирования. По этой причине он не может
 ссылаться на имена, присваивание которым производится ниже.
 
  Программный код внутри функций не выполняется, пока функция не будет 
 вызвана, – разрешение имен внутри функций не производится до момента
 их вызова, поэтому они обычно могут ссылаться на имена, расположенные
 в любой части файла.
 
 Вообще опережающие ссылки доставляют беспокойство только в программном 
коде верхнего уровня, который выполняется немедленно; функции могут 
ссылаться на любые имена. Ниже приводится пример, демонстрирующий 
опережающие ссылки:

func1()             # Ошибка: имя “func1” еще не существует
def func1():
print(func2())      # OK: поиск имени “func2” будет выполнен позднее
func1()             # Ошибка: имя “func2” еще не существует
def func2():
return “Hello”
func1()             # OK: “func1” и “func2” определены

 Когда этот файл будет импортироваться (или запускаться 
как самостоятельная программа), интерпретатор Python будет выполнять 
его инструкции сверху вниз. Первый вызов func1 потерпит неудачу,
потому что инструкция def для имени func1 еще не была выполнена.
Вызов func2 внутри func1 будет работать без ошибок при условии, 
что к моменту вызова func1 инструкция def func2 уже будет выполнена 
(этого еще не произошло к моменту второго вызова func1 на верхнем 
уровне). Последний вызов func1 в конце файла будет выполнен успешно, 
потому что оба имени, func1 и func2, уже определены.

 Смешивание инструкций def с программным кодом верхнего уровня не только
осложняет его чтение, но еще и ставит его работоспособность 
в зависимость от порядка следования инструкций. Если вам необходимо 
объединять в модуле программный код, выполняемый непосредственно,
с инструкциями def, возьмите за правило помещать инструкции def 
в начало файла, а программный код верхнего уровня – в конец файла.
При таком подходе ваши функции гарантированно будут определены 
к моменту выполнения программного кода, который их использует.


 Инструкция from создает копии, а не ссылки
 
 Несмотря на то что инструкция from широко применяется, она часто 
становится источником самых разных проблем. Инструкция from
при выполнении присваивания именам в области видимости импортирующего 
модуля не создает синонимы, а копирует имена. Результат будет 
тем же самым, что и для любых других инструкций присваивания 
в языке Python, но есть одно тонкое отличие, особенно когда программный 
код, использующий объекты совместно, находится в разных файлах. 
Например, предположим, что у нас имеется следующий модуль (nested1.py):

# nested1.py
X = 99
def printer(): print(X)

 Если импортировать эти два имени с помощью инструкции from в другом 
модуле (nested2.py), будут получены копии этих имен, а не ссылки на них.
Изменение имени в импортирующем модуле приведет к изменениям только
локальной версии этого имени, а имя в модуле nested1.py будет иметь
прежнее значение:

# nested2.py
from nested1 import X, printer  # Копировать имена
X = 88                          # Изменит только локальную версию “X”!
printer()                       # X в nested1 по-прежнему будет равно 99

% python nested2.py
99

 Однако если выполнить импорт всего модуля с помощью инструкции import
и затем изменить значение с использованием полного имени, это приведет 
к изменению имени в файле nested1.py. Квалифицированное имя направляет
интерпретатор к имени в указанном объекте модуля, а не к имени 
в импортирующем модуле nested3.py:

# nested3.py
import nested1  # Импортировать модуль целиком
nested1.X = 88  # OK: изменяется имя X в nested1
nested1.printer()
% python nested3.py
88

 Инструкция from * может затушевывать смысл переменных
 
 Я упоминал об этом ранее, но оставил подробности до этого момента. 
Поскольку в инструкции from module import * не указываются необходимые
имена переменных, она может непреднамеренно перезаписать имена, 
уже используемые в области видимости импортирующего модуля. Хуже того, 
это может осложнить поиск модуля, откуда исходит переменная, вызвавшая 
проблемы. Это особенно верно, когда форма инструкции from * 
используется более чем в одном импортированном файле.

 Например, если инструкция from * применяется к трем модулям, 
то у вас не будет иного способа узнать, какая в действительности 
вызывается функция, кроме как выполнить поиск в трех разных файлах 
модулей (каждый из которых может находиться в отдельном каталоге):

>>> from module1 import *  # Плохо: может незаметно перезаписать мои 
>>> from module2 import *  # Еще хуже: нет никакого                имена
>>> from module3 import *  # способа понять, что мы получили!
>>> ...
>>> func() # Ну???

 Решение опять же заключается в том, чтобы так не делать: старайтесь 
явно перечислять требуемые атрибуты в инструкции from и ограничивайте 
применение формы from * одним модулем на файл. В этом случае любые 
неопределенные имена, согласно дедуктивному методу, должны находиться 
в модуле, который импортируется единственной инструкцией from *. Этой
проблемы вообще можно избежать, если всегда использовать инструкцию 
import вместо from, но это слишком сложно – как и многое другое 
в программировании, инструкция from – очень удобный инструмент 
при разумном использовании. Даже этот пример не может расцениваться,
как неправильный, – этот способ вполне может применяться в программах,
для большего удобства собирающих имена в одном месте, при условии, 
что это место хорошо известно.


 Функция reload может не оказывать влияния, 
если импорт осуществлялся инструкцией from

 Это еще одна ловушка, связанная с инструкцией from: как уже говорилось 
ранее, инструкция from копирует (присваивает) имена при выполнении,
поэтому нет никакой обратной связи с модулем, откуда были скопированы
имена. Имена, скопированные инструкцией from, просто становятся ссылками
на объекты, на которые ссылались по тем же именам в импортируемом 
модуле, когда была выполнена инструкция from.

 Вследствие этого повторная загрузка импортируемого модуля может 
не оказывать воздействия на клиентов, которые импортировали его имена 
с помощью инструкции from. То есть имена в модулях-клиентах будут 
по-прежнему ссылаться на оригинальные объекты, полученные инструкцией
from, даже если имена в оригинальном модуле будут переопределены:

from module import X  # X может не измениться в результате перезагрузки!
. . .
from importlib import reload
reload(module)  # Изменится модуль, но не мои имена
X               # По-прежнему ссылается на старый объект

 Чтобы сделать повторную загрузку более эффективной, используйте
инструкцию import и полные имена переменных вместо инструкции from.
Поскольку полные имена всегда ведут обратно в импортированный модуль,
после повторной загрузки они автоматически будут связаны с новыми 
именами в модуле. 

import module                # Получить объект модуля, а не имена
. . .
from importlib import reload
reload(module)               # Изменит непосредственно сам объект модуля
module.X          # Текущее значение X: отражает результат перезагрузки


 reload, from и тестирование в интерактивной оболочке
 
 На практике предыдущая проблема имеет более глубокие корни, чем может
показаться. В главе 3 уже говорилось, что из-за возникающих сложностей 
лучше не использовать операции импорта и повторной загрузки для запуска
программ. Дело еще больше осложняется, когда в игру вступает инструкция
from. Начинающие осваивать язык Python часто сталкиваются с проблемой,
описываемой здесь. Представим, что после открытия модуля 
в окне редактирования текста вы запускаете интерактивный сеанс, 
чтобы загрузить и протестировать модуль с помощью инструкции from:

from module import function
function(1, 2, 3)

 Отыскав ошибку, вы переходите обратно в окно редактирования, 
исправляете ее и пытаетесь повторно загрузить модуль следующим способом:

from importlib import reload
reload(module)

 Но вы не получите ожидаемого эффекта – инструкция from создала 
имя function, но не создала имя module. Чтобы сослаться на модуль
в функции reload, его сначала необходимо импортировать инструкцией
import:

from importlib import reload
import module
reload(module)
function(1, 2, 3)

 Однако и в этом случае вы не получите ожидаемого эффекта – функция 
reload обновит объект модуля, но, как говорилось в предыдущем разделе,
имена, такие как function, скопированные из модуля ранее, по-прежнему 
продолжают ссылаться на старые объекты (в данном случае – 
на первоначальную версию функции). Чтобы действительно получить доступ 
к новой версии функции, после перезагрузки модуля ее необходимо вызывать 
как module.function или повторно запустить инструкцию from:

from importlib import reload
import module
reload(module)
from module import function     # Или оставить этот прием и использовать
function(1, 2, 3)               # module.function()

 Теперь наконец-то нам удалось запустить новую версию функции. 
Как видите, прием, основанный на использовании функции reload в паре
с инструкцией from, имеет врожденные проблемы: вы не только должны
не забывать перезагружать модуль после импорта, но и не забывать 
повторно запускать инструкции from после перезагрузки модуля. 
Это достаточно сложно, чтобы время от времени сбивать с толку даже 
опытного программиста. (При этом в Python 3.0 описываемая ситуация 
только усугубилась, потому что нужно не забыть импортировать саму
 функцию reload!)

 Вы не должны ожидать, что функция reload и инструкция from будут
безукоризненно работать в паре. Лучше всего вообще не объединять их – 
используйте функцию reload в паре с инструкцией import или запускайте
свои программы другими способами, как предлагалось в главе 3, например, 
выбирая пункт Run (Запустить) → Run Module (Запустить модуль) в меню 
среды разработки IDLE щелчком мыши на ярлыке файла, из командной строки
системы или с помощью встроенной функции exec.


 Рекурсивный импорт с инструкцией from может не работать

 Напоследок я оставил самую странную (и, к счастью, малоизвестную)
проблему. В ходе импортирования инструкции в файле выполняются 
от начала и до конца, поэтому необходимо быть внимательнее, когда 
используются модули, импортирующие друг друга (эта ситуация называется
рекурсивным импортом). Поскольку не все инструкции в модуле могут быть 
выполнены к моменту запуска процедуры импортирования другого модуля, 
некоторые из его имен могут оказаться еще не определенными.

 Если вы используете инструкцию import, чтобы получить модуль целиком, 
это может иметь, а может не иметь большого значения – имена модуля
не будут доступны, пока позже не будут использованы полные имена 
для получения их значений. Но если для получения определенных имен
используется инструкция from, имейте в виду, у вас будет доступ только 
к тем именам, которые уже были определены в этом модуле.

 Например, рассмотрим следующие модули, recur1 и recur2. Модуль recur1 
создает имя X и затем импортирует recur2 до того, как присвоит значение 
имени Y. В этом месте модуль recur2 может импортировать модуль recur1
целиком с помощью инструкции import (он уже существует во внутренней 
таблице модулей интерпретатора), но если используется инструкция from, 
ей будет доступно только имя X, а имя Y, которому будет присвоено
значение только после инструкции import в recur1, еще не существует,
поэтому возникнет ошибка:

# recur1.py
X = 1
import recur2        # Запустить recur2, если он еще не был импортирован
Y = 2

# recur2.py
from recur1 import X  # OK: “X” уже имеет значение
from recur1 import Y  # Ошибка: “Y” еще не существует

C:\misc> C:\Python30\python
>>> import recur1
Traceback (innermost last):
  File “<stdin>”, line 1, in ?
  File “recur1.py”, line 2, in ?
    import recur2
  File “recur2.py”, line 2, in ?
    from recur1 import Y            # Ошибка: “Y” еще не существует
ImportError: cannot import name Y

 При рекурсивном импорте модуля recur1 и модуля recur2 интерпретатор
не будет повторно выполнять инструкции модуля recur1 (в противном случае
это могло бы привести к бесконечному циклу), но пространство имен модуля
recur1 еще не заполнено до конца к моменту, когда он импортируется 
модулем recur2. Решение? Не используйте инструкцию from в операции 
рекурсивного импорта (в самом деле!). Интерпретатор не зациклится, 
если вы все-таки сделаете это, но ваша программа попадет в зависимость 
от порядка следования инструкций в модулях.

 Существует два способа решения этой проблемы:
 
  Обычно можно ликвидировать рекурсивный импорт, подобный приведенному, 
 правильно проектируя модули: увеличить согласованность внутри модуля 
 и уменьшить взаимозависимость между модулями – это самое первое,
 что стоит попробовать сделать.
 
  Если от циклов не удается избавиться полностью, попробуйте отсрочить
 обращение к именам модуля, используя инструкции import и полные имена 
 (вместо инструкции from), или поместите инструкции from либо внутрь
 функций (чтобы они не вызывались в программном коде верхнего уровня),
 либо ближе к концу файла, чтобы отложить их выполнение.
"""

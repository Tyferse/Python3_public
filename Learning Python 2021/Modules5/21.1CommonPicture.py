"""
 Модули: общая картина


 Зачем нужны модули?

 В двух словах, модули обеспечивают простой способ организации
компонентов в систему автономных пакетов переменных, известных
как пространства имен. Все имена, определяемые на верхнем уровне модуля,
становятся атрибутами объекта импортируемого модуля. Как мы видели
в предыдущей части, операция импорта предоставляет доступ к именам
в глобальной области видимости модуля. Таким образом, в процессе
импортирования глобальная область видимости модуля образует пространство
имен атрибутов объекта модуля. В конечном счете модули позволяют
связывать отдельные файлы в крупные программные системы.

 Если говорить более определенно, с точки зрения теории модули играют
как минимум три роли:

 Повторное использование программного кода
  Как говорилось в главе 3, модули позволяют сохранять программный код
 в виде файлов. В отличие от программного кода, который вводится
 в интерактивной оболочке интерпретатора Python и исчезает безвозвратно
 после выхода из оболочки, программный код в файлах модулей хранится
 постоянно – его можно повторно загружать и запускать столько раз,
 сколько потребуется. Можно добавить, что модули – это место,
 где определяются имена, известные как атрибуты, на которые могут
 ссылаться множество внешних клиентов.

 Разделение системы пространств имен

  Модули в языке Python также являются самой высокоуровневой единицей
 организации программ. По существу, они – всего лишь пакеты имен. Модули
 позволяют изолировать имена в замкнутые пакеты, которые позволяют
 избежать конфликтов имен – вы никогда не увидите имя в другом файле,
 если не импортируете его. Фактически все, что находится в модуле, –
 выполняемый программный код и создаваемые объекты – всегда неявно
 включается в модули. Вследствие этого модули являются естественными
 инструментами группировки компонентов системы.

 Реализация служб или данных для совместного пользования

  С функциональной точки зрения модули могут также использоваться
 для реализации компонентов, используемых системой, вследствие чего
 требуется только одна копия такого компонента. Например, если необходим
 глобальный объект, который используется более чем одной функцией
 или модулем, можно написать его в виде модуля, который затем может
 импортироваться множеством клиентов.

 Однако, чтобы понять действительную роль модулей в системе Python,
нам необходимо отступить на шаг назад и исследовать общую структуру
программы на языке Python.


 Архитектура программы на языке Python

 До сих пор в этой книге я избегал сложностей в описаниях программ
на языке Python. Обычно программы состоят более, чем из одного файла, –
любые программы, за исключением самых простых сценариев, состоят
из нескольких файлов. Даже если вам удастся поместить всю логику
в один файл, вы почти наверняка будете использовать сторонние модули,
которые уже кем-то были написаны.

 В этом разделе дается введение в общую архитектуру программ на языке
Python – способ, которым программа делится на коллекцию файлов
с исходными текстами (то есть модулей) и увязывается в единое целое.
Кроме того, мы попутно рассмотрим основные концепции модулей
в языке Python, процедуру импортирования и атрибуты объектов.


 Как организована программа

 Как правило, программа на языке Python состоит из множества текстовых
файлов, содержащих инструкции. Программа организована как один главный
файл, к которому могут подключаться дополнительные файлы, известные
как модули. Главный файл (или сценарий) определяет, как будет двигаться
основной поток выполнения программы, – это тот файл, который необходимо
запустить, чтобы начать работу приложения. Файлы модулей –
это библиотеки инструментальных средств, где содержатся компоненты,
используемые главным файлом (и, возможно, где-то еще). Главный файл
использует инструменты, определенные в файлах модулей, а модули
используют инструменты, определенные в других модулях.

 Обычно файлы модулей ничего не делают, если попытаться запустить их
отдельно – в них определяются инструментальные средства, используемые
в других файлах. Чтобы получить доступ к определенным в модуле
инструментам, именующимся атрибутами модуля (имена переменных, связанные
с такими объектами, как функции), в языке Python необходимо
импортировать этот модуль. То есть мы импортируем модули и получаем
доступ к их атрибутам, что дает нам возможность использовать их
функциональные возможности.


 Импортирование и атрибуты

 Давайте сделаем наше обсуждение более конкретным. На рис. схематически
изображена структура программы на языке Python, состоящей из трех
файлов: a.py, b.py и c.py. Файл a.py является главным файлом программы –
это простой текстовый файл, состоящий из инструкций, который при запуске
выполняется от начала и до конца. Файлы b.py и c.py – это модули,
они также являются простыми текстовыми файлами, содержащими инструкции,
но обычно они не запускаются как самостоятельные программы. Вместо этого
они, как уже говорилось выше, обычно импортируются другими файлами,
использующими инструментальные средства, определяемые в этих файлах.

 Например, предположим, что файл b.py на рис. 21.1 определяет функцию
с именем spam. Как мы уже знаем из четвертой части книги,
чтобы определить функцию, которая затем сможет быть запущена за счет
передачи ей нуля или более аргументов в круглых скобках, файл b.py
должен содержать инструкцию def:

def spam(text):
    print(text, ‘spam’)

 Теперь предположим, что модуль a.py использует функцию spam.
Для этого он мог бы содержать следующие инструкции:

import b
b.spam(‘gumby’)

 В первой строке здесь располагается инструкция import, дающая файлу
a.py доступ ко всему, что определено на верхнем уровне в файле b.py.
В общих чертах это означает следующее: «загрузить файл b.py (если он
еще не загружен) и предоставить доступ ко всем его атрибутам через
имя модуля b». Инструкции import (и, как вы узнаете далее, from)
загружают и запускают другие файлы на этапе времени выполнения.

 В языке Python невозможно обращаться к именам в других модулях, пока
такие инструкции импорта не будут выполнены на этапе времени выполнения.
Основная задача этих инструкций состоит в том, чтобы связать имена
в модуле – простые переменные – с объектами загруженных модулей.
Фактически имя модуля, используемое в инструкции import, во-первых,
идентифицирует внешний файл и, во-вторых, становится именем переменной,
которая будет представлять загруженный модуль. Объекты, определяемые
модулем, также создаются во время выполнения, когда производится импорт
модуля: инструкция import, в действительности, последовательно выполняет
инструкции в указанном файле, чтобы воссоздать его содержимое.

 Вторая инструкция в файле a.py вызывает функцию spam, определенную
 в модуле b, используя форму записи атрибутов объекта. Запись b.spam
означает следующее: «извлечь значение имени spam, расположенного
в объекте b». В нашем примере – это вызываемая функция, поэтому далее
ей передается строка в круглых скобках (‘gumby’). Если вы создадите
эти файлы, сохраните их и запустите файл a.py, то будут выведены слова
«gumby spam».

 Вы увидите, что повсюду в сценариях на языке Python используется
нотация object.attribute – большинство объектов обладают атрибутами,
доступ к которым можно получить с помощью оператора «.». Некоторые
атрибуты – имена вызываемых функций, а другие – простые значения,
которые представляют свойства объекта (например, имя персоны).

 Импорт – широко используемое понятие в языке Python. Любой файл может
импортировать функциональные возможности из любого другого файла.
Например, файл a.py может импортировать файл b.py, чтобы иметь
возможность вызывать его функцию, при этом файл b.py может
в свою очередь импортировать файл c.py, чтобы получить доступ к другим
функциональным возможностям, определенным в нем. Цепочка импортирования
может уходить так глубоко, как это потребуется: в этом примере модуль a
может импортировать модуль b, который импортирует модуль c, который
в свою очередь может еще раз импортировать модуль b, и так далее.

 Помимо самой крупной единицы в организационной структуре программы
модули (и пакеты модулей, которые описываются в главе 23) также играют
роль самой крупной единицы программного кода, доступного для повторного
использования. Оформив программные компоненты в виде файлов модулей,
вы сможете использовать их не только в оригинальной программе,
но и в любых других программах, которые вам придется писать. Например,
если после написания программы, структура которой изображена на рис.,
вдруг обнаружится, что функция b.spam является универсальным
инструментом, мы сможем использовать в других программах. Все, что нам
потребуется, – это импортировать файл b.py из файлов другой программы.


 Модули стандартной библиотеки

 Обратите внимание на правую часть рис. Некоторые из модулей, которые
будут импортироваться вашими программами, входят непосредственно
в состав языка Python, и вам не придется писать их.

 Интерпретатор Python поставляется с обширной коллекцией дополнительных
модулей, которая известна как стандартная библиотека. Эта коллекция
насчитывает порядка 200 крупных модулей и содержит платформно-зависимую
поддержку распространенных задач программирования: интерфейсы
операционных систем, организацию хранилищ объектов, поиск по шаблону,
сетевые взаимодействия, создание графического интерфейса
и многих других. Ни один из этих инструментов не является
непосредственной частью языка Python, но вы можете использовать их,
импортируя соответствующие модули. Так как это модули стандартной
библиотеки, можно быть уверенным, что они будут доступны
и будут работать переносимым образом на большинстве платформ, на которых
работает интерпретатор Python.

 В примерах этой книги вы увидите несколько модулей стандартной
библиотеки в действии, но за полной информацией вам следует обратиться
к справочному руководству по стандартной библиотеке языка Python,
которое можно найти в инсталляции Python (в IDLE или в меню кнопки Пуск
(Start) в операционной системе Windows) или в Интернете, по адресу:
http://www.python.org.


 Как работает импорт

 В предыдущем разделе говорилось об импортировании модулей, но никак
не объяснялось, что происходит во время импорта. Так как в языке Python
инструкции импортирования составляют основу структуры программы, в этом
разделе более подробно будет рассмотрена операция импорта, чтобы сделать
представление об этом процессе менее абстрактным.

 Некоторые программисты на языке C любят сравнивать инструкцию import
в языке Python с инструкцией #include, но они в корне неправы –
импортирование в языке Python – это не просто включение текста
одного файла в другой. Это самые настоящие операции времени выполнения,
которые выполняют следующие действия, когда программа впервые
импортирует заданный файл:

 1. Отыскивают файл модуля.

 2. Компилируют в байт-код (если это необходимо).

 3. Запускают программный код модуля, чтобы создать объекты,
которые он определяет.

 Чтобы лучше понять, как протекает импорт модулей, мы исследуем все эти
действия по порядку. Примите во внимание, что все три действия
выполняются, только когда модуль впервые импортируется во время
выполнения программы, – все последующие операции импорта того же модуля
пропускают эти действия и просто выбирают уже находящийся в памяти
объект модуля. Технически это обеспечивается за счет того,
что интерпретатор сохраняет информацию о загруженных модулях в словаре
с именем sys.modules и проверяет его при выполнении каждой операции
импортирования. Если модуль отсутствует в словаре, выполняется
трехэтапный процесс, описанный выше.


 1. Поиск

 Прежде всего, интерпретатор должен определить местонахождение файла
модуля, указанного в инструкции import. Обратите внимание, что имена
файлов в инструкции import в примерах из предыдущих разделов указаны
без расширения .py и без пути к каталогу: вместо записи в виде,
например, import c:\dir1\b.py, инструкция записывается просто –
import b. Фактически допускается указывать лишь простые имена – путь
к каталогу и расширение файла должны быть опущены, потому что для поиска
файла, соответствующего имени, указанному в инструкции import,
интерпретатор использует стандартный путь поиска модулей.1 Поскольку
это основная часть операции импорта, которую необходимо знать
программистам, мы вернемся к ней чуть ниже.


 2. Компиляция (если необходимо)

 После того как в пути поиска модулей будет найден файл, соответствующий
имени в инструкции import, интерпретатор компилирует его в байт-код,
если это необходимо. (Мы рассматривали байт-код в главе 2.)

 Интерпретатор проверяет время создания файла и пропускает этап
компиляции исходного программного кода, если файл с байт-кодом .pyc
не старше, чем соответствующий ему файл .py с исходным текстом.
Кроме того, если Python обнаружит в пути поиска только файл с байт-кодом
и не найдет файл с исходным текстом, он просто загрузит байт-код (это
означает, что вы можете распространять свою программу исключительно
в виде файлов с байт-кодом и не передавать файлы с исходными текстами).
Другими словами, этап компиляции пропускается, если можно ускорить
запуск программы. Если вы измените исходный программный код, Python
автоматически скомпилирует байт-код при следующем запуске программы.

 Обратите внимание, что компиляция выполняется в момент импортирования
файла. По этой причине файл .pyc с байт-кодом для главного файла
программы обычно не создается, если только он не был импортирован
еще куда-нибудь – файлы .pyc создаются только при импортировании файлов.
Байт-код главного файла программы создается в памяти компьютера,
а байт-код импортированных файлов сохраняется в файлах для ускорения
будущих операций импорта. Главные файлы программ часто планируется
исполнять непосредственно и никуда их не импортировать. Позднее
мы увидим, что существует возможность создать файл, который будет играть
роль как главного файла программы, так и модуля, доступного для импорта.
Такие файлы могут и исполняться, и импортироваться, поэтому для них
создаются соответствующие файлы .pyc. Чтобы разобраться с тем,
как это получается, читайте обсуждение специальных атрибутов __name__
и __main__ в главе 24.


 3. Запуск

 На последнем шаге операции импортирования производится запуск байт-кода
модуля. Все инструкции в файле модуля выполняются по порядку, сверху
вниз, и любые операции присваивания, которые встретятся на этом шаге,
будут создавать атрибуты конечного объекта модуля. Таким образом,
этот этап выполнения создает все инструменты, которые определяются
модулем. Например, во время импортирования выполняются инструкции def
в файле, которые создают функции и присваивают их атрибутам модуля.
После этого функции могут вызываться из программы, выполнившей импорт.

 На этом последнем шаге операции импортирования фактически запускается
программный код модуля, поэтому если программный код верхнего уровня
в файле модуля выполняет какие-нибудь действия, результаты этих действий
можно будет наблюдать во время импорта. Например, при импорте файла
можно будет наблюдать результат работы инструкций print на верхнем
уровне модуля. Инструкции def просто определяют объекты для последующего
использования.

 Как видите, во время импорта выполняется достаточно много работы –
производится поиск файла, в случае необходимости запускается компилятор
и производится запуск программного кода. Вследствие этого любой заданный
модуль по умолчанию импортируется только один раз за все время работы
программы. При повторных попытках импортировать модуль все три шага
просто пропускаются, и повторно используется модуль, уже загруженный
в память. Если вам потребуется еще раз импортировать файл, который
уже был загружен (например, чтобы обеспечить поддержку настроек,
выполняемых пользователем), воспользуйтесь функцией imp.reload,
с которой мы встретимся в следующей главе.


 Путь поиска модулей

 Как уже отмечалось выше, для большинства программистов наиболее важным
в операции импортирования является первый этап – поиск файла
импортируемого модуля (раздел «1. Поиск»). Вам может потребоваться
сообщить интерпретатору, где следует искать импортируемые файлы,
поэтому вы должны знать, как получить доступ к пути поиска,
чтобы дополнить его.

 В большинстве случаев можно положиться на автоматически организованные
пути поиска модулей и вообще не настраивать этот путь. Однако,
если вам потребуется импортировать модули из пользовательских каталогов,
вам необходимо будет знать, как работает путь поиска файлов,
чтобы настроить его соответствующим образом. В общих чертах пути поиска
модулей в языке Python выбираются из объединенных данных следующих
основных источников. Некоторые из них предопределены, а некоторые
можно настроить и тем самым сообщить интерпретатору,
где выполнять поиск:

  1. Домашний каталог программы.

  2. Содержимое переменной окружения PYTHONPATH
 (если таковая определена).

  3. Каталоги стандартной библиотеки.

  4. Содержимое любых файлов с расширением .pht (если таковые имеются).


 В конечном итоге объединение этих четырех компонентов составляет
sys.path – список строк с именами каталогов, о котором я расскажу
подробнее в следующем разделе. Первый и третий компоненты пути поиска
определяются автоматически, но так как интерпретатор при поиске
использует данные всех этих компонентов, от первого до последнего,
то второй и четвертый компоненты можно использовать для расширения
пути поиска, включая в него свои собственные каталоги с исходными
текстами. Далее описывается, как интерпретатор Python использует
эти компоненты пути:

 Домашний каталог

  В первую очередь интерпретатор ищет импортируемые файлы в домашнем
 каталоге. В зависимости от того, как была запущена программа, это может
 быть каталог, где находится главный файл программы. При работе
 в интерактивном сеансе этот элемент содержит путь к каталогу, откуда
 была запущена интерактивная оболочка (то есть текущий рабочий каталог).
 Поскольку поиск в первую очередь всегда производится в этом каталоге,
 если программа целиком располагается в одном каталоге, все операции
 импорта будут выполнены автоматически, без необходимости настраивать
 путь поиска. С другой стороны, из-за того, что поиск в первую очередь
 производится в этом каталоге, файлы, находящиеся в нем, могут сделать
 недоступными модули с теми же именами, находящиеся в других
 каталогах, – будьте внимательны, чтобы случайно не сделать недоступными
 библиотечные модули, которые могут потребоваться вашей программе.

 Каталоги в PYTHONPATH

  После этого поиск производится во всех каталогах, перечисленных
 в переменной окружения PYTHONPATH, слева направо (если эта переменная
 вообще установлена). В двух словах, переменная окружения PYTHONPATH –
 это просто список имен каталогов, определяемых пользователем
 и системой, в которых располагаются файлы с программным кодом на языке
 Python. Вы можете добавить в эту переменную все каталоги, откуда
 предполагается импортировать модули, и интерпретатор будет использовать
 ваши настройки при создании пути поиска модулей.

  Поскольку интерпретатор пытается отыскать файлы сначала в домашнем
 каталоге, настройка этой переменной приобретает большое значение,
 только когда необходимо импортировать модули, размещающиеся в разных
 каталогах, – то есть, когда импортируемый файл хранится в каталоге,
 отличном от каталога, где располагается импортирующий файл. Вам
 наверняка потребуется настраивать переменную окружения PYTHONPATH,
 как только вы начнете писать большие программы, но на начальном этапе
 освоения языка храните файлы всех своих модулей в каталоге, в котором
 вы работаете (то есть в домашнем каталоге), и тогда операции импорта
 будут работать без необходимости выполнять какие-либо настройки.

 Каталоги стандартной библиотеки

  Далее интерпретатор автоматически выполняет поиск в каталогах, куда
 были установлены модули стандартной библиотеки. Так как эти каталоги
 всегда участвуют в поиске, их можно не добавлять в переменную окружения
 PYTHONPATH, или включать в файлы с расширением .pth, о которых
 рассказывается ниже.

 Каталоги в файле .pth

  Наконец, относительно новая особенность языка Python дает
 пользователям возможность добавлять нужные каталоги в путь поиска
 модулей, просто перечисляя их по одному в строке в текстовом файле,
 имя которого оканчивается расширением .pth (от слова «path» – «путь»).
 Эти файлы представляют собой расширенную возможность, имеющую отношение
 к проблеме установки, и мы не будем здесь подробно их обсуждать.
 Впрочем, они могут служить альтернативой настройки переменной
 PYTHONPATH.

  Текстовый файл со списком каталогов помещается в соответствующий
 каталог и может играть примерно ту же роль, что и переменная окружения
 PYTHONPATH. Например, если вы работаете в Python 3.0 под Windows, файл
 с именем myconfig.pth можно поместить в главный каталог, куда
 был установлен Python 3.0 (например, C:\Python30), или в подкаталог
 site-packages C:\Python30\Lib\site-packages стандартной библиотеки,
 что позволит расширить путь поиска модулей. В UNIX-подобных системах
 этот файл можно поместить в каталог
 /usr/local/lib/python3.0/site-packages или /usr/local/lib/site-python.

  Обнаружив этот файл, интерпретатор добавит в конец пути поиска модулей
 каталоги, перечисленные во всех строках файла, от первой до последней.
 Интерпретатор выберет все имена каталогов во всех файлах .pth, которые
 обнаружит, и отфильтрует повторяющиеся имена и имена несуществующих
 каталогов. Поскольку это файлы, а не параметры настройки командной
 оболочки, они могут применяться ко всем пользователям системы,
 а не только к одному пользователю или одной командной оболочке.
 Кроме того, для некоторых пользователей процедура создания текстовых
 файлов выглядит проще, чем настройка переменных окружения.

  Эта особенность на практике более сложная, чем я описал.
 За дополнительной информацией обращайтесь к руководству по библиотеке
 языка Python, в частности к описанию модуля site, входящего
 в стандартную библиотеку, – этот модуль позволяет создавать файлы .pth
 и определять местоположение библиотек языка Python, а в документации
 к нему описываются каталоги, где вообще могут располагаться файлы .pth.
 Начинающим я рекомендую использовать переменную окружения PYTHONPATH
 или единственный файл .pth и только в том случае, если возникает
 необходимость импортировать файлы из других каталогов.
 Наиболее часто файлы .pth используются в сторонних библиотеках,
 которые обычно устанавливают файлы .pth в каталог site-packages,
 чтобы исключить необходимость дополнительных настроек
 (система установки пакетов distutils, описываемая во врезке ниже,
 позволяет автоматизировать многие операции, выполняемые при установке).


 Настройка пути поиска

 Из всего вышесказанного следует, что переменная окружения PYTHONPATH
и файлы .pth позволяют вам определять каталоги, где интерпретатор будет
искать файлы при выполнении операции импортирования. Способ настройки
переменных окружения и имена каталогов, где могут храниться файлы .pth,
зависит от типа платформы. Например, в Windows можно воспользоваться
ярлыком Система (System) в панели управления, чтобы записать
в переменную PYTHONPATH список каталогов, разделенных точкой с запятой,
как показано ниже:

c:\pycode\utilities;d:\pycode\package1

 Или создать текстовый файл с именем C:\Python30\pydirs.pth,
который выглядит примерно так:

c:\pycode\utilities
d:\pycode\package1

 Аналогичным образом выполняются настройки и на других платформах,
однако детали настроек могут изменяться в слишком широком диапазоне,
чтобы осветить их все в этой главе. В приложении A вы найдете указания
по расширению пути поиска файлов с помощью переменной окружения
PYTHONPATH или файлов .pth на различных платформах.


 Автоматическое изменение пути поиска

 Точная конфигурация пути поиска зависит от типа платформы и версии
Python. В зависимости от используемой платформы в путь поиска модулей
автоматически могут добавляться дополнительные каталоги.

 Например, в путь поиска вслед за каталогами из переменной окружения
PYTHONPATH и перед каталогами стандартной библиотеки интерпретатор может
добавлять текущий рабочий каталог – каталог, откуда была запущена
программа. Когда программа запускается из командной строки, текущий
рабочий каталог может не совпадать с домашним каталогом, где находится
главный файл программы (то есть с каталогом, где находится программа).
Так как от запуска к запуску программы текущий рабочий каталог может
изменяться, при обычных условиях рабочий каталог не должен иметь
значения для операций импорта. Подробнее о запуске программ
из командной строки рассказывается в главе 3.

 Чтобы увидеть, как интерпретатор настраивает путь поиска модулей
на вашей платформе, вы можете проверить содержимое переменной sys.path,
обсуждение которой является темой следующего раздела.


 Список sys.path

 Если вам потребуется узнать, как выглядит путь поиска на вашей машине,
вы всегда сможете сделать это, просмотрев содержимое встроенного списка
sys.path (- то есть содержимое атрибута path модуля sys, входящего
в состав стандартной библиотеки). Этот список строк с именами каталогов
представляет собой фактический путь поиска, используемый
интерпретатором, – при выполнении операций импорта Python просматривает
каждый каталог из списка, слева направо.

 Действительно, sys.path – это путь поиска модулей. Интерпретатор
создает его во время запуска программы, автоматически объединяя в список
домашний каталог (или пустую строку, что соответствует текущему рабочему
каталогу) все каталоги, перечисленные в переменной окружения PYTHONPATH
и в файлах .pth, и каталоги стандартной библиотеки. В результате
получается список строк с именами каталогов, которые просматриваются
интерпретатором при импортировании новых файлов.

 Представление языком Python этого списка имеет два основных полезных
результата. Во-первых, он обеспечивает возможность проверить настройки
пути поиска, которые вы выполнили, – если вы не видите свои настройки
в этом списке каталогов, вам следует проверить, насколько правильно
вы все проделали. Например, ниже показано, как выглядит путь поиска
модулей у меня, в операционной системе Windows, в Python 3.0,
с моими настройками переменной окружения PYTHONPATH, куда записан
каталог C:\users, и с моим файлом C:\Python30\mypath.pth, содержащим
путь к каталогу C:\users\mark. Пустая строка в начале списка
соответствует текущему рабочему каталогу, а мои настройки объединены
с системными (остальные пути в списке – это каталоги стандартной
библиотеки):

\>>> import sys
\>>> sys.path
[‘’, ‘C:\\users’, ‘C:\\Windows\\system32\\python30.zip’,
 ‘c:\\Python30\\DLLs’, ‘c:\\Python30\\lib’,
 ‘c:\\Python30\\lib\\plat-win’, ‘c:\\Python30’, ‘C:\\Users\\Mark’,
 ‘c:\\Python30\\lib\\site-packages’]

 Во-вторых, если вы понимаете, как формируется список, вы можете
обеспечить сценариям возможность самостоятельно задавать свои пути
поиска. Как будет показано далее в этой части книги, изменяя список
sys.path, вы можете изменить путь поиска для всех последующих операций
импорта. Однако эти изменения продолжают действовать, только пока
выполняется сценарий; переменная окружения PYTHONPATH и файлы .pth
обеспечивают возможность более долговременного хранения измененного
пути.


 Выбор файла модуля

 Имейте в виду, что расширения имен файлов (например, .py) преднамеренно
опущены в инструкции import. Интерпретатор выбирает первый найденный
в пути поиска файл, который соответствует указанному имени. Например,
инструкция import b могла бы загрузить:

  Файл с исходным текстом, имеющий имя b.py.

  Файл с байт-кодом, имеющий имя b.pyc.

  Содержимое каталога b при импортировании пакета (описывается
 в главе 23).

  Скомпилированный модуль расширения, написанный, как правило,
 на языке C или C++ и скомпонованный в виде динамической библиотеки
 (например, b.so в Linux и b.dll или b.pyd в Cygwin и в Windows).

  Скомпилированный встроенный модуль, написанный на языке C и статически
 скомпонованный с интерпретатором Python.

  Файл ZIP-архива с компонентом, который автоматически извлекается
 при импорте.

  Образ памяти для фиксированных двоичных исполняемых файлов.

  Класс Java в версии Jython.

  Компонент .NET в версии IronPython.

 Импортирование расширений, написанных на языке C, операция импорта
в Jython и импортирование пакетов – это расширенные возможности
импортирования компонентов, не являющихся простыми файлами модулей.
Впрочем, для импортера различия в типах загружаемых файлов совершенно
незаметны как при импорте, так и при обращении к атрибутам модуля.
Инструкция import b загружает некоторый модуль b в соответствии
с настройками пути поиска модулей, а инструкция b.attr извлекает элемент
модуля, будь то переменная или функция, написанная на языке C. Некоторые
стандартные модули, которые мы будем использовать в этой книге,
в действительности написаны на языке C, но благодаря прозрачности
импортирования, это не имеет никакого значения для клиентов.

 Если у вас в различных каталогах имеются файлы b.py и b.so,
интерпретатор всегда будет загружать тот, что будет найден в каталоге,
который располагается раньше (левее) в пути поиска модулей,
так как поиск в списке sys.path выполняется слева направо.
Но что произойдет, если оба файла, b.py и b.so, находятся в одном
и том же каталоге? В этом случае интерпретатор будет следовать
стандартному порядку выбора файлов, впрочем, нет никаких гарантий,
что такой порядок будет оставаться неизменным с течением времени.
Вообще вы должны избегать зависимости от порядка выбора файлов
интерпретатором Python в одном и том же каталоге – давайте своим модулям
различные имена или настраивайте путь поиска модулей, чтобы обеспечить
более очевидный порядок выбора файлов.


 Дополнительные возможности выбора модуля

 Обычно операция импорта работает именно так, как описывается в данном
разделе, – она отыскивает и загружает файлы, находящиеся на вашей
машине. Однако вполне возможно переопределить большую часть того,
что делает операция импорта, используя то, что называется программными
ловушками импорта. Эти ловушки могут использоваться, чтобы придать
операции импорта дополнительные полезные возможности, такие как
загрузка файлов из архивов, расшифровывание и так далее.

 Фактически сам интерпретатор Python использует эти ловушки,
чтобы обеспечить возможность извлечения импортируемых компонентов
из ZIP-архивов, – заархивированные файлы автоматически извлекаются
во время импорта, когда в пути поиска выбирается файл
с расширением .zip. Например, один из каталогов стандартной библиотеки
в списке sys.path, представленном выше, на сегодняшний день является
файлом .zip. За дополнительной информацией обращайтесь к описанию
встроенной функции __import__ в руководстве по стандартной библиотеке
Python – настраиваемому инструменту, которым в действительности
пользуется инструкция import.

 Кроме того, Python поддерживает понятие файлов с оптимизированным
байт-кодом (.pyo), которые создаются и запускаются интерпретатором
из командной строки с флагом –O, – однако они выполняются лишь немногим
быстрее, чем обычные файлы .pyc (обычно на 5 процентов быстрее),
поэтому они используются достаточно редко. Система Psyco (глава 2)
обеспечивает куда более существенный прирост в скорости выполнения.


 Стороннее программное обеспечение: distutils

 Настройка пути поиска модулей, описание которой приводится
в этой главе, в первую очередь касается программного кода, который
вы пишете самостоятельно. Сторонние расширения для Python обычно
используют для автоматической установки самих себя такой инструмент,
как distutils, входящий в состав стандартной библиотеки, поэтому для
использования такого программного кода не требуется выполнять настройку
пути поиска модулей.

 Системы, использующие distutils, обычно поставляются со сценарием
setup.py, который запускается для установки таких систем, –
этот сценарий импортирует и использует модуль distutils, чтобы поместить
систему в каталог, который уже является частью пути поиска модулей
(обычно в подкаталог Lib\sitepackages в каталоге, куда был установлен
Python).

 За дополнительной информацией о распространении и установке программ
с помощью distutils обращайтесь к стандартному набору руководств
по языку Python, потому что эта тема далеко выходит за рамки
данной книги (например, этот инструмент дополнительно обеспечивает
возможность компиляции расширений на языке C на машине, где производится
установка). Кроме того, обратите внимание на развивающуюся систему eggs,
распространяемую с открытыми исходными текстами, которая добавляет
возможность проверки зависимостей для установленного программного кода
на языке Python.
"""

"""
 Основы программирования модулей


 Создание модуля
 

 Чтобы определить модуль, достаточно воспользоваться текстовым
редактором, с его помощью ввести некоторый программный код на языке
Python в текстовый файл и сохранить его с расширением «.py» – любой
такой файл автоматически будет считаться модулем Python. Все имена,
которым будет выполнено присваивание на верхнем уровне модуля, станут
его атрибутами (именами, ассоциированными с объектом модуля) и будут
доступны для использования клиентами.

 Например, если ввести следующую инструкцию def в файл с именем
module1.py и импортировать его, тем самым будет создан объект модуля
с единственным атрибутом – именем printer, которое ссылается на объект
функции:

def printer(x):  # Атрибут модуля
    print(x)

 Прежде чем мы двинемся дальше, следует сказать несколько слов об именах
файлов модулей. Вы можете называть ваши модули, как вам будет угодно,
при условии, что эти имена будут оканчиваться расширением .py, если вы
собираетесь импортировать их. Для главных файлов программ, которые будут
запускаться, но не будут импортироваться, имена необязательно должны
иметь расширение .py, однако было бы желательно использовать
это расширение в любом случае, потому что оно делает назначение файлов
более очевидным и позволит в будущем импортировать любой
из ваших файлов.

 Поскольку имена модулей внутри программы превращаются в имена
переменных (без расширения .py), они также должны следовать правилам
именования обычных переменных, которые приводились в главе 11. Например,
можно создать файл модуля с именем if.py, но его невозможно будет
импортировать, потому что if – это зарезервированное слово, и когда
вы попытаетесь выполнить инструкцию import if, интерпретатор выдаст
сообщение о синтаксической ошибке. Фактически и имена модулей, и имена
каталогов, используемых при импортировании пакетов (рассматривается
в следующей главе), должны соответствовать требованиям, предъявляемым
к именам переменных и представленным в главе 11 – они могут, например,
содержать только алфавитные символы, цифры и символы подчеркивания.
Имена каталогов с пакетами также не могут содержать посторонних
символов, таких как пробелы, даже если они являются допустимыми
для используемой платформы.

 Когда производится импорт модуля, интерпретатор Python преобразует имя
модуля в имя внешнего файла, добавляя в начало путь к каталогу
из пути поиска модулей и добавляя .py или другое расширение в конец.
Например, в конечном итоге имя модуля M преобразуется в имя некоторого
внешнего файла <каталог>\M.<расширение>, который содержит программный
код модуля.

 Как упоминалось в предыдущей главе, существует возможность создать
модуль для Python на другом языке программирования, таком как C или C++
(или Java в реализации Jython). Такие модули называются модулями
расширений и обычно используются для создания библиотек, используемых
сценариями на языке Python. Когда модули расширений импортируются
программным кодом на языке Python, они выглядят и ведут себя
точно так же, как обычные модули, написанные на языке Python, – они
импортируются инструкцией import и предоставляют функции и объекты
в виде атрибутов объекта модуля. Обсуждение модулей расширений выходит
далеко за рамки этой книги, поэтому за дополнительной информацией
обращайтесь к стандартным руководствам по языку Python или
к специализированным книгам, таким как «Программирование на Python».


 Использование модулей

 Клиенты могут использовать простой файл модуля, только что написанный
нами, выполнив инструкцию import или from. Обе инструкции отыскивают,
компилируют и запускают программный код модуля, если он еще
не был загружен. Главное различие этих инструкций заключается в том,
что инструкция import загружает модуль целиком, поэтому при обращении
к именам в модуле их необходимо дополнять именем модуля.
Инструкция from, напротив, загружает (или копирует) из модуля отдельные
имена. Все следующие примеры вызывают функцию printer, определенную
во внешнем модуле module1.py, но делают это различными способами.


 Инструкция import

 В первом примере имя module1 служит двум различным целям – оно
идентифицирует внешний файл, который должен быть загружен,
и превращается в имя переменной, которая ссылается на объект модуля
после загрузки файла:

\>>> import module1  # Загрузить модуль целиком
\>>> module1.printer(‘Hello world!’)  # Имя дополняется именем модуля
Hello world!

 Так как в результате выполнения инструкции import в сценарии появляется
имя, ссылающееся на полный объект модуля, нам необходимо использовать
имя модуля при обращении к его атрибутам (например, module1.printer).


 Инструкция from

 Инструкция from, напротив, копирует имена из области видимости одного
файла в область видимости другого, что позволяет непосредственно
использовать скопированные имена, не предваряя их именем модуля
(например, printer):

\>>> from module1 import printer  # Копировать одну переменную
\>>> printer(‘Hello world!’)  # Имя не требует дополнения
Hello world!

 Этот пример дает тот же результат, что и предыдущий, но так как
импортируемое имя копируется в область видимости, в которой находится
сама инструкция from, можно напрямую обращаться к переменной в сценарии,
не предваряя его именем вмещающего модуля.

 Как будет показано далее, инструкция from является всего лишь небольшим
расширением инструкции import – она импортирует файл модуля, как обычно,
но выполняет дополнительный шаг, на котором копирует одно или более имен
из импортируемого файла.


 Инструкция from *

 Наконец, в следующем примере используется специальная форма инструкции
from: когда используется символ *, копируются все имена, которым
присваиваются значения на верхнем уровне указанного модуля.
В этом случае точно так же можно использовать скопированное имя printer,
не предваряя его именем модуля:

\>>> from module1 import *  # Скопировать все переменные
\>>> printer(‘Hello world!’)
Hello world!

 С технической точки зрения обе инструкции, from и import, вызывают
одну и ту же операцию импорта, просто форма from * дополнительно
выполняет копирование всех имен в импортируемом модуле в область
видимости, откуда производится импорт. По сути происходит совмещение
пространств имен модулей, что позволяет нам меньше вводить с клавиатуры.

 Как видите, модули действительно легко использовать. Чтобы еще лучше
понять, что происходит в действительности, когда вы определяете
и используете модули, рассмотрим некоторые их свойства более подробно.
В Python 3.0 форма инструкции from ...*, описанная здесь, может
использоваться только на верхнем уровне модуля – она не может вызываться
внутри функций. В Python 2.6 эту инструкцию можно использовать
внутри функций, но она вызывает появление предупреждения. На практике
эта инструкция чрезвычайно редко встречается в функциях, так как
ее присутствие лишает интерпретатор возможности определять переменные
статически, до вызова функции.


 Импорт выполняется только один раз

 Один из самых типичных вопросов, которые задают начинающие
программисты, начав использовать модули: «Почему операция импорта
перестает работать?» Они часто сообщают, что при первой попытке
импортировать модуль все работает, но последующие попытки импорта
в интерактивной оболочке (или во время работы программы)
не дают должного эффекта. В действительности такой эффект
и не предполагается, и вот почему.

 Модули загружаются и запускаются первой, и только первой инструкцией
import или from. Реализовано такое поведение преднамеренно, потому что
импортирование – это дорогостоящая операция и интерпретатор выполняет
ее всего один раз за все время работы. Последующие операции импорта
просто получают объект уже загруженного модуля.

 Из этого следует: так как программный код на верхнем уровне модуля
выполняется всего один раз, это обстоятельство можно использовать
для инициализации переменных. Рассмотрим пример модуля simple.py:

Print(‘hello’)
spam = 1  # Инициализировать переменную

 В этом примере инструкции print и = выполняются, когда модуль
импортируется впервые, и переменная spam инициализируется во время
импортирования:

% python
\>>> import simple   # Первая инструкция import: загружает
hello                # и запускает код модуля
\>>> simple.spam     # Операция присваивания создает атрибут
1

 Вторая и все последующие операции импортирования не приводят
к перезапуску программного кода модуля – они просто получают объект
модуля из внутренней таблицы модулей интерпретатора. В результате
повторная инициализация переменной spam не происходит:

\>>> simple.spam = 2  # Изменить атрибут модуля
\>>> import simple    # Просто получает уже загруженный модуль
\>>> simple.spam      # Код не перезапускается: атрибут не изменился
2

 Конечно, иногда действительно бывает необходимо перезапустить
программный код модуля при повторных операциях импортирования. Позднее
в этой главе мы увидим, как это можно сделать с помощью функции reload.


 Инструкции import и from – операции присваивания

 Так же, как и инструкция def, инструкции import и from являются
выполняемыми инструкциями, а не объявлениями времени компиляции.
Они могут вкладываться в условные инструкции if, присутствовать
в объявлениях функций def и так далее, и они не имеют никакого эффекта,
пока интерпретатор не достигнет их в ходе выполнения программы.
Другими словами, импортируемые модули и имена в них не будут доступны,
пока не будут выполнены соответствующие инструкции import или from.
Кроме того, подобно инструкции def, import и from – это явные операции
присваивания:

  Инструкция import присваивает объект модуля единственному имени.

  Инструкция from присваивает одно или более имен объектам
 с теми же именами в другом модуле.

 Все, что уже обсуждалось ранее, в равной степени применимо и к модулям.
Например, имена, копируемые инструкцией from, становятся ссылками
на разделяемые объекты – как и в случае с аргументами функций, повторное
присваивание полученному имени не оказывает воздействия на модуль,
откуда это имя было скопировано, но модификация изменяемого объекта
может оказывать воздействие на объект в модуле, откуда он был
импортирован. Для иллюстрации рассмотрим следующий файл small.py:

x = 1
y = [1, 2]

% python
\>>> from small import x, y   # Скопировать два имени
\>>> x = 42                   # Изменяется только локальная переменная x
\>>> y[0] = 42            # Изменяется непосредственно изменяемый объект

 Здесь x не является разделяемым изменяемым объектом, а вот y –
является. Имена y в импортирующем и импортируемом модулях ссылаются
на один и тот же объект списка, поэтому изменения, произведенные
в одном модуле, будут видны в другом модуле:

\>>> import small    # Получить имя модуля (инструкция from его не дает)
\>>> small.x # x     в модуле small – это не моя переменная x
1
\>>> small.y         # Но изменяемый объект используется совместно
[42, 2]

 Чтобы увидеть графическое изображение того, что делает со ссылками
инструкция from, вернитесь к рис. 18.1 (передача аргументов функциям)
и мысленно замените слова «вызывающая программа» и «функция»
на «импортируемый модуль» и «импортирующий модуль». Эффект тот же самый,
за исключением того, что здесь мы имеем дело с именами в модулях,
а не с функциями. Операция присваивания везде в языке Python работает
одинаково.


 Изменение значений имен в других файлах

 Вспомним, что в предыдущем примере присваивание переменной x
в интерактивной оболочке изменяло ее значение только в этой области
видимости и не оказывало влияния на переменную x в файле – между именем,
скопированным инструкцией from, и именем в файле, откуда это имя было
скопировано, нет никакой связи. Чтобы действительно изменить глобальное
имя в другом файле, необходимо использовать инструкцию import:

% python
\>>> from small import x, y   # Скопировать два имени
\>>> x = 42                   # Изменить только локальное имя x
\>>> import small             # Получить имя модуля
\>>> small.x = 42             # Изменить x в другом модуле

 Это явление было описано в главе 17. Поскольку изменение переменных
в других модулях, как в данном случае, часто является источником проблем
(и следствием неудачного проектирования), мы еще вернемся к этому приему
позднее в этой части книги. Обратите внимание, что изменение элемента
y[0] в предыдущем примере – это нечто иное; изменяется объект, а не имя.


 Эквивалентность инструкций import и from

 Обратите внимание: в предыдущем примере после инструкции from нам
потребовалось выполнить инструкцию import, чтобы получить доступ к имени
модуля small, – инструкция from копирует только имена из одного модуля
в другой и ничего не присваивает самому имени модуля. Инструкция from,
приведенная ниже:

from module import name1, name2        # Копировать только эти два имени

 эквивалентна следующей последовательности, по крайней мере,
концептуально:

import module             # Получить объект модуля
name1 = module.name1      # Скопировать имена с помощью присваивания
name2 = module.name2
del module                # Удалить имя модуля

 Как и все операции присваивания, инструкция from создает новые
переменные в импортирующем модуле, которые ссылаются на объекты
с теми же именами в импортируемом файле. При этом копируются только
имена, а не сам модуль. При использовании формы from * этой инструкции
(from module import *) эквивалентная последовательность действий
та же самая, только при этом копируются все имена, определенные
на верхнем уровне импортируемого модуля.

 Обратите внимание, что на первом шаге инструкция from выполняет обычную
операцию import. Вследствие этого инструкция from всегда импортирует
весь модуль целиком, если он еще не был импортирован, независимо
от того, сколько имен копируется из файла. Нет никакой возможности
загрузить только часть модуля (например, только одну функцию),
но так как модули – это байт-код, а не машинный код, влияние
на производительность оказывается незначительным.


 Потенциальные проблемы инструкции from

 Инструкция from делает местоположение переменных менее явным
и очевидным (имя name несет меньше информации, чем module.name), поэтому
некоторые пользователи Python рекомендуют использовать инструкцию import
вместо from. Однако я не уверен, что это такой уж однозначный совет:
инструкция from используется достаточно часто и без каких-либо страшных
последствий. На практике часто бывает удобно избавиться от необходимости
набирать имя модуля всякий раз, когда требуется использовать один из его
инструментов. Это особенно справедливо для крупных модулей, которые
предоставляют большое число атрибутов, таких как модуль tkinter
из стандартной библиотеки, например.

 Суть проблемы состоит в том, что инструкция from способна повреждать
пространства имен, по крайней мере, в принципе – если использовать ее
для импортирования переменных, когда существуют одноименные переменные
в имеющейся области видимости, то эти переменные просто будут
перезаписаны. Эта проблема отсутствует при использовании инструкции
import, потому что доступ к содержимому импортируемого модуля возможен
только через его имя (имя module.attr не конфликтует с именем attr
в текущей области видимости). Пока вы понимаете и контролируете все,
что может происходить при использовании инструкции from,
во всем этом нет большой проблемы, особенно если импортируемые имена
указываются явно (например, from module import x, y, z).

 С другой стороны, инструкция from скрывает в себе более серьезные
проблемы, когда используется в комбинации с функцией reload, так как
импортированные имена могут ссылаться на предыдущие версии объектов.
Кроме того, инструкция в форме from module import * действительно может
повреждать пространства имен и затрудняет понимание имен, особенно когда
она применяется более чем к одному файлу, – в этом случае нет никакого
способа определить, какому модулю принадлежит то или иное имя, разве
только выполнить поиск по файлам с исходными текстами.
В действительности форма from * вставляет одно пространство имен
в другое, что сводит на нет преимущества, которые несет возможность
разделения пространств имен. Мы будем рассматривать эти проблемы более
подробно в разделе «Типичные ошибки при работе с модулями» в конце
этой части книги (глава 24).

 Пожалуй, лучший совет, который можно дать, – отдавать предпочтение
инструкции import для простых модулей, явно перечислять необходимые
переменные в инструкциях from и не использовать форму from * для импорта
более чем одного файла в модуле. При таком подходе можно предполагать,
что все неопределенные имена располагаются в модуле, к которому
обращались через инструкцию from *. При работе с инструкцией from,
конечно, следует проявлять осторожность, но, вооруженные знаниями,
большинство программистов находят ее удобной для организации доступа
к модулям.


 Когда необходимо использовать инструкцию import

 Единственное, когда необходимо вместо инструкции from использовать
инструкцию import, – когда требуется использовать одно и то же имя,
присутствующее в двух разных модулях. Например, когда два файла
по-разному определяют одно и то же имя:

# M.py
def func():
    ...выполнить что-то одно...
# N.py
def func():
    ...выполнить что-то другое...

 и необходимо использовать обе версии имени в программе. В этом случае
инструкцию from использовать нельзя, потому что в результате вы получите
единственное имя в вашей области видимости:

# O.py
from M import func
from N import func  # Перезапишет имя, импортированное из модуля M
func()              # Будет вызвана N.func

 Зато можно использовать инструкцию import, потому что включение имени
вмещающего модуля сделает имена уникальными:

# O.py
import M, N   # Получить модуль целиком, а не отдельные имена
M.func()      # Теперь можно вызывать обе функции
N.func()      # Наличие имени модуля делает их уникальными

 Этот случай достаточно необычен, поэтому вы вряд ли часто будете
сталкиваться с ним на практике. Но если такая ситуация все-таки
возникнет, инструкция import позволит вам избежать конфликта имен.


 Пространства имен модулей

 Модули будут, вероятно, более понятны, если представлять их,
как простые пакеты имен, – то есть место, где определяются переменные,
которые должны быть доступны остальной системе. С технической
точки зрения каждому модулю соответствует отдельный файл,
и интерпретатор создает объект модуля, содержащий все имена, которым
присвоены какие-либо значения в файле модуля. Проще говоря, модули –
это всего лишь пространства имен (места, где создаются имена), и имена,
находящиеся в модуле, называются его атрибутами. В этом разделе
мы исследуем, как работает этот механизм.


 Файлы создают пространства имен

 Итак, как же файлы трансформируются в пространства имен? Суть в том,
что каждое имя, которому присваивается некоторое значение на верхнем
уровне файла модуля (то есть не вложенное в функции или в классы),
превращается в атрибут этого модуля.

 Например, операция присваивания, такая как X = 1, на верхнем уровне
модуля M.py превращает имя X в атрибут модуля M, обратиться к которому
из-за пределов модуля можно как M.X. Кроме того, имя X становится
глобальной переменной для программного кода внутри M.py,
но нам необходимо более формально объяснить понятия загрузки модуля
и областей видимости, чтобы понять, почему:

  Инструкции модуля выполняются во время первой попытки импорта. Когда
 модуль импортируется в первый раз, интерпретатор Python создает пустой
 объект модуля и выполняет инструкции в модуле одну за другой,
 от начала файла до конца.

  Операции присваивания, выполняемые на верхнем уровне, создают атрибуты
 модуля. Во время импортирования инструкции присваивания, выполняемые
 на верхнем уровне файла и не вложенные в инструкции def или class
 (например, =, def), создают атрибуты объекта модуля – при присваивании
 имена сохраняются в пространстве имен модуля.

  Доступ к пространствам имен модулей можно получить через атрибут
 __dict__ или dir(M). Пространства имен модулей, создаваемые операцией
 импортирования, представляют собой словари – доступ к ним можно
 получить через встроенный атрибут __dict__, ассоциированный с модулем,
 и с помощью функции dir. Функция dir – это примерный эквивалент
 отсортированного списка ключей атрибута __dict__, но она включает
 унаследованные имена классов, может возвращать не полный список
 и часто изменяется от версии к версии.

  Модуль – это единая область видимости (локальная является глобальной).
 Как мы видели в главе 17, имена на верхнем уровне модуля подчиняются
 тем же правилам обращения/присваивания, что и имена в функциях,
 только в этом случае локальная область видимости совпадает с глобальной
 (точнее, они следуют тому же правилу LEGB поиска в областях видимости,
 с которым мы познакомились в главе 17, только без уровней поиска
 L и E). Но в модулях область видимости модуля после загрузки модуля
 превращается в атрибут-словарь объекта модуля. В отличие от функций
 (где локальное пространство имен существует только во время выполнения
 функции), область видимости файла модуля превращается в область
 видимости атрибутов объекта модуля и никуда не исчезает после
 выполнения операции импортирования.

 Ниже эти понятия демонстрируются в программном коде. Предположим,
мы создаем в текстовом редакторе следующий файл модуля
с именем module2.py:

Print(‘starting to load...’)
import sys
name = 42
def func(): pass
class klass: pass
print(‘done loading.’)

 Когда модуль будет импортироваться в первый раз (или будет запущен
как программа), интерпретатор выполнит инструкции модуля от начала
до конца. В ходе операции импортирования одни инструкции создают имена
в пространстве имен модуля, а другие выполняют определенную работу.
Например, две инструкции print в этом файле выполняются во время
импортирования:

\>>> import module2
starting to load...
done loading.

 Но как только модуль будет загружен, его область видимости превратится
в пространство имен атрибутов объекта модуля, который возвращает
инструкция import. После этого можно обращаться к атрибутам в этом
пространстве имен, дополняя их именем вмещающего модуля:

\>>> module2.sys
<module ‘sys’ (built-in)>
\>>> module2.name
42
\>>> module2.func
<function func at 0x026D3BB8>>
\>>> module2.klass
<class module2.klass>

 Здесь именам sys, name, func и klass были присвоены значения во время
выполнения инструкций модуля, поэтому они стали атрибутами после
завершения операции импортирования. О классах мы будем говорить
в шестой части книги, но обратите внимание на атрибут sys – инструкции
import действительно присваивают объекты модулей именам, а любая
операция присваивания на верхнем уровне файла создает атрибут модуля.

 Внутри интерпретатора пространства имен хранятся в виде объектов
словарей. Это самые обычные объекты словарей с обычными методами.
Обратиться к словарю пространства имен модуля можно через атрибут
__dict__ модуля (не забудьте обернуть вызов этого метода вызовом
функции list – в Python 3.0 он возвращает объект представления!):

\>>> list(module2.__dict__.keys())
[‘name’, ‘__builtins__’, ‘__file__’, ‘__package__’, ‘sys’, ‘klass’,
 ‘func’, ‘__name__’, ‘__doc__’]

 Имена, которые былиопределены в файле модуля, становятся ключами
внутреннего словаря, таким образом, большинство имен здесь отражают
операции присваивания на верхнем уровне в файле. Однако интерпретатор
Python добавляет в пространство имен модуля еще несколько имен,
например __file__ содержит имя файла, из которого был загружен модуль,
а __name__ – это имя, под которым модуль известен импортерам
(без расширения .py и без пути к каталогу).


 Квалификация имен атрибутов

 После ознакомления с модулями мы должны поближе рассмотреть понятие
квалификации имен. В языке Python для доступа к атрибутам любого объекта
используется синтаксис квалификации имени object.attribute. Квалификация
имени в действительности является выражением, возвращающим значение,
присвоенное имени атрибута, ассоциированного с объектом. Например,
выражение module2.sys в предыдущем примере возвращает значение атрибута
sys в объекте module2. Точно так же, если имеется встроенный объект
списка L, выражение L.append вернет метод append, ассоциированный
с этим списком.

 Итак, какую роль играет квалификация имен атрибутов с точки зрения
правил, рассмотренных нами в главе 17? В действительности – никакую:
это совершенно независимые понятия. Когда вы обращаетесь к именам,
квалифицируя их, вы явно указываете интерпретатору объект, атрибут
которого требуется получить. Правило LEGB применяется только к кратким,
неполным именам. Ниже приводятся принятые правила:

 Простые переменные

  Использование краткой формы имени, например X, означает, что будет
 произведен поиск этого имени в текущих областях видимости
 (следуя правилу LEGB).

 Квалифицированные имена

  Имя X.Y означает, что будет произведен поиск имени X в текущих
 областях видимости, а затем будет выполнен поиск атрибута Y
 в объекте X (не в областях видимости).

 Квалифицированные пути

  Имя X.Y.Z означает, что будет произведен поиск имени Y в объекте X,
 а затем поиск имени Z в объекте X.Y.

 Общий случай

  Квалификация имен применима ко всем объектам, имеющим атрибуты:
 модулям, классам, расширениям типов на языке C и так далее.

 В шестой части книги мы увидим, что квалификация имен для классов имеет
немного большее значение (здесь также имеет место то, что называется
наследованием), но в общем случае правила, описанные здесь, применяются
ко всем именам в языке Python.


 Импортирование и области видимости

 Как мы уже знаем, невозможно получить доступ к именам, определенным
в другом модуле, не импортировав его предварительно. То есть вы никогда
автоматически не получите доступ к именам в другом файле, независимо
от вида импортируемого модуля и вызовов функций в вашей программе.
Смысл переменной всегда определяется местоположением операции
присваивания в программном коде, а для обращения к атрибутам всегда
необходимо явно указывать объект.

 Например, рассмотрим два следующих простых модуля. Первый, moda.py,
определяет переменную X, которая является глобальной только
для программного кода в этом файле, и функцию, изменяющую глобальную
переменную X в этом файле:

X = 88        # Переменная X: глобальная только для этого файла
def f():
    global X  # Изменяет переменную X в этом файле
    X = 99    # Имена в других модулях недоступны

 Второй модуль, modb.py, определяет свою собственную глобальную
переменную X, а также импортирует и вызывает функцию из первого модуля:

X = 11           # Переменная X: глобальная только для этого файла
import moda      # Получает доступ к именам в модуле moda
moda.f()         # Изменяет переменную moda.X, но не X в этом файле
print X, moda.X

 При запуске этого модуля функция moda.f изменит переменную X
в модуле moda, а не в modb. Глобальной областью видимости
для функции moda.f всегда является файл, вмещающий ее, независимо
от того, из какого модуля она была вызвана:

% python modb.py
11 99

 Другими словами, операция импортирования никогда не изменяет область
видимости для программного кода в импортируемом файле –
из импортируемого файла нельзя получить доступ к именам в импортирующем
файле. Если быть более точным:

  Функциям никогда не будут доступны имена, определенные
 в других функциях, если только они физически не вложены друг в друга.

  Программному коду модуля никогда не будут доступны имена, определенные
 в других модулях, если только они явно не были импортированы.

 Это поведение является частью понятия лексической области видимости –
в языке Python области видимости, доступные части программного кода,
полностью определяются физическим расположением этого программного кода
в файле. Области видимости не подвержены влияниям вызовов функций
или операции импортирования.


 Вложенные пространства имен

 Операция импорта не дает возможности доступа к внешним областям
видимости, но она дает возможность обращаться к вложенным областям
видимости. Используя квалифицированные пути к именам атрибутов, вполне
возможно погрузиться в сколь угодно глубоко вложенные модули и получить
доступ к их атрибутам. Например, рассмотрим следующие три файла.
Файл mod3.py определяет единственное глобальное имя и атрибут операцией
присваивания:

X = 3

 Файл mod2.py определяет свою переменную X, затем импортирует модуль
mod3 и использует квалификацию имени, чтобы получить доступ к атрибуту
импортированного модуля:

X = 2
import mod3
print(X, end=’ ‘)  # Моя глобальная переменная X
print mod3.X       # Глобальная переменная X из модуля mod3

 Файл mod1.py также определяет свою собственную переменную X, затем
импортирует модуль mod2 и получает значения атрибутов обоих модулей:

X = 1
import mod2
print(X, end=’ ‘)       # Моя глобальная переменная X
print(mod2.X, end=’ ‘)  # Переменная X из модуля mod2
print(mod2.mod3.X       # Переменная X из модуля mod3

 В действительности, когда mod1 импортирует mod2, он создает
двухуровневое вложение пространств имен. Используя полный путь
к имени mod2.mod3.X, он может погрузиться в модуль mod3, который вложен
в импортированный модуль mod2. Суть в том, что модуль mod1 может
обращаться к переменным X во всех трех файлах и, следовательно, имеет
доступ ко всем трем глобальным областям видимости:

% python mod1.py
2 3
1 2 3

 Однако обратное утверждение неверно: модуль mod3 не имеет доступа
к именам в mod2, а модуль mod2 не имеет доступа к именам в mod1.
Возможно, этот пример будет проще понять, если отвлечься от пространств
имен и областей видимости и сосредоточиться на объектах, задействованных
в примере. mod2 внутри модуля mod1 – это всего лишь имя, которое
ссылается на объект с атрибутами, некоторые из которых могут ссылаться
на другие объекты с атрибутами (инструкция import выполняет операцию
присваивания). Для таких путей, как mod2.mod3.X, интерпретатор Python
выполняет вычисления слева направо, извлекая атрибуты из объектов.

 Обратите внимание: в mod1 можно вставить инструкцию import mod2
и затем использовать обращение mod2.mod3.X, но нельзя записать
import mod2.mod3 – такой синтаксис используется для операции
импортирования пакетов (каталогов), которая будет описана в следующей
главе. При импортировании пакетов также создаются вложенные пространства
имен, но в этом случае инструкция import воспринимает свой аргумент
как дерево каталогов, а не как цепочку модулей.


 Повторная загрузка модулей

 Как мы уже видели, программный код модуля по умолчанию запускается
всего один раз за все время работы программы. Чтобы принудительно
повторно загрузить модуль и запустить программный код в нем, необходимо
явно вызвать встроенную функцию reload. В этом разделе мы исследуем,
как использовать возможность повторной загрузки модулей, чтобы сделать
систему более динамичной. В двух словах:

  При вызове операции импортирования (с помощью инструкций import
 и from) программный код модуля загружается и выполняется, только когда
 модуль импортируется в первый раз за время работы программы.

  При последующих попытках импортировать модуль будет использоваться
 объект уже загруженного модуля. Повторная загрузка и запуск
 программного кода в этом случае не происходит.

  Функция reload принудительно выполняет повторную загрузку
 уже загруженного модуля и запускает его программный код. Инструкции
 присваивания, выполняемые при повторном запуске, будут изменять
 существующий объект модуля.

 Для чего вся эта суета вокруг повторной загрузки модулей? Функция
reload позволяет изменять части программы, не останавливая
всю программу. Благодаря функции reload эффект от изменений
в программном коде можно наблюдать сразу же после внесения
этих изменений. Повторная загрузка модулей поможет не во всех ситуациях,
но она позволит существенно сократить цикл разработки. Например,
представьте себе программу, предназначенную для работы с базами данных,
которая должна при запуске соединиться с сервером, – так как изменения
или настройки могут проверяться немедленно после повторной загрузки,
вам достаточно соединиться с базой данных всего один раз за весь сеанс
отладки. Таким же способом можно обновлять программный код долго
работающих серверов, которые нельзя останавливать.

 Язык Python относится к языкам интерпретирующего типа
(более или менее), поэтому в нем отсутствуют этапы
компиляции/компоновки, необходимые, чтобы запустить программу, например,
на языке C: модули загружаются динамически уже запущенной программой.
Возможность повторной загрузки обеспечивает повышение производительности
труда, позволяя вам изменять части работающей программы
без ее остановки. Обратите внимание, что в настоящее время функция
reload может обслуживать только модули, написанные на языке Python, –
скомпилированные модули расширений, написанные на таких языках, как C,
тоже могут динамически загружаться во время работы программы,
но их нельзя загрузить повторно.


 Основы использования функции reload

 В отличие от инструкций import и from:

  reload – это не инструкция, а функция.

  Функции reload передается существующий объект модуля, а не имя.

  В Python 3.0 функции reload находится в модуле importlib, который
 требуется импортировать, чтобы получить доступ к функции.

 Функция reload ожидает получить объект, поэтому к моменту ее вызова
модуль уже должен быть успешно импортирован (если операция импорта
оказалась неудачной из-за синтаксических или каких-либо других ошибок,
вам может потребоваться повторить ее, прежде чем можно будет повторно
загрузить модуль). Кроме того, синтаксис инструкции import и функции
reload отличается: аргумент должен передаваться функции reload
в круглых скобках, а инструкции import – без них. Повторная загрузка
модуля выполняется примерно следующим образом:

import module  # Первоначальное импортирование
...используются атрибуты модуля...
... # Теперь выполняются изменения в файле модуля
...
from importlib import reload  # Импортировать функцию reload (в 3.9)
reload(module)  # Загрузить обновленный модуль
...используются атрибуты модуля...

 Это типичный случай, когда вы импортируете модуль, затем изменяете
исходный программный код в текстовом редакторе, а потом повторно
загружаете его. Когда вы вызываете функцию reload, интерпретатор
повторно читает файл с исходными текстами и выполняет инструкции,
находящиеся на верхнем уровне. Пожалуй, самое важное, что следует знать
о функции reload, – это то, что она изменяет непосредственно сам объект
модуля – она не удаляет и не создает его повторно. Вследствие этого все
ссылки на объект модуля, имеющиеся в программе, автоматически будут
учитывать изменения, произошедшие в результате повторной загрузки.
А теперь подробнее о том, как происходит повторная загрузка:

  Функция reload запускает новый программный код в файле модуля
 в текущем пространстве имен модуля. При повторном выполнении
 программный код перезаписывает существующее пространство имен
 вместо того, чтобы удалять его и создавать вновь.

  Инструкции присваивания на верхнем уровне файла замещают имена новыми
 значениями. Например, повторный запуск инструкции def приводит
 к замещению предыдущей версии функции в пространстве имен модуля,
 выполняя повторную операцию присваивания имени функции.

  Повторная загрузка оказывает воздействие на всех клиентов,
 использовавших инструкцию import для получения доступа к модулю.
 Клиенты, использовавшие инструкцию import, получают доступ к атрибутам
 модуля, указывая полные их имена, поэтому после повторной загрузки
 они будут получать новые значения атрибутов.

  Повторная загрузка будет воздействовать лишь на тех клиентов, которые
еще только будут использовать инструкцию from в будущем. Клиенты,
которые использовали инструкцию from для получения доступа к атрибутам
в прошлом, не заметят изменений, произошедших в результате повторной
загрузки, – они по-прежнему будут ссылаться на старые объекты,
полученные до выполнения перезагрузки.


 Пример использования reload

 Ниже приводится более конкретный пример использования функции reload.
В следующем примере мы изменяем и повторно загружаем файл модуля без
остановки интерактивного сеанса работы с интерпретатором Python.
Повторная загрузка может использоваться в различных других случаях
(смотрите врезку «Придется держать в уме: повторная загрузка модулей»
ниже), но мы рассмотрим лишь самый простой пример. Во-первых,
в текстовом редакторе создайте файл модуля с именем changer.py
и добавьте в него следующее содержимое:

message = “First version”
def printer():
    print(message)

 Этот модуль создает и экспортирует два имени – одно связано
со строкой, а другое является функцией. Теперь запустите интерпретатор
Python, импортируйте модуль и вызовите функцию, которую он экспортирует.
Функция выведет значение глобальной переменной message:

% python
\>>> import changer
\>>> changer.printer()
First version

 Не закрывая интерактивную оболочку интерпретатора, отредактируйте файл
модуля в другом окне:

...измените файл changer.py, не останавливая интерактивный сеанс...
% vi changer.py

 Измените глобальную переменную message, а также тело функции printer:

message = “After editing”
def printer():
    print(‘reloaded:’, message)

 Затем вернитесь в окно интерактивной оболочки и перезагрузите модуль,
чтобы выполнить обновленный программный код. Обратите внимание:
в следующем листинге видно, что операция импортирования модуля не дает
желаемого результата – на экран выводится первоначальный текст
сообщения, несмотря на то, что файл был изменен. Чтобы задействовать
новую версию, необходимо вызвать функцию reload:

...вернитесь обратно в интерактивную оболочку...
\>>> import changer
\>>> changer.printer()  # Никакого эффекта: используется
First version           # прежняя версия модуля
\>>> from imp import reload
\>>> reload(changer)    # Принудительная загрузка/выполнение нового кода
<module ‘changer’ from ‘changer.py’>
\>>> changer.printer()  # Теперь будет запущена новая версия
reloaded: After editing

 Обратите внимание, что функция reload в действительности возвращает
объект – обычно ее результат игнорируется, но поскольку интерактивная
оболочка автоматически выводит результат выражения, интерпретатор вывел
результат в виде строки <module ‘name’...>.


 Придется держать в уме: повторная загрузка модулей

 Помимо возможности перезагружать (и соответственно, перезапускать)
модули в интерактивной оболочке операция повторной загрузки может также
использоваться в крупных системах, особенно когда стоимость перезапуска
всего приложения слишком высока. Например, первыми кандидатами
на использование возможности динамической перезагрузки модулей являются
системы, которые на запуске соединяются с серверами сети.

 Эта возможность также может использоваться в приложениях с графическим
интерфейсом (чтобы изменять действие обработчиков событий в графических
элементах управления, не закрывая окна графического интерфейса)
и при использовании Python в качестве встроенного языка в программах,
написанных на C или C++ (вмещающая программа может вызывать повторную
загрузку программного кода на языке Python без остановки
всего приложения). За более подробным описанием повторной загрузки
обработчиков событий в графическом интерфейсе и встроенном программном
коде на языке Python обращайтесь к книге «Программирование на Python».

 Как правило, повторная загрузка позволяет программам реализовать
высокодинамичные интерфейсы. Например, Python часто используется
как язык для настройки больших систем – пользователи могут настраивать
программные продукты, изменяя программный код на языке Python
без необходимости перекомпилировать весь продукт (и даже не имея
исходных текстов этого продукта). В таких условиях программный код
на языке Python уже сам по себе добавляет динамичности. В более общем
случае возможность повторной загрузки позволяет программам обеспечивать
высокодинамичные интерфейсы. Например, Python часто используется
как язык для создания сценариев настройки в крупных системах –
пользователи могут настраивать программные продукты под свои нужды
за счет создания небольших встраиваемых сценариев на языке Python,
не пересобирая весь продукт целиком (или вообще не имея исходных текстов
программ). Возможность внедрения сценариев на языке Python в таких
системах сама по себе привносит динамические особенности.

 Тем не менее, чтобы обеспечить еще более высокую динамичность, такие
системы могут автоматически выполнять повторную загрузку настроечного
кода на языке Python с заданной периодичностью. В этом случае изменения,
внесенные пользователями, автоматически вступают в силу прямо во время
работы системы – нет никакой необходимости останавливать и перезапускать
ее всякий раз, когда изменяется программный код на языке Python.
Не все системы реализуют такой подход, но для тех из них, которые
обеспечивают такую возможность, повторная перезагрузка модулей является
простым и удобным средством выполнения настроек.
"""

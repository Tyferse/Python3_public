"""
 Упражнения к пятой части

 Решения приводятся в разделе «Часть V, Модули» приложения A.

 1. Основы импортирования. Напишите программу, которая подсчитывает
количество строк и символов в файле (в духе утилиты wc в операционной
системы UNIX). В своем текстовом редакторе создайте модуль
с именем mymod.py, который экспортирует три имени:

  Функцию countLines(name), которая читает входной файл и подсчитывает
 число строк в нем (подсказка: большую часть работы можно выполнить
 с помощью метода file.readlines, а оставшуюся часть – с помощью функции
 len).

  Функцию countChars(name), которая читает входной файл и подсчитывает
 число символов в нем (подсказка: метод file.read возвращает единую
 строку).

  Функцию test(name), которая вызывает две предыдущие функции с заданным
 именем файла. Вообще говоря, имя файла можно жестко определить
 в программном коде, принимать ввод от пользователя или принимать имя
 как параметр командной строки через список sys.argv – но пока исходите
 из предположения, что оно передается как аргумент функции.

 Все три функции в модуле mymod должны принимать имя файла в виде
строки. Если размер любой из функций превысит две-три строки,
это значит, что вы делаете лишнюю работу, – используйте подсказки,
которые я вам дал!

 Затем проверьте свой модуль в интерактивной оболочке, используя
инструкцию import и полные имена экспортируемых функций. Следует ли
добавить в переменную PYTHONPATH каталог,
где находится ваш файл mymod.py? Попробуйте проверить модуль
на самом себе: например, test(“mymod.py”). Обратите внимание,
что функция test открывает файл дважды, – если вы достаточно
честолюбивы, попробуйте оптимизировать программный код, передавая
двум функциям счета объект открытого файла (подсказка:
метод file.seek(0) выполняет переустановку указателя в начало файла).
"""

import codecs


def count_lines(name: str) -> int:
    return len(codecs.open(name, 'r', encoding='utf-8').readlines())


def count_chars(name: str) -> int:
    return len(codecs.open(name, 'r', encoding='utf-8').read())


def test(name: str):
    print(count_lines(name), ' lines')
    print(count_chars(name), ' chars')


"""
 2. from/from *. Проверьте модуль mymod из упражнения 1 в интерактивной 
оболочке, используя для загрузки экспортируемых имен инструкцию from –
сначала по имени, а потом с помощью формы from *.

from ExtraAbilities24_2 import reload_all
from ExtraAbilities24_2 import *

 3. __main__. Добавьте в модуль mymod строку, в которой автоматически
производился бы вызов функции test, только когда модуль выполняется как
самостоятельный сценарий, а не во время импортирования. Добавляемая
вами строка, вероятно, должна содержать проверку значения атрибута
__name__ на равенство строке “__main__”, как было показано в этой главе.
Попробуйте запустить модуль из системной командной строки, затем 
импортируйте модуль и проверьте работу функций в интерактивном режиме.
Будут ли работать функции в обоих режимах?
"""

if __name__ == '__main__':
    file = 'ExtraAbilities24_1.py'
    test(file)

"""
 4. Вложенное импортирование. Напишите второй модуль myclient.py,
который импортирует модуль mymod и проверяет работу его функций, затем 
запустите myclient из системной командной строки. Будут ли доступны 
функции из mymod на верхнем уровне myclient, если импортировать их 
с помощью инструкции from? А если они будут импортированы с помощью 
инструкции import? Попробуйте реализовать оба варианта в myclient 
и проверить в интерактивном режиме, импортируя модуль myclient 
и проверяя содержимое его атрибута __dict__.
"""

from . import ExtraAbilities24_1


print(ExtraAbilities24_1.__dict__)
print(ExtraAbilities24_1.money(100000000000.2582, width=19))


from ExtraAbilities24_1 import money


print(money(100000000000.2582, width=19))

"""
 5. Импорт пакетов. Импортируйте ваш файл из пакета. Создайте каталог
с именем mypkg, вложенный в каталог, находящийся в пути поиска модулей.
Переместите в него файл mymod.py, созданный в упражнении 1 или 3,
и попробуйте импортировать его как пакет, инструкцией 
import mypkg.mymod.

 Вам потребуется добавить файл __init__.py в каталог, куда был помещен
ваш модуль. Это упражнение должно работать на всех основных платформах 
Python (это одна из причин, почему в языке Python в качестве разделителя
компонентов пути используется символ «.»). Каталог пакета может быть 
простым подкаталогом в вашем рабочем каталоге – в этом случае он будет 
обнаружен интерпретатором при поиске в домашнем каталоге и вам 
не потребуется настраивать путь поиска. Добавьте какой-нибудь 
программный код в __init__.py и посмотрите, будет ли он выполняться 
при каждой операции импортирования.
"""

from .. import Functions4


print(Functions4.hello())


from ..Functions4.ItersAndGens2_20_4 import add_dict


print(add_dict([1, 2], [3, 9]))

"""
 6. Повторная загрузка. Поэкспериментируйте с возможностью повторной 
загрузки модуля: выполните тесты, которые приводятся в примере 
changer.py в главе 22, многократно изменяя текст сообщения 
и/или поведение модуля, без остановки интерактивного сеанса работы
с интерпретатором Python. В зависимости от операционной системы файл 
модуля можно было бы редактировать в другом окне или, приостановив 
интерпретатор, редактировать модуль в том же окне (в UNIX комбинация 
клавиш Ctrl-Z обычно приводит к приостановке текущего процесса, 
а команда fg – возобновляет его работу).
"""

from importlib import reload
from ..Functions4 import ItersAndGens2_20_4 as IA


IA.L = [36, 49, 64, 81, 100]
reload(IA)

print(IA.L)

"""
 7. Циклический импорт.1 В разделе, где описываются проблемы, связанные
с рекурсивным импортом, импортирование модуля recur1 вызывает появление 
ошибки. Но если перезапустить интерактивный сеанс работы 
с интерпретатором и предварительно импортировать модуль recur2,
ошибка не возникает – проверьте этот факт сами. Как вы думаете, почему 
импортирование recur2 проходит без ошибок, а импортирование recur1 
с ошибками? (Подсказка: интерпретатор Python сохраняет новые модули
во встроенной таблице (словаре) sys.modules перед их запуском, 
независимо от того, «завершен» модуль или нет.) Теперь попробуйте 
запустить recur1 как самостоятельный сценарий: python recur1.py. 
Получите ли вы ту же самую ошибку, которая возникает при импортировании 
recur1 в интерактивной оболочке? Почему? (Подсказка: когда модули
запускаются как самостоятельные программы, они не импортируются,
поэтому здесь возникает тот же эффект, как и при импортировании recur2
в интерактивной оболочке, – recur2 является первым импортируемым
модулем.) Что произойдет, если запустить recur2 как самостоятельный
сценарий? Почему?
"""

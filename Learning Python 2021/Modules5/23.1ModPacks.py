"""
 Пакеты модулей


 Основы операции импортирования пакетов

 Пакеты и настройка пути поиска

 Если вы используете эту возможность, имейте в виду, что пути
к каталогам в инструкции import могут содержать только имена переменных,
разделенные точками. Здесь нельзя использовать синтаксис путей
к каталогам, специфичный для текущей платформы. Например,
C:\dir1.My Documents.dir2 или ../dir1 – это недопустимый синтаксис.
Напротив, в настройках путей поиска модулей используется
платформозависимый синтаксис – для именования необходимых
каталогов-контейнеров.

 Так, в предыдущем примере dir0 – это имя каталога, которое требуется
добавить в путь поиска модулей и которое может иметь произвольную длину
и путь, с учетом специфики используемой платформы, ведущий
к каталогу dir1. Вместо того, чтобы использовать ошибочный синтаксис,
как показано ниже:

import C:\mycode\dir1\dir2\mod # Ошибка: недопустимый синтаксис

 добавьте путь C:\mycode в переменную окружения PYTHONPATH
или в файл .pth (предполагается, что это не домашний каталог программы,
поскольку в этом случае этот шаг не является необходимым) и используйте
такую инструкцию:

import dir1.dir2.mod

 В сущности, записи в списке путей поиска модулей содержат
платформозависимые пути к каталогам, которые ведут к самым левым именам
в цепочках,


 Файлы __init__.py пакетов

 Если вы решили использовать импортирование пакетов, существует еще одно
условие, которое необходимо будет соблюдать: каждый каталог в пути,
указанном в инструкции импортирования пакета, должен содержать файл
с именем __init__.py, в противном случае операция импорта пакета будет
терпеть неудачу. То есть в примере выше каталоги dir1 и dir2 должны
содержать файл с именем __init__.py; каталог-контейнер dir0 может
не содержать такой файл, потому что сам он не указан в инструкции
импортирования пакета. Точнее говоря, для такой структуры каталогов:

dir0\dir1\dir2\mod.py

 и инструкции импортирования, имеющей следующий вид:

import dir1.dir2.mod

 применяются следующие правила:

  dir1 и dir2 должны содержать файл __init__.py.

  dir0, каталог-контейнер, может не содержать файл __init__.py –
 этот файл будет проигнорирован, если он присутствует.

  dir0, но не dir0\dir1, должен присутствовать в пути поиска модулей
 (то есть он должен быть домашним каталогом или присутствовать
 в переменной окружения PYTHONPATH и так далее).

 Таким образом, структура каталогов в этом примере должна иметь
следующий вид (здесь отступы указывают на вложенность каталогов):

dir0\  # Каталог-контейнер в пути поиска модулей
    dir1\
        __init__.py
        dir2\
            __init__.py
            mod.py

 Файлы __init__.py могут содержать программный код на языке Python,
как любые другие файлы модулей. Отчасти они являются объявлениями
для интерпретатора и могут вообще ничего не содержать. Эти файлы,
будучи объявлениями, предотвращают неумышленное сокрытие в каталогах
с совпадающими именами истинно требуемых модулей, если они отображаются
позже в списке путей поиска модулей. Без этого защитного механизма
интерпретатор мог бы выбирать каталоги, которые не имеют никакого
отношения к вашему программному коду, только лишь потому, что
в пути поиска они появляются ранее.

 В общем случае файл __init__.py предназначен для выполнения действи
по инициализации пакета, создания пространства имен для каталога
и реализации поведения инструкций from * (то есть from ... import *),
когда они используются для импортирования каталогов:

 Инициализация пакета

  Когда интерпретатор Python импортирует каталог в первый раз,
 он автоматически запускает программный код файла __init__.py
 этого каталога. По этой причине обычно в эти файлы помещается
 программный код, выполняющий действия по инициализации, необходимые
 для файлов в пакете. Например, этот файл инициализации в пакете может
 использоваться для создания файлов с данными, открытия соединения
 с базой данных и так далее. Обычно файлы __init__.py не предназначены
 для непосредственного выполнения – они запускаются автоматически,
 когда выполняется первое обращение к пакету.

 Инициализация пространства имен модуля

  При импортировании пакетов пути к каталогам в вашем сценарии после
 завершения операции импортирования превращаются в настоящие иерархии
 вложенных объектов. Например, в предыдущем примере после завершения
 операции импортирования можно будет использовать выражение dir1.dir2,
 которое возвращает объект модуля, чье пространство имен содержит все
 имена, определяемые файлом __init__.py из каталога dir2. Такие файлы
 создают пространства имен для объектов модулей, соответствующих
 каталогам, в которых отсутствуют настоящие файлы модулей.

 Поведение инструкции from *

  В качестве дополнительной особенности, в файлах __init__.py можно
 использовать списки __all__, чтобы определить, что будет
 импортироваться из каталога инструкцией from *. Список __all__ в файлах
 __init__.py представляет собой список имен субмодулей, которые должны
 импортироваться, когда в инструкции from * указывается имя пакета
 (каталога). Если список __all__ отсутствует, инструкция from *
 не будет автоматически загружать субмодули, вложенные в каталог, –
 она загрузит только имена, определяемые инструкциями присваивания
 в файле __init__.py, включая любые субмодули, явно импортируемые
 программным кодом в этом файле. Например, инструкция from submodule
 import X в файле __init__.py создаст имя X в пространстве
 имен каталога. (Мы поближе познакомимся со списком __all__ в главе 24.)

 Эти файлы можно оставить пустыми, если вам не требуется выполнять
 специальных действий. Однако для успешного выполнения операции
 импортирования каталогов они должны существовать обязательно.

 Не путайте файлы __init__.py пакетов с методами-конструкторами
__init__ классов, с которыми мы встретимся в следующей части книги.
Первые из них – это файлы с программным кодом, который выполняется,
когда операция импортирования производит обход каталогов пакета,
тогда как вторые вызываются при создании экземпляров классов.
Оба они служат для инициализации, но во всем остальном – это совершенно
разные вещи.


 Пример импортирования пакета

 Рассмотрим практический пример программного кода, который демонстриру-
ет, как используются файлы инициализации и пути к каталогам. Следующие
три файла располагаются в каталоге dir1 и в подкаталоге dir2 –
комментарии описывают пути к этим файлам:

# Файл: dir1\__init__.py
Print(‘dir1 init’)
x = 1

# Файл: dir1\dir2\__init__.py
Print(‘dir2 init’)
y = 2

# Файл: dir1\dir2\mod.py
Print(‘in mod.py’)
z = 3

 В данном случае каталог dir1 может быть подкаталогом нашего рабочего
каталога (то есть домашнего каталога программы) или подкаталогом одного
из каталогов, перечисленных в пути поиска модулей (технически, входящего
в список sys.path). В любом из этих случаев для каталога, вмещающего
подкаталог dir1, не требуется наличие файла __init__.py.

 Инструкции import выполняют файлы инициализации в каждом каталоге,
которые присутствуют в пути к модулю, – инструкции print, присутствующие
в этих файлах, позволят отследить их выполнение. Кроме того, как и файлы
модулей, уже импортированные каталоги могут передаваться функции reload
для принудительного повторного исполнения этого единственного элемента.
Как показано ниже, для повторной загрузки каталогов и файлов функция
reload также может принимать цепочку имен, разделенных точками:

% python
\>>> import dir1.dir2.mod  # Сначала запускаются файлы инициализации
dir1 init
dir2 init
in mod.py
\>>>
\>>> import dir1.dir2.mod   # Повторное импортирование не выполняется
\>>>
\>>> from importlib import reload  # Требуется в верси
\>>> reload(dir1)
dir1 init
<module ‘dir1’ from ‘dir1\__init__.pyc’>
\>>>
\>>> reload(dir1.dir2)
dir2 init
<module ‘dir1.dir2’ from ‘dir1\dir2\__init__.pyc’>

 После операции импортирования путь, указанный в инструкции import,
становится цепочкой вложенных объектов. Здесь mod – это объект,
вложенный в объект dir2, который в свою очередь вложен в объект dir1:

\>>> dir1
<module ‘dir1’ from ‘dir1\__init__.pyc’>
\>>> dir1.dir2
<module ‘dir1.dir2’ from ‘dir1\dir2\__init__.pyc’>
\>>> dir1.dir2.mod
<module ‘dir1.dir2.mod’ from ‘dir1\dir2\mod.pyc’>

 Каждый каталог в пути фактически становится переменной, которой
присваивается объект модуля, пространство имен которого инициализируется
всеми инструкциями присваивания в файле __init__.py, находящемся
в этом каталоге. Имя dir1.x ссылается на переменную x, которой
присваивается значение в файле dir1\__init__.py, точно так же,
как имя mod.z ссылается на переменную z, которой присваивается значение
в файле mod.py:

\>>> dir1.x
1
\>>> dir1.dir2.y
2
\>>> dir1.dir2.mod.z
3


 Инструкции from и import для пакетов

 Использование инструкции import могут оказаться несколько неудобным
для импортирования пакетов, потому что в этом случае далее в программе
вам придется часто вводить полные пути для обращения к именам.
В примере из предыдущего раздела, например, приходилось каждый раз
вводить полный путь от dir1, когда необходимо было обратиться
к переменой z. Если попытаться непосредственно обратиться к dir2
или mod, будет получено сообщение об ошибке:

\>>> dir2.mod
NameError: name ‘dir2’ is not defined
\>>> mod.z
NameError: name ‘mod’ is not defined

 Поэтому для импортирования пакетов часто более удобно использовать
инструкцию from, чтобы избежать необходимости ввода полного имени
при каждом обращении к нему. Еще более важно следующее: если вы
когда-нибудь произведете реструктуризацию дерева каталогов, то в случае
использования инструкции from достаточно будет обновить путь только
в самой этой инструкции, тогда как в случае использования инструкции
import придется обновлять все обращения к именам в изменившемся пакете.
Расширение import as, обсуждаемое в следующей главе, поможет вам
определить сокращенные синонимы для полных путей:

% python
\>>> from dir1.dir2 import mod  # Описание пути находится только
dir1 init                       #  в этом месте
dir2 init
in mod.py
\>>> mod.z  # Указывать полный путь не требуется
3
\>>> from dir1.dir2.mod import z
\>>> z
3
\>>> import dir1.dir2.mod as mod  # Использование короткого синонима
\>>> mod.z
3


 Когда используется операция импортирования пакетов?

 Если вы только начинаете осваивать язык Python, то прежде чем
переходить к использованию пакетов, вам сначала необходимо освоить
работу с простыми модулями. Пакеты действительно являются полезным
инструментом, особенно в крупных программах: они делают операцию
импортирования более информативной, выступают в роли организационного
инструмента, упрощают поиск файлов модулей и способны разрешать
возникающие неоднозначности.

 Прежде всего, так как операция импортирования пакетов содержит
некоторые сведения о структуре каталогов, где находятся файлы программы,
они, в первую очередь, упрощают поиск файлов и служат организационным
инструментом. Не имея информации о путях к пакетам, вам часто
пришлось бы обращаться к содержимому пути поиска модулей, чтобы отыскать
требуемые файлы. Кроме того, если вы организовали размещение своих
файлов в дереве каталогов по функциональным признакам, то операция
импортирования пакетов делает более очевидной роль, которую играют
пакеты, что обеспечивает более высокую удобочитаемость программного
кода. Например, обычная операция импорта файла в каталоге, находящемся
где-то в пути поиска модулей, выглядит так:

import utilities

 предлагая намного меньше информации, чем операция импорта, включающая
путь к модулю:

import database.client.utilities

 Операция импортирования пакетов может также упростить задание
переменной окружения PYTHONPATH и файлов .pth, хранящих настройки пути
поиска модулей. Фактически если вы используете импортирование пакетов
для всех имеющихся каталогов, где хранится ваш программный код, и импорт
производится относительно общего корневого каталога, вам достаточно
будет добавить единственную запись в путь поиска модулей: общий корневой
каталог. Наконец, операция импортирования пакетов способна разрешать
неоднозначности за счет явного и точного указания импортируемых файлов.
В следующем разделе эта роль исследуется более подробно.


 История о трех программах

 Единственный случай, когда операция импортирования действительно
необходима, – это разрешение неоднозначностей, которые могут возникать,
когда на одной машине установлено множество программ, содержащих файлы
с одинаковыми именами. В определенной степени это проблема установки
программ, но она может стать источником беспокойств в обычной практике.
Давайте рассмотрим гипотетическую ситуацию, чтобы проиллюстрировать
эту проблему.

 Предположим, что программист разработал программу на языке Python,
которая содержит файл именем utilities.py, хранящий вспомогательный
программный код, и файл main.py, используемый для запуска программы.
Все файлы программы вызывают инструкцию import utilities для загрузки
и использования общего программного кода. Программа распространяется
в виде единого архива в формате .tar или .zip, содержащего все файлы
программы, и при установке все файлы распаковываются в единственный
каталог с именем system1:

system1\
    utilities.py  # Общие вспомогательные функции, классы
    main.py       # Этот файл запускает программу
    other.py      # Импортирует и использует модуль utilities

 Теперь предположим, что другой программист разработал другую программу,
в которой также имеются файлы utilities.py и main.py,
и также используется инструкция import utilities во всех файлах
программы для загрузки общего программного кода. Во время установки
этой второй программы на том же самом компьютере, где уже
была установлена первая программа, ее файлы были распакованы в новый
каталог с именем system2, чтобы не перезаписать одноименные файлы
первой программы:

system2\
    utilities.py # Общие вспомогательные функции
    main.py # Этот файл запускает программу
    other.py # Импортирует модуль utilities

 Пока что никаких явных проблем не наблюдается: обе программы прекрасно
сосуществуют и работают на одной и той же машине. Фактически для этих
программ вам даже не нужно настраивать путь поиска модулей, потому что
интерпретатор всегда начинает поиск модулей с домашнего каталога
программы (то есть с каталога, в котором находится главный файл
программы), операции импортирования в любой из этих программ
автоматически будут находить все необходимые файлы в домашнем каталоге
программы. Например, если запускается файл system1\main.py, все операции
импортирования сначала будут просматривать каталог system1. Точно так же
при запуске файла system2\main. py в первую очередь будет
просматриваться каталог system2. Не забывайте, что настраивать
путь поиска модулей необходимо только при необходимости импортировать
модули из разных каталогов.

 А теперь предположим, что после установки этих двух программ вы решили
использовать вспомогательные функции из обоих файлов utilities.py
в своей собственной программе. В конце концов, это обычный
вспомогательный программный код, а для программного кода на языке Python
вполне естественно, когда он используется многократно. В такой ситуации
вам необходима возможность из своего программного кода, хранящегося
в третьем каталоге, загрузить один из двух файлов:

import utilities
utilities.func(‘spam’)

 Теперь проблема начинает вырисовываться. Чтобы вообще выполнить эту
работу, вам придется включить в путь поиска модулей каталоги, содержащие
файлы utilities.py. Но какой каталог поместить первым – system1
или system2? Проблема заключается в линейной природе пути поиска.
Он всегда просматривается слева направо. Независимо от того, как долго
вы будете ломать голову над этой проблемой, вы всегда будете получать
файл utilities.py из каталога, который находится в пути поиска раньше
(левее). Как следствие, вы никогда не сможете импортировать одноименный
файл из другого каталога. Вы можете попытаться изменять sys.path
в своей программе перед каждой операцией импортирования, но это сложная
работа и при ее выполнении легко ошибиться. По умолчанию проблема
оказывается для вас неразрешимой.

 Эту проблему можно решить с помощью пакетов. Вместо того, чтобы
устанавливать программы как плоские списки файлов в независимые
каталоги, можно установить их в подкаталоги с общим корнем. Например,
можно было бы организовать установку всего программного кода из этого
примера в виде следующей иерархии:

root\
    system1\
        __init__.py
        utilities.py
        main.py
        other.py
    system2\
        __init__.py
        utilities.py
        main.py
        other.py
    system3\          # Здесь или в другом месте
        __init__.py  # располагается ваш новый программный код
        myfile.py

 Теперь достаточно просто добавить общий корневой каталог в путь поиска
модулей. Если выполнять импортирование относительно этого общего корня,
можно будет с помощью операции импортирования пакетов импортировать
любой файл из любой программы – использование имени вмещающего каталога
делает путь (а, значит, и ссылку на модуль) уникальным. Фактически можно
даже импортировать обе утилиты сразу в одном и том же модуле,
при условии, что вы будете использовать инструкцию import и при каждом
обращении к именам будете указывать полный путь к вспомогательным
модулям:

import system1.utilities
import system2.utilities
system1.utilities.function(‘spam’)
system2.utilities.function(‘eggs’)

 В данном случае имя вмещающего каталога обеспечивает уникальность
ссылок на модули.

 Обратите внимание, что вместо инструкции from необходимо использовать
инструкцию import, только если вам необходимо получить доступ
к двум или более одноименным атрибутам. Если бы имена вызываемых здесь
функций различались, можно было бы использовать инструкцию from,
чтобы избежать необходимости всякий раз вводить полные пути к пакетам,
как уже описывалось выше. Кроме того, следует заметить,
что в приведенной выше иерархии установки файлы __init__.py были
добавлены в каталоги установки программ system1 и system2,
но не в корневой каталог root. Этот файл требуется помещать только
в каталоги, перечисленные в инструкциях import, – как вы наверняка
помните, они автоматически выполняются интерпретатором
при первой попытке программы импортировать каталог пакета.

 Технически, каталог system3 не обязательно должен находиться в каталоге
root – здесь должны находиться только каталоги, откуда производится
импорт пакетов. Однако, поскольку ваши собственные модули могут
когда-нибудь быть использованы в других программах, было бы желательно
поместить их в общий корневой каталог, чтобы избежать подобных проблем
в будущем.

 Наконец, обратите внимание, что операции импорта в обеих оригинальных
программах продолжают действовать без изменений. Поскольку в этих
программа поиск модулей производится в первую очередь в их домашних
каталогах, добавление общего корневого каталога в путь поиска модулей
никак не отражается на программном коде в system1 и system2 – они
по-прежнему могут использовать инструкции import utilities и получать
в ответ свои собственные файлы. Кроме того, если вы предусмотрительно
будете устанавливать все программы на языке Python в общий корневой
каталог, как в данном примере, настройка пути поиска станет
элементарной: вам достаточно будет один раз добавить в него общий
корневой каталог.


 Импортирование относительно пакета

 При описании операции импортирования пакетов мы пока рассматривали
возможность импортирования файлов пакетов из-за пределов этих пакетов.
При импортировании файлов пакета внутри самого пакета можно использовать
тот же синтаксис, как и при импортировании из-за пределов пакета,
но можно также использовать специальные правила поиска модулей внутри
пакета, позволяющие упростить инструкции import. То есть вместо того,
чтобы указывать полный путь к модулю пакета, можно использовать форму
относительного пути внутри пакета.

 На сегодняшний день принцип действия операции импортирования
относительно пакета зависит от версии Python: в Python 2.6 операция
импортирования неявно выполняет поиск в каталогах пакета, тогда как
в версии 3.0 необходимо явно использовать синтаксис относительного
импортирования. Это изменение в версии 3.0 помогает повысить
удобочитаемость программного кода, делая операцию импортирования модулей
из того же пакета более очевидной.


 Изменения в Python 3.0

 Принцип действия операции импортирования внутри пакетов немного
изменился в Python 3.0. Изменения коснулись лишь импортирования файлов
пакета из файлов, находящихся в каталогах этого же пакета, о котором
мы говорим в этой главе, – операция импортирования других файлов
действует, как и прежде. В Python 3.0 в операцию импортирования внутри
пакетов было внесено два изменения:

  Изменилась семантика пути поиска модулей так, что теперь операция
 импортирования модуля по умолчанию пропускает собственный каталог
 пакета. Она проверяет только компоненты пути поиска. Эта операция н
 азывается импортированием по «абсолютному» пути.

  Расширен синтаксис инструкции from так, что теперь имеется возможность
 явно указать, что поиск импортируемых модулей должен производиться
 только в каталоге пакета. Эта операция называется импортированием по
 «относительному» пути.

 Эти изменения были полностью реализованы в Python 3.0. Новый синтаксис
операции импортирования относительно пакета доступен также в Python 2.6,
но по умолчанию изменения в семантике пути поиска отключены
и их требуется активировать. В настоящее время эти изменения
предполагается добавить в версию 2.71 – такое поэтапное изменение
обусловлено тем, что изменения семантики пути поиска нарушают обратную
совместимость с более ранними версиями Python.

 Суть этих изменений в версии 3.0 (и в 2.6, если они используются)
состоит в том, что вы должны использовать специальный синтаксис
инструкции from для импортирования модулей, находящихся в том же пакете,
что и импортирующий модуль, если вы не указываете полный путь к модулю,
начиная от корневого каталога пакета. Если не использовать
этот синтаксис, интерпретатор не сможет отыскать требуемый модуль
в пакете.


 Основы импортирования по относительному пути

 В обеих версиях, Python 3.0 и 2.6, инструкции from теперь
могут использовать точки («.»), чтобы указать, что поиск модулей
в первую очередь должен производиться в том же самом пакете
(эта особенность известна как импортирование относительно пакета),
а не где-то в другом месте, в пути поиска (эта особенность называется
импортирование по абсолютному пути). То есть:

 В обеих версиях Python, 3.0 и 2.6, в инструкции from в начале пути
можно использовать точки, чтобы указать, что импорт должен производиться
относительно вмещающего пакета, – при таком способе импортирования
поиск модулей будет производиться только внутри пакета, а модули с теми
же именами, находящиеся где-то в пути поиска (sys.path),
будут недоступны. Благодаря этому модули внутри пакета
получают преимущество перед модулями за его пределами.

 В Python 2.6 обычная операция импортирования в программном коде па-
кета (без точек) в настоящее время по умолчанию выполняется в порядке
«сначала поиск относительно пакета, потом – абсолютный поиск». То есть
поиск сначала производится в каталоге пакета и только потом в пути по-
иска. Однако в Python 3.0 по умолчанию выполняется импортирование по
абсолютному пути – при отсутствии точек операции импортирования про-
пускают вмещающий пакет и пытаются отыскать импортируемые модули
в пути поиска sys.path.

 Например, в обеих версиях Python, 3.0 и 2.6, инструкция вида:

from . import spam  # Импортирование относительно текущего пакета

 предписывает интерпретатору импортировать модуль с именем spam,
расположенный в том же пакете, что и файл, где находится эта инструкция.
Аналогично, следующая инструкция:

from .spam import name

 означает: «из модуля с именем spam, расположенного в том же пакете,
что и файл, где находится эта инструкция, импортировать
переменную name». Поведение инструкции без начальной точки зависит
от используемой версии Python. В версии 2.6 такая инструкция
импортирования по умолчанию также будет использовать порядок поиска
«сначала относительно пакета, а затем – абсолютный поиск» (то есть
сначала поиск выполняется в каталоге пакета), если только
в импортирующий файл не будет включена следующая инструкция:

from __future__ import absolute_import      # Обязательно до версии 2.7?

 Если эта инструкция присутствует, она включает использование
абсолютного пути поиска, которое по умолчанию используется в Python 3.0.

 В Python 3.0 все операции импортирования без дополнительных точек
никогда не пытаются отыскать модуль внутри пакета и производят поиск
по абсолютному пути, хранящемуся в списке sys.path. Например, когда
задействован механизм импортирования в версии 3.0, следующая инструкция
всегда будет находить не модуль string в текущем пакете, а одноименный
модуль в стандартной библиотеке:

import string  # Пропустит поиск модуля в пакете

 Без инструкции from __future__ в Python 2.6 всегда будет
импортироваться модуль string из пакета. Чтобы получить то же поведение
в версии 3.0 и 2.6, когда по умолчанию выполняется импорт по абсолютному
пути, для выполнения операции импортирования относительно пакета можно
использовать следующую форму инструкции:

from . import string  # Поиск выполняется только в пределах пакета

 На сегодняшний день этот прием работает в обеих версиях Python,
2.6 и 3.0. Единственное отличие модели импортирования в версии 3.0
состоит в том, что она является обязательной, когда требуется
по простому имени загрузить модуль, находящийся в том же каталоге
пакета, что и файл, откуда производится импортирование.

 Обратите внимание: ведущий символ точки может использоваться только
в инструкции from – в инструкции import он недопустим. В Python 3.0
инструкция import modname всегда выполняет импортирование
по абсолютному пути, пропуская поиск в каталоге пакета. В Python 2.6
она по-прежнему выполняет импорт по относительному пути (то есть
сначала она просматривает каталог пакета), но в Python 2.7 она будет
выполнять импорт по абсолютному пути. Инструкции from без ведущей точки
ведут себя точно так же, как инструкции import, – в версии 3.0 они
выполняют импортирование по абсолютному пути (пропуская каталог пакета),
а в версии 2.6 они выполняют поиск «сначала относительно пакета,
а затем – абсолютный поиск» (поиск в каталоге пакета выполняется
в первую очередь).

 Возможны также и другие варианты точечной нотации для ссылки на модули
в пакете. Допустим, что имеется каталог mypkg пакета, тогда следующие
альтернативные варианты импортирования внутри этого пакета будут
работать так, как описывается:

from .string import name1, name2  # Импорт имен из mypkg.string
from . import string              # Импорт mypkg.string
from .. import string          # Импорт string из родительского каталога

 Чтобы лучше понять эти последние формы инструкций, необходимо
разобраться с обоснованием этого изменения.


 Зачем необходим импорт относительно пакета?

 Эта возможность предназначена, чтобы дать сценариям возможность
ликвидировать возникающие неоднозначности, которые могут возникать,
когда в разных местах в пути поиска присутствует несколько одноименных
модулей. Рассмотрим следующий каталог пакета:

mypkg\
    __init__.py
    main.py
    string.py

 Это каталог пакета с именем mypkg, содержащий модули mypkg.main
и mypkg.string. Теперь предположим, что модуль main пытается
импортировать модуль с именем string. В Python 2.6 и в более ранних
версиях интерпретатор будет сначала искать модуль в каталоге mypkg,
выполняя импорт относительно пакета. Он найдет и импортирует файл
string.py, находящийся в этом каталоге, и присвоит его имени string
в пространстве имен модуля mypkg.main.

 Однако может так получиться, что этой инструкцией предполагалось
импортировать модуль string из стандартной библиотеки языка Python.
К сожалению, в этих версиях Python нет достаточно простого способа
проигнорировать модуль mypkg.string и импортировать модуль string
из стандартной библиотеки, расположенной в пути поиска модулей.
Кроме того, мы не сможем решить эту проблему с помощью инструкции
импортирования пакетов, потому что мы не можем зависеть от структуры к
аталогов пакета, описанных выше, стандартной библиотеки, присутствующей
на любом компьютере.

 Другими словами, инструкции импортирования в пакетах могут быть
неоднозначными – внутри пакета может быть непонятно, какой модуль
пытается импортировать инструкция import spam, – внутри пакета
или за его пределами. Если говорить более точно, локальный модуль
или пакет могут сделать невозможным импорт другого модуля,
присутствующего в пути поиска sys.path, преднамеренно или нет.

 На практике пользователи Python могут избегать использовать имена
модулей стандартной библиотеки для своих модулей (если вам требуется
стандартный модуль string, не называйте свой модуль этим именем!).
Но это не поможет, если пакет делает недоступным стандартный модуль
случайно. Кроме того, с течением времени в стандартную библиотеку Python
могут добавляться новые модули – с теми же именами, которые присвоены
вашим уже существующим модулям. Программный код, использующий
особенности импорта относительно пакетов, сложнее понять, потому что
бывает трудно выяснить, какой модуль импортируется. Гораздо лучше,
если решение явно описывается в программном коде.


 Решение проблемы с импортированием тотносительно пакета в 3.0

 С целью разрешить эту дилемму поведение операции импортирования внутри
пакетов в Python 3.0 (и в виде дополнительной возможности в 2.6) было
изменено так, что теперь она выполняет импорт только по абсолютному
пути. Согласно этой модели следующая инструкция import, находящаяся
в нашем файле mypkg/main.py, всегда будет находить модуль string
за пределами пакета, за счет использования схемы поиска модулей
по абсолютному пути sys.path:

import string  # Импортирует модуль string за пределами пакета

 Инструкция from, в которой не используется синтаксис с ведущей точкой,
также выполняет импорт по абсолютному пути:

from string import name  # Импортирует имя name из модуля string
# за пределами пакета

 Однако, если вы действительно хотите импортировать модуль из своего
пакета, не указывая полный путь, начиная от корневого каталога пакета,
можно воспользоваться синтаксисом инструкции from:

from . import string    # Импортирует mypkg.string (относительно пакета)

 Данная форма инструкции пытается импортировать модуль string только
из текущего пакета и является относительным эквивалентом абсолютной
формы инструкции import из предыдущего примера – когда используется
специальный синтаксис относительного импортирования, поиск модулей
выполняется только в каталоге пакета.

 Кроме того, мы можем копировать имена из модуля, используя синтаксис
импортирования относительно пакета:

from .string import name1, name2     # Импортирует имена из mypkg.string

 Эта инструкция также ссылается на модуль string в текущем пакете.
Если поместить эту инструкцию в модуль mypkg.main, например, она будет
импортировать имена name1 и name2 из модуля mypkg.string.

 По сути, символ точки «.» в инструкции относительного импорта
представляет каталог в пакете, содержащий файл, где выполняется операция
импортирования. Дополнительная начальная точка предписывает выполнить
относительный импорт, начиная с родительского каталога текущего пакета.
Например, инструкция:

from .. import spam   # Импортирует модуль одного уровня с пакетом mypkg

 загрузит модуль, находящийся на том же уровне в иерехии каталогов,
что и пакет mypkg, – то есть модуль spam, находящийся в каталоге,
родительском по отношению к пакету mypkg. В общем случае действия
программного кода в модуле A.B.C будут следующими:

from . import D    # Импортирует A.B.D (. означает A.B)
from .. import E   # Импортирует A.E (.. означает A)

from .D import X   # Импортирует A.B.D.X (. означает A.B)
from ..E import X  # Импортирует A.E.X (.. означает A)


 Импорт в пакетах по относительному и абсолютному пути

 Как вариант, в файле может явно указываться имя его пакета в инструкции
импортирования по абсолютному пути. Например, следующая инструкция
найдет пакет mypkg по абсолютному пути в sys.path:

from mypkg import string  # Импортирует mypkg.string
                          # (по абсолютному пути)

 Однако результат этой инструкции зависит от настроек и от порядка
следования каталогов в пути поиска модулей, тогда как форма
импортирования с точкой, относительно текущего пакета, такой зависимости
не имеет. Фактически чтобы иметь возможность использовать данную форму
импортирования, требуется включить путь к каталогу пакета mypkg в путь
поиска модулей. Вообще говоря, инструкция поиска по абсолютному пути
должна просмотреть все каталоги, находящиеся левее каталога пакета
в sys.path, когда имя пакета указывается явно, как в следующей
инструкции:

from system.section.mypkg import string  # sys.path содержит
                                         # только system

 В крупных пакетах или в пакетах с глубокой вложенностью такое
импортирование будет выполняться дольше, чем в случае использования
точки:

from . import string  # Синтаксис импортирования относительно
                      # текущего пакета

 При использовании этой последней формы инструкции поиск автоматически
будет выполняться только в объемлющем пакете, независимо от настройки
пути поиска.


 Правила импортирования по относительному пути

 Операция импортирования при первой встрече может показаться немного
замысловатой, но разобраться в ней вам помогут следующие ключевые
моменты:

  Операция импортирования по относительному пути применяется
 исключительно для импортирования внутри пакета. Имейте в виду,
 что изменение семантики пути поиска модулей действует только
 в инструкциях импортирования внутри модуля, помещенного в пакет.
 Обычная операция импортирования в файлах за пределами пакетов действует
 точно так, как было описано выше, – она в первую очередь выполняет
 поиск в каталоге, содержащем главный файл сценария.

  Импортирование по относительному пути возможно только с помощью
 инструкции from. Запомните также, что новый синтаксис может применяться
 только в инструкциях from и считается недопустимым в инструкциях
 import. Требование импортирования по относительному пути определяется
 по тому, что имя модуля в инструкции from начинается с одной
 или более точек. Если в инструкции указано имя, содержащее точки,
 но не начинающееся с точек, она интерпретируется как инструкция
 импортирования пакета, а не как инструкция импортирования
 по относительному пути.

  Неоднозначность терминологии. Честно признаться, терминология,
 используемая для описания этой особенности, создает больше путаницы,
 чем должна бы. В действительности, все операции импортирования
 выполняются относительно чего-нибудь. За пределами пакетов
 импортирование выполняется относительно каталогов, перечисленных в пути
 поиска модулей sys.path. Как мы узнали в главе 21, этот путь включает
 в себя домашний каталог программы, значение переменной окружения
 PYTHONPATH, каталоги из файлов .pth и каталоги стандартной библиотеки.
 При работе в интерактивной оболочке домашним каталогом программы
 считается текущий рабочий каталог.

  Операции импорта внутри пакета в 2.6 расширяют это поведение
 и выполняют поиск модулей сначала внутри самого пакета. Единственное,
 что изменилось в модели поиска в версии 3.0, – обычная инструкция
 импортирования по «абсолютному» пути пропускает каталог пакета,
 а инструкции импорта со «специальным» синтаксисом импортирования
 относительно текущего пакета выполняют поиск только в пределах пакета.
 Когда мы говорим об импортировании по «абсолютному» пути в версии 3.0,
 мы в действительности подразумеваем, что импортирование будет
 выполняться относительно каталогов, перечисленных в sys.path,
 но не внутри самого пакета. И наоборот, когда мы говорим
 об импортировании «относительно» текущего пакета, мы подразумеваем,
 что импортирование будет выполняться только внутри каталога пакета.
 Конечно, пути к каталогам в sys.path могут быть не только абсолютными,
 но и относительными. (Этим утверждением я, возможно, запутал вас
 еще больше, но не волнуйтесь, это была всего лишь разминка!)

  Другими словами, реализация «импортирования относительно текущего
 пакета» в 3.0 в действительности сводится лишь к тому,
 что из реализации импортирования для пакетов версии 2.6 был убран
 просмотр каталогов в пути поиска, и в инструкцию from был добавлен
 специальный синтаксис, явно указывающий, что операция импортирования
 выполняется относительно текущего пакета. Если ранее вам приходилось
 писать инструкции импортирования в версии 2.6, не зависящие от неявного
 поведения инструкции импортирования в пакетах (например, за счет
 повсеместного использования полных путей, начиная от корневого
 каталога пакета), это изменение может показаться вам спорным. Если вы
 поступали иначе, вам придется внести изменения в свои пакеты
 и использовать новый синтаксис в инструкциях from, импортирующих
 модули из локального пакета.


 Правила поиска модулей

 Полное представление о природе импортирования пакетов и импортирования
относительно текущего пакета в Python 3.0 дают следующие правила:

  Для простых имен пакетов (например, A) поиск выполняется
 во всех каталогах, перечисленных в списке sys.path, слева направо.
 Этот список конструируется из системных значений по умолчанию
 и из настроек пользователя.

  Пакеты – это обычные каталоги с модулями на языке Python, содержащие
 специальный файл __init__.py, который позволяет указывать в инструкциях
 импортирования цепочки каталогов вида A.B.C. Чтобы получить возможность
 импортировать, например, A.B.C, каталог A должен находиться в одном
 из каталогов, перечисленных в пути поиска модулей sys.path, B должен
 быть подкаталогом пакета в каталоге A, а C должен быть модулем
 или другим компонентом в каталоге B, доступным для импортирования.

  Внутри файлов пакета обычные инструкции import выполняют поиск модулей
 в sys.path в соответствии с теми же правилами, что и инструкции
 импортирования в любых других модулях. Однако при импортировании
 с использованием инструкций from и начальных точек в именах поиск
 выполняется относительно текущего пакета – то есть поиск производится
 только в каталоге текущего пакета, а обычный поиск в sys.path н
 е выполняется. Инструкция from . import A, например, ограничится
 поиском модуля в каталоге, содержащем файл, где находится
 эта инструкция.


 Относительный импорт в примерах


 Импортирование за пределами пакетов

 Прежде всего, как уже упоминалось выше, данная особенность не оказывает
влияния на операцию импортирования за пределами пакета.
То есть следующий пример загрузит модуль string из стандартной
библиотеки, как и предполагалось:

C:\test> c:\Python30\python
\>>> import string
\>>> string
<module ‘string’ from ‘c:\Python30\lib\string.py’>

 Но если в текущий рабочий каталог добавить модуль с тем же именем,
будет загружен он, вместо библиотечного модуля, потому что текущий
рабочий каталог стоит на первом месте в пути поиска:

# test\string.py
print(‘string’ * 8)
C:\test> c:\Python30\python
\>>> import string
stringstringstringstringstringstringstringstring
\>>> string
<module ‘string’ from ‘string.py’>

 Другими словами, обычная операция импортирования выполняется
относительно «домашнего» каталога (где находится главный сценарий,
или относительно текущего рабочего каталога). В действительности
синтаксис импортирования относительно текущего пакета считается
недопустимым для использования в файлах, не входящих в состав пакета:

\>>> from . import string
Traceback (most recent call last):
File “<stdin>”, line 1, in <module>
ValueError: Attempted relative import in non-package

 В этом и во всех остальных примерах, что приводятся в этом разделе,
инструкции, которые вводятся в интерактивной оболочке, ведут себя точно
так же, как они вели бы себя, находясь на верхнем уровне сценария.
Это обусловлено тем, что первый элемент списка sys.path соответствует
либо текущему рабочему каталогу интерактивной оболочки, либо каталогу,
содержащему главный файл программы. Единственное отличие состоит в том,
что во втором случае первый элемент списка sys.path содержит не пустую
строку, а абсолютный путь к каталогу:

# test\main.py
import string
print(string)
C:\test> C:\python30\python main.py # Тот же результат получается в 2.6
stringstringstringstringstringstringstringstring
<module ‘string’ from ‘C:\test\string.py’>


 Импортирование внутри пакетов

 Теперь избавимся от локального модуля string, находящегося в текущем
рабочем каталоге, и создадим каталог пакета с двумя модулями, включая
обязательный, но пустой файл test\pkg\__init__.py (который я опустил
здесь):

C:\test> del string*
C:\test> mkdir pkg

# test\pkg\spam.py
import eggs  # <== Работает в 2.6, но не в 3.0!
print(eggs.X)

# test\pkg\eggs.py
X = 99999
import string
print(string)

 Первый файл в этом пакете пытается импортировать второй с помощью
обычной инструкции import. Поскольку в версии 2.6 эта инструкция
выполняет импортирование относительно текущего пакета, а в версии 3.0 –
импортирование по абсолютному пути, в будущем она будет терпеть неудачу.
То есть в версии 2.6 она сначала выполнит поиск в каталоге пакета,
а в версии 3.0 – нет. Вы должны помнить об этой несовместимости
в версии 3.0:

C:\test> c:\Python26\python
\>>> import pkg.spam
<module ‘string’ from ‘c:\Python26\lib\string.pyc’>
99999

C:\test> c:\Python30\python
\>>> import pkg.spam
Traceback (most recent call last):
  File “<stdin>”, line 1, in <module>
  File “pkg\spam.py”, line 1, in <module>
    import eggs
ImportError: No module named eggs

 Чтобы эта операция работала в обеих версиях, 2.6 и 3.0, в первом файле
необходимо использовать специальный синтаксис операции импортирования
относительно текущего пакета, чтобы в версии 3.0 обеспечить поиск
в каталоге пакета:

# test\pkg\spam.py
from . import eggs  # <== Используйте операцию импорта
# относительно print(eggs.X) текущего пакета в 2.6 или 3.0

# test\pkg\eggs.py
X = 99999
import string
print(string)

C:\test> c:\Python26\python
\>>> import pkg.spam
<module ‘string’ from ‘c:\Python26\lib\string.pyc’>
99999

C:\test> c:\Python30\python
\>>> import pkg.spam
<module ‘string’ from ‘c:\Python30\lib\string.py’>
99999


 Импорт по-прежнему выполняется относительно текущего рабочего каталога

 Обратите внимание, что модули пакета по-прежнему могут импортировать
модули из стандартной библиотеки, такие как string. В действительности
инструкции импортирования в этих модулях по-прежнему выполняют операцию
относительного импортирования, но уже относительно элементов пути
поиска, даже если сами эти элементы содержат относительные пути. Если
теперь снова добавить модуль string в текущий рабочий каталог, операции
импортирования будут обнаруживать его в пакете, а не в стандартной
библиотеке. В версии 3.0 имеется возможность выполнить импортирование
по абсолютному пути, пропустив каталог пакета, но невозможно пропустить
домашний каталог программы, которая импортирует пакет:

# test\string.py
print(‘string’ * 8)

# test\pkg\spam.py
from . import eggs
print(eggs.X)

# test\pkg\eggs.py
X = 99999
import string   # <== Импортирует модуль string из текущего рабочего
print(string)   # каталога, а не из стандартной библиотеки!

C:\test> c:\Python30\python # Тот же результат будет получен в 2.6
\>>> import pkg.spam
stringstringstringstringstringstringstringstring
<module ‘string’ from ‘string.py’>
99999


 Выбор модулей операциями импортирования по относительному
и абсолютному пути

 Чтобы показать, как это относится к операциям импортирования модулей
из стандартной библиотеки, изменим пакет еще раз. Удалите локальный
модуль string и создайте новый внутри пакета:

C:\test> del string*

# test\pkg\spam.py
import string  # <== Относительная в 2.6, абсолютная в 3.0
print(string)

# test\pkg\string.py
print(‘Ni’ * 8)

 Теперь выбор, какая версия модуля будет импортирована, зависит от того,
какая версия Python используется. Как и прежде, в Python 3.0 операция
импортирования в первом файле будет интерпретироваться,
как импортирование по абсолютному пути, и она пропустит каталог пакета,
а в Python 2.6 – нет:

C:\test> c:\Python30\python
\>>> import pkg.spam
<module ‘string’ from ‘c:\Python30\lib\string.py’>

C:\test> c:\Python26\python
\>>> import pkg.spam
NiNiNiNiNiNiNiNi
<module ‘pkg.string’ from ‘pkg\string.py’>

 Использование синтаксиса импортирования относительно текущего пакета
вынудит интерпретатор версии 3.0 выполнить поиск в пакете,
как это делается в версии 2.6. Используя синтаксис импортирования
по абсолютному или относительному пути в версии 3.0, вы можете явно
указать, как следует поступить – пропустить или просмотреть каталог
пакета. Фактически так действует модель импортирования в версии 3.0:

# test\pkg\spam.py
from . import string      # <== Относительная в обеих версиях, 2.6 и 3.0
print(string)

# test\pkg\string.py
print(‘Ni’ * 8)

C:\test> c:\Python30\python
\>>> import pkg.spam
NiNiNiNiNiNiNiNi
<module ‘pkg.string’ from ‘pkg\string.py’>

C:\test> c:\Python26\python
\>>> import pkg.spam
NiNiNiNiNiNiNiNi
<module ‘pkg.string’ from ‘pkg\string.py’>

 Важно отметить, что синтаксис импортирования относительно текущего
пакета в действительности является не просто объявлением предпочтений,
а обязывающей декларацией. Если мы удалим файл string.py и снова
запустим этот пример, инструкция импортирования относительного текущего
пакета в файле spam.py будет терпеть неудачу в обеих версиях, 3.0 и 2.6,
и не будет обнаруживать одноименный модуль в стандартной библиотеке
(или в любом другом месте):

# test\pkg\spam.py
from . import string     # <== Будет терпеть неудачу в случае отсутствия

# string.py в каталоге пакета!
C:\test> C:\python30\python
\>>> import pkg.spam
...текст сообщения опущен...
ImportError: cannot import name string

 Модули, которые упоминаются в инструкциях импорта относительно текущего
пакета, должны существовать в каталоге пакета.


 Импорт по-прежнему выполняется относительно текущего рабочего каталога
(еще раз)

 Инструкции импортирования по абсолютному пути позволяют пропускать
модули пакета, однако они по-прежнему зависят от других элементов списка
sys.path. В последнем нашем примере попробуем определить два собственных
модуля string. Один модуль с этим именем находится в текущем рабочем
каталоге, другой – в пакете и еще один – в стандартной библиотеке:

# test\string.py
print(‘string’ * 8)

# test\pkg\spam.py
from . import string      # <== Относительная в обеих версиях, 2.6 и 3.0
print(string)

# test\pkg\string.py
print(‘Ni’ * 8)

 Когда мы импортируем модуль string с применением синтаксиса
импортирования относительно пакета, мы получаем версию модуля из пакета,
как и следовало ожидать:

C:\test> c:\Python30\python          # Тот же результат получается в 2.6
\>>> import pkg.spam
NiNiNiNiNiNiNiNi
<module ‘pkg.string’ from ‘pkg\string.py’>

 Однако, когда используется синтаксис импортирования по абсолютному
пути, версия модуля зависит от версии интерпретатора. Python 2.6
интерпретирует эту инструкцию, как операцию импортирования относительно
пакета, но Python 3.0 рассматривает ее, как «абсолютную», то есть просто
пропускает каталог пакета и импортирует модуль из текущего рабочего
каталога (не из стандартной библиотеки):

# test\string.py
print(‘string’ * 8)

# test\pkg\spam.py
import string      # <== Относительная в 2.6, “абсолютная” в 3.0:
print(string)      # текущий рабочий каталог!

# test\pkg\string.py
print(‘Ni’ * 8)

C:\test> c:\Python30\python
>>> import pkg.spam
stringstringstringstringstringstringstringstring
<module ‘string’ from ‘string.py’>

C:\test> c:\Python26\python
>>> import pkg.spam
NiNiNiNiNiNiNiNi
<module ‘pkg.string’ from ‘pkg\string.pyc’>

 Как видите, хотя внутри пакета можно явно запросить модуль из этого же
пакета, тем не менее за его пределами инструкция импортирования
все равна остается относительной по отношению к остальным обычным
модулям в пути стандартной библиотеке оказывается недоступным.
Все, что в действительности было достигнуто изменениями в Python 3.0, –
это лишь возможность выбирать, откуда импортировать модуль, – из пакета
или из-за его пределов (то есть выполнять импортирование относительно
текущего пакета или по абсолютному пути). Поскольку разрешающая
способность операции импортирования зависит от окружения, которое
невозможно предсказать заранее, операция импортирования по абсолютному
пути в версии 3.0 не гарантирует, что модуль будет найден в стандартной
библиотеке.

 Поэкспериментируйте с этими примерами самостоятельно, чтобы глубже
вникнуть в их смысл. На практике иногда имеется возможность
структурировать инструкции импортирования, пути поиска и подбирать
имена модулей так, что все будет работать именно так, как задумывалось
при разработке. Но имейте в виду, что операции импортирования в крупных
системах могут в значительной степени зависеть от окружения,
а определение правил импортирования является неотъемлемой частью
архитектуры успешной библиотеки.


 Теперь, когда вы познакомились с операциями импортирования относительно
пакетов, запомните также, что их использование не всегда представляет
собой лучший выбор. Импортирование пакетов по абсолютному пути,
относительно каталогов в sys.path, иногда оказывается предпочтительнее,
чем неявные операции импортирования относительно пакета в Python 2
и явные операции импортирования относительно пакета в обеих версиях
Python, 2 и 3.

 Синтаксис импортирования относительно пакетов и новые правила поиска
в операции импортирования по абсолютному пути в Python 3.0 требуют,
как минимум, чтобы импортирование относительно текущего пакета
выполнялось явно, что облегчает понимание и сопровождение. Однако файлы,
в которых используется синтаксис инструкций импортирования с точками,
неявно оказываются привязанными к каталогу пакета
и не могут использоваться где-либо в другом месте без внесения изменений
в программный код.

 Естественно, степень влияния этого обстоятельства на ваши модули может
отличаться от пакета к пакету – инструкции импортирования по абсолютному
пути также могут потребовать внесения изменений в случае реорганизации
структуры каталогов.


 Придется держать в уме: пакеты модулей

 Теперь, когда пакеты стали стандартной частью Python, часто можно
встретить крупные расширения сторонних разработчиков, распространяемые
не как плоский список модулей, а как набор каталогов с пакетами.
Например, пакет расширений win32all для Python в операционной системе
Windows был одним из первых, кто перешел на сторону победителя.

 Многие вспомогательные модули этого пакета располагаются в пакетах,
импортируемых посредством указания пути. Например, чтобы загрузить набор
инструментальных средств для работы с технологией COM на стороне
клиента, можно использовать такую инструкцию:

from win32com.client import constants, Dispatch

 Эта инструкция извлекает имена из модуля client в пакете win32com
(подкаталог, куда был установлен пакет).

 Импортирование пакетов повсеместно используется в программном коде,
работающем под управлением Jython, – реализации языка Python на Java,
потому что библиотеки самого языка Java тоже организованы
в виде иерархии каталогов. В последних версиях Python инструменты
для работы с электронной почтой и XML в стандартной библиотеке также
были организованы в подкаталоги пакетов, а в Python 3.0 еще большее
число родственных модулей было перемещено в пакеты (включая инструменты
создания графического интерфейса tkinter, инструменты организации
сетевых взаимодействий по протоколу HTTP и многие другие). Следующие
инструкции обеспечивают доступ к различным инструментам стандартной
библиотеки в Python 3.0:

from email.message import Message
from tkinter.filedialog import askopenfilename
from http.server import CGIHTTPRequestHandler

 Независимо от того, создаете вы каталоги пакетов или нет, в конечном
итоге у вас наверняка будет возможность импортировать их.
"""

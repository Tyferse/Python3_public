"""
 Как пользователь запускает программы


 Интерактивный режим

 Пожалуй, самый простой способ запускать программы на языке Python –
это вводить инструкции непосредственно в командной строке
интерпретатора, которая иногда называется интерактивной оболочкой.
Запустить эту командную строку можно разными способами –
в интегрированной среде разработки, в системной консоли и так далее.
 Предположим, что интерпретатор установлен в вашей системе
как выполняемая программа, тогда самый универсальный способ запустить
интерактивный сеанс работы с интерпретатором заключается в том,
чтобы ввести команду python без аргументов в командной строке
вашей операционной системы. Например:

% python
Python 3.0.1 (r301:69561, Feb 13 2009, 20:04:18)\
 [MSC v.1500 32 bit (Intel)] ...
Type “help”, “copyright”, “credits” or “license” for more information.
\>>>

 Если вы не включили путь к каталогу установки Python в переменную
окружения PATH, вместо простого слова «python» вам может потребоваться
ввести полный путь к выполняемой программе. В операционной системе
Windows можно попробовать ввести команду
C:\Python30\python (для версии 3.0):

C:\misc> c:\python30\python
Python 3.0.1 (r301:69561, Feb 13 2009, 20:04:18)\
 [MSC v.1500 32 bit (Intel)] ...
Type “help”, “copyright”, “credits” or “license” for more information.
\>>>

 Или перед вводом команды «python» можно перейти в каталог,
куда был установлен интерпретатор Python. Для этого
в операционной системе Windows, например, можно выполнить команду
cd c:\python30, например:

C:\misc> cd C:\Python30
C:\Python30> python
Python 3.0.1 (r301:69561, Feb 13 2009, 20:04:18)\
 [MSC v.1500 32 bit (Intel)] ...
Type “help”, “copyright”, “credits” or “license” for more information.
\>>>

 В Windows, кроме ввода команды python в окне командной оболочки,
запустить интерактивный сеанс можно также, открыв главное окно IDLE
 или выбрав пункт Python (command line) (Python (командная строка))
в подменю Python в меню Пуск (Start). В обоих случаях
открывается интерактивный сеанс Python с одинаковыми возможностями,
то есть ввод команды в командной оболочке не является
обязательным условием.


 Выполнение инструкций в интерактивном режиме

 Интерактивный сеанс работы с интерпретатором Python начинается с вывода
двух строк информационного текста (которые я буду опускать в примерах
для экономии места), затем выводится приглашение к вводу >>>,
когда интерпретатор Python переходит в режим ожидания ввода
новой инструкции или выражения. При работе в интерактивном режиме
результаты выполнения ваших инструкций будут выводиться сразу же после
нажатия клавиши Enter вслед за строкой с приглашением >>>.

 Например, ниже приводятся результаты выполнения двух инструкций print
(в действительности инструкция print была инструкцией в Python 2.6, а в
Python 3.0 она стала функцией, поэтому круглые скобки являются
обязательным элементом только в версии 3.0):

% python
\>>> print(‘Hello world!’)
Hello world!
\>>> print(2 ** 8)
256

 Вам пока также не стоит вникать в детали инструкций print,
приведенные здесь, – изучение синтаксиса мы начнем в следующей главе.
В двух словах, эта инструкция вывела текстовую строку и целое число,
как видно в строках, которые были напечатаны ниже строк с приглашением
к вводу >>> (выражение 2 ** 8 на языке Python означает 2 в степени 8).

 При работе в интерактивном режиме, как показано в этом примере,
вы можете вводить любое число команд Python, и каждая из них
будет выполняться сразу же после ввода. Более того, поскольку
в интерактивном сеансе результаты выражений, которые вы вводите,
выводятся автоматически, совершенно необязательно явно использовать
функцию «print»:

\>>> lumberjack = ‘okay’
\>>> lumberjack
‘okay’
\>>> 2 ** 8
256
\>>> # Для выхода используйте клавиши Ctrl-D (в UNIX)
или Ctrl-Z (в Windows)
%

 В этом примере первая строка сохраняет значение в переменной,
а две последние введенные строки являются выражениями
(lumberjack и 2 ** 8), результаты вычисления которых отображаются
автоматически. Чтобы завершить работу интерактивного сеанса,
как показано в данном примере, и вернуться в системную командную строку,
в UNIX-подобной системе нажмите комбинацию клавиш Ctrl-D,
а в системах MS-DOS и Windows – комбинацию Ctrl-Z.
В графическом интерфейсе IDLE, который будет рассматриваться ниже,
нужно либо нажать комбинацию клавиш Ctrl-D, либо просто закрыть окно.

 В приведенных примерах мы сделали немногое – всего лишь ввели несколько
инструкций print, одну инструкцию присваивания и несколько выражений,
о которых подробнее мы поговорим позднее. Главное, на что следует
обратить внимание, – интерпретатор немедленно выполняет введенный
программный код сразу же после нажатия клавиши Enter.

 Например, когда в строке приглашения к вводу >>> была введена первая
инструкция print, результат (строка) был немедленно выведен на экран.
Нам не потребовалось создавать файл с исходным текстом программы
и для выполнения программного кода не понадобилось сначала компилировать
и компоновать его, что является обычным делом при использовании
таких языков программирования, как C или C++. Как будет показано
в последующих главах, при работе с интерактивной оболочкой вы можете
также вводить многострочные инструкции – такие инструкции
будут выполняться только после ввода всех строк.


 Когда может пригодиться интерактивный режим?

 В интерактивном режиме интерпретатор немедленно выполняет введенные
инструкции и выводит результат, но эти инструкции не сохраняются
в файле. Это означает, что в интерактивном режиме вы едва ли будете
выполнять длинные отрывки программного кода, но при этом
интерактивный режим предоставляет отличную возможность
для проведения экспериментов с возможностями языка
и тестирования файлов программ на лету.


 Экспериментирование

 Благодаря тому, что программный код выполняется немедленно,
интерактивный режим превращается в замечательный инструмент
для проведения экспериментов с конструкциями языка. Самое первое,
что вы должны запомнить: если вы чувствуете, что не понимаете,
как работает тот или иной отрывок программного кода на языке Python,
запустите интерактивный сеанс и попробуйте ввести этот фрагмент,
чтобы посмотреть, что произойдет.

 Например, предположим, что вы изучаете некоторый фрагмент программы на
языке Python и наталкиваетесь на выражение ‘Spam!’ * 8,
которое вам кажется непонятным. Можно, конечно, потратить
с десяток минут, пробираясь через руководства и учебники,
в попытках выяснить, что же делает этот код, но можно просто выполнить
его в интерактивной оболочке:

\>>> ‘Spam!’ * 8                <== Изучение методом проб и ошибок
‘Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!’

 Немедленная обратная связь, которую предоставляет интерактивная
оболочка, часто позволяет быстрее всего выяснить, что делает тот
или иной фрагмент программного кода. Эксперимент наглядно показывает,
что произошло дублирование строки: в языке Python оператор *
выполняет операцию умножения над числами, но если левый операнд
является строкой, он действует как оператор многократной
конкатенации строки с самой собой.

 При проведении подобных экспериментов вы едва ли что-нибудь испортите,
по крайней мере, пока. Чтобы причинить серьезный ущерб, например удалить
файл или выполнить команду системной командной оболочки, необходимо
явно импортировать модули (чтобы стать опасным для системы, вы должны
хорошо знать системные интерфейсы языка Python!). Простой программный
код на языке Python практически всегда может быть выполнен без опаски.

 В языке Python считается ошибкой пытаться использовать переменную
прежде чем ей будет присвоено значение (в противном случае,
если бы переменные заполнялись некоторым значением по умолчанию,
некоторые ошибки было бы очень сложно обнаруживать).
С этой особенностью мы познакомимся позднее, а пока обратите внимание,
что допущенная ошибка не вызвала ни аварийного завершения
оболочки Python, ни краха системы. Вместо этого было выведено
информативное сообщение об ошибке с указанием номера строки,
где она была допущена, и вы получили возможность продолжить
сеанс работы с интерпретатором. В действительности, как только вы
более или менее освоитесь с языком Python, сообщения об ошибках
во многих случаях станут оказывать вам вполне достаточную помощь
при отладке.


 Тестирование

 Помимо функции инструмента, предоставляющего возможность
поэкспериментировать в процессе изучения языка, интерактивная оболочка
также является идеальным средством тестирования программного кода,
сохраненного в файлах. В интерактивном режиме вы можете импортировать
файлы модулей и тестировать функциональные возможности,
которые они предоставляют, вводя вызовы функций в строке
с приглашением к вводу.

 Например, ниже приводится пример тестирования функции, находящей
в одном из модулей, входящих в стандартную библиотеку Python
(она возвращает имя текущего рабочего каталога). Вы сможете проделывать
то же самое со своими собственными функциями, как только начнете
создавать свои модули:

\>>> import os
\>>> os.getcwd() <== Тестирование “на лету”
‘c:\\Python30’

 В более широком понимании интерактивная оболочка – это инструмент для
тестирования программных компонентов независимо от их происхождения –
вы можете вводить вызовы функций из связанных библиотек на языке C,
создавать экземпляры классов Java в интерпретаторе Jython
и делать многое другое. Интерпретатор поддерживает возможность
проведения экспериментов и исследований при программировании,
и вы найдете это удобным, начав работать с ним.


 Использование интерактивного режима

 Несмотря на то, что интерактивный режим прост в использовании,
я хочу дать несколько советов начинающим, которые следует запомнить.
Я привожу списки наиболее распространенных ошибок,
подобные приведенному в этой главе, для справки,
потому что знакомство с ними позволит вам избежать лишней головной боли:

  Вводите только инструкции на языке Python.

  Инструкция print необходима только в файлах.

  Не используйте отступы в интерактивном режиме (пока).

  Будьте внимательны, когда строка приглашения к вводу изменяется на
 строку ввода составной инструкции.

  При работе в интерактивном режиме завершайте ввод составных
 инструкций вводом пустой строки. Если при работе в интерактивном режиме
 не завершить ввод составной инструкции двумя нажатиями клавиши Enter,
 у вас может сложиться впечатление, что все повисло,
 потому что интерпретатор не будет


 Ввод многострочных инструкций

 Во-первых, при работе в интерактивном режиме завершайте ввод составных
инструкций, таких как циклы for и условные операторы if, вводом пустой
строки. Вы должны нажать клавишу Enter дважды, чтобы завершить
многострочную инструкцию и выполнить ее. Например:

\>>> for x in ‘spam’:
... print(x) <== Здесь нажать Enter дважды, чтобы выполнить этот цикл
...

 В файлах сценариев не требуется добавлять пустую строку после составных
инструкций – это необходимо только при работе в интерактивном режиме.
В файле пустые строки не являются обязательными, и они просто
игнорируются, а в интерактивном режиме они завершают многострочные
инструкции. Обратите также внимание на то, что интерактивная оболочка
выполняет по одной инструкции за один раз: прежде чем вводить
следующую инструкцию, вы должны дважды нажать клавишу Enter,
чтобы выполнить цикл или другую многострочную инструкцию:

\>>> for x in ‘spam’:
... print(x) <== Здесь нажать Enter дважды,
                 прежде чем вводить новую инструкцию
... print(‘done’)
File “<stdin>”, line 3
print(‘done’)
^
SyntaxError: invalid syntax

 Это означает, что вы не можете копировать и вставлять сразу несколько
строк программного кода в интерактивном режиме, если копируемый
фрагмент не содержит пустые строки после каждой составной инструкции.
Такой код лучше выполнять в виде файла, о чем рассказывается
в следующем разделе.


 Системная командная строка и файлы

 Хотя интерактивная командная оболочка является прекрасным инструментом
для проведения экспериментов, тем не менее, у нее есть один
существенный недостаток: программы, которые вы вводите
во время интерактивного сеанса, исчезают сразу же после того,
как интерпретатор Python выполнит их. Программный код,
который вводится в интерактивном режиме, нигде не сохраняется,
поэтому вы не сможете запустить его еще раз, не введя код
с самого начала.

 Чтобы хранить программы длительное время, необходимо сохранять
программный код в файлах, которые обычно называются модулями. Модули –
это простые текстовые файлы, содержащие инструкции на языке Python.
Как только такой файл будет создан, вы можете предложить интерпретатору
Python выполнить инструкции в нем столько раз, сколько пожелаете.
Такой файл можно запустить на выполнение разными способами –
из командной строки системы, щелчком на ярлыке файла,
из пользовательского интерфейса IDLE и другими способами.
Независимо от выбранного вами способа интерпретатор Python
будет выполнять весь программный код в модуле от начала до конца
всякий раз, когда вы будете его запускать.

 Терминология в этой области может несколько изменяться. Например,
файлы модулей часто называются программами на языке Python,
где под программой понимается последовательность заранее написанных
инструкций, сохраненных в файле для обеспечения возможности
многократного использования. Файлы модулей, которые запускаются
на выполнение непосредственно, иногда называют сценариями –
этим неофициальным термином обозначаются файлы программ верхнего уровня.
Термин «модуль» зарезервирован для обозначения файлов,
которые могут импортироваться другими файлами.


 Первый сценарий
"""

# Первый сценарий на языке Python
import sys          # Загружает библиотечный модуль


print(sys.platform)
print(2 ** 100)     # Возводит число 2 в степень 100
x = 'Spam!'
print(x * 8)        # Дублирует строку

"""
 Имя sys.platform – это просто строковая переменная, 
содержимое которой идентифицирует тип компьютера, на котором 
выполняется сценарий. Эта переменная находится в стандартном модуле 
с именем sys, который необходимо загрузить с помощью инструкции 
import.

 Для разнообразия я также добавил комментарии – текст, следующий за 
символом #. Комментарии могут занимать отдельную строку или добавляться
в строку с программным кодом, правее его. Текст, следующий 
за символом #, интерпретатором просто игнорируется, как комментарий,
добавленный для человека, и не считается частью инструкции. 
Если вы копируете этот пример, чтобы опробовать его, можете смело 
игнорировать комментарии. 

 Повторюсь еще раз, не старайтесь пока вникнуть в синтаксис программного
кода в этом файле – с ним мы познакомимся позднее. Главное здесь то, 
что программный код вводится в текстовый файл, 
а не в интерактивной командной оболочке интерпретатора Python. 
Итак, вы создали полноценный сценарий на языке Python.

 Обратите внимание, что файл модуля называется script1.py. Так как он 
является файлом верхнего уровня, его точно так же можно было бы назвать
просто script, но имена файлов с программным кодом, которые 
предполагается импортировать из других файлов, должны оканчиваться 
расширением .py. Позднее вам может потребоваться импортировать 
тот или иной файл, поэтому всегда желательно использовать 
расширение .py в именах файлов с программным кодом на языке Python. 
Кроме того, некоторые текстовые редакторы определяют принадлежность 
файлов по расширению .py – если расширение отсутствует,
вы можете лишиться таких функциональных возможностей редактора, 
как подсветка синтаксиса и автоматическое оформление отступов.


 Запуск файлов из командной строки
 
 Сохранив этот текстовый файл, вы сможете предложить интерпретатору
Python выполнить его, указав полное имя файла в качестве первого 
аргумента команды python, введя следующую строку в системной 
командной строке:

% python script1.py
win32
1267650600228229401496703205376
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!

 И в этом случае также вы должны использовать командную оболочку,
которая предоставляется вашей операционной системой – в окне 
Командная строка (Command Prompt) в Windows, в xterm
или в подобных им программах. Не забывайте заменять слово «python» 
на полный путь к исполняемому файлу интерпретатора, если переменная 
окружения PATH у вас не настроена.

 Если все было сделано правильно, эта команда запустит интерпретатор 
Python, который в свою очередь последовательно, строку за строкой, 
выполнит инструкции в файле, и вы увидите на экране результаты 
выполнения трех инструкций print – название платформы,
результат возведения числа 2 в степень 100 и результат многократного 
дублирования строки, который мы уже видели выше.

 Если что-то пошло не так, на экране появится сообщение об ошибке – 
проверьте еще раз, не было ли допущено ошибок при вводе 
программного кода в файл и повторите попытку.

 Поскольку в данной ситуации для запуска программ на языке Python 
используется командная оболочка, можно применять любые синтаксические 
конструкции, допускаемые командной оболочкой. Например, 
можно перенаправить вывод сценария Python в файл, чтобы детально 
исследовать полученные результаты позднее, как показано ниже:

% python script1.py > saveit.txt

 В этом случае три строки, которые были показаны в предыдущем примере 
запуска сценария, не будут выводиться на экран, а будут записаны 
в файл saveit.txt. Это широко известная возможность 
перенаправления потоков – она может использоваться как для вывода 
текста, так и для ввода. Она присутствует в Windows и в UNIX-подобных 
системах. Она мало связана с Python (интерпретатор Python 
просто поддерживает ее), поэтому здесь мы не будем углубляться 
в подробности работы механизма перенаправления.  Если вы пользуетесь 
операционной системой Windows, этот пример будет работать точно так же,
хотя сама командная строка будет выглядеть несколько иначе:

C:\Python30> python script1.py
win32
1267650600228229401496703205376
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!

 Если у вас переменная окружения PATH не настроена и не был выполнен
переход в каталог интерпретатора, вам необходимо вводить полный путь 
к исполняемому файлу интерпретатора Python:

D:\\temp> C:\python30\python script1.py
win32
1267650600228229401496703205376
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!

 В новейших версиях Windows вы можете просто вводить имя файла сценария
независимо от того, в каком каталоге вы находитесь, потому что новейшие
версии системы Windows отыскивают программы, необходимые для запуска
файлов, с помощью реестра Windows, и вам не требуется явно указывать ее
в командной строке. Например, в современных версиях Windows предыдущую
команду можно упростить до:

D:\\temp> script1.py

 Наконец, не нужно забывать указывать полный путь к файлу сценария, 
если он находится в каталоге, отличном от того, в котором вы работаете.
Например, следующая команда будет работать в каталоге D:\other 
в предположении, что путь к команде python включен 
в переменную окружения PATH, при этом она должна запустить сценарий,
расположенный в некотором другом каталоге: 

D:\other> python c:\code\otherscript.py 

 Если переменная окружения PATH не включает путь к каталогу 
с исполняемым файлом интерпретатора Python и при этом файл сценария 
не находится в текущем рабочем каталоге, тогда необходимо будет 
указать полный путь как к исполняемому файлу интерпретатора, 
так и к файлу сценария:

D:\other> C:\Python30\python c:\code\otherscript.py


 Использование системной командной строки и файлов
 
 Запуск файлов программ из командной строки системы является достаточно
простой задачей, особенно если у вас уже есть опыт работы с командной 
строкой. Тем не менее ниже описываются несколько ловушек, 
в которые часто попадают начинающие:

 Остерегайтесь автоматического присвоения расширения файлам 
в операционной системе Windows. Если для создания файлов программ 
в Windows вы пользуетесь редактором «Блокнот» («Notepad»),
перед сохранением выбирайте тип файла Все файлы (All Files) 
и явно указывайте расширение .py. В противном случае «Блокнот» 
(«Notepad») будет присваивать файлам расширение .txt 
(например, script1.py.txt), что в некоторых ситуациях осложнит 
запуск таких файлов.

 Хуже того, по умолчанию операционная система Windows скрывает 
расширения файлов, поэтому, если вы забыли указать тип файла, 
вы можете даже не заметить, что создали обычный текстовый файл, 
а не файл, который должен запускаться интерпретатором Python. 

 Текстовый процессор Microsoft Word похожим образом по умолчанию 
добавляет расширение .doc. Мало этого, он добавляет в файл символы 
форматирования, которые являются недопустимыми с точки зрения 
синтаксиса Python. Поэтому возьмите за правило всегда выбирать тип файла 
Все файлы (All Files) при сохранении в операционной системе Windows 
или используйте более удобные для программистов текстовые редакторы, 
такие как IDLE. IDLE не добавляет расширение к имени файла
автоматически, даже расширение .py – эта особенность нравится 
программистам, но не пользователям.

 Указывайте расширение имени файла и полный путь в командной строке,
но не в инструкциях импорта.

 Используйте в файлах инструкции print.
 
 
 Импортирование и перезагрузка модулей
 
 Мы уже говорили об «импортировании модулей», но до сих пор я не давал 
никаких пояснений, что означает этот термин.

 Проще говоря, каждый файл с исходным текстом на языке Python, 
имя которого оканчивается расширением .py, является модулем. 
Другие файлы могут обращаться к программным компонентам, 
объявляемым модулем, импортируя этот модуль. По сути инструкция import
выполняет загрузку другого файла и обеспечивает доступ к его
содержимому. Содержимое модуля становится доступным внешнему миру 
через его атрибуты.

 Такая модульная модель является центральной идеей, лежащей в основе 
архитектуры программ на языке Python. Крупные программы обычно 
организованы в виде множества файлов модулей, которые импортируют 
и используют функциональные возможности из других модулей. Один из 
модулей определяется как основной файл верхнего уровня, 
который запускает всю программу. Проблемы модульной архитектуры
мы будем рассматривать подробнее позже, в этой же книге, а в этой главе 
основное внимание уделяется тому факту, что операция импорта 
на заключительном этапе приводит к выполнению программного кода 
загружаемого файла. Как следствие, импорт файла является еще одним 
способом запустить его.

 Например, если запустить интерактивный сеанс работы с интерпретатором
(в IDLE, из командной строки или как-то иначе), можно будет запустить 
файл script1.py, созданный ранее, с помощью простой инструкции 
import (не забудьте перед этим удалить инструкцию input, 
добавленную в предыдущем разделе, иначе вам придется нажимать 
клавишу Enter без всякой необходимости):

C:\misc> c:\python30\python
>>> import script1
win32
1267650600228229401496703205376
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!

 Такой способ пригоден только для однократного запуска модуля 
в течение сеанса. После первой операции импорта все последующие попытки
импортировать модуль не приводят ни к каким результатам, даже если
изменить и сохранить исходный текст модуля в другом окне:

>>> import script1
>>> import script1

 Так сделано преднамеренно – операция импорта требует слишком больших
затрат вычислительных ресурсов, чтобы выполнять ее более одного раза 
в ходе выполнения программы. Как вы узнаете в главе 21, в ходе импорта 
производится поиск файлов, компиляция их в байт-код и выполнение этого 
байт-кода. Если действительно возникает необходимость вынудить 
интерпретатор многократно запускать файл в рамках одного и того же 
сеанса (без остановки и перезапуска сеанса), можно воспользоваться 
встроенной функцией reload, доступной в модуле imp из стандартной 
библиотеки (в Python 2.6 эта функция была обычной встроенной функцией,
но в Python 3.0 она была перенесена в модуль imp):

>>> from imp import reload # В версии 3.0 требуется загрузить функцию
>>> reload(script1)
win32
65536
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!
<module ‘script1’ from ‘script1.py’>
>>>

 Инструкция from в этом примере просто копирует имя функции из модуля.
Функция reload загружает и запускает текущую версию программного кода
в файле, если он был изменен в другом окне.

 Функция reload ожидает получить имя уже загруженного модуля, поэтому,
прежде чем перезагрузка станет возможной, модуль должен быть 
импортирован. Примечательно также, что имя модуля при вызове функции 
reload должно быть заключено в круглые скобки, тогда как инструкция
import не требует этого. Дело в том, что reload – это функция, 
которая вызывается, а import – это инструкция.

 Именно поэтому имя модуля следует передавать функции reload 
как аргумент, в круглых скобках и именно поэтому после перезагрузки 
модуля выводится дополнительная строка. Последняя строка в выводе выше –
это всего лишь представление результата, возвращаемого функцией reload 
после перезагрузки модуля. 

 
 Важные сведения о модулях: атрибуты
 
 Операции импортирования и перезагрузки модулей обеспечивают 
естественный способ запуска программы, так как на заключительном этапе 
этих операций производится исполнение файлов. При этом в более широком 
понимании модули играют роль библиотек инструментов. Модуль – это, 
главным образом, всего лишь пакет имен переменных, известный как
пространство имен. Имена внутри этого пакета называются атрибутами,
то есть атрибут – это имя переменной, которая связана с определенным 
объектом (таким как модуль). 

 В самом типичном случае импортирующий программный код получает доступ 
ко всем именам верхнего уровня, определяемым в файле модуля. 
Эти имена обычно связаны с функциональными возможностями, 
экспортируемыми модулем – функциями, классами, переменными и так далее,
которые предназначены для использования в других файлах и программах. 
Снаружи доступ к именам в файле модуля можно получить с помощью 
двух инструкций языка Python, import и from, 
а также с помощью вызова функции reload.

 Для иллюстрации вышесказанного создайте с помощью текстового редактора
однострочный файл модуля Python с именем myfile.py со следующим 
содержимым:

title = “The Meaning of Life”

 Это, пожалуй, один из самых простых модулей Python (он содержит 
единственную операцию присваивания), но его вполне достаточно 
для иллюстрации основных положений. При импортировании этого модуля 
выполняется его программный код, который создает атрибут модуля. 
Инструкция присваивания создает атрибут с именем title.

 Доступ к атрибуту title можно получить из других программных
компонентов двумя разными способами. Первый заключается в том, 
чтобы загрузить модуль целиком с помощью инструкции import, 
а затем обратиться к атрибуту по его имени, уточнив его именем модуля:

% python           # Запуск интерпретатора Python
>>> import myfile  # Запуск файла; модуль загружается целиком
>>> print(myfile.title)  # Имя атрибута, уточненное именем 
The Meaning of Life      # модуля через ‘.’


 Вообще синтаксис точечной нотации в виде object.attribute позволяет 
получить доступ к любому атрибуту в любом объекте, и этот прием широко 
используется в программном коде на языке Python. Здесь мы использовали
его для обращения к строковой переменной title, определенной внутри 
модуля myfile – то есть myfile.title.

 Кроме того, доступ к именам внутри модулей (Фактически создать 
копии имен) можно получать с помощью инструкции from:

% python # Запуск интерпретатора Python
>>> from myfile import title
# Запуск файла; выполняется копирование имен
>>> print(title)
# Имя атрибута используется напрямую, уточнение не требуется
The Meaning of Life

 С технической точки зрения, инструкция from копирует атрибуты модуля
так, что они становятся простыми переменными в программном коде, 
выполняющем импорт, благодаря чему на этот раз он может обратиться
к импортированной строке уже не по имени myfile.title 
(ссылка на атрибут), а просто – title (переменная).

 Неважно, как выполняется импортирование модуля, с помощью инструкции
import или from, в любом случае это приводит к выполнению инструкций 
в файле myfile.py, а импортирующий компонент (в данном случае –
интерактивная оболочка интерпретатора) получает доступ к именам, 
определенным в файле на верхнем уровне. В этом простом примере 
существует только одно такое имя – переменная title, которой присвоена
строка, но сама концепция приобретает более важное значение, 
когда речь заходит об определении в модулях таких объектов, как функции
и классы. Такие объекты становятся программными компонентами 
многократного использования, доступ к которым можно получить из одного
или более клиентских модулей.

 На практике модули обычно определяют более чем одно имя, которые могут
использоваться и внутри, и за пределами модуля. Ниже приводится пример
модуля, в котором определяются три имени:

a = ‘dead’     # Определяются три атрибута,
b = ‘parrot’   # экспортируемые другим модулям
c = ‘sketch’
print a, b, c  # Кроме того, они используются и самим этим модулем

 файле threenames.py создаются три переменные, которые становятся тремя
атрибутами, доступными внешнему миру. Этот модуль сам также использует
эти переменные в инструкции print, в чем можно убедиться, если запустить
этот модуль как файл верхнего уровня:

% python threenames.py
dead parrot sketch

 Как обычно, программный код этого модуля выполняется всего один раз, 
при импортировании (с помощью инструкции import или from). Клиенты,
использующие инструкцию import, получают модуль со всеми его атрибутами,
а клиенты, использующие инструкцию from, получают копии имен 
из этого модуля:

% python
>>> import threenames # Загрузить модуль целиком
dead parrot sketch
>>>
>>> threenames.b, threenames.c
(‘parrot’, ‘sketch’)
>>>
>>> from threenames import a, b, c # Скопировать несколько имен
>>> b, c
(‘parrot’, ‘sketch’)

 Результаты здесь выводятся в круглых скобках, потому что 
в действительности они являются кортежами. 

 Как только вы начнете создавать модули, содержащие несколько имен, 
как в данном случае, вам наверняка пригодится встроенная функция dir.
Она может использоваться для получения списка имен, доступных внутри 
модуля. Следующая инструкция возвращает список строк
:
>>> dir(threenames)
[‘__builtins__’, ‘__doc__’, ‘__file__’, ‘__name__’, ‘a’, ‘b’, ‘c’]

 Такой результат получается при вызове функции в Python 3.0 и 2.6; 
в более ранних версиях количество возвращаемых имен может быть меньше. 
При вызове функции dir передается имя импортированного модуля 
в круглых скобках, как показано выше, а возвращает она список всех 
атрибутов, определенных внутри модуля. Некоторые возвращаемые имена,
которые начинаются и завершаются двумя символами подчеркивания, 
присутствуют всегда; эти встроенные имена определяются самим 
интерпретатором Python и имеют для него особый смысл. Имена переменных, 
которые определяются нашими инструкциями присваивания, – a, b и c – 
выводятся в конце списка, получаемого от функции dir.


 Модули и пространства имен
 
 Импортирование модулей – это один из способов запуска программного кода
в файлах, но, помимо этого, и это будет рассмотрено в книге позже, 
модули являются также самой крупной структурной единицей в программах 
на языке Python.

 Вообще программы на языке Python состоят из множества файлов модулей,
связанных между собой инструкциями import. Каждый файл модуля – 
это самостоятельный пакет переменных, или пространство имен. Один модуль
не сможет увидеть переменные, определенные в другом модуле, если явно 
не импортирует его. Модули позволяют уменьшить вероятность конфликтов
имен в программном коде – так как каждый файл является самостоятельным
пространством имен, имена в одном файле не вступают в конфликт с именами
в другом файле, даже если они одинаковые.

 Как можно понять, модули – одно из ухищрений, которые используются 
в языке Python для упаковки переменных в категории, чтобы избежать
конфликтов имен. Далее мы еще будем обсуждать модули и другие
конструкции образования пространств имен (включая классы и функции).
А пока будем использовать модули в качестве средства многократного 
использования программного кода, позволяющего не вводить его повторно
с клавиатуры.

 import или from: необходимо отметить, что инструкция from в некотором
смысле стирает границы пространств имен между модулями, потому что 
она копирует переменные из одного файла в другой. Это может вызывать 
затирание переменных в импортирующем файле одноименными переменными
в импортируемом файле (при этом никаких предупреждений выводиться 
не будет). По сути, эта инструкция выполняет разрушительное
объединение пространств имен, по крайней мере, в терминах копируемых 
переменных.

 По этой причине многие рекомендуют использовать инструкцию import 
вместо from. Я не буду вдаваться в глубокомысленные рассуждения, 
однако отмечу, что инструкция from не только короче,
но и подразумеваемая проблема редко возникает на практике. 
Обратите внимание, что инструкция from позволяет явно указывать перечень
импортируемых имен, и пока вы помните, что им будут присвоены значения, 
эта операция не более опасна, чем обычная инструкция присваивания, – 
еще одна возможность, которая наверняка будет использоваться вами!


 import и reload, примечания к использованию
 
 Зачастую, узнав о возможности запуска файлов с помощью import и reload,
начинающие разработчики концентрируют все свое внимание на этом способе
и забывают о других возможностях запуска, позволяющих запускать всегда
самую свежую версию программного кода (например, щелчок мышью на ярлыке,
пункты меню в IDLE и системная командная строка). К тому же, 
такой подход может быстро привести к появлению ошибок – вам придется 
помнить, импортировали ли вы тот или иной модуль, чтобы 
иметь возможность перезагрузить его; вам нужно будет помнить 
о необходимости использовать круглые скобки при вызове функции reload 
(только для нее) и не забывать использовать ее, чтобы запустить 
самую последнюю версию модуля. Более того, операция перезагрузки 
не является транзитивной – перезагружается только модуль, указанный 
в вызове функции reload, но не перезагружаются модули, 
которые он импортирует, поэтому может возникнуть потребность 
перезагрузить несколько файлов.

 Из-за этих сложностей (и некоторых других, с которыми мы еще столкнемся
позднее) пока лучше избегать пользоваться операциями импорта 
и перезагрузки. Пункт меню Run (Запустить) → Run Module 
(Запустить модуль) в IDLE (описывается в следующем разделе), например,
предоставляет более простой способ запуска файлов, менее подверженный 
ошибкам. Системная командная строка предлагает похожие удобства. 
Вам не придется выполнять перезагрузку при использовании этих приемов.

 Следует добавить, что в случае использования необычных способов 
применения модулей, отличных от тех, которые к этому моменту описаны 
в книге, вы можете столкнуться с некоторыми неприятностями. Например, 
если вам необходимо импортировать файл модуля, который хранится 
в каталоге, отличном от того, в котором вы работаете, вам придется 
перейти к главе 21, где вы узнаете о пути поиска модулей.

 
 Запуск модулей с помощью функции exec
 
 В действительности существует еще несколько способов выполнить 
программный код, хранящийся в файлах модулей. Например, вызов встроенной
функции exec(open(‘module.py’).read()) – это еще один способ выполнять 
файлы из интерактивной оболочки, фактически не импортируя модуль. 
Каждый последующий вызов exec будет выполнять текущую версию файла 
и ликвидирует необходимость позднее выполнять перезагрузку модуля 
(возьмем опять сценарий script1.py в том виде, в каком мы оставили его 
после перезагрузки в предыдущем разделе):

C:\misc> c:\python30\python
>>> exec(open(‘script1.py’).read())
win32
65536
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!

...изменим script1.py в текстовом редакторе...

>>> exec(open(‘script1.py’).read())
win32
4294967296
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!

 Вызов функции exec производит эффект, похожий на вызов инструкции 
import, но при этом он не импортирует модуль – по умолчанию всякий раз, 
когда вызывается функция call, она выполняет файл заново, как если бы 
он был вставлен в месте вызова функции exec. По этой причине 
при использовании функции exec не требуется перезагружать модуль 
после внесения в него изменений – она не следует обычной логике 
импортирования. Однако, так как вызов exec по своему действию 
напоминает простую вставку программного кода модуля на его место,
подобно инструкции from, упоминавшейся выше, он может без предупреждения 
затереть существующие переменные. Например, в нашем сценарии script1.py 
выполняется присваивание значения переменной x. Если это имя 
уже используется к моменту вызова функции exec, значение переменной 
с этим именем будет затерто:

>>> x = 999
>>> exec(open(‘script1.py’).read())  # Код выполняется в этом же
# пространстве имен

...тот же самый вывод...

>>> x  # Присваивание в модуле затерло прежнее значение
‘Spam!’ 

 Инструкция import, напротив, выполняет файл только один раз 
за все время выполнения программы и создает отдельное пространство
имен модуля, поэтому подобные операции присваивания не приводят 
к затиранию значений переменных в импортирующем программном коде. 
Однако за удобства, которые несут пространства имен, приходится платить 
необходимостью перезагружать модули после их изменения.
"""

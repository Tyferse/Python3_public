"""
 Подробности реализации II


 Использование псевдочастных имен вида __X

 Помимо обобщения в этой версии также используется механизм искажения
псевдочастных имен вида __X (который мы обсуждали в главе 30), чтобы
обеспечить локальность атрибута __wrapped в управляющем классе за счет
добавления имени класса в начало имени атрибута. Это позволяет избежать
конфликта с возможным именем wrapped в обернутом классе, и вообще этот
прием полезно использовать в подобных универсальных инструментах.
Тем не менее псевдочастные атрибуты не являются по-настоящему
«частными», потому что искаженное имя доступно за пределами класса.
Обратите также внимание, что в методе __setattr__ используется строка
с полностью развернутым именем (‘_onInstance__wrapped’), потому что
именно такое имя создается интерпретатором.


 Нарушение ограничений

 Несмотря на то, что этот пример действительно ограничивает доступ
к атрибутам экземпляров и их классов, тем не менее, существует
возможность обойти эти ограничения несколькими способами. Например,
с использованием искаженной версии имени атрибута __wrapped
(попытка обратиться к атрибуту bob.pay может оказаться неудачной,
но обращение к атрибуту bob._onInstance__wrapped.pay
увенчается успехом!). Однако если для обхода ограничений требуется
явно использовать подобные имена, вероятно, этих ограничений вполне
достаточно для большинства применений. Конечно, ограничения на доступ
к частным атрибутам можно преодолеть в любом языке, если действовать
достаточно грубо (в некоторых реализациях языка C++ может помочь
объявление #define private public). Механизмы управления доступом
могут помочь снизить вероятность случайных ошибок, которые совершаются
программистами на любом языке, но всегда, когда имеется возможность
изменить исходные тексты, управление доступом оказывается недостижимой
мечтой.


 Преимущества декораторов

 Те же результаты мы могли бы получить без применения декораторов,
используя управляющие функции или реализуя повторное присваивание
именам вручную. Однако синтаксис декораторов делает программный код
более последовательным и немного более очевидным. Главный недостаток
декораторов, как и любого другого подхода, основанного на обертывании
исходных объектов, заключается в дополнительных вызовах, которые
производятся при обращении к атрибутам, а также в том, что экземпляры
декорированных классов в действительности не являются экземплярами
оригинальных, декорируемых классов. Если, к примеру, проверить тип
с помощью X.__class__ или isinstance(X, C), можно убедиться, что они
являются экземплярами обертывающего класса. Однако если вы не планируете
выполнять проверку типов объектов, то проблема изменения типа, вероятно,
не будет иметь никакого значения.


 Нерешенные проблемы


 Внимание: вызовы методов перегрузки операторов в 3.0 выполняются иначе

 Как и все другие классы, использующие прием делегирования на основе
метода __getattr__, этот декоратор будет работать в любой версии Python
только в случае применения к атрибутам с обычными именами – обработка
методов перегрузки операторов, таких как __str__ и __add__, в классах
нового стиля выполняется иначе. Поэтому в версии 3.0 попытки перехватить
таким способом обращения к этим методам во встроенном объекте будут
терпеть неудачу. Как мы узнали в предыдущей главе, поиск методов
перегрузки операторов в классических классах начинается с экземпляра,
но в классах нового стиля это не так – интерпретатор вообще пропускает
этап поиска в экземплярах и производит поиск таких методов, начиная
с классов. Поэтому при неявном обращении к методам перегрузки операторов
с именами вида __X__, в процессе выполнения встроенных операций
интерпретатор не вызывает ни метод __getattr__, ни метод
__getattribute__ при работе с классами нового стиля в версии 2.6
и со всеми классами в версии 3.0. Обращение к таким атрибутам
про-исходит без вызова метода onInstance.__getattr__, вследствие чего
декоратор не имеет возможности ни управлять доступом к ним,
ни делегировать их вызовы.

 Класс нашего декоратора определен не как класс нового стиля
(он не наследует явно супер-класс object), поэтому в версии 2.6
он будет перехватывать обращения к методам перегрузки операторов.
Но, поскольку в версии 3.0 все классы автоматически считаются классами
нового стиля, обращения к таким методам встроенного объекта
перехватываться не будут. Чтобы обойти эту проблему в версии 3.0,
проще всего будет переопределить в классе onInstance все методы
перегрузки операторов, которые могут иметься в обертываемых объектах.
Такие дополнительные методы можно добавить вручную, с помощью
инструментов, частично автоматизирующих эту задачу (например,
с помощью декораторов классов или метаклассов, которые обсуждаются
в следующей главе), или за счет определения этих методов
в супер-классах.

 Если то же самое выполнить под управлением Python 3.0, неявные вызовы
методов __str__ и __add__ будут выполняться, минуя метод __getattr__
декоратора, при этом поиск определений методов будет производиться
в классе самого декоратора и выше в дереве наследования. Функция print
выведет информацию по умолчанию, вызвав метод отображения,
унаследованный от типа класса (технически, от подразумеваемого
в версии 3.0 супер-класса object), а операция + сгенерирует ошибку,
потому что отсутствует наследуемый метод __add__ по умолчанию:
"""

traceMe = True


def trace(*args):
    if traceMe:
        print('[' + ' '.join(map(str, args)) + ']')


def accessControl(failif):
    def onDecorator(aClass):
        class onInstance:
            def __init__(self, *args, **kargs):
                self.__wrapped = aClass(*args, **kargs)

            def __getattr__(self, attr):
                trace('get:', attr)
                if failif(attr):
                    raise TypeError('private attribute fetch: ' + attr)
                else:
                    return getattr(self.__wrapped, attr)

            def __setattr__(self, attr, value):
                trace('set:', attr, value)
                if attr == '_onInstance__wrapped':
                    self.__dict__[attr] = value
                elif failif(attr):
                    raise TypeError('private attribute change: ' + attr)
                else:
                    setattr(self.__wrapped, attr, value)
                    
        return onInstance
    
    return onDecorator


def Private(*attributes):
    return accessControl(failif=(lambda attr: attr in attributes))


def Public(*attributes):
    return accessControl(failif=(lambda attr: attr not in attributes))


@Private('age')
class Person:
    def __init__(self):
        self.age = 42

    def __str__(self):
        return 'Person: ' + str(self.age)

    def __add__(self, yrs):
        self.age += yrs


X = Person()
# print(X.age)  # Проверка обычного имени по-прежнему действует
print(X)  # Но в 3.0 делегирование встроенных операций не выполняется!
# print(X + 10) TypeError:
# unsupported operand type(s) for +: ‘onInstance’ and ‘int’
print(X)

"""
 Использование альтернативного метода __getattribute__ не дает 
положительных результатов – несмотря на то, что он должен перехватывать
обращения к любым атрибутам (не только к именам, которые не определены),
он также не вызывается встроенными операциями. Здесь не поможет 
и использование свойств, с которыми мы встречались в главе 37, – 
напомню, что свойства автоматически выполняют программный код, 
ассоциированный с определенными атрибутами, объявленными в классе,
и не предназначены для обработки произвольных атрибутов 
в обернутых объектах.

 Как уже упоминалось ранее, самое простое решение этой проблемы 
в Python 3.0 заключается в том, чтобы в классах, реализующих шаблон 
делегирования, как наш декоратор, переопределить методы перегрузки 
операторов, которые могут присутствовать во встраиваемых объектах. 
Это далеко не идеальное решение, так как при этом создается избыточный 
программный код, особенно если сравнить с решением в версии 2.6. 
Однако реализация такого решения не требует большого количества усилий 
и до некоторой степени может быть автоматизирована с помощью 
дополнительных инструментов или супер-классов. Такого решения вполне
достаточно, чтобы обеспечить корректную работу нашего декоратора 
под управлением Python 3.0 и возможность объявления методов перегрузки 
операторов частными или общедоступными (предполагается, что каждый метод
перегрузки операторов будет выполнять проверку failif):
"""


def accessControl(failif):
    def onDecorator(aClass):
        class onInstance:
            def __init__(self, *args, **kargs):
                self.__wrapped = aClass(*args, **kargs)
            # Перехват и делегирование методов перегрузки операторов

            def __str__(self):
                return str(self.__wrapped)

            def __add__(self, other):
                return self.__wrapped + other

            def __getitem__(self, index):
                return self.__wrapped[index]  # Если необходимо

            def __call__(self, *args, **kargs):
                return self.__wrapped(*args, *kargs)
            # Если необходимо
            # ...плюс любые другие необходимые методы...

            # Перехват и делегирование обращений к обычным атрибутам
            def __getattr__(self, attr):
                return getattr(self.__wrapped, attr)

            def __setattr__(self, attr, value):
                setattr(self.__wrapped, attr, value)

        return onInstance
    
    return onDecorator


"""
 После добавления методов перегрузки операторов предыдущий пример 
с методами __str__ и __add__ будет работать одинаково в обеих версиях 
Python, 2.6 и 3.0. Однако чтобы полностью адаптировать декоратор 
для работы в версии 3.0, может потребоваться добавить существенный объем
избыточного программного кода. В принципе, в таких универсальных 
инструментах, как этот декоратор, в версии 3.0 необходимо переопределить 
каждый метод перегрузки операторов, доступ к которому не может 
управляться автоматически (именно по этой причине данное расширение
было опущено в нашем программном коде). Поскольку в Python 3.0 
все классы автоматически считаются классами нового стиля, реализация 
шаблона делегирования в этой версии оказывается более сложной 
(хотя и не невозможной).

 С другой стороны, классы-обертки, использующие прием делегирования, 
могут просто наследовать общий супер-класс, который переопределяет
методы перегрузки операторов, реализующие стандартный способ
делегирования. Кроме того, такие инструменты, как дополнительные
декораторы классов или метаклассы, могут автоматизировать
какую-то часть работы, связанной с добавлением таких методов
(дополнительные подробности вы найдете в примерах расширения классов
в главе 39). Такие приемы могут помочь сделать классы-обертки
в Python 3.0 более обобщенными, хотя решение не будет таким же простым,
как в Python 2.6.


 Альтернативные реализации: вставка метода __getattribute__, 
проверка стека вызовов

 Один из недостатков этого примера заключается в том, что объекты 
экземпляров в действительности не являются экземплярами оригинального 
класса – они являются экземплярами класса-обертки. В некоторых 
программах, которые при принятии решений опираются на проверку типов,
это обстоятельство может иметь большое значение. Чтобы обеспечить 
поддержку таких проверок, можно было бы попробовать добиться похожего 
эффекта, вставив метод __getattribute__ в оригинальный класс, 
чтобы перехватывать все попытки обращения к атрибутам его экземпляров. 
Этот добавленный метод мог бы передавать запросы супер-классу,
чтобы избежать зацикливания.
"""


# Поддерживает трассировку, как и прежде
def accessControl(failif):
    def onDecorator(aClass):
        def getattributes(self, attr):
            trace('get:', attr)
            if failif(attr):
                raise TypeError('private attribute fetch: ' + attr)
            else:
                return object.__getattribute__(self, attr)
            
        aClass.__getattribute__ = getattributes
        return aClass
    
    return onDecorator


def Private(*attributes):
    return accessControl(failif=(lambda attr: attr in attributes))


def Public(*attributes):
    return accessControl(failif=(lambda attr: attr not in attributes))


"""
 Эта альтернативная реализация решает проблему проверки типа, 
но страдает от двух других проблем. Например, она обрабатывает только 
попытки получения атрибутов – в таком своем виде эта версия позволяет
выполнять присваивание значений частным атрибутам. Чтобы перехватить 
операции присваивания, по-прежнему необходимо использовать метод 
__setattr__ либо добавив объект-обертку, либо вставив метод 
в оригинальный класс. Добавление обертки, перехватывающей операции 
присваивания, снова приведет к изменению типа, а добавляя метод 
в оригинальный класс, можно затереть уже существующий в нем метод 
__setattr__ (или __getattribute__ в данном случае!). Добавляемый метод 
__setattr__ должен также учитывать возможное наличие атрибута __slots__ 
в клиентском классе.

 Кроме того, эта реализация не решает проблему встроенных операций, 
описанную в предыдущем разделе, потому что в таких случаях метод 
__getattribute__ не вызывается. Если бы наш класс Person имел
собственный метод __str__, операция вывода вызывала бы его,
но только потому, что он присутствует в данном конкретном классе. 
Однако, как и прежде, попытка обращения к атрибуту __str__ не привела бы 
к вызову вставленного метода __getattribute__ – операция вывода обойдет
этот метод и напрямую вызовет метод __str__ класса. Хотя такое решение, 
возможно, лучше, чем полный отказ от поддержки методов перегрузки
операторов в обернутом объекте (исключая переопределение, 
по крайней мере), тем не менее, этот прием по-прежнему не обеспечивает 
возможность перехватывать и проверять допустимость вызовов 
методов __X__, делая невозможным ограничить доступ к ним. Большинство 
методов перегрузки операторов, как предполагается, должны быть
общедоступными, но для некоторых бывает желательно сделать исключение.

 Хуже того, так как этот прием, не использующий обертку, добавляет 
метод __getattribute__ в декорируемый класс, этот метод будет 
перехватывать попытки обращения к атрибутам, выполняемые самим классом,
и проверять их так, как если бы они выполнялись из-за пределов класса, – 
это означает, что методы класса тоже лишатся возможности использовать 
частные атрибуты!

 Фактически вставка методов таким способом функционально эквивалентна их
наследованию, что предполагает наличие ограничений, свойственных
оригинальной версии реализации частных атрибутов в главе 29. 
Чтобы узнать, откуда была выполнена попытка доступа к атрибуту, 
изнутри  класса или снаружи, нашему методу могло бы потребоваться 
проверить  объекты кадров стека вызовов. В конечном счете, 
это помогло бы решить  проблему (например, можно было бы заменить 
частные атрибуты свойствами или дескрипторами, проверяющими 
стек вызовов), но это существенно замедлило бы операции доступа, 
а кроме того, для нас реализация такого решения слишком отдает 
шаманством, чтобы рассматривать ее здесь.

 Несмотря на оригинальность и пригодность для использования в некоторых
случаях, этот прием вставки метода не достигает поставленных нами целей.
У нас нет возможности продолжить исследование этого приема, потому что
приемы расширения классов мы будем рассматривать в следующей главе,
в соединении с метаклассами. Как мы увидим там, метаклассы не являются
единственной возможностью изменения классов таким способом, потому что
нередко эту же роль могут играть декораторы классов.


 Для языка Python не характерно управлять доступом
 
 Теперь, когда я прошел такой длинный путь, объясняя, как реализовать
объявления Private и Public для атрибутов, я должен снова напомнить,
что это не совсем в стиле программирования на Python – ограничивать 
доступ к классам. Фактически большинство программистов на языке Python 
сочтут эти примеры нужными разве что для демонстрации декораторов 
в действии. Даже очень большие программы на языке Python благополучно 
обходятся вообще без каких-либо средств управления доступом. Если вам 
действительно необходимо регулировать доступ к атрибутам, чтобы
уменьшить число ошибок при программировании, или так случилось, 
что вы – бывший-программист-на-языке-C++ или Java, то и тогда 
большую часть того, что вам действительно необходимо, можно реализовать 
с помощью инструментов интроспекции и перегрузки операторов. 


 Пример: проверка аргументов функций
 
 В качестве заключительного примера, демонстрирующего удобство
декораторов, в этом разделе мы создадим декоратор, который автоматически
проверяет числовые аргументы, передаваемые функции или методу, 
на вхождение в определенный диапазон. Он предназначен для использования 
на стадии разработки или эксплуатации и может рассматриваться как шаблон
для решения похожих задач (например, для проверки типов аргументов, 
если это потребуется).


 Цель
 
 В пособии по объектно-ориентированному программированию в главе 27 
мы написали класс, метод giveRaise которого используется для увеличения 
на указанный процент зарплаты сотрудникам, которых представляют объекты
класса:


class Person:
    ...
    def giveRaise(self, percent):
        self.pay = int(self.pay * (1 + percent))
        
        
 Тогда мы отметили, что для повышения надежности программного кода было
бы неплохо проверить аргумент percent, чтобы убедиться, что он имеет 
не слишком большое и не слишком маленькое значение. Мы могли бы 
реализовать такую проверку с помощью инструкции if или assert внутри 
самого метода, используя встроенную проверку:


class Person:
    def giveRaise(self, percent):
        # Проверка с помощью встроенного прогр. кода
        if percent < 0.0 or percent > 1.0:
            raise TypeError('percent invalid')
            
        self.pay = int(self.pay * (1 + percent))
        
        
class Person: # Проверка с помощью инструкции assert
    def giveRaise(self, percent):
        assert 0.0 <= percent <= 1.0, 'percent invalid'
        self.pay = int(self.pay * (1 + percent))


 Однако такой подход загромождает метод встроенными проверками, которые,
скорее всего, будут иметь смысл только во время разработки. 
В более сложных случаях такой подход может стать утомительным 
(попробуйте представить, как мог бы выглядеть программный код встроенной 
проверки для управления доступом к атрибуту, которое было реализовано
в предыдущем разделе в виде декоратора). Хуже того, если логику проверки 
придется когда-нибудь изменить, может потребоваться найти и изменить 
множество копий встроенной проверки. Гораздо удобнее и интереснее 
было бы создать альтернативу в виде универсального инструмента,
который мог бы автоматически выполнять проверку на вхождение значения 
любого аргумента любой функции или метода в заданный диапазон.
Наиболее очевидным и удобным представляется решение на основе 
декоратора:


class Person:
    @rangetest(percent=(0.0, 1.0))  # Проверка с помощью декоратора
    def giveRaise(self, percent):
        self.pay = int(self.pay * (1 + percent))
        
        
 Реализация логики проверки в виде декоратора упрощает реализацию 
клиентов и сопровождение программы в будущем.

 Обратите внимание, что наша цель здесь отличается от проверки 
атрибутов, реализованной в последнем примере предыдущей главы. 
Здесь мы собираемся проверять значения аргументов в вызовах функций, 
а не значения атрибутов при выполнении операции присваивания. 
Декораторы и средства интроспекции в языке Python позволяют легко
реализовать эту задачу. 


 Простой декоратор проверки значений позиционных аргументов 
на вхождение в заданный диапазон.

 Начнем с реализации простой проверки на вхождение в диапазон. 
Для простоты мы сначала создадим декоратор, который работает только 
с позиционными аргументами и предполагает, что они всегда передаются 
в одной и той же позиции во всех вызовах. Они не могут передаваться 
в виде именованных аргументов, и нам не требуется обеспечивать поддержку 
передачи именованных аргументов **args, потому что в этом случае порядок 
следования аргументов может не соответствовать позициям, объявленным 
в декораторе.
"""


def rangetest(*argchecks):
    # Проверяет позиционные аргументы на вхождение
    def onDecorator(func):  # в заданный диапазон
        if not __debug__:  # True – если “python -O main.py args...”
            return func  # Ничего не выполняет: просто возвращает
            # оригинальную функцию
        else:  # Иначе, на этапе отладки, возвращает обертку
            def onCall(*args):
                for (ix, low, high) in argchecks:
                    if args[ix] < low or args[ix] > high:
                        errmsg = 'Argument %s not in %s..%s' %\
                                 (ix, low, high)
                        raise TypeError(errmsg)
                    
                return func(*args)
            
            return onCall
        
    return onDecorator


"""
 Как можно заметить, этот программный код в основном реализует шаблоны
проектирования, исследованные нами ранее: здесь используются аргументы
декоратора, вложенные области видимости для сохранения информации 
о состоянии и так далее.

 Кроме того, опираясь на полученные ранее знания, мы использовали 
вложенные инструкции def, чтобы гарантировать возможность применения 
декоратора и к простым функциям, и к методам. Когда декоратор 
применяется к методу класса, функция onCall будет принимать 
подразумеваемый экземпляр класса в первом элементе списка *args 
и передавать его в виде аргумента self оригинальному методу – нумерация
проверяемых аргументов в этом случае начинается с 1, а не с 0.

 Обратите также внимание, что здесь используется встроенная переменная 
__debug__ – интерпретатор присваивает ей значение True, если только он 
не был запущен с параметром –O командной строки, включающим режим 
оптимизации (например, python –O main.py). Если переменная __debug__ 
имеет значение False, декоратор возвращает оригинальную функцию, 
чтобы избежать дополнительных вызовов и связанной с ними потери 
производительности.
"""

print(__debug__)  # False, если “python –O main.py”


@rangetest((1, 0, 120))  # persinfo = rangetest(...)(persinfo)
def persinfo(name, age):  # Значение age должно быть в диапазоне 0..120
    print('%s is %s years old' % (name, age))


@rangetest([0, 1, 12], [1, 1, 31], [2, 0, 2009])
def birthday(M, D, Y):
    print('birthday = {0}/{1}/{2}'.format(M, D, Y))


class Person:
    def __init__(self, name, job, pay):
        self.job = job
        self.pay = pay

    @rangetest([1, 0.0, 1.0])  # giveRaise = rangetest(...)(giveRaise)
    def giveRaise(self, percent):
        # Аргумент 0 – ссылка self на экземпляр
        self.pay = int(self.pay * (1 + percent))


# Закомментированные строки возбуждают исключение TypeError,
# если сценарий не был запущен командой “python -O”
persinfo('Bob Smith', 45)  # В действительности вызывает onCall(...)
# persinfo(‘Bob Smith’, 200) или person,
# если был использован аргумент –O командной строки
birthday(5, 31, 1963)
# birthday(5, 32, 1963)
sue = Person('Sue Jones', 'dev', 100000)
sue.giveRaise(.10)  # В действительности вызывает onCall(self, .10)
print(sue.pay)  # или giveRaise(self, .10), если использован –O
# sue.giveRaise(1.10)
# print(sue.pay)

"""
 Если запустить интерпретатор с аргументом –O командной строки, 
проверка на вхождение в диапазон выполняться не будет, но при этом 
не будет и падения производительности, вызванного логикой обертки, – 
сценарий будет вызывать оригинальные, не декорированные функции.
Так как мы решили, что этот декоратор является инструментом отладки,
мы можем использовать аргумент –O для оптимизации программы при работе
в эксплуатационном режиме:

C:\misc> C:\python30\python –O devtools_test.py
False
Bob Smith is 45 years old
birthday = 5/31/1963
110000
231000


 Обобщение на именованные аргументы 
и аргументы со значениями по умолчанию

 Предыдущая версия представляет собой основу, которую мы можем 
использовать, но она весьма ограниченна – она поддерживает проверку 
только позиционных аргументов и не предусматривает проверку именованных 
аргументов (фактически она предполагает, что именованные аргументы 
вообще не будут передаваться, так как при их использовании может 
нарушаться порядок следования позиционных аргументов). Кроме того, 
она ничего не делает с аргументами, имеющими значения по умолчанию, 
которые могут быть опущены в том или ином вызове. Эта версия отлично 
подходит для случаев, когда все аргументы передаются по позициям
и не используются аргументы со значениями по умолчанию, но она далека 
от идеала, если рассматривать ее как универсальный инструмент. 
Интерпретатор поддерживает множество более гибких режимов передачи 
аргументов, к которым мы пока не обращаемся.

 Ниже приводится измененная версия нашего примера, расширенная 
в этом отношении. Сопоставляя аргументы, ожидаемые обернутой функцией,
с фактическими аргументами в вызове, она обеспечивает проверку
аргументов, которые могут передаваться по позиции или по имени, 
и пропускает проверку аргументов со значениями по умолчанию, 
которые отсутствуют в вызове. Проще говоря, проверяемые аргументы 
определяются в декораторе в виде именованных аргументов, которые затем 
будут отыскиваться в кортеже *pargs позиционных аргументов и в словаре 
**kargs именованных аргументов.


Файл - декоратор функций, выполняющий проверку аргументов на вхождение 
в заданный диапазон. Проверяемые аргументы передаются декоратору 
в виде именованных аргументов. В фактическом вызове функции аргументы 
могут передаваться как в виде позиционных, так и в виде именованных 
аргументов, при этом аргументы со значениями по умолчанию 
могут быть опущены.
"""

trace = True


def rangetest(**argchecks):  # Проверяемые аргументы с диапазонами
    def onDecorator(func):  # onCall сохраняет func и argchecks
        if not __debug__:  # True – если “python –O main.py args...”
            return func  # Обертывание только при отладке; иначе
        else:  # возвращается оригинальная функция
            import sys
            
            code = func.__code__
            allargs = code.co_varnames[:code.co_argcount]
            funcname = func.__name__

            def onCall(*pargs, **kargs):
                # Все аргументы в кортеже pargs сопоставляются
                # с первыми N ожидаемыми аргументами по позиции
                # Остальные либо находятся в словаре kargs,
                # либо опущены, как аргументы со значениями по умолчанию
                positionals = list(allargs)
                positionals = positionals[:len(pargs)]
                for (argname, (low, high)) in argchecks.items():
                    # Для всех аргументов, которые должны быть проверены
                    if argname in kargs:
                        # Аргумент был передан по имени
                        if kargs[argname] < low \
                                or kargs[argname] > high:
                            errmsg = '{0} argument “{1}”' \
                                     ' not in {2}..{3}'
                            errmsg = errmsg.format(funcname, argname,
                                                   low, high)
                            raise TypeError(errmsg)
                    elif argname in positionals:
                        # Аргумент был передан по позиции
                        position = positionals.index(argname)
                        if pargs[position] < low \
                                or pargs[position] > high:
                            errmsg = '{0} argument “{1}” ' \
                                     'not in {2}..{3}'
                            errmsg = errmsg.format(funcname, argname,
                                                   low, high)
                            raise TypeError(errmsg)
                    else:
                        # Аргумент не был передан: предполагается,
                        # что он имеет значение по умолчанию
                        if trace:
                            print('Argument “{0}” defaulted'
                                  .format(argname))
                            
                return func(*pargs, **kargs)
                # OK: вызвать оригинальную функцию
            
            return onCall
        
    return onDecorator


"""
 Следующий тестовый сценарий демонстрирует порядок использования 
декоратора – аргументы, которые требуется проверить, передаются 
декоратору в виде именованных аргументов, а в фактическом вызове функции 
аргументы могут передаваться по имени или по позиции. Аргументы 
со значениями по умолчанию могут быть опущены, даже если они определены
для проверки:
"""

# Закомментированные строки возбуждают исключение TypeError,
# если сценарий не был запущен командой “python -O”


# Тест вызовов функций с позиционными и именованными аргументами
@rangetest(age=(0, 120))  # persinfo = rangetest(...)(persinfo)
def persinfo(name, age):
    print('%s is %s years old' % (name, age))


@rangetest(M=(1, 12), D=(1, 31), Y=(0, 2009))
def birthday(M, D, Y):
    print('birthday = {0}/{1}/{2}'.format(M, D, Y))


persinfo('Bob', 40)
persinfo(age=40, name='Bob')
birthday(5, D=1, Y=1963)
# persinfo(‘Bob’, 150)
# persinfo(age=150, name=’Bob’)
# birthday(5, D=40, Y=1963)


# Тест вызовов методов с позиционными и именованными аргументами
class Person:
    def __init__(self, name, job, pay):
        self.job = job
        self.pay = pay

    # giveRaise = rangetest(...)(giveRaise)
    # Аргумент percent передается по имени
    @rangetest(percent=(0.0, 1.0))
    def giveRaise(self, percent):  # или по позиции
        self.pay = int(self.pay * (1 + percent))


bob = Person('Bob Smith', 'dev', 100000)
sue = Person('Sue Jones', 'dev', 100000)
bob.giveRaise(.10)
sue.giveRaise(percent=.20)
print(bob.pay, sue.pay)
# bob.giveRaise(1.10)
# bob.giveRaise(percent=1.20)


# Тест вызовов функций с опущенными аргументами по умолчанию
@rangetest(a=(1, 10), b=(1, 10), c=(1, 10), d=(1, 10))
def omitargs(a, b=7, c=8, d=9):
    print(a, b, c, d)


omitargs(1, 2, 3, 4)
omitargs(1, 2, 3)
omitargs(1, 2, 3, d=4)
omitargs(1, d=4)
omitargs(d=4, a=1)
omitargs(1, b=2, d=4)
omitargs(d=8, c=7, a=1)
# omitargs(1, 2, 3, 11) # Недопустимое значение аргумента d
# omitargs(1, 2, 11) # Недопустимое значение аргумента c
# omitargs(1, 2, 3, d=11) # Недопустимое значение аргумента d
# omitargs(11, d=4) # Недопустимое значение аргумента a
# omitargs(d=4, a=11) # Недопустимое значение аргумента a
# omitargs(1, b=11, d=4) # Недопустимое значение аргумента b
# omitargs(d=8, c=7, a=11) # Недопустимое значение аргумента a

"""
 Если запустить этот сценарий, передача значений вне заданного диапазона
будет приводить к исключению, как и прежде, но теперь аргументы могут
передаваться по имени или по позиции, а отсутствующие аргументы 
со значениями по умолчанию не проверяются.

 Если раскомментировать любой из недопустимых вызовов, обнаруженная
при проверке ошибка приведет к исключению, как и прежде 
(если интерпретатор не был запущен с параметром –O командной строки):

TypeError: giveRaise argument “percent” not in 0.0..1.0


 Подробности реализации


 Интроспекция функций
 
 Как оказывается, механизм интроспекции позволяет исследовать объекты
функций, а связанные с функциями объекты программного кода обладают
именно теми инструментами, которые нам необходимы. Эти инструменты
были кратко представлены в главе 19, а здесь мы находим им практическое
применение. Множество имен ожидаемых аргументов – это просто первые N
имен переменных, присоединенных к объекту программного кода функции:
"""


def func(a, b, c, d):
    x = 1
    y = 2


code = func.__code__  # Объект с программным кодом,
print(code.co_nlocals)  # принадлежащий объекту функции

print(code.co_varnames)  # Все имена локальных переменных

print(code.co_varnames[:code.co_argcount])
# Первые N локальных имен – это ожидаемые аргументы

import sys  # Для обратной совместимости


print(sys.version_info)  # [0] – старший номер версии

code = func.__code__

"""
 Допущения относительно аргументов
 
 Помимо множества имен ожидаемых аргументов решение опирается также 
на два ограничения, которые накладываются интерпретатором на порядок 
следования передаваемых аргументов (эти ограничения действуют в обеих
версиях Python, 2.6 и 3.0):

  В вызове функции все позиционные аргументы предшествуют всем 
 именованным аргументам.
 
  В инструкции def все аргументы, не имеющие значений по умолчанию, 
 указываются перед всеми аргументами, имеющими значения по умолчанию.
 
 То есть в вызове функции позиционные аргументы не могут следовать 
за именованными аргументами, а аргументы, не имеющие значений 
по умолчанию, не могут следовать за аргументами, имеющими значения 
по умолчанию. Все определения аргументов вида name=value должны 
следовать за простыми аргументами вида name.

 Чтобы упростить реализацию, мы можем также допустить, что сам вызов 
вообще является допустимым, то есть либо все аргументы получат значения
(по имени или по позиции), либо какие-то аргументы будут опущены 
преднамеренно, чтобы им были присвоены значения по умолчанию.
Это допущение не обязательно будет соблюдаться, потому что на момент
выполнения проверки оригинальная функция фактически еще 
не была вызвана – вызов функции может потерпеть неудачу, когда позднее 
она будет вызвана оберткой, из-за некорректной передачи аргументов. 
Однако подобные неудачи не имеют отрицательных последствий для работы 
обертки, поэтому мы можем просто игнорировать допустимость 
самого вызова.


 Алгоритм сопоставления
 
 Теперь с учетом этих ограничений и допущений мы можем реализовать 
алгоритм обработки именованных аргументов и опущенных аргументов 
со значениями по умолчанию. Перехватив вызов функции, мы можем исходить 
из следующих предположений:

  Все N переданных позиционных аргументов в *pargs должны 
 соответствовать первым N ожидаемым аргументам, перечисленным в объекте
 с программным кодом функции. Это следует из правил, определяющих 
 порядок следования аргументов в вызовах функций, обозначенных выше, 
 поскольку все позиционные аргументы предшествуют именованным.
 
  Чтобы получить имена аргументов, которые фактически были переданы
 в виде позиционных аргументов, можно извлечь срез из списка всех 
 ожидаемых аргументов длиной N, равной длине кортежа *pargs 
 с позиционными аргументами.
 
  Любые аргументы, следующие за первыми N ожидаемыми аргументами, 
 будут либо именованными, либо аргументами со значениями по умолчанию,
 которые могут быть опущены в вызове функции.

  Для каждого имени аргумента из числа тех, что требуется проверить: 
 если имя присутствует в словаре **kargs, следовательно, аргумент 
 был передан по имени, а если имя попадает в число первых N ожидаемых 
 аргументов, следовательно, соответствующий аргумент был передан 
 как позиционный (в этом случае относительная позиция в списке ожидаемых
 аргументов соответствует относительной позиции в *pargs). В противном
 случае можно предположить, что аргумент был опущен при вызове функции 
 и имеет значение по умолчанию, которое не требуется проверять.

 Другими словами, мы можем пропустить проверку аргументов, которые 
были опущены при вызове функции, исходя из того, что первые N фактически
переданных позиционных аргументов в *pargs должны соответствовать 
первым N именам аргументов в списке всех ожидаемых аргументов и что 
все остальные аргументы либо должны передаваться по именам и потому
попасть в **kargs, либо имеют значения по умолчанию 
и могут быть опущены. Следуя этой схеме, декоратор просто 
будет пропускать проверку любых аргументов, которые находятся 
между самым правым позиционным аргументом и самым левым именованным 
аргументом, между именованными аргументами или после самого правого 
позиционного аргумента вообще.


 Нерешенные проблемы
 
 Несмотря на то, что наш инструмент проверки аргументов действует так, 
как и задумывалось, тем не менее, остаются нерешенными две проблемы.
Во-первых, как уже упоминалось выше, если вызов оригинальной функции 
окажется недопустимым, он будет терпеть неудачу в конце декоратора.
Например, следующие два вызова приводят к исключению:

omitargs()
omitargs(d=8, c=7, b=6)

 Однако они терпят неудачу только в тот момент, когда производится вызов
оригинальной функции, в конце обертки. Мы могли бы попытаться 
сымитировать алгоритм сопоставления аргументов в языке Python, 
чтобы избежать этого, однако для этого нет никаких веских причин – 
поскольку так или иначе вызов все равно потерпел бы неудачу, мы можем
доверить интерпретатору самому обнаружить проблемы, которые не удалось
обнаружить нам.

 Наконец, хотя наша последняя версия обрабатывает позиционные 
и именованные аргументы, а также опущенные аргументы со значениями 
по умолчанию, тем не менее, она никак не обрабатывает аргументы *args
и **args, которые могут использоваться в декорируемой функции для приема
произвольного количества аргументов. Впрочем, учитывая поставленную 
цель, мы не должны беспокоиться об этом:

  При передаче дополнительного именованного аргумента его имя попадет
 в словарь **kargs и будет проверено, если оно упоминается в декораторе.
 
  Если дополнительный именованный аргумент не будет передан, его имя 
 не попадет ни в словарь **kargs, ни в срез со списком ожидаемых 
 позиционных аргументов и потому просто не будет проверяться. 
 Этот аргумент будет интерпретироваться как аргумент со значением 
 по умолчанию, даже если в действительности он является необязательным 
 дополнительным аргументом.

  При передаче дополнительного позиционного аргумента у нас нет никакого
 способа сослаться на него в декораторе – его имя не попадет 
 ни в словарь **kargs, ни в срез со списком ожидаемых аргументов, 
 поэтому он просто будет пропущен. Поскольку такие аргументы 
 не перечисляются в определении функции, нет никакой возможности 
 отобразить в декораторе его имя на относительную позицию в списке 
 ожидаемых аргументов.

 Другими словами, этот декоратор поддерживает возможность проверки
произвольных именованных аргументов, но он не поддерживает возможность
проверки произвольных позиционных аргументов, не имеющих имени и потому
не имеющих определенной позиции в сигнатуре функции.

 В принципе, мы могли бы расширить интерфейс декоратора поддержкой 
конструкции *args в декорируемой функции для тех редких случаев, 
когда это может оказаться полезным (например, добавив специальное имя 
аргумента с диапазоном, на соответствие которому проверялись бы 
все аргументы в списке *pargs обертки, с позициями, превышающими длину 
списка ожидаемых аргументов).


 Аргументы декораторов и аннотации функций
 
 Интересно отметить, что возможность создания аннотаций функций, 
появившаяся в Python 3.0, может использоваться как альтернатива
аргументам декоратора в нашем примере проверки значений аргументов 
на вхождение в заданный диапазон. Как мы узнали в главе 19, аннотации
позволяют ассоциировать выражения с аргументами и возвращаемыми 
значениями за счет внедрения их в строку заголовка инструкции def. 
Интерпретатор собирает аннотации в словарь и присоединяет его 
к аннотированной функции.

 Мы могли бы использовать эту возможность в нашем примере, определив 
границы диапазонов в строке заголовка, вместо аргументов декоратора.
Правда, при этом нам все еще будет необходим декоратор для обертывания 
функции, чтобы с помощью обертки перехватывать вызовы, но по сути 
мы лишь заменим декоратор с аргументами:


@rangetest(a=(1, 5), c=(0.0, 1.0))
def func(a, b, c):  # func = rangetest(...)(func)
    print(a + b + c)


 на простой декоратор для аннотированной функции:


@rangetest
def func(a: (1, 5), b, c: (0.0, 1.0)):
    print(a + b + c)

 
 То есть теперь границы диапазона определяются уже не во внешнем
программном коде, а в самой функции. Следующий сценарий иллюстрирует 
структуру декораторов для каждого из двух случаев с неполной,
схематической реализацией. Шаблон декоратора с аргументами представляет 
полное решение, показанное выше. Альтернатива, основанная 
на использовании аннотаций, имеет на один уровень вложенности меньше, 
потому что ей не требуется сохранять аргументы декоратора:
"""


# С использованием декоратора с аргументами
def rangetest(**argchecks):
    def onDecorator(func):
        def onCall(*pargs, **kargs):
            print(argchecks)
            cd = func.__code__
            allargs = cd.co_varnames[:cd.co_argcount]
            positionals = allargs[:len(pargs)]
            funcname = func.__name__
            for argname, check in argchecks.items():
                if argname in kargs:
                    # Аргумент был передан по имени
                    if kargs[argname] < check[0] \
                            or kargs[argname] > check[1]:
                        errmsg = '{0} argument “{1}”' \
                                 ' not in {2}..{3}'
                        errmsg = errmsg.format(funcname, argname,
                                               check[0], check[1])
                        raise TypeError(errmsg)
                elif argname in positionals:
                    # Аргумент был передан по позиции
                    position = positionals.index(argname)
                    if pargs[position] < check[0] \
                            or pargs[position] > check[1]:
                        errmsg = '{0} argument “{1}” ' \
                                 'not in {2}..{3}'
                        errmsg = errmsg.format(funcname, argname,
                                               check[0], check[1])
                        raise TypeError(errmsg)
                else:
                    # Аргумент не был передан: предполагается,
                    # что он имеет значение по умолчанию
                    if trace:
                        print('Argument “{0}” defaulted'
                              .format(argname))
                        
            return func(*pargs, **kargs)
        
        return onCall
    
    return onDecorator


@rangetest(a=(1, 5), c=(0.0, 1.0))
def func(a, b, c):  # func = rangetest(...)(func)
    print(a + b + c)


func(1, 2, c=0.3)  # Вызовет onCall, argchecks –
# в области видимости объемлющей функции


# С использованием аннотаций функций
def rangetest(func):
    def onCall(*pargs, **kargs):
        argchecks = func.__annotations__
        print(argchecks)
        for argname, check in argchecks.items():
            cd = func.__code__
            allargs = cd.co_varnames[:cd.co_argcount]
            positionals = allargs[:len(pargs)]
            funcname = func.__name__

            if argname in kargs:
                # Аргумент был передан по имени
                if kargs[argname] < check[0] \
                        or kargs[argname] > check[1]:
                    errmsg = '{0} argument “{1}”' \
                                ' not in {2}..{3}'
                    errmsg = errmsg.format(funcname, argname,
                                           check[0], check[1])
                    raise TypeError(errmsg)
            elif argname in positionals:
                # Аргумент был передан по позиции
                position = positionals.index(argname)
                if pargs[position] < check[0] \
                        or pargs[position] > check[1]:
                    errmsg = '{0} argument “{1}” ' \
                                'not in {2}..{3}'
                    errmsg = errmsg.format(funcname, argname,
                                           check[0], check[1])
                    raise TypeError(errmsg)
            else:
                # Аргумент не был передан: предполагается,
                # что он имеет значение по умолчанию
                if trace:
                    print('Argument “{0}” defaulted'
                          .format(argname))
                    
        return func(*pargs, **kargs)
    
    return onCall


@rangetest
def func(a: (1, 5), b, c: (0.0, 1.0)):  # func = rangetest(func)
    print(a + b + c)


func(1, 2, c=0.3)  # Вызовет onCall, аннотации в функции func


"""
 В процессе работы обе обертки получают доступ к одной и той информации
о проверяемых аргументах и диапазонах, но хранится она в разных формах:
в версии декоратора с аргументами информация сохраняется в аргументах,
в области видимости объемлющей функции, а в версии с аннотациями
информация сохраняется в атрибутах самой функции.

 Фактически использование аннотаций вместо аргументов декоратора в этом
примере лишь ограничивает область его применения. С одной стороны, 
аннотации доступны только в Python 3.0, поэтому в версии 2.6 
этот декоратор не может использоваться. С другой стороны, декораторы 
с аргументами могут применяться в обеих версиях.

 Еще более важно, что переместив определения границ в заголовок 
инструкции def, мы по сути отводим функции единственную роль – аннотации 
позволяют указать для каждого аргумента только одно выражение, которое 
может преследовать только одну цель. Например, мы не сможем использовать 
аннотации, чтобы определить для функции другие роли.

 С другой стороны, аргументы декоратора определяются за пределами самой
функции, их проще удалить и они обеспечивают более широкие возможности – 
реализация самой функции не подразумевает единственное назначение 
декоратора. Фактически за счет вложения декораторов с аргументами 
мы можем предусмотреть несколько уровней декорирования одной и той же 
функции – аннотации поддерживают только один. Кроме того, 
при использовании декоратора с аргументами сама функция сохраняет 
простое и привычное оформление.


 Другие области применения: проверка типов (если настаиваете!)

 Шаблон реализации обработки аргументов в декораторах, который 
мы выработали выше, можно было бы использовать и в других целях.
Например, совсем несложно реализовать проверку типов аргументов, 
которую можно было бы использовать на этапе разработки:
"""


def typetest(**argchecks):
    def onDecorator(func):
        def onCall(*pargs, **kargs):
            cd = func.__code__
            allargs = cd.co_varnames[:cd.co_argcount]
            positionals = list(allargs)[:len(pargs)]
            for (argname, tp) in argchecks.items():
                if argname in kargs:
                    if not isinstance(kargs[argname], tp):
                        errmsg = ''
                        raise TypeError(errmsg)
                elif argname in positionals:
                    position = positionals.index(argname)
                    if not isinstance(pargs[position], tp):
                        errmsg = ''
                        raise TypeError(errmsg)
                else:
                    # Предполагается, что аргумент был опущен:
                    # аргумент со значением по умолчанию
                    pass
                
            return func(*pargs, **kargs)
        
        return onCall
    
    return onDecorator


@typetest(a=int, c=float)
def func(a, b, c, d):  # func = typetest(...)(func)
    print(a, b, c, d)


func(1, 2, 3.0, 4)  # Корректный вызов
# func('spam', 2, 99, 4)  # Возбудит исключение, как и ожидалось

"""
 Фактически мы могли бы пойти по пути обобщения еще дальше 
и организовать передачу функции проверки, как мы сделали это ранее,
при реализации декоратора Public, – единственной копии программного
кода такого рода было бы достаточно, чтобы организовать и проверку 
значений аргументов, и проверку их типов. Если в этом декораторе вместо 
аргументов использовать аннотации, как описано в предыдущем разделе, 
это сделало бы аннотации похожими на объявления типов в других языках 
программирования:


@typetest
def func(a: int, b, c: float, d):  # func = typetest(func)
    ...  # Ух ты!...
    
 Однако, как вы уже узнали в этой книге, на практике вообще не принято 
проверять типы объектов, это не характерно для языка Python
(на практике такого рода проверки выявляют программистов на языке C++, 
начинающих изучать Python).

 Проверки типов ограничивают область применения ваших функций узким
кругом объектов определенных типов и не позволяют им взаимодействовать
с объектами других типов, имеющими совместимые интерфейсы. В результате 
это накладывает ненужные ограничения на программный код и снижает
его гибкость. С другой стороны, из каждого правила есть исключения – 
проверка типов может пригодиться в отдельных случаях при отладке 
и при организации взаимодействий с программами, написанными 
на более строгих языках программирования, таких как C++.


 Закрепление пройденного


 Контрольные вопросы

 1. Как упоминалось в одном из примечаний в этой главе, декоратор
с аргументами, реализующий хронометраж функций, который мы написали
в разделе «Добавление аргументов декоратора» выше, может применяться
только к простым функциям, потому что для перехвата вызовов функций
он использует вложенный класс с методом __call__ перегрузки операторов.
Этот декоратор не может применяться к методам класса, потому что в этом
случае в аргументе self будет передаваться экземпляр декоратора, 
а не подразумеваемый экземпляр класса. Перепишите этот декоратор так, 
чтобы его можно было применять и к простым функциям, и к методам класса,
и протестируйте его с функциями и методами. (Подсказка: 
прочитайте раздел «Ошибки при использовании классов I: 
декорирование методов классов» выше, где приводятся некоторые 
рекомендации.) Обратите внимание, что для сохранения общего времени 
выполнения можно использовать атрибуты объекта функции, так как в вашем 
распоряжении уже не будет вложенного класса, где можно было бы сохранять 
информацию, и не будет возможности обращаться к нелокальным переменным 
из-за пределов декоратора.

 Ниже приводится один из способов решения этой задачи и результаты,
полученные при его выполнении (методы представленного класса выполняются 
очень быстро). Вся хитрость состоит в том, чтобы заменить вложенный 
класс вложенной функцией и тем самым обеспечить передачу в аргументе
self экземпляра самого класса, и сохранить общее время выполнения
в атрибутах функции, благодаря чему оно сможет быть извлечено позднее,
обращением к оригинальному имени
"""

import time


def timer(label='', trace=True):
    # Декоратор с аргументами: сохраняет арг.
    def onDecorator(func):  # На этапе декорирования @:
        # сохраняет декорируемую функцию
        def onCall(*args, **kargs):  # При вызове: вызывает оригинал
            start = time.time()  # Информация в области видимости +
            result = func(*args, **kargs)  # атрибуты функции
            elapsed = time.time() - start
            onCall.alltime += elapsed
            if trace:
                frmt = ' %s %s: %.5f, %.5f'
                values = (label, func.__name__, elapsed, onCall.alltime)
                print(frmt % values)
                return result
            
        onCall.alltime = 0
        return onCall
    
    return onDecorator


# Проверка на функциях
@timer(trace=True, label='[CCC] == >')
def listcomp(N):  # listcomp = timer(...)(listcomp)
    return [x * 2 for x in range(N)]  # listcomp(...) вызовет onCall


@timer(trace=True, label='[MMM] == >')
def mapcall(N):
    return list(map((lambda x: x * 2), range(N)))
    # list() для представлений


# в 3.0
for func in (listcomp, mapcall):
    result = func(5)
    # Время этого вызова, всех вызовов и возвращает значение
    func(5000000)
    print(result)
    print('allTime = %s\n' % func.alltime)  # Общее время всех вызовов


# Проверка на методах
class Person:
    def __init__(self, name, pay):
        self.name = name
        self.pay = pay

    @timer()
    def giveRaise(self, percent):  # giveRaise = timer()(giveRaise)
        self.pay *= (1.0 + percent)  # декоратор сохранит giveRaise

    @timer(label=' ** ')
    def lastName(self):  # lastName = timer(...)(lastName)
        return self.name.split()[-1]
        # общее время для класса, а не экз.


bob = Person('Bob Smith', 50000)
sue = Person('Sue Jones', 100000)
bob.giveRaise(.10)
sue.giveRaise(.20)  # runs onCall(sue, .10)
print(bob.pay, sue.pay)
print(bob.lastName(), sue.lastName())
# runs onCall(bob), remembers lastName
print(' %.5f %.5f' % (Person.giveRaise.alltime,
                      Person.lastName.alltime))

"""
 2. Декораторы классов Public/Private, которые мы написали в этой главе, 
добавляют дополнительную нагрузку к операциям извлечения атрибутов 
декорируемых классов. Конечно, для повышения скорости мы можем просто
удалить строку с объявлением декоратора @, но точно так же можно было бы
дополнить сам декоратор проверкой переменной __debug__ и не выполнять
обертывание вообще, когда интерпретатор запускается с флагом –O (как мы
сделали это в декораторах, реализующих проверку значений аргументов).
При таком подходе мы сможем поднять скорость выполнения программы
с помощью аргументов командной строки (python –O main.py...), не изменяя
исходных текстов. Реализуйте и протестируйте это расширение.

 Следующая реализация декоратора удовлетворяет условиям 
второго вопроса – при выполнении в оптимизированном режиме (-O) 
она возвращает оригинальный класс, поэтому операции обращения 
к атрибутам будут выполняться без потери скорости. В действительности,
все, что я сделал, – это добавил инструкции проверки работы в отладочном
режиме и увеличил отступы в определении класса. Добавьте определения 
методов перегрузки операторов в класс-обертку, если вам потребуется 
обеспечить их делегирование клиентскому классу в Python 3.0 
(обращения к этим методам в версии 2.6 приводят к вызову метода 
__getattr__, но в версии 3.0 и при использовании классов нового стиля
в версии 2.6 – нет).
"""

traceMe = False


def trace(*args):
    if traceMe:
        print('[' + ' '.join(map(str, args)) + ']')


def accessControl(failIf):
    def onDecorator(aClass):
        if not __debug__:
            return aClass
        else:
            class onInstance:
                def __init__(self, *args, **kargs):
                    self.__wrapped = aClass(*args, **kargs)

                def __getattr__(self, attr):
                    trace('get:', attr)
                    if failIf(attr):
                        raise TypeError('private attribute fetch: '
                                        + attr)
                    else:
                        return getattr(self.__wrapped, attr)

                def __setattr__(self, attr, value):
                    trace('set:', attr, value)
                    if attr == '_onInstance__wrapped':
                        self.__dict__[attr] = value
                    elif failIf(attr):
                        raise TypeError('private attribute change: '
                                        + attr)
                    else:
                        setattr(self.__wrapped, attr, value)
                        
            return onInstance
        
    return onDecorator


def Private(*attributes):
    return accessControl(failif=(lambda attr: attr in attributes))


def Public(*attributes):
    return accessControl(failif=(lambda attr: attr not in attributes))


# Проверка: выделите следующий код в отдельный файл,
# чтобы декоратор можно было использовать в других модулях
@Private('age')  # Person = Private(‘age’)(Person)
class Person:  # Person = onInstance с информацией о состоянии
    def __init__(self, name, age):
        self.name = name
        self.age = age  # Доступ изнутри разрешен всегда


X = Person('Bob', 40)
print(X.name)  # Доступ снаружи контролируется
X.name = 'Sue'
print(X.name)
# print(X.age) # ОШИБКА, если сценарий не был запущен как “python -O”
# X.age = 999 # то же самое
# print(X.age) # то же самое


@Public('name')
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age


X = Person('bob', 40)  # X – это onInstance
print(X.name)  # onInstance встраивает Person
X.name = 'Sue'
print(X.name)
# print(X.age) # ОШИБКА, если сценарий не был запущен как “python -O”
# X.age = 999 # то же самое
# print(X.age) # то же самое

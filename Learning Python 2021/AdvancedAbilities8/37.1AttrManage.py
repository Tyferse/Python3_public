"""
 Управляемые атрибуты


 Зачем нужно управлять атрибутами?

 Атрибуты объектов занимают центральное положение в большинстве программ
на языке Python - они хранят информацию об объектах или процессах,
протекающих в сценарии. Обычно атрибуты являются простыми
именами объектов – атрибут name, например, может быть простой строкой,
получить и изменить значение которой можно с применением обычного
синтаксиса обращения к атрибутам:

person.name # Возвращает значение атрибута
person.name = value # Изменяет значение атрибута

 В большинстве случаев атрибуты присоединяются непосредственно
к объектам или наследуются от родительского класса.

 Однако иногда требуется обеспечить больше гибкости. Предположим,
что вы написали программу, которая обращается к атрибуту name
непосредственно, но затем вам потребовалось изменить ее, например
добавить логику проверки имен при присваивании атрибуту или обеспечить
получение видоизмененного имени при обращении к нему. Такого рода доступ
к значению атрибута легко реализовать с помощью методов (проверка
и преобразование в примере ниже выполняются абстрактно):


class Person:
    def getName(self):
        if not valid():
            raise TypeError('cannot fetch name')
        else:
            return self.name.transform()

    def setName(self, value):
        if not valid(value):
            raise TypeError('cannot change name')
        else:
            self.name = transform(value)


person = Person()
person.getName()
person.setName('valueэ')

 Однако в этом случае придется изменить программный код везде,
где производится обращение к атрибуту name, что может оказаться
не самой простой задачей. Кроме того, при таком подходе требуется
помнить, как экспортируются значения: как простые значения или
как вызовы методов. Если вы помните об этом и используете интерфейс
доступа к данным на основе методов, клиенты будут защищены от изменений,
 – в противном случае изменения могут стать источником проблем.

 Данная проблема может возникать гораздо чаще, чем можно было бы
ожидать. Значение ячейки в программе электронной таблицы, например,
может начинать свое существование как простое значение, но позднее
превратиться в поле, значение которого вычисляется по некоторой формуле.
Поскольку интерфейсы объектов должны быть достаточно гибкими,
чтобы поддерживать подобные изменения в будущем, не влияя
на работоспособность существующего программного кода, переход
к использованию методов выглядит не самым идеальным.


 Добавление программного кода, вызываемого при обращении к атрибуту

  Методы __getattr__ и __setattr__, которые вызываются при обращении
 к несуществующим атрибутам и при присваивании значений любым атрибутам.

  Метод __getattribute__, который вызывается при обращении к любым
 атрибутам в классах нового стиля в Python 2.6 и во всех классах
 в Python 3.0.

  Встроенная функция property, которая позволяет определить
 для отдельных атрибутов методы чтения и записи, – такие атрибуты
 часто называют свойствами.

  Протокол дескрипторов, который позволяет организовать доступ
 к отдельным атрибутам с помощью экземпляров классов с произвольными
 методами чтения и записи.


 Свойства

 Протокол свойств позволяет направлять операции чтения и записи
для отдельных атрибутов нашим функциям и методам, что позволяет нам
добавлять программный код, который будет вызываться автоматически
при попытках обращения к атрибуту, перехватывать операции удаления
атрибутов и возвращать описание атрибутов, в случае необходимости.

 Свойства создаются с помощью встроенной функции property
и присваиваются атрибутам классов, точно так же, как выполняется
присваивание функций методам. Кроме того, свойства наследуются
подклассами и экземплярами, как любые другие атрибуты класса. Функциям,
реализующим доступ к атрибутам, передается сам экземпляр в виде
аргумента self, что обеспечивает доступ к информации о состоянии объекта
и к атрибутам класса, доступным объекту экземпляра.

 Каждое свойство управляет доступом к единственному атрибуту – свойства
не могут перехватывать обращения ко всем атрибутам, однако они позволяют
нам управлять операциями чтения и записи и дают возможность превратить
атрибут из простого хранилища данных в значение, вычисляемое
по произвольной формуле, не оказывая влияния на работоспособность
существующего программного кода. Как мы увидим далее, свойства тесно
связаны с дескрипторами – фактически свойства являются ограниченной
разновидностью дескрипторов.


 Основы

 Свойство создается операцией присваивания атрибуту класса результата,
возвращаемого встроенной функцией:

attribute = property(fget, fset, fdel, doc)

 Ни один из аргументов этой функции не является обязательным, и все они
получают значение None по умолчанию. Если какой-то аргумент опущен, это
означает, что соответствующая ему операция не поддерживается, а попытка
выполнить ее приводит к исключению. При вызове функции в аргументе fget
передается функция, которая будет вызываться при попытке прочитать
значение атрибута, в аргументе fset – функция, которая будет вызываться
при попытке выполнить операцию присваивания,
и в аргументе fdel – функция, которая будет вызываться при попытке
удалить атрибут. В аргументе doc передается строка документирования
с описанием атрибута, если это необходимо (в противном случае
будет скопирована строка документирования из функции fget, если имеется,
которая по умолчанию получает значение None). Функция fget
должна возвращать вычисленное значение атрибута, а функции fset и fdel
ничего не должны возвращать (в действительности, они возвращают значение
None).

 Данная встроенная функция возвращает объект свойства, присваиваемый
имени атрибута, который будет находиться в области видимости класса
и наследоваться всеми его экземплярами.


 Первый пример

 Следующий класс демонстрирует, как это выглядит
в действующем программном коде. Он использует свойство для управления
доступом к атрибуту с именем name – фактические данные хранятся
в атрибуте с именем _name, благодаря чему исключается возможность
конфликта с именем свойства:
"""


class Person:                        # Используйте (object) в Python 2.6
    def __init__(self, name):
        self._name = name

    def getName(self):
        print('fetch...')
        return self._name

    def setName(self, value):
        print('change...')
        self._name = value

    def delName(self):
        print('remove...')
        del self._name

    name = property(getName, setName, delName, 'name property docs')


bob = Person('Bob Smith')   # Объект bob имеет управляемый атрибут
print(bob.name)             # Вызовет getName
bob.name = 'Robert Smith'   # Вызовет setName
print(bob.name)
del bob.name                # Вызовет delName
print('-'*20)
sue = Person('Sue Jones')   # Объект sue также наследует свойство
print(sue.name)
print(Person.name.__doc__)  # Или help(Person.name)

"""
 Данное конкретное свойство не делает ничего особенного – оно просто 
перехватывает обращения к атрибуту, но оно прекрасно демонстрирует 
действие протокола. Если запустить этот пример, он создаст 
два экземпляра, которые унаследуют свойство, как любой другой атрибут,
присоединенный к классу. Однако доступ к их атрибутам находится
под полным нашим контролем:

fetch...
Bob Smith
change...
fetch...
Robert Smith
remove...
--------------------
fetch...
Sue Jones
name property docs

 Как и все остальные атрибуты класса, свойства наследуются обоими 
экземплярами, а также подклассами, находящимися ниже в иерархии 
наследования. Если изменить пример, как показано ниже:


class Super:
    ...оригинальная реализация класса Person...
    name = property(getName, setName, delName, ‘name property docs’)
    
    
class Person(Super):
    pass # Унаследует свойства
    
    
bob = Person(‘Bob Smith’)
...остальной программный код остался без изменений...

 он выведет те же самые результаты – подкласс Person унаследовал 
свойство name от класса Super, а экземпляр bob получил его 
от класса Person. С точки зрения наследования, свойства действуют
 точно так же, как обычные методы, – они имеют доступ к экземпляру 
через аргумент self, поэтому они могут обращаться к информации
о состоянии экземпляра подобно методам, как демонстрируется 
в следующем разделе.


 Вычисляемые атрибуты

 Пример в предыдущем разделе просто выводит сообщения при обращении
к атрибуту. Однако обычно свойства реализуют более полезные действия, 
например динамически вычисляют значение атрибута при обращении к нему.
Эту возможность иллюстрирует следующий пример:
"""


class PropSquare:
    def __init__(self, start):
        self.value = start

    def getX(self):  # Операция получения атрибута
        return self.value ** 2

    def setX(self, value):  # Операция присваивания значения атрибуту
        self.value = value

    X = property(getX, setX)  # Операция удаления не поддерживается,
    # описание отсутствует


P = PropSquare(3)  # 2 экземпляра класса со свойством
Q = PropSquare(32)  # Каждый хранит собственное значение
print(P.X)  # 3 ** 2
P.X = 4
print(P.X)  # 4 ** 2
print(Q.X)  # 32 ** 2

"""
 Этот класс определяет атрибут X, к которому можно обращаться, 
как если бы это был атрибут со статическими данными, 
но в действительности вычисляет значение этого атрибута в момент 
обращения к нему. Этот эффект очень напоминает неявный вызов метода. 
В процессе работы этот фрагмент сохранит в экземпляре 
начальное значение, а потом, при каждой попытке обратиться 
к управляемому атрибуту, его значения автоматически возводятся 
в квадрат:

9
16
1024

 Обратите внимание, что мы создали два различных экземпляра – благодаря
тому, что методы свойства автоматически получают аргумент self, 
они получают доступ к информации, хранящейся в экземплярах. 
В нашем случае это означает, что вычисляется квадрат числа, 
хранящегося в объекте экземпляра.

 
 Определение свойств с помощью декораторов
 
 Мы познакомились с основами декораторов в главе 31, однако оставили 
изучение дополнительных подробностей до следующей главы. Вспомните 
синтаксис декораторов функций:

@decorator
def func(args): ...

 Он автоматически преобразуется интерпретатором в следующую конструкцию, 
которая повторно присваивает имени функции результат вызова декоратора:

def func(args): ...
func = decorator(func)

 Благодаря этой особенности встроенная функция property может играть 
роль декоратора, позволяющего определить функцию, которая автоматически 
будет вызываться при попытке получить значение атрибута:

class Person:
    @property
    def name(self): ... # Повторное присваивание: name = property(name)
    
 В процессе выполнения этого определения декорируемый метод
автоматически передается встроенной функции property в первом аргументе.
Фактически это всего лишь альтернативный синтаксис конструкции, 
которая создает свойство и повторно выполняет присваивание 
имени атрибута вручную:


class Person:
    def name(self): ...
    name = property(name)


 Начиная с версии Python 2.6, объекты свойств также обладают методами
getter, setter и deleter, которые присваивают соответствующие методы 
доступа к свойству и возвращают копию самого свойства. Мы можем 
использовать эти методы, чтобы определить компоненты свойств, декорируя
обычные методы, однако компонент getter обычно устанавливается 
автоматически, в процессе создания самого свойства:
"""


class Person:
    def __init__(self, name):
        self._name = name

    @property
    def name(self):  # name = property(name)
        """name property docs"""
        print('fetch...')
        return self._name

    @name.setter
    def name(self, value):  # name = name.setter(name)
        print('change...')
        self._name = value

    @name.deleter
    def name(self):  # name = name.deleter(name)
        print('remove...')
        del self._name


bob = Person('Bob Smith')  # Объект bob имеет управляемый атрибут
print(bob.name)  # Вызовет метод getter свойства name (name 1)
bob.name = 'Robert Smith'  # Вызовет метод setter свойства name (name 2)
print(bob.name)
del bob.name  # Вызовет метод deleter свойства name (name 3)
print('-'*20)
sue = Person('Sue Jones')  # Объект sue также наследует свойство
print(sue.name)
print(Person.name.__doc__)  # Или: help(Person.name)

"""
 Фактически этот программный код эквивалентен первому примеру в этом
разделе. В данном случае декорирование – это просто альтернативный
способ определения свойств. Если запустить этот пример, он выведет 
те же результаты:

fetch...
Bob Smith
change...
fetch...
Robert Smith
remove...
--------------------
fetch...
Sue Jones
name property docs


Дескрипторы

 Дескрипторы обеспечивают альтернативный способ управления доступом
к атрибутам. Они тесно связаны со свойствами, обсуждавшимися 
в предыдущем разделе. Фактически свойства являются разновидностью
дескрипторов. С технической точки зрения, встроенная функция property 
лишь упрощает способ создания дескриптора определенного типа, 
который вызывает функции, управляющие доступом к атрибутам.

 С функциональной точки зрения, протокол дескрипторов позволяет 
передавать выполнение операций чтения и записи для определенного 
атрибута методам отдельного объекта класса, что дает возможность 
определять программный код, который будет вызываться автоматически 
при попытках обращения к атрибуту, а также при выполнении операции 
удаления атрибута и получения его описания, если это необходимо.

 Дескрипторы создаются как независимые классы и присваиваются атрибутам
класса точно так же, как функции методов. Подобно любым другим атрибутам
классов они наследуются подклассами и экземплярами. Методы дескрипторов,
управляющие доступом, получают аргумент self со ссылкой 
на сам дескриптор и экземпляр клиентского класса. Благодаря этому 
они могут сохранять и использовать собственные данные, а также данные 
объекта экземпляра. Например, дескриптор может вызывать не только методы
клиентского класса, но и собственные методы, определенные 
в классе дескриптора.

 Подобно свойству дескриптор управляет доступом 
к единственному атрибуту – дескрипторы не могут использоваться 
для организации управления доступом сразу ко всем атрибутам, 
однако они позволяют управлять операциями чтения и записи 
и дают возможность превратить атрибут из простого хранилища данных 
в значение, вычисляемое по некоторой формуле, не оказывая влияния 
на работоспособность существующего программного кода. В действительности
свойства – это упрощенный способ создания дескрипторов 
определенного типа, и, как мы увидим ниже, они могут быть определены
непосредственно в виде дескрипторов.

 Возможности свойств достаточно ограничены, тогда как дескрипторы 
позволяют получить более общее решение. Например, благодаря тому, 
что дескрипторы определяются как обычные классы, они имеют собственные
данные, могут занимать место в иерархиях наследования дескрипторов, 
могут использовать прием композиции для агрегирования других объектов 
и предоставляют естественный способ задания внутренних методов 
и строк документирования атрибутов.


 Основы
 
 Как уже упоминалось выше, дескрипторы определяются в виде отдельных
классов и предоставляют методы доступа со специальными именами, 
реализующие операции доступа к атрибутам, – методы чтения, записи 
и удаления, определенные в классе дескриптора, будут вызываться 
автоматически при выполнении соответствующих операций над атрибутом,
после того как ему будет присвоен экземпляр класса дескриптора:


class Descriptor:
    “docstring goes here”
    def __get__(self, instance, owner): ...  
    # Возвращает значение атрибута
    def __set__(self, instance, value): ... 
    # Ничего не возвращает (None)
    def __delete__(self, instance): ...  # Ничего не возвращает (None)
    
    
 Классы с любыми из этих методов считаются дескрипторами, а их методы
становятся специальными, когда экземпляры этих классов присваиваются 
атрибутам других классов, – они будут вызываться автоматически 
при обращении к таким атрибутам. Если реализация какого-либо
из методов отсутствует, в общем случае это означает, что соответствующая
ему операция не поддерживается. Однако в отличие от свойств, 
отсутствие метода __set__ позволяет переопределить атрибут в экземпляре 
и тем самым отключить дескриптор – чтобы сделать атрибут доступным 
только для чтения, необходимо определить метод __set__, который 
будет перехватывать операции присваивания и возбуждать исключение.


 Аргументы методов дескриптора
 
 Прежде чем перейти к изучению действующих примеров, нам необходимо 
коротко познакомиться с некоторыми основами. Все три метода 
дескрипторов, представленные в предыдущем разделе, получают экземпляр 
класса дескриптора (self) и экземпляр клиентского класса, к которому
присоединен экземпляр дескриптора (instance).

 Метод __get__ дополнительно принимает аргумент owner, 
определяющий класс, к которому присоединен экземпляр дескриптора.
В аргументе instance ему передается экземпляр, к атрибуту которого 
выполняется обращение (instance.attr), или None, если обращение 
к атрибуту выполняется непосредственно через имя клиентского класса
(class.attr). В первом случае метод обычно возвращает вычисленное 
значение атрибута экземпляра, а во втором – значение self, 
если поддерживается доступ к объекту дескриптора. 

 Например, в следующем фрагменте, когда производится попытка получить
значение атрибута X.attr, интерпретатор автоматически вызывает 
метод __get__ класса Descriptor, который присвоен атрибуту Subject.attr
класса (как и в случае со свойствами, в Python 2.6 класс дескриптора 
должен наследовать супер-класс object – в Python 3.0 это наследование
подразумевается по умолчанию, хотя его указание и не повредит):
"""


class Descriptor(object):
    def __get__(self, instance, owner):
        print(self, instance, owner, sep='\n')


class Subject:
    attr = Descriptor()  # Атрибут класса – экземпляр класса Descriptor


X = Subject()
X.attr
Subject.attr

"""
 Обратите внимание на аргументы, которые автоматически передаются методу
__get__ в первой попытке получить значение атрибута, – выражение X.attr
как бы преобразуется в следующую конструкцию (хотя здесь обращение 
к Subject.attr не приводит к повторному вызову метода __get__):

X.attr -> Descriptor.__get__(Subject.attr, X, Subject)

 Дескриптор понимает, что была выполнена попытка обращения к самому 
дескриптору, когда получает значение None в аргументе instance.


 Дескрипторы атрибутов, доступных только для чтения
 
 Как уже упоминалось выше, в отличие от свойств, если в дескрипторе
просто опустить реализацию метода __set__, этого будет недостаточно 
для создания атрибута, доступного только для чтения, потому что 
имени атрибута экземпляра, которому присвоен дескриптор,
может быть присвоено любое другое значение. Ниже демонстрируется, 
что операция присваивания атрибуту X.a сохраняет присваиваемое значение
в атрибуте экземпляра X и тем самым отключает дескриптор, 
хранящийся в классе C:
"""


class D:
    def __get__(*args): print('get')


class C:
    a = D()


X = C()
X.a  # Вызовет метод __get__ унаследованного дескриптора

C.a

X.a = 99  # Сохранит значение в X, отключит C.a
print(X.a)

print(list(X.__dict__.keys()))

Y = C()
Y.a  # Y также наследует дескриптор

C.a

"""
 Именно так реализовано присваивание значений атрибутам экземпляров
в языке Python, и это позволяет экземплярам переопределять значения
по умолчанию в атрибутах классов. Чтобы с помощью дескриптора сделать 
атрибут доступным только для чтения, необходимо перехватить операцию
присваивания в классе дескриптора и возбудить исключение, чтобы 
предотвратить возможность присваивания. Когда выполняется присваивание 
атрибуту, который является дескриптором, интерпретатор фактически 
обходит обычную процедуру присваивания атрибутам экземпляров 
и обращается к объекту дескриптора:
"""


class D:
    def __get__(*args):
        print('get')
        
    def __set__(*args):
        raise AttributeError('cannot set')


class C:
    a = D()


X = C()
X.a  # Вызовет C.a.__get__

# X.a = 99  # Вызовет C.a.__set__
# AttributeError: cannot set

"""
 Кроме того, не путайте метод дескрипторов __delete__ с обычным методом 
__del__. Первый вызывается при попытке удалить управляемый атрибут 
экземпляра клиентского класса, тогда как второй является обычным методом
деструктора экземпляра, который вызывается, когда экземпляр 
любого класса утилизируется сборщиком мусора. Метод __delete__ 
более похож на метод __delattr__ удаления атрибутов, с которым 
мы познакомимся ниже в этой главе.


 Первый пример
 
 Чтобы рассмотреть, как все это действует в комплексе, 
на более реалистичном примере, начнем с того же примера, с которого 
мы начинали, когда знакомились со свойствами. Ниже приводится 
определение дескриптора, который управляет доступом к атрибуту name 
в клиентском классе. Для доступа к данным в объекте экземпляра, 
где фактически сохраняется строка с именем, его методы используют
аргумент instance.
"""


class Name:  # Используйте (object) в 2.6
    """name descriptor docs"""
    def __get__(self, instance, owner):
        print('fetch...')
        return instance._name

    def __set__(self, instance, value):
        print('change...')
        instance._name = value

    def __delete__(self, instance):
        print('remove...')
        del instance._name


class Person:  # Use (object) in 2.6
    def __init__(self, name):
        self._name = name
    name = Name()  # Присвоить атрибуту дескриптор


bob = Person('Bob Smith')  # Объект bob имеет управляемый атрибут
print(bob.name)  # Вызовет Name.__get__
bob.name = 'Robert Smith'  # Вызовет Name.__set__
print(bob.name)
del bob.name  # Вызовет Name.__delete__

print('-'*20)
sue = Person('Sue Jones')  # Объект sue также наследует дескриптор
print(sue.name)
print(Name.__doc__)  # Или: help(Name)

"""
 Обратите внимание, как в этом примере выполняется присваивание 
экземпляра класса дескриптора атрибуту класса клиентского класса – 
благодаря этому он будет унаследован всеми экземплярами класса, 
точно так же, как и методы класса. В действительности мы должны 
присвоить дескриптор атрибуту класса, как в данном случае, – 
если присвоить его атрибуту экземпляра self, дескриптор 
не будет работать. Когда вызывается метод __get__ дескриптора, 
ему передается три объекта, определяющие контекст вызова:

  self – экземпляр класса Name.
  
  instance – экземпляр класса Person.
  
  owner – класс Person.
  
 В процессе работы этого примера методы дескриптора будут перехватывать 
попытки обращения к атрибуту практически так же, как в версии примера
со свойствами. Фактически этот пример выведет те же результаты.

 Кроме того, как и в примере со свойствами, экземпляр класса дескриптора
является значением атрибута класса и потому будет унаследован всеми 
экземплярами клиентского класса и любыми подклассами. Если теперь 
изменить класс Person, как показано ниже, вывод сценария не изменится:

...
class Super:
    def __init__(self, name):
        self._name = name
    name = Name()
    
    
class Person(Super):  # Унаследует дескриптор
    pass
...

 Обратите также внимание, что если класс дескриптора не имеет 
практического применения за пределами клиентского класса, вполне разумно 
включить определение дескриптора внутрь клиентского класса. 
Ниже показано, как выглядит наш пример с использованием 
вложенного класса:
"""


class Person:
    def __init__(self, name):
        self._name = name

    class Name:  # Вложенный класс
        """name descriptor docs"""
        def __get__(self, instance, owner):
            print('fetch...')
            return instance._name

        def __set__(self, instance, value):
            print('change...')
            instance._name = value

        def __delete__(self, instance):
            print('remove...')
            del instance._name

        name = Name()


"""
 В этом случае имя Name становится локальной переменной в области 
видимости инструкции определения класса Person, благодаря этому оно 
не будет конфликтовать с именами за пределами класса. Данная версия 
действует точно так же, как и оригинал. Мы просто переместили 
определение класса дескриптора в область видимости клиентского класса – 
однако последнюю строку в программном коде, выполняющем тестирование, 
необходимо изменить, чтобы он извлекал строку документирования
из нового местоположения:
"""

print(Person.Name.__doc__)  # Изменено: за пределами класса
# имя Name.__doc__  больше недоступно

"""
 Вычисляемые атрибуты
 
 Как и в случае со свойствами, наш первый пример дескриптора 
из предыдущего раздела не делает ничего особенного – он просто выводит
сообщение при попытке обратиться к атрибуту. На практике дескрипторы 
часто используются для вычисления значений атрибутов при каждой попытке
обращения к ним. Ниже приводится переработанная версия того же самого
примера со свойствами, в котором с помощью дескриптора реализовано 
автоматическое возведение значения атрибута в квадрат при попытке 
получить его:
"""


class DescSquare:
    def __init__(self, start):  # Каждый дескриптор имеет свои данные
        self.value = start

    def __get__(self, instance, owner):  # Операция получения значения
        return self.value ** 2

    def __set__(self, instance, value):  # Операция присваивания
        self.value = value  # Операции удаления и получения описания
        #                     не поддерживаются


class Client1:
    X = DescSquare(3)  # Присвоить экземпляр дескриптора атрибуту класса


class Client2:
    X = DescSquare(32)  # Другой экземпляр в другом клиентском классе
    # Также можно было бы создать 2 экземпляра в одном классе


c1 = Client1()
c2 = Client2()
print(c1.X)  # 3 ** 2
c1.X = 4
print(c1.X)  # 4 ** 2
print(c2.X)  # 32 ** 2

"""
 Использование данных в дескрипторах
 
 Если внимательно изучить два примера дескрипторов, которые 
мы уже написали, можно заметить, что они получают информацию 
из разных мест: в первом примере они используют данные, хранящиеся 
в экземпляре клиентского класса (атрибут name), а во втором – данные, 
присоединенные непосредственно к объекту дескриптора (атрибут, значение
которого возводится в квадрат). Фактически дескрипторы могут 
одновременно использовать данные экземпляра и дескриптора или любые 
их комбинации:

  Данные дескриптора используются для управления внутренней работой 
 дескриптора.
 
  Данные экземпляра хранят информацию, связанную с клиентским классом 
 и, возможно, созданную этим классом.
 
 Методы дескриптора могут использовать любые данные, но когда
в дескрипторах определяются собственные атрибуты, часто бывает 
необязательным следовать специальным соглашениям об именовании, 
чтобы избежать конфликтов с именами атрибутов экземпляров. Например, 
следующий дескриптор определяет атрибуты собственных экземпляров, 
имена которых никак не конфликтуют с именами атрибутов 
клиентского класса:
"""


class DescState:  # Дескриптор использует собственный атрибут
    def __init__(self, value):
        self.value = value

    def __get__(self, instance, owner):  # Операция получения значения
        print('DescState get')
        return self.value * 10

    def __set__(self, instance, value):  # Операция присваивания
        print('DescState set')
        self.value = value


# Клиентский класс
class CalcAttrs:
    X = DescState(2)  # Дескриптор атрибута класса
    Y = 3  # Атрибут класса

    def __init__(self):
        self.Z = 4  # Атрибут экземпляра


obj = CalcAttrs()
print(obj.X, obj.Y, obj.Z)  # X - вычисляется, другие - нет
obj.X = 5                   # Операция присваивания X перехватывается
obj.Y = 6
obj.Z = 7
print(obj.X, obj.Y, obj.Z)

"""
 В этом примере атрибут value находится в области видимости дескриптора,
поэтому никаких конфликтов не возникнет, если в экземплярах клиентского
класса будет присутствовать атрибут с таким же именем. 
Обратите внимание, что здесь только один атрибут управляется 
дескриптором – перехватываются только операции чтения и записи 
над атрибутом X, доступ к атрибутам Y и Z никак не регулируется
(атрибут Y присоединен к клиентскому классу, а атрибут Z – 
к экземпляру). Если запустить этот пример, при обращении к атрибуту X 
его значение будет вычисляться динамически.

 Дескриптор точно так же может сохранять и использовать информацию 
в атрибутах экземпляра клиентского класса. В следующем примере 
дескриптор предполагает, что экземпляр имеет атрибут _Y, присоединенный
к клиентскому классу, и использует его для вычисления значения атрибута,
который он представляет:
"""


class InstState:  # Дескриптор использует атрибут экземпляра
    def __get__(self, instance, owner):
        print('InstState get')  # Предполагает наличие атрибута
        return instance._Y * 100  # в клиентском классе

    def __set__(self, instance, value):
        print('InstState set')
        instance._Y = value


# Клиентский класс
class CalcAttrs:
    X = DescState(2)  # Дескриптор атрибута класса
    Y = InstState()  # Дескриптор атрибута класса

    def __init__(self):
        self._Y = 3  # Атрибут экземпляра
        self.Z = 4  # Атрибут экземпляра


obj = CalcAttrs()
print(obj.X, obj.Y, obj.Z)  # X и Y - вычисляемые, Z - нет
obj.X = 5  # Присваивания атрибутам X и Y перехватываются
obj.Y = 6
obj.Z = 7
print(obj.X, obj.Y, obj.Z)

"""
 На этот раз дескрипторы присваиваются двум атрибутам, X и Y, 
и при попытке обратиться к ним их значения вычисляются динамически 
(атрибуту X присвоен экземпляр класса дескриптора 
из предыдущего примера). В этом примере определен новый дескриптор,
который не имеет собственных данных, но он использует атрибут, который,
как предполагается, существует в экземпляре; этот атрибут был назван _Y,
чтобы избежать конфликта с именем самого атрибута дескриптора.
Если запустить этот пример, он выведет похожие результаты, 
но на этот раз у нас имеется второй управляемый атрибут, 
значение которого вычисляется с учетом значения атрибута экземпляра,
а не самого дескриптора.

 Данные дескриптора и экземпляра выступают каждый в своей роли.
Фактически именно в этом заключается основное преимущество дескрипторов
перед свойствами – благодаря тому, что дескрипторы могут иметь 
собственные данные, они легко могут сохранять данные внутри себя,
не засоряя пространство имен клиентского объекта экземпляра.

 
 Взаимосвязь между свойствами и дескрипторами
 
 Как уже упоминалось выше, свойства и дескрипторы тесно связаны между 
собой – встроенная функция property является просто удобным способом 
создания дескриптора. Теперь, когда вы знаете, как действуют свойства
и дескрипторы, вы сможете также понять, как можно имитировать 
встроенную функцию property с помощью класса дескриптора:
"""


class Property:
    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel  # Сохранить несвязанные методы
        self.__doc__ = doc  # или другие вызываемые объекты

    def __get__(self, instance, instancetype=None):
        if instance is None:
            return self
        if self.fget is None:
            raise AttributeError('can’t get attribute')
        return self.fget(instance)  # Передать методу доступа экземпляр
    # в аргументе self

    def __set__(self, instance, value):
        if self.fset is None:
            raise AttributeError('can’t set attribute')
        self.fset(instance, value)

    def __delete__(self, instance):
        if self.fdel is None:
            raise AttributeError('can’t delete attribute')
        self.fdel(instance)


"""
class Person:
    def getName(self): ...
    def setName(self, value): ...
    name = Property(getName, setName) # Используется подобно property()
    

 Данный класс Property перехватывает операции доступа к атрибутам
с помощью протокола дескрипторов и передает их выполнение функциям 
или методам, сохраненным в самом дескрипторе в процессе создания класса. 
Операция получения значения атрибута, например, передается из класса 
Person методу __get__ класса Property и затем – методу getName 
класса Person. Благодаря дескрипторам этот прием «просто работает».

 Обратите внимание, что этот класс дескриптора имитирует только 
простейший случай использования функции property. Чтобы можно было 
использовать синтаксис декораторов @ и определять операции присваивания
и удаления, в наш класс Property следовало бы добавить методы 
setter и deleter, которые должны сохранять декорированную функцию 
доступа и возвращать объект свойства (self – вполне достаточно). 
Поскольку все это уже реализовано во встроенной функции property,
мы не будем продолжать доработку нашего класса.

 Обратите внимание, что дескрипторы также используются в языке Python 
для реализации атрибута __slots__ – при обращении к именам в слотах 
словари атрибутов экземпляров не просматриваются интерпретатором,
потому что эти операции перехватываются с помощью дескрипторов,
хранящихся на уровне класса.

 В главе 38 дескрипторы будут использоваться для реализации декораторов 
функций, которые могут применяться как к функциям, так и к методам.
Как вы узнаете в этой главе, благодаря тому, что дескрипторы получают
ссылку на сам дескриптор и на объект экземпляра класса, они прекрасно 
справляются с этой ролью, хотя вложенные функции позволяют получить 
более простое решение.
"""

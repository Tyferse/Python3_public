"""
 Пример: проверка атрибутов


 Использование свойств для проверки

 Наш первый пример реализует управление атрибутами с помощью свойств.
Как обычно, вместо управляемых атрибутов мы могли бы использовать
обычные методы, но свойства помогут нам, если атрибуты уже используются
где-то в существующем программном коде. Свойства позволяют автоматически
вызывать программный код при обращении к ним, но они могут применяться
только к отдельным атрибутам – свойства не позволяют перехватывать
обращения к атрибутам обобщенным способом.

 Для понимания этого примера крайне важно отметить, что операции
присваивания значений атрибутам в конструкторе __init__ также вызывают
методы записи свойств. Например, когда в конструкторе выполняется
присваивание значения атрибуту self.name, эта операция вызывает метод
setName, который преобразует значение и сохраняет его в атрибуте
экземпляра с именем __name, благодаря чему исключается конфликт
с именем свойства.

 Такое переименование (иногда называется искажением имен) необходимо
потому, что свойства не имеют своих данных и используют данные
экземпляра. Фактические данные всегда хранятся в атрибуте с именем
__name, а атрибут с именем name – это свойство, а не данные.

 Наконец, этот класс реализует управление атрибутами с именами name, age
и acct, обеспечивает прямой доступ к атрибуту addr и реализует атрибут
remain, доступный только для чтения, который фактически является
виртуальным атрибутом, значение которого вычисляется по требованию.
"""


class CardHolder:
    acctlen = 8  # Данные класса
    retireage = 59.5

    def __init__(self, acct, name, age, addr):
        self.acct = acct  # Данные экземпляра
        self.name = name  # Эти операции вызывают методы записи свойств
        self.age = age  # К именам вида __X добавляется имя класса
        self.addr = addr  # addr – неуправляемый атрибут
        # remain – не имеет фактических данных

    def getName(self):
        return self.__name

    def setName(self, value):
        value = value.lower().replace(' ', '_')
        self.__name = value
    name = property(getName, setName)

    def getAge(self):
        return self.__age

    def setAge(self, value):
        if value < 0 or value > 150:
            raise ValueError('invalid age')
        else:
            self.__age = value
    age = property(getAge, setAge)

    def getAcct(self):
        return self.__acct[:-3] + '***'

    def setAcct(self, value):
        value = value.replace('-', '')
        if len(value) != self.acctlen:
            raise TypeError('invald acct number')
        else:
            self.__acct = value
    acct = property(getAcct, setAcct)

    def remainGet(self):  # Можно было бы реализовать как
        return self.retireage - self.age
        # метод, если нигде не используется
    remain = property(remainGet)  # как атрибут


"""
 Программный код самопроверки

 Ниже приводится фрагмент программного кода, тестирующего наш класс, –
добавьте его в конец файла или поместите определение класса в модуль 
и импортируйте его. Во всех четырех версиях этого примера мы будем 
использовать один и тот же программный код самопроверки. Он создает 
два экземпляра класса с управляемыми атрибутами и извлекает и изменяет 
значения его атрибутов. Операции, которые могут вызвать исключение, 
обернуты в инструкции try:
"""

bob = CardHolder('1234-5678', 'Bob Smith', 40, '123 main st')
print(bob.acct, bob.name, bob.age, bob.remain, bob.addr, sep=' / ')
bob.name = 'Bob Q. Smith'
bob.age = 50
bob.acct = '23-45-67-89'
print(bob.acct, bob.name, bob.age, bob.remain, bob.addr, sep=' / ')
sue = CardHolder('5678-12-34', 'Sue Jones', 35, '124 main st')
print(sue.acct, sue.name, sue.age, sue.remain, sue.addr, sep=' / ')
try:
    sue.age = 200
except:
    print('Bad age for Sue')
try:
    sue.remain = 5
except:
    print('Can’t set sue.remain')
try:
    sue.acct = '1234567'
except:
    print('Bad acct for Sue')


"""
 Напомню, что все четыре версии этого примера дают одни и те же
результаты. Внимательно изучите их, чтобы понять, как вызываются методы
класса – в учетных номерах вместо некоторых цифр отображаются звездочки,
имена преобразуются в стандартный формат, а время, оставшееся до выхода 
на пенсию, вычисляется с использованием атрибута класса.


 Использование дескрипторов для проверки
 
 Теперь реализуем пример с применением дескрипторов вместо свойств. 
Как мы уже знаем, дескрипторы очень похожи на свойства в смысле 
функциональности и области применения – фактически свойства по сути
являются ограниченной формой дескрипторов. Подобно свойствам дескрипторы
предназначены для обработки отдельных атрибутов – они не позволяют 
реализовать обобщенное управление сразу всеми атрибутами. В отличие 
от свойств, дескрипторы могут хранить собственные данные и обеспечивают 
более универсальное решение.

 Для понимания этого примера снова важно отметить, что операции 
присваивания значений атрибутам в конструкторе __init__ также вызывают 
методы __set__ дескрипторов. Например, когда в конструкторе выполняется 
присваивание значения атрибуту self.name, эта операция автоматически 
вызывает метод Name.__set__(), который преобразует значение и сохраняет
его в атрибуте name дескриптора.

 Однако в отличие от предыдущей версии, в данном случае атрибут name 
с фактическим значением присоединяется к объекту дескриптора, 
а не к экземпляру клиентского класса. Конечно, мы могли бы реализовать 
хранение фактических значений и в экземпляре, однако сохранение данных 
в дескрипторе позволяет нам избежать необходимости искажать имена, 
добавлением символов подчеркивания во избежание конфликтов. 
В клиентском классе CardHolder атрибут с именем name всегда представляет
дескриптор, а не фактические данные.

 Наконец, этот класс реализует управление теми же атрибутами, 
что и класс в предыдущей версии примера: он управляет атрибутами 
с именами name, age и acct, обеспечивает прямой доступ к атрибуту addr 
и реализует атрибут remain, доступный только для чтения, 
который фактически является виртуальным атрибутом, значение которого 
вычисляется по требованию. Обратите внимание, что попытки выполнить 
присваивание атрибуту remain должны перехватываться его дескриптором 
и возбуждать исключение – как мы узнали выше, если этого не сделать, 
операция присваивания создаст обычный атрибут экземпляра, 
который отменит действие дескриптора атрибута класса.
"""


class CardHolder:
    acctlen = 8  # Данные класса
    retireage = 59.5

    def __init__(self, acct, name, age, addr):
        self.acct = acct  # Данные экземпляра
        self.name = name  # Эти операции вызывают методы __set__
        self.age = age  # Имена вида __X не требуются в дескрипторах
        self.addr = addr  # addr – неуправляемый атрибут
        # remain – не имеет фактических данных

    class Name:
        def __get__(self, instance, owner):  # Класс имен: локальный для
            return self.name  # CardHolder

        def __set__(self, instance, value):
            value = value.lower().replace(' ', '_')
            self.name = value
    name = Name()

    class Age:
        def __get__(self, instance, owner):
            return self.age  # Данные дескриптора

        def __set__(self, instance, value):
            if value < 0 or value > 150:
                raise ValueError('invalid age')
            else:
                self.age = value
    age = Age()

    class Acct:
        def __get__(self, instance, owner):
            return self.acct[:-3] + '***'

        def __set__(self, instance, value):
            value = value.replace('-', '')
            if len(value) != instance.acctlen:  # Данные экземпляра
                raise TypeError('invald acct number')
            else:
                self.acct = value
    acct = Acct()

    class Remain:
        def __get__(self, instance, owner):
            return instance.retireage - instance.age
            # Вызовет Age.__get__

        def __set__(self, instance, value):
            raise TypeError('cannot set remain')
            # При необходимости здесь
    remain = Remain()  # можно реализовать операцию присваивания


bob = CardHolder('1234-5678', 'Bob Smith', 40, '123 main st')
print(bob.acct, bob.name, bob.age, bob.remain, bob.addr, sep=' / ')
bob.name = 'Bob Q. Smith'
bob.age = 50
bob.acct = '23-45-67-89'
print(bob.acct, bob.name, bob.age, bob.remain, bob.addr, sep=' / ')
sue = CardHolder('5678-12-34', 'Sue Jones', 35, '124 main st')
print(sue.acct, sue.name, sue.age, sue.remain, sue.addr, sep=' / ')
try:
    sue.age = 200
except:
    print('Bad age for Sue')
try:
    sue.remain = 5
except:
    print('Can’t set sue.remain')
try:
    sue.acct = '1234567'
except:
    print('Bad acct for Sue')

"""
 Использование метода __getattr__ для проверки
 
 Как мы уже знаем, метод __getattr__ перехватывает попытки обратиться
к любым неопределенным атрибутам, поэтому на его основе можно 
реализовать более обобщенный способ управления атрибутами, 
чем с применением свойств или дескрипторов. В нашем примере 
мы просто будем проверять имена атрибутов, чтобы отличать управляемые 
атрибуты от всех остальных, – другие атрибуты будут физически храниться 
в экземпляре и потому при попытках получить их значения метод 
__getattr__ вызываться не будет. Хотя такой подход является более 
универсальным, чем с использованием свойств или дескрипторов, 
тем не менее, он может потребовать приложить больше усилий, 
чтобы имитировать действие других, более специализированных 
инструментов. Во время выполнения нам необходимо будет проверять имена 
атрибутов, и мы должны определить метод __setattr__, чтобы реализовать 
проверку допустимости операций присваивания значений атрибутам.

 Как и в версиях этого примера, основанных на применении свойств 
и дескрипторов, важно отметить, что операции присваивания значений
атрибутам в конструкторе __init__ вызывают метод __setattr__ класса. 
Например, когда в конструкторе выполняется присваивание значения 
атрибуту self.name, эта операция автоматически вызывает метод 
__setattr__, который преобразует значение и сохраняет его 
в атрибуте name. Сохранение имени в атрибуте name экземпляра 
гарантирует, что последующие обращения к нему не будут приводить 
к вызову метода __getattr__. Значение атрибута acct, напротив, 
сохраняется в фактическом атрибуте _acct, поэтому все последующие 
попытки обращения к нему будут вызывать метод __getattr__.

 Наконец, этот класс, как и два предыдущих, реализует управление 
атрибутами с именами name, age и acct, обеспечивает прямой доступ 
к атрибуту addr и реализует атрибут remain, доступный только для чтения,
который фактически является виртуальным атрибутом, значение которого 
вычисляется по требованию.

 Вероятно, здесь более важна роль программного кода: обобщенные 
инструменты, такие как метод __getattr__, лучше подходят для реализации
шаблона делегирования, тогда как свойства и дескрипторы более 
предназначены для управления конкретными атрибутами.

 Обратите также внимание, что при присваивании значений неуправляемым
атрибутам (таким как addr) в этой реализации выполняются дополнительные
вызовы, но при обращении к неуправляемым атрибутам таких дополнительных 
вызовов не производится, поскольку они физически существуют 
в экземпляре. В большинстве случаев применение свойств и дескрипторов, 
вероятно, приведет к некоторому снижению производительности, 
тем не менее, при их использовании дополнительные вызовы производятся
только при попытках обращения к управляемым атрибутам.
"""


class CardHolder:
    acctlen = 8  # Данные класса
    retireage = 59.5

    def __init__(self, acct, name, age, addr):
        self.acct = acct  # Данные экземпляра
        self.name = name  # Эти операции вызывают метод __setattr__
        self.age = age  # _acct не искажается: проверяемое имя
        self.addr = addr  # addr – неуправляемый атрибут
        # remain – не имеет фактических данных

    def __getattr__(self, name):
        if name == 'acct':  # Вызывается для неопределенных атрибутов
            return self._acct[:-3] + '***'
            # name, age, addr - определены
        elif name == 'remain':
            return self.retireage - self.age  # Не вызывает __getattr__
        else:
            raise AttributeError(name)

    def __setattr__(self, name, value):
        if name == 'name':  # Вызывается всеми операциями присваивания
            value = value.lower().replace(' ', '_')
            # addr сохраняется непосредственно
        elif name == 'age':  # acct изменено на _acct
            if value < 0 or value > 150:
                raise ValueError('invalid age')
        elif name == 'acct':
            name = '_acct'
            value = value.replace('-', '')
            if len(value) != self.acctlen:
                raise TypeError('invald acct number')
        elif name == 'remain':
            raise TypeError('cannot set remain')
        self.__dict__[name] = value  # Предотвращение зацикливания


bob = CardHolder('1234-5678', 'Bob Smith', 40, '123 main st')
print(bob.acct, bob.name, bob.age, bob.remain, bob.addr, sep=' / ')
bob.name = 'Bob Q. Smith'
bob.age = 50
bob.acct = '23-45-67-89'
print(bob.acct, bob.name, bob.age, bob.remain, bob.addr, sep=' / ')
sue = CardHolder('5678-12-34', 'Sue Jones', 35, '124 main st')
print(sue.acct, sue.name, sue.age, sue.remain, sue.addr, sep=' / ')
try:
    sue.age = 200
except:
    print('Bad age for Sue')
try:
    sue.remain = 5
except:
    print('Can’t set sue.remain')
try:
    sue.acct = '1234567'
except:
    print('Bad acct for Sue')

"""
 Использование метода __getattribute__ для проверки
 
 Наша заключительная версия основана на использовании метода
__getattribute__, который перехватывает все попытки обращения 
к атрибутам и реализует управление ими в случае необходимости. 
Этот метод перехватывает обращения к любым атрибутам, поэтому мы будем
проверять имена атрибутов, чтобы отличать управляемые атрибуты от всех
остальных и делегировать чтение остальных атрибутов супер-классу.
В этой версии используется точно такой же метод __setattr__, 
как и в предыдущей версии, который перехватывает операции присваивания
значений.

 Эта версия действует практически так же, как и предыдущая, 
на основе метода __getattr__, поэтому я не буду повторять полное 
ее описание. Тем не менее, обратите внимание, что в этой версии метод 
__getattribute__ перехватывает обращения ко всем атрибутам, поэтому
здесь нам не требуется искажать имена, чтобы перехватить обращения к ним
(атрибут acct хранится под своим именем acct). С другой стороны, 
в этой версии необходимо переадресовать операцию чтения значений 
неуправляемых атрибутов супер-классу, чтобы избежать зацикливания.

 Обратите также внимание, что в этой версии выполняются дополнительные
вызовы методов как при чтении, так и при присваивании значений
неуправляемым атрибутам (таким, как addr), – с точки зрения скорости
выполнения, эта версия может оказаться самой медленной.
"""


class CardHolder:
    acctlen = 8  # Данные класса
    retireage = 59.5

    def __init__(self, acct, name, age, addr):
        self.acct = acct  # Данные экземпляра
        self.name = name  # Эти операции вызывают метод __setattr__
        self.age = age  # acct не искажается: проверяемое имя
        self.addr = addr  # addr – неуправляемый атрибут
        # remain – не имеет фактических данных

    def __getattribute__(self, name):
        superget = object.__getattribute__
        # Не зацикливается: на уровень выше

        if name == 'acct':  # Вызывается для всех атрибутов
            return superget(self, 'acct')[: -3] + ' *** '
        elif name == 'remain':
            return superget(self, 'retireage') - superget(self, 'age')
        else:
            return superget(self, name)  # name, age, addr: сохраняются

    def __setattr__(self, name, value):
        if name == 'name':  # Вызывается всеми операциями присваивания
            value = value.lower().replace(' ', '_')
            # addr сохраняется непоср.
        elif name == 'age':
            if value < 0 or value > 150:
                raise ValueError('invalid age')
        elif name == 'acct':
            value = value.replace('-', '')
            if len(value) != self.acctlen:
                raise TypeError('invald acct number')
            elif name == 'remain':
                raise TypeError('cannot set remain')
        self.__dict__[name] = value
        # Предотвращение зацикливания, исх. имена


bob = CardHolder('1234-5678', 'Bob Smith', 40, '123 main st')
print(bob.acct, bob.name, bob.age, bob.remain, bob.addr, sep=' / ')
bob.name = 'Bob Q. Smith'
bob.age = 50
bob.acct = '23-45-67-89'
print(bob.acct, bob.name, bob.age, bob.remain, bob.addr, sep=' / ')
sue = CardHolder('5678-12-34', 'Sue Jones', 35, '124 main st')
print(sue.acct, sue.name, sue.age, sue.remain, sue.addr, sep=' / ')
try:
    sue.age = 200
except:
    print('Bad age for Sue')
try:
    sue.remain = 5
except:
    print('Can’t set sue.remain')
try:
    sue.acct = '1234567'
except:
    print('Bad acct for Sue')

"""
 Программирование декораторов классов

 До сих пор мы создавали декораторы, которые управляют вызовами функций,
но, как мы уже знаем, в Python 2.6 и 3.0 возможности декораторов были
расширены, и теперь они могут применяться и к классам. Как описывалось
выше, в отличие от декораторов функций, декораторы классов применяются
к классам – они могут использоваться для управления самими классами
или для перехвата операций создания экземпляров и реализации управления
ими. Кроме того, подобно декораторам функций декораторы классов
в действительности являются всего лишь синтаксическим подсластителем,
хотя принято считать, что они делают намерения программиста более
очевидными и минимизируют количество ошибочных вызовов.


 Классы одиночных экземпляров

 Поскольку декораторы классов способны перехватывать операции создания
экземпляров, они могут использоваться для управления всеми экземплярами
класса или расширять интерфейс каждого экземпляра в отдельности.
Для демонстрации сказанного ниже приводится первый пример декоратора
класса, который реализует первый случай – управление всеми экземплярами
класса. Этот пример реализует классический шаблон проектирования
singleton (одиночка1), когда в каждый конкретный момент во время работы
программы может существовать не более одного экземпляра класса. Функция
singleton в примере определяет и возвращает другую функцию, которая
управляет экземплярами, а применение синтаксиса @ автоматически
обертывает декорируемый класс этой функцией:
"""

instances = {}


def getInstance(aClass, *args):  # Управляет глобальной таблицей
    if aClass not in instances:  # Добавьте **kargs, чтобы обрабатывать
        # именованные аргументы
        instances[aClass] = aClass(*args)
        # По одному элементу словаря для каждого класса
        
    return instances[aClass]


def singleton(aClass):  # На этапе декорирования
    def onCall(*args):  # На этапе создания экземпляра
        return getInstance(aClass, *args)
    
    return onCall


"""
 Чтобы воспользоваться этой функцией, достаточно применить ее как 
декоратор к классу, количество экземпляров которого должно быть 
не больше одного:
"""


@singleton
class Person:  # Присвоит onCall имени Person
    def __init__(self, name, hours, rate):  # onCall сохранит Person
        self.name = name
        self.hours = hours
        self.rate = rate

    def pay(self):
        return self.hours * self.rate


@singleton  # Spam = singleton(Spam)
class Spam:  # Присвоит onCall имени Spam
    def __init__(self, val):  # onCall сохранит Spam
        self.attr = val


bob = Person('Bob', 40, 10)  # В действительности вызовет onCall
print(bob.name, bob.pay())
sue = Person('Sue', 50, 20)  # Тот же единственный объект
print(sue.name, sue.pay())

X = Spam(42)  # Один экземпляр Person, один – Spam
Y = Spam(99)
print(X.attr, Y.attr)

"""
 Теперь, когда позднее классы Person и Spam будут использоваться 
для создания экземпляров, логика декоратора, обертывающая операцию 
создания экземпляров, передаст управление функции onCall, которая 
в свою очередь вызовет функцию getInstance, создающую и возвращающую 
единственный экземпляр класса независимо от количества попыток 
создать экземпляр.

 Интересно отметить, что здесь можно было бы предложить более автономное
решение, если бы имелась возможность использовать инструкцию nonlocal,
позволяющую изменять переменные в области видимости объемлющей функции. 
Следующее альтернативное решение достигает желаемого эффекта за счет 
использования отдельной области видимости для каждого класса вместо 
единой глобальной таблицы, в которой отводится по одному элементу
для каждого класса:
"""


def singleton(aClass):  # На этапе декорирования
    instance = None

    def onCall(*args):  # На этапе создания экземпляра
        nonlocal instance  # nonlocal доступна в 3.0 и выше
        
        if not instance:
            instance = aClass(*args)  # По одной области видимости
            return instance  # на каждый класс
        
    return onCall


"""
 Эта версия действует точно так же, но она уже не зависит от имен 
в глобальной области видимости за пределами декоратора. Имеется
возможность реализовать подобное автономное решение, которое будет 
действовать в обеих версиях Python, 2.6 и 3.0, – с применением класса.
В следующем примере вместо областей видимости или глобальной таблицы 
создается по одному экземпляру на каждый класс. Он действует 
точно так же, как и две другие версии (Фактически он опирается на тот же
самый шаблон проектирования, который мы увидим далее в разделе «Ошибки 
при использовании классов II: сохранение множества экземпляров» ниже. 
Здесь нам требуется получить единственный экземпляр, но это лишь 
частный случай):
"""


class Singleton:
    def __init__(self, aClass):  # На этапе декорирования
        self.aClass = aClass
        self.instance = None

    def __call__(self, *args):  # На этапе создания экземпляра
        if not self.instance:
            self.instance = self.aClass(*args)
            # По одному экземпляру на класс
            
        return self.instance


"""
 Изменение интерфейсов объектов
 
 Пример в предыдущем разделе продемонстрировал возможность использования 
декоратора классов для управления всеми экземплярами класса. Другой
распространенный случай использования декораторов классов – расширение
интерфейса каждого отдельного экземпляра. Декораторы классов могут 
добавлять к экземплярам обертывающий уровень логики, которая некоторым 
способом организует доступ к интерфейсам.

 Для справки ниже приводится оригинальный пример, не использующий 
декораторы, где демонстрируется работа с объектами двух встроенных 
типов:
"""


class Wrapper:
    def __init__(self, obj):
        self.wrapped = obj  # Сохранить объект

    def __getattr__(self, attrname):
        print('Trace:', attrname)
        # Сообщить о попытке получить значение
        return getattr(self.wrapped, attrname)
        # Делегировать выполнение операции


x = Wrapper([1, 2, 3])  # Обернуть список
x.append(4)  # Делегирует операцию методу списка

print(x.wrapped)  # Вывести элементы
x = Wrapper({'a': 1, 'b': 2})  # Обернуть словарь
print(list(x.keys()))  # Делегирует операцию методу словаря

"""
 В этом примере класс Wrapper перехватывает попытки обращения к любым
атрибутам обернутого объекта, выводит трассировочные сообщения 
и использует встроенную функцию getattr для передачи запросов обернутому 
объекту. В частности, он отслеживает попытки доступа к атрибутам, 
которые выполняются за пределами класса обернутого объекта, – обращения,
выполняемые внутри обернутого объекта, не перехватываются и выполняются,
как предусмотрено реализацией. Такая модель обертывания всего интерфейса
отличается от поведения декораторов функций, которые обертывают один 
определенный метод.

 Декораторы классов обеспечивают альтернативный и не менее удобный 
способ реализовать прием, основанный на применении метода __getattr__, 
для обертывания всего интерфейса. В Python 2.6 и 3.0, например, 
предыдущий пример класса может быть реализован в виде декоратора класса,
который вмешивается в процесс создания экземпляра, вместо того чтобы 
передавать предварительно созданный экземпляр конструктору 
класса-обертки (а также дополнен конструкцией **kargs, дающей 
возможность принимать именованные аргументы, и счетчиком общего числа 
обращений):
"""


def Tracer(aClass):  # На этапе декорирования @
    class Wrapper:
        def __init__(self, *args, **kargs):
            # На этапе создания экземпляра
            self.fetches = 0
            self.wrapped = aClass(*args, **kargs)  # Использует имя в

        def __getattr__(self, attrname):  # объемлющей области
            print('Trace: ' + attrname)  # Перехватывает обращения ко
            self.fetches += 1  # всем атрибутам, кроме своих
            return getattr(self.wrapped, attrname)
            
    return Wrapper  # Делегирует обращения обернутому объекту


@Tracer
class Spam:  # Spam = Tracer(Spam)
    def display(self):  # Имени Spam присваивается экземпляр Wrapper
        print('Spam!' * 8)


@Tracer
class Person:  # Person = Tracer(Person)
    def __init__(self, name, hours, rate):  # Wrapper сохраняет Person
        self.name = name
        self.hours = hours
        self.rate = rate

    def pay(self):  # Доступ извне перехватывается
        return self.hours * self.rate  # Изнутри – не перехватывается


food = Spam()  # Вызовет Wrapper()
food.display()  # Вызовет __getattr__
print([food.fetches])

bob = Person('Bob', 40, 50)
# bob – в действительности экземпляр Wrapper
print(bob.name)  # экземпляр Person встраивается во Wrapper
print(bob.pay())

print('')
sue = Person('Sue', rate=100, hours=60)
# sue – другой экземпляр Wrapper
print(sue.name)  # с другим экземпляром Person
print(sue.pay())

print(bob.name)  # Состояние bob отличается
print(bob.pay())
print([bob.fetches, sue.fetches])  # Атрибуты Wrapper не отслеживаются

"""
 Важно отметить, что этот пример существенно отличается от декоратора
tracer, с которым мы встречались выше. В разделе «Программирование 
декораторов функций» выше мы рассматривали декораторы, которые позволяют
отслеживать и хронометрировать отдельные функции или методы. В отличие
от него представленный здесь декоратор класса, перехватывающий операции
создания экземпляров, позволяет отслеживать попытки обращения ко всему
интерфейсу объекта, то есть попытки доступа к любым его атрибутам.

 Попытки получить значения атрибутов экземпляров обоих классов, 
Spam и Person, запускают логику метода __getattr__ в классе Wrapper,
потому что в действительности объекты food и bob являются экземплярами
класса Wrapper благодаря тому, что операции создания экземпляров были
перехвачены декоратором.

 Обратите внимание, что в предыдущем примере декорировался
пользовательский класс. Однако точно так же, как и в оригинальном 
примере в главе 30, мы можем использовать декоратор для обертывания 
встроенных типов, таких как list, если при этом мы создадим подкласс,
что позволит нам применить синтаксис декораторов, или выполним 
декорирование вручную – синтаксис декораторов требует, чтобы вслед за 
строкой с именем декоратора, начинающегося символом @, следовала 
инструкция class.

 В следующем примере x в действительности является экземпляром класса
Wrapper из-за того, что было выполнено косвенное декорирование.
"""


@Tracer
class MyList(list):
    pass  # MyList = Tracer(MyList)


x = MyList([1, 2, 3])  # Вызовет Wrapper()
x.append(4)  # Вызовет __getattr__, append

print(x.wrapped)

WrapList = Tracer(list)  # Декорирование выполняется вручную
x = WrapList([4, 5, 6])  # В противном случае потребовалось бы
x.append(7)  # определить подкласс

print(x.wrapped)

"""
 Прием на основе декоратора позволяет поместить процедуру создания 
экземпляра непосредственно в декоратор и тем самым избавиться 
от необходимости создавать экземпляр предварительно. Даже при том,
что разница на первый взгляд кажется незначительной, тем не менее, 
декораторы позволяют сохранить привычный синтаксис создания экземпляров 
и одновременно пользоваться всеми преимуществами декораторов.
Вместо того чтобы передавать все созданные экземпляры конструктору 
класса-обертки вручную, нам достаточно всего лишь добавить декоратор 
перед определением класса.

 Представьте, что вам требуется создать множество экземпляров класса. 
Применение декораторов в подобных ситуациях принесет вам чистую победу 
как в смысле размера программного кода, так и в смысле простоты его
сопровождения.

 Ошибки при использовании классов II: сохранение множества экземпляров

 Любопытно отметить, что функция декоратора в этом примере практически
полностью реализована не как функция, а как класс с соответствующим 
методом перегрузки операторов. Ниже приводится несколько упрощенная 
альтернатива, действующая похожим способом, потому что ее метод __init__ 
вызывается в момент применения декоратора @ к классу, а метод __call__ 
вызывается при создании экземпляра декорируемого класса. На этот раз 
наши объекты в действительности являются экземплярами класса Tracer,
и здесь мы, по сути, лишь заменили объемлющую область видимости 
атрибутами экземпляра:
"""


class Tracer:
    def __init__(self, aClass):  # На этапе декорирования @
        self.aClass = aClass  # Использует атрибуты экземпляра

    def __call__(self, *args):  # На этапе создания экземпляра
        self.wrapped = self.aClass(*args)  # ЕДИНСТВЕННЫЙ (ПОСЛЕДНИЙ)
        return self  # ЭКЗЕМПЛЯР ДЛЯ КАЖДОГО КЛАССА!

    def __getattr__(self, attrname):
        print('Trace: ' + attrname)
        return getattr(self.wrapped, attrname)


@Tracer  # Вызовет __init__
class Spam:  # То же, что и Spam = Tracer(Spam)
    def display(self):
        print('Spam!' * 8)


food = Spam()  # Вызовет __call__
food.display()  # Вызовет __getattr__

"""
 Однако как мы уже видели ранее, эта альтернатива, основанная 
исключительно на использовании класса, может применяться к множеству 
классов, как и прежде, но она не обеспечивает возможность создания 
множества экземпляров для каждого конкретного класса: каждая операция
создания экземпляра будет вызывать метод __call__, который будет
затирать ссылку на предыдущий экземпляр. В результате экземпляр класса
Tracer будет сохранять единственный экземпляр декорируемого класса,
созданный последним. Поэкспериментируйте с этим примером самостоятельно,
чтобы понять, как это происходит, а ниже приводится пример, 
иллюстрирующий проблему:
"""


@Tracer
class Person2:  # Person = Tracer(Person)
    def __init__(self, name):  # Имени Person присваивается Wrapper
        self.name = name


bob = Person2('Bob')  # bob – экземпляр класса Wrapper
print(bob.name)
# экземпляр класса Wrapper содержит экземпляр класса Person
Sue = Person2('Sue')
print(sue.name)  # объект sue затер объект bob
print(bob.name)  # ОЙ: теперь Боба зовут ‘Sue’!

"""
 Проблема здесь заключается в некорректной реализации сохранения 
информации о состоянии – интерпретатор создает по одному экземпляру 
декоратора для каждого класса, а не для каждого экземпляра класса, 
поэтому сохраняется только последний созданный экземпляр. Решение 
этой проблемы точно такое же, как и в предыдущем разделе, описывающем 
ошибки при использовании классов для декорирования методов, – отказаться
от реализации декораторов в виде классов.

 Предыдущая версия декоратора Tracer на основе функции поддерживает 
возможность создания множества экземпляров, потому что для каждого 
создаваемого экземпляра создается новый экземпляр Wrapper, что исключает
возможность затирания единственного общего экземпляра Tracer. 
Оригинальная версия примера, не использующая декоратор, обеспечивает 
возможность создания множества экземпляров по той же причине. Декораторы 
могут быть не только чрезвычайно удобными, но и порождать трудноуловимые 
ошибки!


 Декораторы и управляющие функции
 
 Независимо от подобных тонкостей пример декоратора классов Tracer 
все так же целиком опирается на использование метода __getattr__ 
для перехвата обращений к обернутому и встроенному объекту экземпляра.
Как мы уже поняли ранее, все, чего мы достигли, – это лишь перенесли 
операцию создания экземпляра в класс, вместо того, чтобы передавать 
уже готовый экземпляр управляющей функции. В оригинальном примере 
трассировщика, не использующем декоратор, мы могли бы просто немного 
иначе реализовать создание экземпляров:


class Spam: # Версия, не использующая декоратор
    ... # Это может быть любой класс


food = Wrapper(Spam())  # Специальный синтаксис создания экземпляра


@Tracer
class Spam:  # Версия на основе декоратора
    ...  # Обязательный синтаксис @ определения класса
    
food = Spam()  # Обычный синтаксис создания экземпляра

 По сути декораторы классов перекладывают требования к синтаксису 
оформления с операции создания экземпляра на саму инструкцию class. 
То же справедливо и для примера реализации шаблона singleton,
приводившегося выше в этом разделе, – вместо того, чтобы декорировать 
класс и использовать обычную конструкцию создания экземпляра, мы могли 
бы просто передать класс и аргументы конструктора управляющей функции:
"""

instances = {}


def getInstance(aClass, *args):
    if aClass not in instances:
        instances[aClass] = aClass(*args)
        
    return instances[aClass]


bob = getInstance(Person, 'Bob', 40, 10)
# Вместо: bob = Person('Bob', 40, 10)

"""
 Как один из вариантов мы могли бы воспользоваться возможностями 
интроспекции, чтобы определить класс из уже созданного экземпляра 
(предполагается допустимость такого способа создания экземпляра):
"""

instances = {}


def getInstance(obj):
    aClass = obj.__class__
    if aClass not in instances:
        instances[aClass] = obj
        
    return instances[aClass]


bob = getInstance(Person('Bob', 40, 10))
# Вместо: bob = Person(‘Bob’, 40, 10)

"""
 То же остается верным и для декораторов функций, таких как tracer,
который был написан нами ранее: вместо того, чтобы декорировать функцию
дополнительной логикой, перехватывающей последующие вызовы, мы могли бы 
просто передать требуемую функцию и ее аргументы управляющей функции, 
которая будет переадресовывать вызовы:

def func(x, y):  # Версия, не использующая декоратор
    ... # def tracer(func, args): ... func(*args)
result = tracer(func, (1, 2))  # Специальный синтаксис вызова

@tracer
def func(x, y):  # Версия на основе декоратора
    ... # Присваивает имени func = tracer(func)

result = func(1, 2)  # Обычный синтаксис вызова

 Подход, основанный на применении управляющих функций, как в данном
примере, переносит бремя использования синтаксиса декораторов
с определений функций и классов на конструкции вызова.


 Зачем нужны декораторы? (Еще раз)

 Итак, почему я только что показал вам способы реализации шаблона 
singleton без применения декораторов? Как я уже упоминал в начале 
этой главы, декораторы дарят нам компромиссные решения. Безусловно 
синтаксис имеет немаловажное значение, но все мы слишком часто забываем
задать вопрос «зачем», когда сталкиваемся с новыми инструментами. 
Теперь, когда мы увидели, как действуют декораторы, давайте отступим 
на шаг назад, чтобы окинуть взглядом получившуюся картину.

 Подобно большинству других особенностей языка декораторы имеют свои 
«за» и «против». Например, в колонке «против» декораторов классов можно
указать два потенциальных недостатка:

 Изменение типа
 
  Как мы уже видели, после обертывания декорируемая функция или класс
 не сохраняет свой первоначальный тип – имени оригинальной функции
 или класса присваивается объект-обертка, что может иметь значение 
 в программах, где выполняется проверка типов объектов. В примере 
 реализации шаблона singleton оба подхода, на основе декоратора 
 и на основе управляющей функции, сохраняют оригинальный тип 
 экземпляров, а в примере реализации трассировщика ни один из подходов 
 не обеспечивает сохранение типа, потому что требуется обертывание 
 оригинальных объектов.

 Дополнительные вызовы

  Дополнительный уровень обертывающей логики, добавляемый 
 при декорировании, привносит дополнительную нагрузку, отрицательно 
 влияющую на производительность, в виде дополнительных вызовов, которые
 производятся при каждом обращении к декорированному объекту. Вызовы 
 функций – это достаточно затратные операции, поэтому декорирование 
 обертками может привести к снижению производительности программы.
 В примере реализации трассировщика доступ к любым атрибутам 
 осуществляется через обертывающую логику – в примере реализации шаблона 
 singleton дополнительные вызовы не производятся благодаря тому, 
 что сохраняется оригинальный тип класса.
 
 Похожие проблемы наблюдаются и в декораторах функций: в обоих случаях,
как при декорировании, так и при использовании управляющих функций,
выполняются дополнительные вызовы. Кроме того, при декорировании обычно
изменяется тип оригинальной функции (но он не изменяется 
при использовании управляющей функции).

 И все же, ни одна из этих проблем не является слишком серьезной. 
Для большинства программ проблема изменения типа вряд ли будет иметь 
хоть какое-то значение, а потеря скорости за счет дополнительных вызовов
будет ничтожной. Кроме того, последняя проблема наблюдается только 
при использовании оберток и ее часто легко ликвидировать, просто убрав 
декоратор, когда требуется обеспечить максимальную производительность.
Этой же проблеме подвержены решения, не использующие декораторы, 
которые добавляют обертывающую логику (включая метаклассы, как мы увидим
в главе 39). Напротив, как мы видели в начале этой главы, декораторы 
обладают тремя важными достоинствами. В сравнении с решениями на основе
управляющих (или «вспомогательных») функций, представленными 
в предыдущем разделе, декораторы могут предложить:

 Явный синтаксис
 
  Декораторы делают наращивание функциональных возможностей более
 явным и очевидным. Синтаксис @ декораторов заметнее, чем специальный
 программный код в вызовах, которые могут быть разбросаны по всему 
 файлу. В наших примерах реализации трассировщика и шаблона singleton, 
 например, строка с декоратором выглядит более заметной, 
 чем дополнительный программный код в вызовах. Кроме того, декораторы 
 позволяют использовать обычный синтаксис вызовов функций и создания 
 экземпляров, знакомый всем программистам на языке Python.
 
 Сопровождение программного кода
 
  Декораторы позволяют избежать использования избыточного программного 
 кода при оформлении каждого вызова функции или класса. Благодаря тому, 
 что декораторы появляются в программном коде всего один раз, 
 непосредственно перед определением класса или функции, они устраняют
 избыточность и упрощают сопровождение программы в будущем. 
 При использовании управляющих функций в наших примерах реализации 
 трассировщика и шаблона singleton нам потребовалось бы использовать
 специальный программный код для оформления каждого вызова,
 что потребовало бы от нас лишних действий при создании программы 
 и при ее изменении в будущем.
 
 Последовательность
 
  Декораторы снижают вероятность того, что программист забудет 
 задействовать требуемую обертывающую логику. Это следует в основном
 из двух предыдущих достоинств – благодаря тому, что декораторы являются
 более очевидными и появляются в программном коде всего один раз,
 непосредственно перед декорируемыми объектами, они обеспечивают более
 непротиворечивый и единообразный способ, чем специализированный 
 программный код, который должен включаться в каждый вызов. В примере
 реализации шаблона singleton, например, легко можно забыть добавить
 специальный программный код во все операции создания экземпляров, 
 что приведет к невозможности гарантировать существование единственного 
 экземпляра класса.
 
 Кроме того, декораторы обеспечивают инкапсуляцию программного кода, 
снижая его избыточность и минимизируя усилия по его сопровождению 
в будущем. Тот же эффект позволяют получить и другие средства
структурирования программного кода, однако декораторы являются 
естественным средством при решении задач расширения функциональных
возможностей.

 Однако ни одно из этих преимуществ не делает декораторы обязательными
к применению. В конечном счете, использовать или не использовать 
декораторы – это в значительной степени вопрос выбора стиля.
И, тем не менее, большинство программистов считают их важным 
приобретением, особенно когда они рассматриваются как средство 
корректного использования библиотек и прикладных интерфейсов.

 Я могу напомнить похожие аргументы, приводившиеся за и против 
использования методов-конструкторов в классах – до появления метода 
__init__ тот же самый эффект можно было получить, вызывая метод 
экземпляра вручную в процессе его создания (например, X=Class().init()).
Однако со временем, невзирая на устоявшийся стиль оформления, синтаксис
__init__ приобрел большую популярность благодаря своей очевидности, 
последовательности и простоте в сопровождении. Судить конечно вам, но,
как мне кажется, декораторы несут в себе множество похожих преимуществ.


 Непосредственное управление функциями и классами
 
 Большинство примеров в этой главе разрабатывалось с целью обеспечить
перехват вызовов функций и операций создания экземпляров. Это наиболее
типичная роль декораторов, но она не единственная. Поскольку декораторы
запускаются, когда создается новая функция или класс, они могут также 
использоваться не только для перехвата обращений к этим функциям 
и классам, но и для управления самими объектами функций и классов.

 Представьте, например, что вам требуется зарегистрировать методы 
или классы, используемые приложением, для последующей обработки 
(возможно, эти объекты будут вызываться приложением в ответ 
на какие-либо события). Вы могли бы написать функцию регистрации,
которую можно было бы вызывать вручную после того, как объекты будут 
определены, однако декораторы позволяют сделать ваши намерения 
более явными.

 Следующий простой пример реализует эту идею, определяя декоратор,
который может применяться к функциям или к классам, чтобы добавить 
объект в реестр на основе словаря. Так как декоратор возвращает 
сам объект, а не обертку, он не оказывает влияния на последующие вызовы 
этого объекта:
"""

# Регистрация декорируемых объектов
registry = {}


def register(obj):  # Декоратор функций и классов
    registry[obj.__name__] = obj  # Добавить в реестр
    return obj  # Возвращает сам объект obj, а не обертку


@register
def spam(x):
    return x ** 2  # spam = register(spam)


@register
def ham(x):
    return x ** 3


@register
class Eggs:  # Eggs = register(Eggs)
    def __init__(self, x):
        self.data = x ** 4

    def __str__(self):
        return str(self.data)


print('Registry:')
for name in registry:
    print(name, '=>', registry[name], type(registry[name]))

print('\nManual calls:')
print(spam(2))  # Вызов объекта вручную
print(ham(2))  # Вызовы не перехватываются декоратором
X = Eggs(2)
print(X)

print('\nRegistry calls:')
for name in registry:
    print(name, '=>', registry[name](3))  # Вызов из реестра

"""
 Этот пример достаточно искусственный, но сам прием используется очень
широко. Например, декораторы функций могут также использоваться для
обработки атрибутов функций, а декораторы классов могут динамически 
добавлять новые атрибуты классов и даже методы. Взгляните на следующие
декораторы функций, – они присваивают функциям новые атрибуты, в которых
сохраняется информация для последующего использования приложением, 
но не добавляют новый слой обертывающей логики, перехватывающей вызовы
этих функций:
"""


# Непосредственное расширение декорируемых объектов
def decorate(func):
    func.marked = True  # Присваивает функции атрибут
    return func  # для последующего использования


@decorate
def spam(a, b):
    return a + b


print(spam.marked)


def annotate(text):  # То же самое, но значение атрибута
    def decor(func):  # передается в аргументе декоратора
        func.label = text
        return func
    
    return decor


@annotate('spam data')
def spam(a, b):  # spam = annotate(...)(spam)
    return a + b


print(spam(1, 2), spam.label)

"""
 Пример: «частные» и «общедоступные» атрибуты
 
 
 Реализация частных атрибутов
 
 Следующий декоратор классов реализует объявление Private для атрибутов
экземпляров классов – то есть атрибутов, которые хранятся в экземпляре
или наследуются от одного из его классов. Этот декоратор препятствует 
возможности получения или изменения значений таких атрибутов 
из-за пределов декорированного класса, но позволяет свободно обращаться 
к этим атрибутам внутри методов класса. Это объявление действует 
не совсем так, как в языках C++ или Java, но обеспечивает похожий способ 
управления доступом в языке Python.

 Мы уже видели первую неполную реализацию частных атрибутов экземпляра,
доступных за пределами класса только для чтения, в главе 29. Версия,
представленная здесь, распространяет эту концепцию также на операцию 
чтения, и для реализации этой модели использует прием делегирования 
вместо наследования. В определенном смысле это всего лишь расширенная 
версия декоратора классов, реализующего трассировку обращений 
к атрибутам, с которым мы встречались выше.

 Несмотря на то, что для реализации частных атрибутов в этом примере 
используется синтаксический подсластитель в виде декоратора классов, 
тем не менее, обработка обращений к атрибутам в нем полностью основана 
на использовании методов __getattr__ и __setattr__ перегрузки
операторов, которые мы рассматривали в предыдущих главах. Когда
обнаруживается попытка обращения к частному атрибуту, эта версия 
возбуждает исключение с помощью инструкции raise, которому передается 
текст сообщения об ошибке. Можно обработать исключение с помощью 
инструкции try или позволить ему завершить работу сценария.


 Ограничение на чтение значений частных атрибутов экземпляров классов.
Примеры использования приводятся в программном коде самопроверки, 
в конце. Декоратор действует как: 
Doubler = Private(‘data’, ‘size’)(Doubler).
Функция Private возвращает onDecorator, 
onDecorator возвращает onInstance, 
а в каждый экземпляр onInstance встраивается экземпляр Doubler
"""

traceMe = False


def trace(*args):
    if traceMe:
        print('[' + ' '.join(map(str, args)) + ']')


def Private(*privates):  # privates – в объемлющей области видимости
    def onDecorator(aClass):  # aClass – в объемлющей области видимости
        class onInstance:  # обертывает экземпляр атрибута
            def __init__(self, *args, **kargs):
                self.wrapped = aClass(*args, **kargs)

            def __getattr__(self, attr):
                # Для собственных атрибутов getattr не вызывается
                trace('get:', attr)  # Другие, как предполагается,
                if attr in privates:  # принадлежат обернутому объекту
                    raise TypeError('private attribute fetch: ' + attr)
                else:
                    return getattr(self.wrapped, attr)

            def __setattr__(self, attr, value):  # Доступ извне
                trace('set:', attr, value)
                # Другие обрабатываются нормально
                if attr == 'wrapped':  # Разрешить доступ к своим атр.
                    self.__dict__[attr] = value  # Избежать зацикливания
                elif attr in privates:
                    raise TypeError('private attribute change: ' + attr)
                else:
                    setattr(self.wrapped, attr, value)
                    # Атрибуты обернутого объекта
                    
        return onInstance  # Или использовать __dict__
    
    return onDecorator


if __name__ == '__main__':
    traceMe = True

    @Private('data', 'size')  # Doubler = Private(...)(Doubler)
    class Doubler:
        def __init__(self, label, start):
            self.label = label  # Доступ изнутри класса
            self.data = start
            # Не перехватывается: обрабатывается как обычно

        def size(self):
            return len(self.data)
            # Методы выполняются без проверки, потому

        def double(self):  # что ограничение доступа не наследуется
            for i in range(self.size()):
                self.data[i] = self.data[i] * 2

        def display(self):
            print('%s => %s' % (self.label, self.data))

X = Doubler('X is', [1, 2, 3])
Y = Doubler('Y is', [-10, -20, -30])

# Все следующие попытки оканчиваются успехом
print(X.label)  # Доступ извне класса
X.display()
X.double()
X.display()  # Перехватывается: проверяется, делегируется

print(Y.label)
Y.display()
Y.double()
Y.label = 'Spam'
Y.display()

# Все следующие попытки терпят неудачу
"""
print(X.size())  # Выведет “TypeError: private attribute fetch: size”
print(X.data)
X.data = [1, 1, 1]
X.size = lambda S: 0
print(Y.data)
print(Y.size())

 Когда переменная traceMe получает значение True, программный код 
самопроверки модуля выводит следующие результаты. Обратите внимание, 
что декоратор перехватывает и проверяет допустимость обеих операций,
чтения и записи, над атрибутами, когда они выполняются за пределами 
обернутого класса, но не перехватывает попытки доступа изнутри самого 
класса.


 Подробности реализации I
 
 
 Наследование и делегирование
 
 В первой прикидочной реализации частных атрибутов, которая приводилась
в главе 29, для перехвата попыток изменить значение атрибута 
использовался механизм наследования и метод __setattr__. Однако
наследование только осложняет ситуацию, потому что отличить,
откуда была произведена попытка доступа, изнутри или снаружи, не так-то
просто (попытки доступа изнутри должны выполняться как обычно,
а попытки доступа снаружи должны ограничиваться). Чтобы обойти 
эту проблему, пример в главе 29 требует, чтобы для изменения значений
атрибутов наследующие их классы использовали словарь __dict__,
что в лучшем случае можно признать неполным решением.
 
 Данная версия вместо наследования использует прием делегирования 
(прием встраивания одного объекта в другой) – он лучше подходит 
для решения нашей задачи, так как позволяет легко определить, 
откуда была выполнена попытка доступа – изнутри класса или снаружи. 
Попытки доступа к атрибутам снаружи перехватываются методами перегрузки 
операторов обертки и делегируются классу, если они допустимы. Попытки
доступа изнутри самого класса (то есть из методов класса через аргумент 
self) не перехватываются и выполняются как обычно, без всяких проверок,
потому что ограничение доступа в данной реализации не наследуется.


 Аргументы 
 
 Декоратор класса, используемый здесь, принимает произвольное число
аргументов – имен частных атрибутов. Однако, обратите внимание, 
что аргументы передаются функции Private, а функция Private возвращает 
функцию декоратора, которая применяется к классу. То есть аргументы 
используются еще до того, как будет выполнена операция декорирования –
функция Private возвращает декоратор, который в свою очередь 
«запоминает» список имен частных атрибутов в виде ссылки в область 
видимости объемлющей функции.


 Сохранение информации и объемлющие области видимости
 
 Говоря об объемлющих областях видимости, следует отметить, 
что в действительности в этом примере существует три уровня, 
где сохраняется информация о состоянии:

  Аргументы функции Private используются еще до того, как будет 
 выполнена операция декорирования, и сохраняются в области видимости 
 объемлющей функции для последующего использования в функции onDecorator
 и в классе onInstance.
 
  Аргумент aClass функции onDecorator используется на этапе 
 декорирования и сохраняется в объемлющей области видимости 
 для последующего использования на этапе создания экземпляра.
 
  Обернутый объект экземпляра сохраняется в атрибуте экземпляра класса
 onInstance для последующего использования при обработке попыток доступа
 к атрибутам из-за пределов класса.
 
 
 Использование __dict__ и __slots__
 
 Метод __setattr__ в этом примере опирается на использование словаря 
__dict__ пространства имен объекта экземпляра, с помощью которого он 
изменяет значение собственного атрибута wrapped экземпляра класса 
onInstance. Как мы узнали в предыдущей главе, в этом методе нельзя 
выполнять прямое присваивание значения атрибуту из-за опасности 
зацикливания. Однако для присваивания значений атрибутам обернутого
объекта вместо словаря __dict__ используется встроенная функция setattr.
Кроме того, для получения значений атрибутов обернутого объекта 
используется функция getattr, потому что атрибуты не только могут 
храниться в самом объекте, но и наследоваться от класса.

 Благодаря этому данная реализация декоратора может применяться 
практически к любым классам. Вы можете вспомнить, как в главе 31 
говорилось, что классы нового стиля с атрибутом __slots__ могут вообще 
не хранить атрибуты в словаре __dict__. Однако так как мы используем 
словарь __dict__ только на уровне экземпляра класса onInstance 
и не используем его на уровне обернутого экземпляра, а также потому, 
что функции setattr и getattr могут применяться к атрибутам, хранящимся 
в __dict__ и __slots__, наш декоратор может применяться к классам, 
использующим любой механизм хранения атрибутов.


 Обобщение на случай объявления общедоступных атрибутов
 
 Теперь, когда у нас имеется реализация декоратора Private частных 
атрибутов, будет совсем несложно обобщить ее и реализовать декоратор 
Public для объявления общедоступных атрибутов – атрибуты этого типа 
по сути являются противоположностью частным атрибутам, поэтому 
в их реализации нам достаточно будет просто инвертировать условие 
во внутренней проверке. Пример, который приводится в этом разделе, 
реализует декораторы классов Private и Public, которые дают возможность 
определять либо множество общедоступных, либо множество частных 
атрибутов (атрибуты, хранящиеся в экземпляре или наследуемые ими
от своих классов) со следующей семантикой:

  Декоратор Private объявляет атрибуты экземпляров класса, которые 
 недоступны, кроме как изнутри методов класса. То есть ни один атрибут, 
 имя которого было объявлено с помощью декоратора Private, не будет 
 доступен за пределами класса, при этом все остальные атрибуты будут
 доступны внешнему программному коду как для чтения, так и для записи.
 
  Декоратор Public объявляет атрибуты экземпляров класса, которые будут
 доступны не только внутри методов класса, но и снаружи. То есть 
 все атрибуты, имена которых были объявлены с помощью декоратора Public,
 будут доступны из любой точки программы, однако атрибуты, которые 
 не были объявлены общедоступными, будут доступны только внутри класса.
 
 Объявления Private и Public являются взаимоисключающими: 
при использовании декоратора Private все необъявленные атрибуты будут 
считаться общедоступными и наоборот, при использовании декоратора Public
все необъявленные атрибуты будут считаться частными. По сути 
эти объявления являются полными противоположностями друг другу. 
Однако в случае необъявленных имен атрибутов, которые не создаются 
внутри методов класса, они ведут себя немного по-разному – сохраняется 
возможность создавать присваиванием атрибуты за пределами класса, 
когда  к классу применяется декоратор Private, (все необъявленные имена 
доступны), но не тогда, когда к классу применяется декоратор Public 
(все необъявленные имена недоступны).

 И снова вам следует изучить этот пример самостоятельно, чтобы получить
представление о том, как он действует. Обратите внимание,
что на этот раз добавился еще один, четвертый уровень, где сохраняется 
информация, вдобавок к описанным в предыдущем разделе: функции проверки,
реализованные в виде lambda-функций, сохраняются в дополнительной
области видимости объемлющей функции.


 Декораторы Private и Public для объявления частных 
и общедоступных атрибутов.
Управляют доступом к атрибутам, хранящимся в экземпляре или наследуемым
от классов. Декоратор Private объявляет атрибуты, которые недоступны 
за пределами декорируемого класса, а декоратор Public объявляет
все атрибуты, которые, наоборот, будут доступны. 
Внимание: в Python 3.0 эти декораторы оказывают воздействие только 
на атрибуты с обычными именами – вызовы методов перегрузки операторов
с именами вида __X__, которые неявно производятся встроенными 
операциями, не перехватываются методами __getattr__ и __getattribute__
в классах нового стиля.
Добавьте здесь реализации методов вида __X__ и с их помощью делегируйте 
выполнение операций встроенным объектам.
"""

traceMe = False


def accessControl(failIf):
    def onDecorator(aClass):
        class onInstance:
            def __init__(self, *args, **kargs):
                self.__wrapped = aClass(*args, **kargs)

            def __getattr__(self, attr):
                trace('get:', attr)
                if failIf(attr):
                    raise TypeError('private attribute fetch: ' + attr)
                else:
                    return getattr(self.__wrapped, attr)

            def __setattr__(self, attr, value):
                trace('set:', attr, value)
                if attr == '_onInstance__wrapped':
                    self.__dict__[attr] = value
                elif failIf(attr):
                    raise TypeError('private attribute change: ' + attr)
                else:
                    setattr(self.__wrapped, attr, value)
                    
        return onInstance
    
    return onDecorator


def Private(*attributes):
    return accessControl(failIf=(lambda attr: attr in attributes))


def Public(*attributes):
    return accessControl(failIf=(lambda attr: attr not in attributes))


@Private('age')  # Person = Private(‘age’)(Person)
class Person3:  # Person = onInstance с информацией о состоянии
    def __init__(self, name, age):
        self.name = name
        self.age = age  # Внутри доступ к атрибутам не ограничивается


X = Person3('Bob', 40)
print(X.name)  # Попытки доступа снаружи проверяются
X.name = 'Sue'
print(X.name)
# print(X.age)  # TypeError: private attribute fetch: age
# X.age = 'Tom'  # TypeError: private attribute change: age


@Public('name')
class Person4:
    def __init__(self, name, age):
        self.name = name
        self.age = age


X = Person4('bob', 40)  # X – экземпляр onInstance
print(X.name)  # экземпляр Person встраивается в экземпляр onInstance
X.name = 'Sue'
print(X.name)
# print(X.age)
# X.age = 'Tom'

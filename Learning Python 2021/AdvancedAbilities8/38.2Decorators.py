"""
 Программирование декораторов функций


 Трассировка вызовов

 Для начала мы вернемся к примеру трассировщика вызовов, с которым мы
встретились в главе 31. Следующий пример демонстрирует определение
и использование декоратора функций, который подсчитывает количество
вызовов декорированной функции и при каждом ее вызове выводит
трассировочное сообщение:
"""


class Tracer:
    def __init__(self, func):  # На этапе декорирования @:
        self.calls = 0  # сохраняет оригинальную функцию func
        self.func = func

    def __call__(self, *args):  # При последующих вызовах: вызывает
        self.calls += 1  # оригинальную функцию func
        print('call %s to %s' % (self.calls, self.func.__name__))
        self.func(*args)


@Tracer
def spam(a, b, c):  # spam = tracer(spam)
    print(a + b + c)  # Обертывает функцию spam объектом декоратора


"""
 Обратите внимание, что при декорировании каждой функции этим классом
создается новый экземпляр, который сохраняет объект функции и счетчик ее
вызовов. Обратите также внимание, как используется синтаксис *args 
аргументов, позволяющий организовать упаковывание и распаковывание 
произвольного количества аргументов. Такой прием позволяет использовать 
декоратор для обертывания любых функций, принимающих любое число
аргументов (эта версия декоратора не может применяться к методам 
классов, но мы исправим этот недостаток ниже, в этом разделе).

 Если теперь импортировать эту функцию из модуля и протестировать ее 
в интерактивной оболочке, мы получим следующие ниже результаты – при 
каждом вызове функции будет выводиться трассировочное сообщение 
благодаря тому, что класс декоратора перехватывает их.
"""

spam(1, 2, 3)  # В действительности вызывается объект-обертка

spam('a', 'b', 'c')  # Вызовет метод __call__ класса

print(spam.calls)  # Счетчик вызовов в объекте-обертке

print(spam)

"""
 При вызове класс tracer сохраняет декорируемую функцию и в последующем
будет перехватывать ее вызовы, выполняя дополнительные операции 
по подсчету количества вызовов и выводу сообщения для каждого вызова. 
Обратите внимание, что счетчик вызовов реализован в виде атрибута 
декорированной функции – в действительности, после декорирования 
имя spam – это экземпляр класса tracer (что может запутать программы,
проверяющие типы объектов, но в общем случае не должно порождать 
проблем).

 Для случаев, когда требуется перехватывать вызовы функций, синтаксис @ 
декораторов может оказаться гораздо удобнее, чем добавление логики 
подсчета в каждый вызов, а кроме того, он позволяет избежать 
непосредственного вызова оригинальной функции по невнимательности.
Рассмотрим эквивалентную реализацию без использования декоратора:
"""

calls = 0


def tracer(func, *args):
    global calls
    calls += 1
    print('call %s to %s' % (calls, func.__name__))
    func(*args)


def spam(a, b, c):
    print(a, b, c)


spam(1, 2, 3)  # Обычный вызов без трассировки: невнимательность?

tracer(spam, 1, 2, 3)  # Вызов с трассировкой без применения декоратора

"""
 Способы сохранения информации о состоянии
 
 Последний пример в предыдущем разделе поднимает весьма важную проблему.
Декораторы функций могут использовать самые разные способы сохранения 
информации о состоянии, предоставляемой на этапе декорирования, 
для последующего использования в фактических вызовах функции. Обычно 
декораторы должны поддерживать возможность создания множества 
декорированных объектов и выполнения множества вызовов, однако достичь 
этой цели можно разными путями: атрибуты экземпляров, глобальные 
переменные, нелокальные переменные и атрибуты функций – все они могут 
использоваться для сохранения информации о состоянии.


 Атрибуты экземпляра класса
 
 Например, ниже приводится расширенная версия предыдущего примера, 
в которую добавлена поддержка именованных аргументов и возврат значения,
полученного от обернутой функции с целью расширить область применение
декоратора:
"""


class Tracer:  # Состояние сохраняется в атрибутах экземпляра
    def __init__(self, func):  # На этапе декорирования @
        self.calls = 0
        self.func = func  # Сохраняет оригинальную функцию func

    def __call__(self, *args, **kwargs):  # Вызывается при обращениях
        self.calls += 1  # к оригинальной функции
        print('call %s to %s' % (self.calls, self.func.__name__))
        return self.func(*args, **kwargs)


@Tracer
def spam(a, b, c):  # То же, что и spam = tracer(spam)
    print(a + b + c)  # Вызывает метод tracer.__init__


@Tracer
def eggs(x, y):  # То же, что и eggs = tracer(eggs)
    print(x ** y)  # Обертывает функцию eggs объектом tracer


spam(1, 2, 3)  # В действительности вызывается tracer.__call__
spam(a=4, b=5, c=6)  # spam – атрибут экземпляра
eggs(2, 16)  # В действительности вызывается tracer.__call__,
eggs(4, y=4)  # self.func – это функция eggs, self.calls – отдельное
# значение для каждой функции

"""
 Как и в предыдущей версии, для сохранения информации о состоянии здесь
используются атрибуты экземпляра. Обе обернутые функции и счетчики вы-
зовов сохраняются как индивидуальные данные экземпляров – каждая опе-
рация декорирования создает собственную копию. Обратите внимание, 
что для каждой из функций, spam и eggs, имеется свой счетчик вызовов, 
потому что каждая операция декорирования создает отдельный экземпляр.


 Области видимости объемлющих функций и глобальные переменные

 В достижении подобного эффекта часто могут помочь ссылки на переменные
в области видимости объемлющих функций и вложенные инструкции def,
особенно для статических данных, таких как ссылка на оригинальную 
функцию. Однако в этом случае нам также потребовалось бы сохранить 
в области видимости объемлющей функции счетчик вызовов, изменяющийся 
при каждом вызове, что невозможно в Python 2.6. В версии 2.6 мы можем 
либо использовать классы и атрибуты, как в примере выше, либо перенести 
переменную, хранящую информацию о состоянии, в глобальную область 
видимости и использовать объявление global:
"""

calls = 0  # Информация сохраняется в объемлющей


def Tracer(func):  # области видимости и в глобальной переменной
    def wrapper(*args, **kwargs):  # Вместо атрибутов класса
        global calls  # calls – глобальная переменная, общая для

        calls += 1  # всех функций, а не для каждой в отдельности
        print('call %s to %s' % (calls, func.__name__))
        return func(*args, **kwargs)
    
    return wrapper


@Tracer
def spam(a, b, c):  # То же, что и spam = tracer(spam)
    print(a + b + c)


@Tracer
def eggs(x, y):  # То же, что и eggs = tracer(eggs)
    print(x ** y)


spam(1, 2, 3)  # В действительности вызывается wrapper,
spam(a=4, b=5, c=6)  # присвоенная имени функции, wrapper вызывает spam
eggs(2, 16)  # В действительности вызывается wrapper,
eggs(4, y=4)  # присвоенная имени eggs. Глобальная переменная
# calls – общая для всех функций!
del calls

"""
 К сожалению, после того как счетчик был перенесен в глобальную область 
видимости, он стал общим для всех обернутых функций. В отличие 
от атрибутов экземпляров, глобальные счетчики не могут использоваться 
для подсчета вызовов каждой функции в отдельности – счетчик наращивается 
при вызове любой трассируемой функции. Вы можете сами заметить различия,
если сравните вывод этой версии и предыдущей – единый, общий счетчик
вызовов изменяется при вызове любой декорированной функции.


 Области видимости объемлющих функций и нелокальные переменные

 В некоторых случаях бывает желательным именно такой способ сохранения
информации в глобальных переменных. Однако если требуется обеспечить 
подсчет вызовов каждой функции в отдельности, мы можем использовать
классы, как было показано прежде, или задействовать новую инструкцию
nonlocal, появившуюся в Python 3.0 и описанную в главе 17. Поскольку 
новая инструкция позволяет изменять переменные в области видимости 
объемлющей функции, они могут использоваться для хранения данных, 
индивидуальных для каждой функции:
"""


def tracer(func):  # Информация сохраняется в объемлющей области
    calls = 0  # видимости и в нелокальной переменной вместо
    # атрибутов класса и глобальных переменных

    def wrapper(*args, **kwargs):  # calls – не глобальная переменная
        nonlocal calls  # для каждой функции в отдельности
        calls += 1
        print('call %s to %s' % (calls, func.__name__))
        return func(*args, **kwargs)
    
    return wrapper


@tracer
def spam(a, b, c):  # То же, что и spam = tracer(spam)
    print(a + b + c)


@tracer
def eggs(x, y):  # То же, что и eggs = tracer(eggs)
    print(x ** y)


spam(1, 2, 3)  # В действительности вызывается wrapper,
spam(a=4, b=5, c=6)  # присвоенная имени функции, wrapper вызывает spam
eggs(2, 16)  # В действительности вызывается wrapper,
eggs(4, y=4)  # присвоенная имени eggs. Нелокальная переменная
# calls теперь отдельная для каждой функции

"""
 Теперь благодаря тому, что переменные в области видимости объемлющей
функции не являются глобальными, каждая обернутая функция получает
свой собственный счетчик, как при использовании классов и атрибутов.


 Атрибуты функций
 
 Наконец, даже если вы не используете Python 3.X и не можете 
задействовать инструкцию nonlocal, вы все равно имеете возможность 
отказаться от глобальных переменных и классов, использовав атрибуты 
функций для хранения некоторой изменяемой информации о состоянии. 
В последних версиях Python допускается присоединять к функциям 
произвольные атрибуты и присваивать им значения инструкцией вида 
func.attr=value. В нашем примере мы можем определить атрибут 
wrapper.calls для хранения счетчика. Следующий пример работает
точно так же, как предыдущая версия, основанная на использовании
инструкции nonlocal, – благодаря тому, что каждая декорируемая функция
получает свой собственный счетчик, при этом он также будет работать 
и под управлением Python 2.6:
"""


def tracer(func):  # Информация сохраняется в объемлющей
    def wrapper(*args, **kwargs):
        # области видимости и в атрибутах функции
        wrapper.calls += 1  # calls – не глобальная переменная,
        # для каждой функции в отдельности
        print('call %s to %s' % (wrapper.calls, func.__name__))
        return func(*args, **kwargs)
    
    wrapper.calls = 0
    return wrapper


"""
 Обратите внимание, что этот прием работает, так как имя wrapper 
сохраняется в области видимости объемлющей функции tracer. Когда позднее
выполняется наращивание счетчика wrapper.calls, сам объект 
с именем wrapper не изменяется, поэтому нам не требуется объявление 
nonlocal.

 Этот прием приведен последним, потому что он менее очевидный, 
чем применение инструкции nonlocal в версии 3.0 и, вероятно, его следует 
использовать только в случаях, когда другие приемы не могут быть 
использованы. Однако мы будем использовать его в ответе на один 
из контрольных вопросов в конце главы, когда нам потребуется 
организовать доступ к информации о состоянии из-за пределов декоратора.
Нелокальные переменные доступны только внутри вложенной функции, 
а атрибуты функций имеют более широкую область видимости.

 Поскольку декораторы часто могут образовывать несколько уровней 
вызываемых объектов, вы можете комбинировать функции с объемлющими 
областями видимости и классы с атрибутами для достижения различных 
желаемых эффектов. Однако, как мы увидим ниже, добиться нужного 
результата порой оказывается сложнее, чем можно было бы ожидать, – 
когда  каждая декорируемая функция должна обладать собственной 
информацией о состоянии и каждый декорируемый класс может требовать 
хранить информацию как свою собственную, так и для каждого экземпляра 
в отдельности.


 Ошибки при использовании классов I: декорирование методов классов

 Когда я писал первый декоратор tracer функций, представленный выше, 
я наивно полагал, что он также может применяться к любым методам – 
декорированные методы должны действовать точно так же, а автоматически
передаваемый аргумент self со ссылкой на экземпляр в этом случае мог бы 
просто быть добавлен в начало списка аргументов *args. К сожалению,
я ошибался: если применить первую версию декоратора tracer к методу 
класса, он потерпит неудачу, потому что аргумент self будет ссылаться 
на экземпляр класса декоратора, а ссылка на подразумеваемый экземпляр 
декорируемого класса не будет включена в список *args. Это справедливо 
для обеих версий Python, 3.0 и 2.6. Я познакомил вас с этим явлением 
выше в этой главе но теперь вы можете наблюдать его в контексте более 
реалистичного примера. Допустим, имеется декоратор трассировки вызовов 
функций, реализованный на основе класса:
"""


class Tracer:
    def __init__(self, func):  # На этапе декорирования @
        self.calls = 0  # Сохраняет функцию для последующего вызова
        self.func = func

    def __call__(self, *args, **kwargs):  # Вызывается при обращениях
        self.calls += 1  # к оригинальной функции
        print('call %s to %s' % (self.calls, self.func.__name__))
        return self.func(*args, **kwargs)


"""
 Тогда декорирование простых функций будет работать именно так, 
как описывалось выше:
"""


@Tracer
def spam(a, b, c):  # spam = tracer(spam)
    print(a + b + c)  # Вызовет метод tracer.__init__


spam(1, 2, 3)  # Вызовет метод tracer.__call__
spam(a=4, b=5, c=6)  # spam – атрибут экземпляра

"""
 Однако декорирование методов класса не даст желаемого результата:
"""


class Person:
    def __init__(self, name, pay):
        self.name = name
        self.pay = pay

    @Tracer
    def giveRaise(self, percent):  # giveRaise = tracer(giverRaise)
        self.pay *= (1.0 + percent)

    @Tracer
    def lastName(self):  # lastName = tracer(lastName)
        return self.name.split()[-1]


bob = Person('Bob Smith', 50000)  # tracer запоминает метод
# bob.giveRaise(.25)  # Вызовет tracer.__call__(???, .25)
# print(bob.lastName())  # Вызовет tracer.__call__(???)
print(type(Person.giveRaise))

"""
 Корень этой проблемы заключен в аргументе self метода __call__ класса 
tracer: это экземпляр класса tracer или класса Person? 
В действительности нам нужны оба экземпляра: экземпляр класса tracer
необходим для сохранения информации о состоянии, а экземпляр класса 
Person – чтобы вызвать оригинальный метод. На самом деле аргумент self 
должен быть ссылкой на объект tracer, чтобы обеспечить доступ 
к информации о состоянии трассировщика; это одинаково верно как в случае
декорирования функции, так и в случае декорирования метода.

 К сожалению, когда имени декорируемого метода повторно присваивается 
экземпляр класса с методом __call__, интерпретатор передает в аргументе 
self только экземпляр класса tracer – он вообще не передает в списке 
аргументов подразумеваемый экземпляр класса Person. Кроме того, 
из-за того, что экземпляр класса tracer вообще ничего не знает 
об экземпляре класса Person, необходимом для вызова метода, мы не можем 
создать метод, связанный с экземпляром, и поэтому не можем корректно 
произвести вызов.

 Фактически в предыдущем примере мы сталкиваемся с ситуацией, когда 
декорируемый метод получает недостаточное количество аргументов, 
что вызывает ошибку. Если добавить в метод __call__ вывод всех 
аргументов, можно будет убедиться, что аргумент self представляет
экземпляр класса tracer, а экземпляр класса Person вообще отсутствует:

 Как уже упоминалось выше, это происходит потому, что интерпретатор 
передает в аргументе self подразумеваемый экземпляр, когда происходит
связывание имени метода с простой функцией, – когда имени соответствует 
экземпляр  вызываемого класса, передается экземпляр этого класса. 
С технической точки зрения, интерпретатор создает объект связанного 
метода, содержащий подразумеваемый экземпляр, только когда метод 
является простой функцией.


 Использование вложенных функций для декорирования методов

 Если вам необходимо, чтобы декоратор мог применяться и к простым 
функциям, и к методам классов, наиболее простое решение заключается 
в использовании одного из других способов организации сохранения 
информации о состоянии, описанных выше. Реализуйте свой декоратор 
в виде вложенной функции, чтобы не зависеть от единственного аргумента 
self для представления экземпляра класса-обертки и подразумеваемого 
экземпляра класса.

 Следующее альтернативное решение решает описанную проблему с помощью
нелокальных переменных, которые могут использоваться в Python 3.0. 
Поскольку теперь имени декорируемого метода присваивается не экземпляр
класса, а простая функция, интерпретатор будет корректно передавать ей
экземпляр класса Person в первом аргументе, а декоратор передаст его 
в виде первого элемента в списке *args настоящему методу:
"""


# Этот декоратор может применяться к функциям и к методам
def tracer(func):
    # Вместо класса с методом __call__ используется функция,
    calls = 0  # иначе “self” будет представлять экземпляр декоратора!

    def onCall(*args, **kwargs):
        nonlocal calls
        
        calls += 1
        print('call %s to %s' % (calls, func.__name__))
        return func(*args, **kwargs)
    
    return onCall


# Может применяться к простым функциям
@tracer
def spam(a, b, c):  # spam = tracer(spam)
    print(a + b + c)  # onCall сохранит ссылку на spam


spam(1, 2, 3)  # Вызовет onCall(1, 2, 3)
spam(a=4, b=5, c=6)


# Может применяться к методам классов!
class Person:
    def __init__(self, name, pay):
        self.name = name
        self.pay = pay

    @tracer
    def giveRaise(self, percent):
        # giveRaise = tracer(giverRaise)
        self.pay *= (1.0 + percent)
        # onCall сохранит ссылку на giveRaise

    @tracer
    def lastName(self):  # lastName = tracer(lastName)
        return self.name.split()[-1]


print('methods...')
bob = Person('Bob Smith', 50000)
sue = Person('Sue Jones', 100000)
print(bob.name, sue.name)
sue.giveRaise(.10)  # Вызовет onCall(sue, .10)
print(sue.pay)
print(bob.lastName(), sue.lastName())
# Вызовет onCall(bob), lastName – в области видимости объемлющей функции

"""
 Использование дескрипторов для декорирования методов
 
 Решение на основе вложенных функций, продемонстрированное в предыдущем 
разделе, является наиболее простым, когда необходимо обеспечить 
поддержку применения декоратора к функциям и к методам классов, однако 
возможны и другие решения. Дескрипторы, особенности которых мы 
исследовали в предыдущей главе, например, также могут помочь нам.

 Вспомните, как в той главе говорилось, что дескрипторы могут быть 
атрибутами классов, которым присваиваются объекты с методом __get__,
который вызывается автоматически при попытке сослаться на атрибут 
и получить его значение.


class Descriptor(object):
    def __get__(self, instance, owner): ...
    
    
class Subject:
    attr = Descriptor()
    
    
X = Subject()
X.attr # Приблизительно вызов будет выглядеть так:
# Descriptor.__get__(Subject.attr, X, Subject)

 Кроме того, дескрипторы могут иметь методы __set__ и __del__ управления
доступом, но в данном случае они нам не потребуются. Теперь, учитывая,
что метод __get__ дескриптора принимает класс дескриптора 
и подразумеваемый экземпляр класса, он отлично подходит 
для декорирования методов, когда для выполнения вызова требуется иметь 
доступ к информации декоратора и к оригинальному экземпляру класса. 
Рассмотрим следующий альтернативный декоратор трассировки, который 
одновременно является дескриптором:
"""


class Tracer(object):
    def __init__(self, func):  # На этапе декорирования @
        self.calls = 0  # Сохраняет функцию для последующего вызова
        self.func = func

    def __call__(self, *args, **kwargs):  # Вызывается при обращениях к
        self.calls += 1  # оригинальной функции
        print('call %s to %s' % (self.calls, self.func.__name__))
        return self.func(*args, **kwargs)

    def __get__(self, instance, owner):
        # Вызывается при обращении к атрибуту
        return Wrapper(self, instance)


class Wrapper:
    def __init__(self, desc, subj):  # Сохраняет оба экземпляра
        self.desc = desc  # Делегирует вызов дескриптору
        self.subj = subj

    def __call__(self, *args, **kwargs):
        return self.desc(self.subj, *args, **kwargs)
        # Вызовет tracer.__call__


# Может применяться к простым функциям
@Tracer
def spam(a, b, c):  # spam = tracer(spam)
    print(a + b + c)  # onCall сохранит ссылку на spam


spam(1, 2, 3)  # Вызовет onCall(1, 2, 3)
spam(a=4, b=5, c=6)


# Может применяться к методам классов!
class Person:
    def __init__(self, name, pay):
        self.name = name
        self.pay = pay

    @Tracer
    def giveRaise(self, percent):
        # giveRaise = tracer(giverRaise)
        self.pay *= (1.0 + percent)
        # onCall сохранит ссылку на giveRaise

    @Tracer
    def lastName(self):  # lastName = tracer(lastName)
        return self.name.split()[-1]


print('methods...')
bob = Person('Bob Smith', 50000)
sue = Person('Sue Jones', 100000)
print(bob.name, sue.name)
sue.giveRaise(.10)  # Вызовет onCall(sue, .10)
print(sue.pay)
print(bob.lastName(), sue.lastName())
# Вызовет onCall(bob), lastName – в области видимости объемлющей функции

"""
 Этот пример действует точно так же, как и предыдущий, основанный 
на вложенной функции. При вызове декорированной функции вызывается
только метод __call__, тогда как при вызове декорированных методов 
сначала вызывается метод __get__, операцией получения метода 
(в выражении instance.method); объект, возвращаемый методом __get__, 
хранит подразумеваемый экземпляр класса, а затем выполняется выражение
вызова, что приводит к вызову метода __call__ (в выражении (args...)).
Например, в тестовом программном коде выполняется вызов

sue.giveRaise(.10)  # Вызовет __get__, затем __call__

 который сначала вызовет метод tracer.__get__, потому что атрибуту 
giveRaise в классе Person был присвоен дескриптор декоратора функций. 
Затем выражение вызова произведет вызов метода __call__ объекта wrapper, 
который в свою очередь вызовет метод tracer.__call__.

 Объект wrapper хранит оба экземпляра, дескриптора и класса, поэтому 
он может передать управление обратно оригинальному экземпляру класса 
дескриптора/декоратора. В результате объект wrapper сохраняет 
подразумеваемый экземпляр класса, доступный в процессе получения 
атрибута, и добавляет его к списку аргументов, который затем передается 
методу __call__. Делегирование вызова обратно экземпляру дескриптора 
необходимо в данном случае, чтобы для всех вызовов обернутого метода
использовался один и тот же счетчик вызовов, который находится 
в экземпляре дескриптора.

 Для достижения того же эффекта можно было бы использовать вложенную
функцию и хранить информацию о состоянии в области видимости объемлющей 
функции. Следующая версия действует точно так же, как и предыдущая, 
но в ней класс и атрибуты объекта заменили вложенная функция 
и переменные в области видимости объемлющей функции, при этом новая 
версия оказалась существенно короче:
"""


class Tracer(object):
    def __init__(self, func):  # На этапе декорирования @
        self.calls = 0  # Сохраняет функцию для последующего вызова
        self.func = func

    def __call__(self, *args, **kwargs):  # Вызывается при обращениях к
        self.calls += 1  # оригинальной функции
        print('call %s to %s' % (self.calls, self.func.__name__))
        return self.func(*args, **kwargs)

    def __get__(self, instance, owner):
        # Вызывается при обращении к методу
        def wrapper(*args, **kwargs):  # Сохраняет оба экземпляра
            return self(instance, *args, **kwargs)  # Вызовет __call__
        
        return wrapper


"""
 Суть всего вышеизложенного заключается в том, что, если вам потребуется
написать декоратор, который может применяться и к функциям, и к методам
классов, лучше использовать описанный здесь прием на основе вложенной
функции, а не класс с методом __call__.


 Хронометраж вызовов
 
 Чтобы полнее ощутить возможности, предлагаемые декораторами функций,
обратимся к другому примеру их использования. Наш следующий декоратор
реализует хронометраж выполнения декорируемых функций – время 
единственного вызова и накопленное время всех вызовов. В нашем примере 
декоратор будет применяться к двум функциям с целью сравнить скорость
работы генератора списков и встроенной функции map.
"""

import time


class timer:
    def __init__(self, func):
        self.func = func
        self.alltime = 0

    def __call__(self, *args, **kargs):
        start = time.time()
        result = self.func(*args, **kargs)
        elapsed = time.time() - start
        self.alltime += elapsed
        print(' % s: % .5f, % .5f' % (self.func.__name__,
                                      elapsed, self.alltime))
        return result


@timer
def listcomp(N):
    return [x * 2 for x in range(N)]


@timer
def mapcall(N):
    return list(map((lambda x: x * 2), range(N)))


result = listcomp(5)  # Хронометраж данного вызова, всех вызовов,
listcomp(500000)  # возвращаемое значение
listcomp(5000000)
listcomp(10000000)
print(result)
print('allTime = %s' % listcomp.alltime)
# Общее время всех вызовов listcomp

print('')
result = mapcall(5)
mapcall(500000)
mapcall(5000000)
mapcall(10000000)
print(result)
print('allTime = %s' % mapcall.alltime)
# Общее время всех вызовов mapcall

print('map/comp = %s' % round(mapcall.alltime / listcomp.alltime, 6))

"""
 В данном случае подход без использования декоратора позволил бы 
использовать испытуемые функции с проведением хронометража или без него,
но если бы мы задумали выполнить хронометраж, это усложнило бы сигнатуру 
вызова (вместо того чтобы добавить декоратор перед инструкцией def 
в одном месте, нам потребовалось бы добавить дополнительный программный 
код везде, где выполняется вызов) и у нас не было бы другого простого 
способа гарантировать, что все вызовы испытуемой функции в программе 
выполняются под управлением логики хронометража, кроме как вручную 
отыскать и изменить все вызовы.

 Важное примечание: я не запускал этот пример под управлением 
Python 3.0, потому что, как описывается в главе 14, в этой версии 
встроенная функция map возвращает итератор, а не список,
как в версии 2.6. По этой причине нельзя напрямую сравнивать 
производительность функции map в 3.0 с производительностью генератора 
списков.


 Добавление аргументов декоратора
 
 Декоратор timer из предыдущего раздела действует, но было бы неплохо,
если бы его можно было настраивать, – например, для такого 
универсального инструмента, как этот, было бы весьма полезно определять 
метку для вывода, а также включать и отключать вывод трассировочных
сообщений. Для этого мы можем использовать аргументы декоратора: 
при надлежащем использовании аргументы могут использоваться, 
как параметры настройки, которые могут принимать индивидуальные значения 
для каждой декорируемой функции. Определить метку для вывода, например,
можно, как показано ниже.

def timer(label=’’):
    def decorator(func):
        def onCall(*args):  # Аргументы args передаются функции
            ...  # func сохраняется в объемлющей области
            print(label, ...  # label сохраняется в объемлющей области
            
        return onCall
        
    return decorator  # Возвращает фактический декоратор
    
@timer(‘==>’) # То же, что и listcomp = timer(‘==>’)(listcomp)
def listcomp(N): ... # Имени listcomp присваивается декоратор

listcomp(...) # В действительности вызывается функция decorator

 Здесь была добавлена область видимости объемлющей функции, 
в которой сохраняется аргумент декоратора, который будет использоваться
в последующих вызовах. После того как функция listcomp будет определена,
при обращении к ней в действительности будет вызываться функция 
decorator (результат, возвращаемый функцией timer, которая вызывается 
непосредственно перед тем, как будет выполнено декорирование) 
со значением label, доступным в объемлющей области видимости. 
То есть функция timer возвращает декоратор, который запоминает аргумент 
декоратора и оригинальную функцию, и возвращает вызываемый объект, 
который, в свою очередь, при последующих вызовах будет вызывать 
оригинальную функцию.

 Мы можем использовать этот подход в нашем декораторе timer, 
чтобы обеспечить возможность передачи метки и флага, управляющего 
выводом трассировочных сообщений на этапе декорирования. Следующий 
пример демонстрирует, как это выглядит в программном коде.
"""


def timer(label='', trace=True):  # Аргументы декоратора: сохраняются
    class Timer:
        def __init__(self, func):  # На этапе декорирования сохраняется
            self.func = func  # декорируемая функция
            self.alltime = 0

        def __call__(self, *args, **kargs):
            # При вызове: вызывается оригинал
            start = time.time()
            result = self.func(*args, **kargs)
            elapsed = time.time() - start
            self.alltime += elapsed
            if trace:
                format = '%s %s: %.5f, %.5f'
                values = (label, self.func.__name__, elapsed,
                          self.alltime)
                print(format % values)
                
            return result
        
    return Timer


"""
 Почти все, что мы проделали в этом примере, – это заключили 
оригинальный класс Timer в объемлющую функцию, чтобы создать область 
видимости, в которой будут сохраняться аргументы декоратора. Внешняя 
функция timer вызывается непосредственно перед операцией декорирования,
она просто возвращает класс Timer, который будет играть роль 
фактического декоратора. В момент декорирования создается экземпляр 
класса Timer, который запоминает саму декорируемую функцию, но при этом 
ему остаются доступными аргументы декоратора, находящиеся в области 
видимости объемлющей функции.
"""


@timer(label='[CCC]==>')
def listcomp(N):  # То же, что и listcomp = timer(...)(listcomp)
    return [x * 2 for x in range(N)]
    # listcomp(...) вызовет Timer.__call__


@timer(trace=True, label='[MMM]==>')
def mapcall(N):
    return list(map((lambda x: x * 2), range(N)))


for func in (listcomp, mapcall):
    print('')
    result = func(5)
    # Хронометраж вызова, всех вызовов, возвращаемое значение
    func(50000)
    func(500000)
    func(1000000)
    print(result)
    print('allTime = %s' % func.alltime)  # Общее время всех вызовов

print('map/comp = %s' % round(mapcall.alltime / listcomp.alltime, 3))


@timer(trace=False)  # Вывод сообщений отключен,
def listcomp(N):  # накапливается общее время
    return [x * 2 for x in range(N)]


x = listcomp(5000)
x = listcomp(5000)
x = listcomp(5000)
print(listcomp)
print(listcomp.alltime)


@timer(trace=True, label='\t=>')  # Вывод сообщений включен
def listcomp(N):
    return [x * 2 for x in range(N)]


x = listcomp(5000)
x = listcomp(5000)
x = listcomp(5000)
print(listcomp.alltime)

"""
 Этот декоратор, реализующий хронометраж вызовов функций, может 
применяться к любым функциям, внутри модулей или в интерактивной 
оболочке. Другими словами, он автоматически превращается в универсальный
инструмент хронометража функций в наших сценариях. Другой пример 
использования аргументов в декораторах вы найдете в разделе «Реализация 
частных атрибутов» ниже, и еще один – в разделе «Простой декоратор 
проверки значений позиционных аргументов на вхождение в заданный 
диапазон» ниже.

 Методы хронометрирования: Декоратор timer, представленный 
в этом разделе, может применяться к любым функциям, а чтобы его можно 
было применять к методам классов, требуются совсем незначительные 
переделки. В двух словах: как было показано в разделе «Ошибки 
при использовании классов I: декорирование методов классов», выше, 
для этого нужно заменить вложенный класс вложенной функцией.
"""

"""
 Юникод и строки байтов


 Изменения в Python 3.0, касающиеся строк

 Одним из наиболее значительных изменений в версии 3.0 является
изменение в объектах строкового типа. Если говорить кратко, типы str
и unicode, имевшиеся в версии 2.X, в версии 3.0 были преобразованы
в типы str и bytes, и появился новый изменяемый тип bytearray. Строго
говоря, тип bytearray доступен и в Python 2.6 (но не доступен в более
ранних версиях), однако реализация поддержки этого типа данных является
результатом переноса из версии 3.0, и в версии 2.6 этот тип данных
не делает четких различий между текстовыми и двоичными данными.

 Эти изменения могут оказать весьма существенное влияние на программный
код, особенно если вам приходится заниматься обработкой Юникода
или данных, по своей природе являющихся двоичными. Фактически степень
значимости этой темы для вас зависит от того, какие из следующих задач
вам приходится решать:

  Если вам приходится иметь дело с текстом Юникода, например
 в интернационализированных приложениях или в результатах, возвращаемых
 некоторыми парсерами разметки XML, вы обнаружите, что поддержка
 кодировок символов в версии 3.0 изменилась, но при этом стала
 более простой и прозрачной, чем в Python 2.6.

  Если вам приходится иметь дело с двоичными данными, например в форме
 изображений или аудио данных, или обрабатывать упакованные данные
 с помощью модуля struct, вам потребуется поближе познакомиться с новым
 типом данных bytes, появившимся в Python 3.0, а также понять,
 что в версии 3.0 текстовые строки и двоичные данные различаются более
 четко.

  Если решаемые вами задачи не относятся ни к одной из двух предыдущих
 категорий, то вы можете просто использовать строки Python 3.0
 практически так же, как в 2.6: использовать обобщенный
 строковый тип str, текстовые файлы и все, уже знакомые вам, строковые
 операции, изученные нами ранее. Ваши строки будут кодироваться
 и декодироваться с учетом кодировки, используемой в системе
 по умолчанию (в США это ASCII или UTF-8 в Windows; кодировку
 по умолчанию можно определить с помощью функции
 sys.getdefaultencoding()), но для вас это, скорее всего, просто пройдет
 незамеченным.

 Другими словами, если вы всегда работаете с текстом, состоящим только
из символов ASCII, вы можете использовать обычные строковые объекты
и текстовые файлы и избежать необходимости вникать в подробности,
о которых рассказывается далее. Как мы вскоре увидим, ASCII –
это простейшая разновидность Юникода и подмножество других кодировок,
поэтому строковые операции и текстовые файлы «просто работают», е
сли программа обрабатывает текст, состоящий только из символов ASCII.

 Однако даже если решаемые вами задачи относятся к последней из трех
предыдущих категорий, понимание основ модели строк в Python 3.0 поможет
вам не только прояснить для себя особенности поведения строк,
но и быстрее овладеть особенностями работы с Юникодом или двоичными
данными, когда это потребуется.


 Основы строк


 Кодировки символов

 Большинство программистов представляют себе текстовые строки
как последовательности символов. Однако в памяти компьютера символы
могут представляться различными способами, в зависимости от того,
какой набор символов используется.

 Стандарт ASCII был выработан в США и для многих американских
программистов определяет понятие текстовых строк. Стандарт ASCII
определяет набор символов с кодами в диапазоне от 0 до 127,
что позволяет сохранять каждый символ в одном 8-битовом байте
(в котором фактически используется только 7 младших битов). Например,
согласно стандарту ASCII символу латиницы ‘a’ соответствует
целочисленное значение 97 (0x61 – в шестнадцатеричном представлении),
которое занимает единственный байт в памяти компьютера и в файлах.
Если вам интересно узнать, как действует этот стандарт, можете
поэкспериментировать со встроенной функцией ord, которая возвращает
целочисленный код символа, и с функцией chr, возвращающей символ
по указанному целочисленному коду:

\>>> ord(‘a’)  # ‘a’ – байт с целочисленным значением 97 в ASCII
97
\>>> hex(97)
‘0x61’
\>>> chr(97)   # Целочисленному значению 97 соответствует символ ‘a’
‘a’

 Однако иногда одного байта бывает недостаточно для представления
отдельных символов. Например, в диапазон символов, определяемых
стандартом ASCII, не попадают различные специальные символы и буквы
с диакритическими знаками. Некоторые стандарты позволяют использовать
все возможные значения 8-битных байтов, от 0 до 255, чтобы обеспечить
возможность представления специальных символов, отображая их в диапазон
значений от 128 до 255 (за пределами диапазона ASCII). Один из таких
стандартов, известный под названием Latin-1, широко используется
в Западной Европе. В стандарте Latin-1 коды со значениями выше 127
присвоены символам с диакритическими знаками и другим специальным
символам. Например, значению 196 в этом стандарте соответствует
специальный символ, не входящий в набор ASCII:

\>>> 0xC4
196
\>>> chr(196)
‘Ä’

 Этот стандарт включает в себя множество дополнительных специальных
символов. И все равно в некоторых алфавитах так много символов,
что нет никакой возможности представить каждый из них одним байтом.
Стандарт Юникод (Unicode) обеспечивает более гибкие возможности.
Строки Юникода иногда называют строками «многобайтовых символов»,
потому что каждый символ в таких строках может быть представлен
несколькими байтами. Юникод обычно используется
в интернационализированных программах, чтобы обеспечить возможность
представления символов из европейских и азиатских алфавитов, которые
содержат гораздо больше символов, чем можно было бы представить
с помощью 8-битных байтов.

 Чтобы хранить такой текст в памяти компьютера, его необходимо
транслировать в последовательность простых байтов и обратно, используя
определенную кодировку – набор правил преобразования строк, состоящих
из символов Юникода, в последовательность байтов и извлечения строк
из последовательностей байтов. Говоря техническим языком, такие
преобразования между последовательностями байтов и строками обозначаются
двумя терминами:

  Кодирование – процесс преобразования строки символов
 в последовательность простых байтов в соответствии с желаемой
 кодировкой.

  Декодирование – процесс преобразования последовательности байтов
 в строку символов в соответствии с желаемой кодировкой.

 То есть мы кодируем строки в последовательности байтов и декодируем
последовательности байтов в строки. Для некоторых кодировок процесс
преобразования тривиально прост – в кодировках ASCII и Latin-1,
например, каждому символу соответствует единственный байт, поэтому
фактически никакого преобразования не требуется. Для других кодировок
процедура отображения может оказаться намного сложнее и порождать
по несколько байтов для каждого символа.

 Широко используемая кодировка UTF-8, например, позволяет представить
широкий диапазон символов, используя схему с переменным числом байтов.
Символы с кодами ниже 128 представляются одним байтом; символы с кодами
в диапазоне от 128 до 0x7ff (2047) преобразуются в двухбайтовые
последовательности, где каждый байт имеет значение от 128 до 255;
а символы с кодами выше 0x7ff преобразуются в трех- и четырех байтовые
последовательности, где каждый байт имеет значение от 128 до 255.
Благодаря этой схеме строки с символами ASCII остаются компактными,
ликвидируются проблемы с порядком следования байтов и исключается
необходимость использовать байты с нулевым значением, которые могут
вызывать проблемы при работе с библиотеками языка C и при организации
сетевых взаимодействий.

 Поскольку для сохранения совместимости различные кодировки отображают
символы в один и тот же диапазон кодов, набор символов ASCII является
подмножеством обеих кодировок, Latin-1 и UTF-8, – то есть допустимые
строки символов ASCII также будут считаться допустимыми строками
символов в кодировках Latin-1 и UTF-8. То же относится и к данным
в файлах: все текстовые файлы, состоящие из символов ASCII, будут
считаться допустимыми текстовыми файлами, с точки зрения кодировки
UTF-8, потому что ASCII – это подмножество 7-битных символов
в кодировке UTF-8.

 И наоборот, кодировка UTF-8 сохраняет двоичную совместимость с ASCII
для всех символов с кодами ниже 128. Кодировки Latin-1 и UTF-8 просто
включают дополнительные символы: Latin-1 включает дополнительные символы
с кодами в диапазоне от 128 до 255, отводя для каждого символа
один байт, а кодировка UTF-8 включает символы, которые могут быть
представлены несколькими байтами. Другие кодировки обеспечивают
расширение наборов символов похожими способами, но все эти наборы –
ASCII, Latin-1, UTF-8 и многие другие – рассматриваются как Юникод.

 С точки зрения программиста на языке Python, кодировки определяются как
строки, содержащие названия кодировок. Язык Python поддерживает примерно
100 различных кодировок – полный список вы найдете в справочнике
по стандартной библиотеке Python. Если импортировать модуль encodings
и вызвать функцию help(encodings), кроме всего прочего можно также
увидеть список из множества названий кодировок; некоторые из них
реализованы на языке Python, некоторые – на языке C. Отдельные кодировки
имеют несколько названий, например: latin-1 и iso8859_1 – это синонимы
одной и той же кодировки Latin-1. Мы еще вернемся к кодировкам,
ниже в этой главе, когда будем рассматривать способы записи строк
Юникода в сценариях.

 За дополнительной информацией о Юникоде обращайтесь к стандартному
набору руководств по языку Python. В разделе «Python HOWTOs» вы найдете
документ «Unicode HOWTO», где приводятся дополнительные сведения,
опущенные здесь для экономии места.


 Типы строк в Python

 Если говорить более конкретно, язык программирования Python
предоставляет строковые типы для представления текстовых данных
в сценариях. Какие именно строковые типы вы будете использовать,
зависит от версии Python. В Python 2.X имеется общий строковый тип,
обеспечивающий возможность представления двоичных данных и 8-битных
символов, таких как символы ASCII, а также более специализированный тип,
предназначенный для представления строк, состоящих из многобайтовых
символов Юникода:

  str – для представления текстовых строк из 8-битных символов
 и двоичных данных

  unicode – для представления текстовых строк из многобайтовых символов
 Юникода

 Эти два строковых типа в Python 2.X отличаются между собой (тип unicode
может представлять многобайтовые символы и обладает дополнительной
поддержкой операций кодирования и декодирования), однако они имеют
схожие наборы операций. Строковый тип str в Python 2.X используется
для представления текстовых данных, которые могут быть представлены
8-битными байтами, а также двоичных данных, которые представлены
абсолютными значениями байтов.

 Напротив, в Python 3.X имеется три строковых типа – один служит
для представления текстовых данных и два – для представления
двоичных данных:

  str – для представления текстовых строк, состоящих из символов Юникода
 (как 8-битных, так и многобайтовых)

  bytes – для представления двоичных данных

  bytearray – изменяемая версия типа bytes

 Как уже упоминалось выше, тип bytearray также имеется в Python 2.6,
однако реализация поддержки этого типа данных является результатом
переноса из версии 3.0 – он не делает четких различий для содержимого
и вообще считается типом данных, присущим версии 3.0.

 Все три строковых типа в версии 3.0 поддерживают похожие наборы
операций, но действуют они по-разному. Основная цель изменений
в версии 3.X состояла в том, чтобы объединить строковые типы,
используемые в версиях 2.X, для представления обычного текста и текста,
состоящего из символов Юникода, в один строковый тип, поддерживающий
обычные символы и символы Юникода: разработчики хотели устранить
разделение строк в 2.X и сделать работу со строками Юникода
более естественной. Учитывая, что символы ASCII и другие 8-битные
символы в действительности являются лишь подмножеством символов Юникода,
такое объединение выглядит вполне логичным.

 Для этого тип str в версии 3.0 определен как неизменяемая
последовательность символов (необязательно байтов), которая может
содержать обычный текст, состоящий из символов ASCII, по одному байту
на символ, или текст, состоящий из многобайтовых символов Юникода,
например из набора UTF-8. При обработке в сценариях строки этого типа
по умолчанию кодируются в соответствии с настройками системы, однако
имеется возможность явно указывать название кодировки для преобразования
объектов типа str как находящихся в памяти, так и при чтении/записи
текстовых файлов.

 Несмотря на то, что в версии 3.0 в новом строковом типе str
было достигнуто желаемое слияние обычных строк со строками Юникода,
тем не менее, во многих программах сохраняется потребность выполнять
обработку простых двоичных данных, которые не должны преобразовываться
в текстовое представление. В эту категорию попадают программы,
выполняющие обработку файлов изображений и аудиофайлов, а также
упакованных данных, используемых для обмена информацией с устройствами
или с программами на языке C при помощи модуля struct. Поэтому
для поддержки возможности обработки двоичных данных был введен новый
тип данных bytes.

 В версии 2.X потребность в обработке двоичных данных удовлетворял общий
тип str, потому что в этой версии строки рассматривались просто
как последовательности байтов (для представления строк, состоящих
из многобайтовых символов, использовался отдельный тип unicode).
В версии 3.0 тип bytes определен как неизменяемая последовательность
8-битных целых чисел, представляющих абсолютные значения байтов.
Кроме того, в версии 3.0 тип bytes поддерживает практически тот же
набор операций, что и тип str, включая строковые методы, операции
над последовательностями и даже поиск совпадений с помощью модуля re,
но не поддерживает операцию форматирования строк.

 В версии 3.0 объект типа bytes в действительности является
последовательностью коротких целых чисел, каждое из которых имеет
значение в диапазоне от 0 до 255. Операция извлечения элемента
по индексу из последовательности типа bytes возвращает объект типа int,
операция извлечения среза возвращает новый объект типа bytes,
а применение встроенной функции list к такому объекту дает в результате
список целых чисел, а не строк. Однако при выполнении операций, которые
применяются к символьным данным, содержимое объектов типа bytes
интерпретируется как байты в кодировке ASCII (например, метод isalpha
будет интерпретировать каждый байт как код символа ASCII). Кроме того,
для удобства объекты типа bytes выводятся как строки символов,
а не как последовательности целых чисел.

 Дополнительно разработчики Python добавили в версию 3.0 новый тип
bytearray. Тип bytearray – это разновидность типа bytes, допускающая
возможность непосредственного изменения объектов в памяти.
Он поддерживает обычные строковые операции, которые поддерживаются
типами str и bytes, а также множество операций, изменяющих сам объект,
как списки (например, методы append и extend и операцию присваивания
по индексу). Учитывая, что строки могут интерпретироваться
как последовательности простых байтов, тип bytearray обеспечивает
возможность непосредственного изменения строковых данных в памяти,
что невозможно в Python 2 без преобразования строк в объекты изменяемого
типа и не поддерживается типами str и bytes в Python 3.0.

 Несмотря на то, что Python 2.6 и 3.0 предлагают практически одни
и те же функциональные возможности, тем не менее, доступ к ним
организован совершенно по-разному. Фактически строковые типы
в Python 2.6 не имеют прямого соответствия в версии 3.0 – тип str
в версии 2.6 совмещает в себе типы str и bytes из версии 3.0,
а тип str в версии 3.0 совмещает в себе типы str и unicode
из версии 2.6. Кроме того, изменяемость типа bytearray в версии 3.0
вообще является уникальной.

 Однако на практике эти различия вовсе не выглядят такими кардинальными,
как может показаться. Все различия сводятся к следующему: в 2.6 тип str
используется для представления текстовых и двоичных данных,
а тип unicode – для других форм представления текста; в 3.0 тип str
используется для представления всех видов текстовых данных (состоящих
как из простых символов, так и из символов Юникода), а типы bytes
и bytearray – для представления двоичных данных. На практике выбор типа
нередко определяется используемыми инструментами – особенно
это относится к инструментам обработки файлов, о которых рассказывается
в следующем разделе.


 Текстовые и двоичные файлы

 Операции ввода-вывода над файлами также претерпели изменение
в Python 3.0. Они учитывают различия между типами str/bytes
и автоматически поддерживают кодирование символов Юникода.
Теперь в языке Python текстовые и двоичные файлы
имеют более существенные различия, не зависящие от платформы:

 Текстовые файлы

  Когда файл открывается в текстовом режиме, данные из него при чтении
 декодируются автоматически (с использованием кодировки по умолчанию,
 в зависимости от настроек системы или с использованием явно указанной
 кодировки) и возвращаются в виде объекта типа str. Операции записи
 принимают объекты типа str и автоматически кодируют содержащиеся в них
 данные перед записью в файл. Текстовые файлы также поддерживают
 универсальный механизм преобразования символов, обозначающих конец
 строки, и дополнительные аргументы, определяющие порядок кодирования.
 В зависимости от имени используемой кодировки, текстовые файлы могут
 также автоматически обрабатывать последовательности, являющиеся
 маркерами порядка следования байтов, находящиеся в начале файла.

 Двоичные файлы

  Когда файл открывается в двоичном режиме, добавлением в строку режима
 символа ‘b’ (только в нижнем регистре) в аргументе встроенной функции
 open, данные при чтении не декодируются, а просто возвращаются в своем
 неизменном виде, в виде объекта типа bytes. Операция записи точно так
 же принимает объект bytes и записывает его в файл, не выполняя никаких
 преобразований. Операции над двоичными файлами могут также принимать
 объекты типа bytearray и записывать их содержимое в файлы.

 Поскольку теперь типы str и bytes разграничиваются более четко, вам
придется заранее определять, какую природу имеют ваши данные – текстовую
или двоичную, и использовать для их представления объекты либо типа str,
либо bytes. И наконец, режим, в котором открывается файл, определяет тип
объектов, который должен использоваться для представления содержимого
этого файла:

  Если сценарий обрабатывает файлы с изображениями, упакованными
 двоичными данными, созданными другими программами, или потоки данных
 от каких-либо устройств, велика вероятность, что вам потребуется
 использовать объекты типа bytes и открывать файлы в двоичном режиме.
 У вас также имеется дополнительная возможность использовать тип
 bytearray, когда потребуется обновлять данные, не создавая
 промежуточные копии в памяти.

  Если сценарий обрабатывает данные, имеющие текстовую природу,
 такие как вывод другой программы, разметка HTML,
 интернационализированный текст или файлы в форматах CSV и XML,
 вам наверняка потребуется использовать объекты типа str и открывать
 файлы в текстовом режиме.

 Обратите внимание, что аргумент со строкой режима встроенной функции
open (второй ее аргумент) имеет особое значение в Python 3.0 –
он не только определяет режим работы с файлом, но и тип объектов.
Добавляя в строку режима символ b, вы определяете двоичный режим работы
и будете получать или должны передавать объекты типа bytes,
представляющие содержимое файла в операциях чтения и записи. Без символа
b файлы будут обрабатываться в текстовом режиме, и для представления
их содержимого вы будете использовать объекты типа str. Например,
режимы rb, wb и rb+ подразумевают использование типа bytes; r, w+ и rt
(по умолчанию) подразумевают использование типа str.

 Кроме того, в текстовом режиме файлы могут обрабатывать
последовательность с маркером порядка следования байтов
(byte order marker, BOM), который может присутствовать в начале файла
при использовании определенных схем кодирования символов. Например,
в кодировках UTF-16 и UTF-32 маркер BOM определяет прямой или обратный
порядок следования байтов (big-endian и little-endian соответственно).
По сути, порядок следования байтов имеет очень большое значение.
Текстовые файлы с данными в кодировке UTF-8 также могут включать
маркер BOM просто, чтобы указать, что содержимое файла записано именно
в кодировке UTF-8, хотя это и не является обязательным.
Когда выполняются операции чтения и записи с использованием этих схем
кодирования, интерпретатор автоматически пропускает или записывает
маркер BOM, если он вообще подразумевается кодировкой или если
вы указываете более конкретное имя кодировки, явно определяющее порядок
следования байтов. Например, обработка маркера BOM всегда выполняется
при использовании кодировки «utf-16», более специфическая кодировка
«utf-16-le» определяет обратный (little-endian) порядок следования б
айтов в кодировке UTF-16. Аналогично более специфическая кодировка
«utf-8-sig» вынуждает интерпретатор пропускать при чтении и записывать
маркер BOM при вводе и выводе соответственно текста в кодировке UTF-8
(обобщенное имя кодировки «utf-8» этого не предполагает).


 Примеры использования строк в Python 3.0

 Рассмотрим несколько примеров, демонстрирующих особенности
использования строковых типов в Python 3.0. Предварительное замечание:
программный код, представленный в этом разделе, может запускаться
только под управлением Python 3.0. Однако основные строковые операции
совместимы с разными версиями Python. Простые строки символов ASCII,
представленные в виде объекта типа str, одинаково обрабатываются
в версиях 2.6 и 3.0 (и в точности так, как мы видели в главе 7).
Кроме того, несмотря на то, что в Python 2.6 отсутствует тип bytes
(в этой версии используется один обобщенный тип str), программный код,
использующий этот тип данных, обычно остается работоспособным – в 2.6
вызов bytes(X) интерпретируется как синоним str(X), а новая форма
литералов b’...’ интерпретируется так же, как обычный строковый литерал
‘...’. Тем не менее в отдельных случаях вы можете столкнуться
с несовместимостью версий – в версии 2.6, например, функция bytes
не принимает второй аргумент (название кодировки), который является
обязательным в версии 3.0.


 Литералы и основные свойства

 В Python 3.0 строковые объекты создаются, когда вы вызываете встроенную
функцию, такую как str или bytes, манипулируете объектом файла,
созданным вызовом функции open (описывается в следующем разделе)
или определяете строковый литерал в тексте сценария. В последнем случае
для создания объектов типа bytes, в версии 3.0 была введена новая форма
литерала b’xxx’ (и эквивалентная ей: B’xxx’), а объекты типа bytearray
могут создаваться вызовом функции bytearray с различными аргументами.

 Если говорить более формально, в версии 3.0 все текущие формы о
пределения строковых литералов – ‘xxx’, “xxx” и текст в тройных кавычках
 – генерируют объект типа str. Добавление символа b или B перед
открывающей кавычкой в любой из этих форм приводит к созданию объекта
типа bytes. Эта новая форма b’...’ литерала bytes похожа на форму r’...’
«сырой» строки, которая использовалась, чтобы избежать необходимости
экранировать символы обратного слеша. Рассмотрим следующий сеанс работы
с интерактивной оболочкой Python 3.0:
"""

B = b'spam'   # Создаст объект bytes (8-битные байты)
S = 'eggs'    # Создаст объект str
# (символы Юникода, 8-битные или многобайтовые)
print(type(B), type(S))

print(B)  # Выведет строку символов,
# в действительности – последовательность целых чисел
print(S)

"""
 В действительности объект типа bytes является последовательностью
коротких целых чисел, однако его содержимое выводится как строка 
символов, если это возможно:
"""

print(B[0], S[0])    # Операция индексирования возвращает
# объект типа int для bytes и объект типа str для str
print(B[1:], S[1:])  # Операция извлечения среза возвращает
# новый объект типа bytes или str
print(list(B), list(S))
# Объект bytes в действительности содержит целые числа

"""
 Тип bytes относится к категории неизменяемых, как и тип str 
(а тип bytearray, описываемый ниже, – нет), – вы не сможете присвоить 
другой объект типа str, bytes или целое число по смещению 
в объекте bytes. Кроме того, префикс b может применяться к любым 
строковым литералам:

>>> B[0] = ‘x’  # Оба типа являются неизменяемыми
TypeError: ‘bytes’ object does not support item assignment
>>> S[0] = ‘x’
TypeError: ‘str’ object does not support item assignment
"""

B = B'''
xxxx
yyyy
'''
# Префикс b может предшествовать апострофам,
# кавычкам или тройным кавычкам
print(B)

"""
 Как уже упоминалось выше, в Python 2.6 также может использоваться форма
литерала b’xxx’, но она интерпретируется точно так же, как форма ‘xxx’ 
и создает объект типа str, а bytes – это всего лишь синоним для str.
В версии 3.0, как было показано выше, обе эти формы воспроизводят 
объекты отличного типа bytes. Обратите также внимание, что формы u’xxx’ 
и U’xxx’ литералов строк Юникода, имеющиеся в 2.6, были убраны в 3.0 – 
вместо них следует использовать форму ‘xxx’, потому что теперь 
все строки интерпретируются как строки Юникода, даже если они состоят 
только из символов ASCII (подробнее о литералах Юникода, содержащих 
не только символы ASCII.


 Преобразования
 
 В Python 2.X допускается смешивать в операциях объекты типов str 
и unicode (если строки содержат только 7-битные символы ASCII). Однако 
в версии 3.0 различия между типами str и bytes считаются настолько 
существенными, что смешивание их в выражениях не допускается, 
и они никогда автоматически не преобразуются из одного в другой 
при передаче в функции. Функция, которая ожидает получить аргумент
типа str, обычно не принимает аргумент типа bytes, и наоборот.

 По этой причине в Python 3.0 требуется, чтобы вы передавали объекты 
того или другого типа или выполняли явное преобразование:

  str.encode() и bytes(S, encoding) преобразуют строку 
 в последовательность простых байтов и на основе объекта типа str 
 создают объект типа bytes.
 
  bytes.decode() и str(B, encoding) преобразуют последовательность 
 простых байтов в строку и на основе объекта типа bytes создают объект 
 типа str.
 
 Эти методы, encode и decode (а также объекты файлов, описываемые 
в следующем разделе), используют либо кодировку по умолчанию, исходя 
из настроек системы, либо явно указанное название кодировки. 
Например, в 3.0:
"""

S = 'eggs'
print(S.encode())  # str в bytes: кодирует текст
#                    в последовательность байтов

print(bytes(S, encoding='ascii'))  # str в bytes, альтернативный способ

B = b'spam'
print(B.decode())  # bytes в str: декодирует байты в текст

print(str(B, encoding='ascii'))  # bytes в str, альтернативный способ

"""
 Здесь следует сделать два замечания. Прежде всего, кодировку 
по умолчанию, используемую в системе, можно узнать с помощью модуля sys,
но аргумент encoding в функции bytes не является необязательным, 
даже при том, что в функции str.encode (и bytes.decode) одноименный 
аргумент – необязательный.

 Во-вторых, несмотря на то, что функция str не требует указывать 
аргумент encoding, в отличие от функции bytes, его отсутствие 
в вызове функции str вовсе не означает, что будет использоваться
кодировка по умолчанию. Когда функция str вызывается без аргумента
encoding, она возвращает строковую форму объекта bytes, а не преобразует 
его в объект str (обычно это не совсем то, что требуется!). Предположим, 
что объекты B и S имеют значения, какие они получили 
в предыдущем сеансе:
"""

import sys


print(sys.platform)  # Тип платформы

print(sys.getdefaultencoding())  # Кодировка по умолчанию

print(str(B))  # Вызов str без аргумента encoding
# Выведет строку, а не выполнит преобразование!
print(len(str(B)))

print(len(str(B, encoding='ascii')))  # С аргументом encoding
# преобразует в объект типа str

"""
 __getattr__ и __getattribute__

 Операция чтения значения атрибута может быть перехвачена с помощью двух
разных методов:
  __getattr__ вызывается при обращении к неопределенным атрибутам –
 то есть к атрибутам, которые отсутствуют в экземпляре
 или в наследуемых им классах.
 
  __getattribute__ вызывается при обращении к любому атрибуту,
 поэтому при его использовании следует проявлять особую осторожность,
 чтобы не попасть в бесконечный цикл рекурсивных вызовов этого метода,
 и переадресовать операцию чтения супер-классу.

 В отличие от свойств и дескрипторов, эти методы являются частью
протокола перегрузки операторов в языке Python – комплекса методов
со специальными именами, которые наследуются подклассами и автоматически
вызываются при использовании экземпляров в соответствующей операции.
Подобно любым методам класса все они принимают ссылку на экземпляр
в первом аргументе self, благодаря которой получают доступ
к любым данным экземпляра и к другим методам класса.

 Кроме того, __getattr__ и __getattribute__ позволяют реализовать
более обобщенный способ управления атрибутами, чем свойства
и дескрипторы, – они могут использоваться для управления чтением любых
(или даже всех) атрибутов экземпляра. Благодаря такой особенности
эти два метода отлично подходят для реализации шаблона делегирования –
они могут использоваться для реализации объектов-оберток, управляющих
доступом ко всем атрибутам встроенного объекта.
В противоположность этому при использовании свойств и дескрипторов
мы можем управлять доступом только для каждого атрибута в отдельности.

 Наконец, эти два метода являются более узкоспециализированными
по сравнению с альтернативными решениями, с которыми мы познакомились
выше: они перехватывают только операцию чтения значения атрибута,
но не операцию присваивания. Чтобы перехватить операцию присваивания,
нам также потребуется реализовать метод __setattr__ – метод перегрузки
операторов, который вызывается при попытке присвоить значение любому
атрибуту и требующий особой осторожности, чтобы не попасть в бесконечный
цикл рекурсивных вызовов, выполняя присваивание посредством словаря
пространства имен экземпляра.

 Чтобы перехватывать операцию удаления атрибутов, мы можем также
реализовать метод __delattr__ (точно так же проявляя осторожность,
чтобы избежать зацикливания), хотя на практике он используется
гораздо реже. В противоположность этим методам, свойства и дескрипторы
перехватывают операции чтения, присваивания и удаления по умолчанию.


 Основы

 Методы __getattr__ и __setattr__ были представлены в главах 29 и 31,
а метод __getattribute__ коротко упоминался в главе 31. В двух словах,
если класс определяет или наследует следующие методы, они будут
вызываться автоматически в случаях, которые описываются в комментариях
справа:

def __getattr__(self, name):      # Обращение к неопределенному атрибуту
#                                   [obj.name]
def __getattribute__(self, name):
                                # Обращение к любому атрибуту [obj.name]
def __setattr__(self, name, value):       # Присваивание любому атрибуту
#                                           [obj.name=value]
def __delattr__(self, name):   # Удаление любого атрибута [del obj.name]

 Во всех этих случаях в аргументе self, как обычно, передается
подразумеваемый объект экземпляра, в аргументе name – строка
с именем атрибута, к которому выполняется доступ, а в аргументе
value – объект, присваиваемый атрибуту. Два метода get обычно возвращают
значение атрибута, а два других – значение None. Например,
чтобы перехватить попытки обращения к любым атрибутам, можно
использовать любой из двух первых методов, а чтобы перехватить попытки
присваивания любым атрибутам, можно использовать третий метод:
"""


class Catcher:
    def __getattr__(self, name):
        print('Get:', name)

    def __setattr__(self, name, value):
        print('Set:', name, value)


X = Catcher()
X.job  # Выведет “Get: job”
X.pay  # Выведет “Get: pay”
X.pay = 99  # Выведет “Set: pay 99”

"""
 Такой способ может использоваться для реализации шаблона делегирования,
с которым мы познакомились в главе 30. Поскольку все операции обращения
к атрибутам переадресуются нашим методам, мы можем проверять 
их допустимость и делегировать их выполнение встроенным объектам.
Следующий класс (заимствованный из главы 30), например, сообщает 
обо всех попытках чтения атрибутов другого объекта, которые 
производятся относительно экземпляра класса обертки:
"""


class Wrapper:
    def __init__(self, obj):
        self.wrapped = obj  # Сохранить объект

    def __getattr__(self, attrname):
        print('Trace:', attrname)  # Сообщить о попытке чтения
        return getattr(self.wrapped, attrname)
        # Делегировать операцию чтения


"""
 Предотвращение зацикливаний в методах управления доступом к атрибутам
 
 Эти методы достаточно просты в использовании – единственная сложность
заключается в возможности попасть в бесконечный цикл
рекурсивных вызовов. Метод __getattr__ вызывается только при попытке 
обратиться к неопределенному атрибуту, поэтому он может 
без всякой опаски обращаться к другим атрибутам. Однако методы
__getattribute__ и __setattr__ вызываются при обращении 
к любым атрибутам, поэтому внутри них следует проявлять осторожность, 
когда возникает необходимость обратиться к другим атрибутам, чтобы
избежать повторного вызова этого же метода и попадания 
в бесконечный цикл рекурсивных вызовов.
 
 Например, если внутри метода __getattribute__ обратиться к другому 
атрибуту, эта операция произведет вызов метода __getattribute__ 
и программный код начнет выполнять бесконечный цикл, пока не будет 
исчерпана доступная память:

def __getattribute__(self, name):
    x = self.other  # ЦИКЛ!

 Чтобы решить эту проблему, следует делегировать выполнение 
этой операции вышестоящему супер-классу – для исключения возможности
вызова метода на данном уровне. Класс object является супер-классом
для любого класса и прекрасно подходит на эту роль:

def __getattribute__(self, name):
    x = object.__getattribute__(self, ‘other’)  # Принудительный вызов 
    #                                             метода супер-класса
    
 В случае с методом __setattr__ складывается похожая ситуация – операция
присваивания любому атрибуту внутри этого метода снова приводит к вызову
метода __setattr__ и к попаданию в бесконечный цикл:

def __setattr__(self, name, value):
    self.other = value  # ЦИКЛ!
    
 Чтобы решить эту проблему, присваивание должно выполняться как запись
значения в словарь __dict__ пространства имен по ключ
с именем атрибута.

 Тем самым предотвращается выполнение прямой операции присваивания
атрибуту:

def __setattr__(self, name, value):
    self.__dict__[‘other’] = value  # С использованием словаря атрибутов
    
 Кроме того, чтобы избежать зацикливания, метод __setattr__ может 
делегировать выполнение операции присваивания вышестоящему супер-классу,
как в случае с методом __getattribute__, однако такой подход редко 
используется на практике:

def __setattr__(self, name, value):
    object.__setattr__(self, ‘other’, value)  # Принудительный вызов 
    #                                           метода супер-класса
    
 При этом в методе __getattribute__ мы не можем использовать трюк 
со словарем __dict__, чтобы избежать зацикливания:

def __getattribute__(self, name):
    x = self.__dict__[‘other’]  # ЦИКЛ!
    
 Попытка обратиться к атрибуту __dict__ также приводит к вызову метода 
__getattribute__, что опять вызывает попадание в бесконечный цикл. 
Странно, но верно!

 Метод __delattr__ редко используется на практике, но если используется, 
то будет вызываться при удалении любого атрибута (так же, как метод 
__setattr__ вызывается при попытке присвоить значение любому атрибуту). 
Поэтому вы также должны принять все меры, чтобы предотвратить попадание
в бесконечный цикл при удалении атрибутов, используя тот же самый прием: 
выполнить операцию над словарем пространства имен или вызвать метод 
супер-класса.


 Первый пример
 
 Чтобы увидеть, как применить на практике все
предложенные идеи, ниже приводится тот же самый первый пример, который
мы использовали для демонстрации свойств и дескрипторов, но на этот раз
он реализован с применением методов перегрузки операторов. Поскольку эти
методы вызываются при операциях с любыми атрибутами, мы добавили 
проверку имен атрибутов, чтобы отличать управляемые атрибуты – 
все остальные атрибуты обрабатываются обычным способом:
"""


class Person:
    def __init__(self, name):  # Вызывается при обращении Person()
        self._name = name  # Вызовет __setattr__!

    def __getattr__(self, attr):  # Вызывается операцией obj.undefined
        if attr == 'name':  # Для отсутствующего атрибута с именем name
            print('fetch...')
            return self._name  # Не вызывает зацикливание:
            #                    существующий атрибут
        else:  # Обращение к другим несуществующим
            raise AttributeError(attr)  # атрибутам вызывает ошибку

    def __setattr__(self, attr, value):  # Вызывается операцией
        #                                  obj.any = value
        if attr == 'name':
            print('change...')
            attr = '_name'  # Внутреннее имя атрибута
        self.__dict__[attr] = value  # Предотвратить зацикливание

    def __delattr__(self, attr):  # Вызывается операцией del obj.any
        if attr == 'name':
            print('remove...')
            attr = '_name'  # Предотвратить зацикливание,
        del self.__dict__[attr]  # но менее обычным способом


bob = Person('Bob Smith')  # Объект bob обладает управляемым атрибутом
print(bob.name)  # Вызовет __getattr__
bob.name = 'Robert Smith'  # Вызовет __setattr__
print(bob.name)
del bob.name  # Вызовет __delattr__
print('-' * 20)
sue = Person('Sue Jones')  # Объект sue также наследует свойство
print(sue.name)
# print(Person.name.__doc__) # Не имеет эквивалента в данном случае

"""
 Обратите внимание, что операция присваивания значения атрибуту 
в конструкторе __init__ приводит к вызову метода __setattr__ – 
этот метод перехватывает операции присваивания любым атрибутам, 
даже когда они выполняются внутри класса.

 Обратите также внимание, что в отличие от свойств и дескрипторов, 
здесь отсутствует возможность определения документации с описанием 
атрибутов – управляемые атрибуты существуют не в виде отдельных 
объектов, а внутри программного кода, обрабатывающего операции доступа 
к атрибутам.

 Чтобы добиться тех же результатов с помощью метода __getattribute__, 
достаточно заменить метод __getattr__ в примере следующим фрагментом.
Так как этот метод перехватывает обращения к любым атрибутам, 
в этой версии предприняты меры, предотвращающие зацикливание, 
за счет делегирования выполнения операции чтения супер-классу,
а кроме того, отпала необходимость явно возбуждать исключение 
при попытке обращения к неизвестному имени:
"""


class Person:
    def __init__(self, name):  # Вызывается при обращении Person()
        self._name = name  # Вызовет __setattr__!

    def __getattribute__(self, attr):  # Вызывается операцией [obj.any]
        if attr == 'name':  # Перехватывает обращения к любым именам
            print('fetch...')
            attr = '_name'  # Отображает на внутреннее имя
        return object.__getattribute__(self, attr)
        # Предотвратить зацикливание

    def __setattr__(self, attr, value):  # Вызывается операцией
        #                                  obj.any = value
        if attr == 'name':
            print('change...')
            attr = '_name'  # Внутреннее имя атрибута
        self.__dict__[attr] = value  # Предотвратить зацикливание

    def __delattr__(self, attr):  # Вызывается операцией del obj.any
        if attr == 'name':
            print('remove...')
            attr = '_name'  # Предотвратить зацикливание,
        del self.__dict__[attr]  # но менее обычным способом


bob = Person('Bob Smith')  # Объект bob обладает управляемым атрибутом
# print(bob.name)  # Вызовет __getattr__
bob.name = 'Robert Smith'  # Вызовет __setattr__
print(bob.name)
del bob.name  # Вызовет __delattr__
print('-' * 20)
sue = Person('Sue Jones')  # Объект sue также наследует свойство
print(sue.name)
# print(Person.name.__doc__) # Не имеет эквивалента в данном случае

"""
 Вследствие своей обобщенности методы __getattr__ и __getattribute__ 
наиболее часто используются для реализации шаблона делегирования 
(как уже отмечалось выше), где выполнение операции доступа к атрибутам 
делегируется вложенному объекту. Везде, где необходимо реализовать 
управление единственным атрибутом, свойства и дескрипторы могут 
предложить решение не только не хуже, а даже лучше. 


 Вычисляемые атрибуты
 
 Как и в случае со свойствами и дескрипторами, в следующем при-
мере создается виртуальный атрибут X, при попытке обращения к которому
производится вычисление его значения:
"""


class AttrSquare:
    def __init__(self, start):
        self.value = start  # Вызовет __setattr__!

    def __getattr__(self, attr):  # Вызывается при обращении
        if attr == 'X':  # к отсутствующему атрибуту
            return self.value ** 2  # value – существующий атрибут
        else:
            raise AttributeError(attr)

    def __setattr__(self, attr, value):  # Вызывается всеми операциями
        if attr == 'X':  # присваивания
            attr = 'value'
        self.__dict__[attr] = value


A = AttrSquare(3)
# 2 экземпляра класса с методами перегрузки операторов
B = AttrSquare(32)  # Каждый экземпляр хранит свои данные
print(A.X)  # 3 ** 2
A.X = 4
print(A.X)  # 4 ** 2
print(B.X)  # 32 ** 2

"""
 Как и прежде, того же эффекта можно добиться с использованием метода
__getattribute__ вместо __getattr__. В следующем примере мы заменили
метод чтения атрибутов на метод __getattribute__ и изменили метод 
__setattr__, реализующий операцию присваивания, воспользовавшись 
способом предотвращения зацикливания, основанным на прямом вызове
метода супер-класса:
"""


class AttrSquare:
    def __init__(self, start):
        self.value = start  # Вызовет __setattr__!

    def __getattribute__(self, attr):  # Вызывается при обращении
        #                                ко всем атр.
        if attr == 'X':
            return self.value ** 2  # Снова вызовет __getattribute__!
        else:
            return object.__getattribute__(self, attr)

    def __setattr__(self, attr, value):  # Вызывается всеми
        #                                   операциями присваивания
        if attr == 'X':
            attr = 'value'
        object.__setattr__(self, attr, value)


"""
 Если запустить эту версию примера, она выведет те же самые результаты.
Обратите внимание, как внутри класса происходит неявный вызов методов:

  Инструкция self.value=start внутри конструктора вызовет метод 
 __setattr__
 
  Выражение self.value внутри метода __getattribute__ повторно вызовет
 метод __getattribute__
 
 Фактически при каждой попытке получить значение атрибута X,
метод __getattribute__ вызывается дважды. Этого не происходит в версии, 
использующей метод __getattr__, потому что атрибут value не является 
неопределенным. Если вас волнует потеря производительности и хотелось 
бы избежать ее, измените реализацию метода __getattribute__ так,
чтобы он обращался к супер-классу для получения значения атрибута value:

def __getattribute__(self, attr):
    if attr == ‘X’:
        return object.__getattribute__(self, ‘value’) ** 2
        
 
 Сравнение методов __getattr__ и __getattribute__
 
 Чтобы обобщить различия между методами __getattr__ и __getattribute__,
в следующем примере используются оба метода для реализации доступа
к трем атрибутам, в числе которых: attr1 – атрибут класса, 
attr2 – атрибут экземпляра и attr3 – виртуальный атрибут, значение 
которого вычисляется при обращении к нему
"""


class GetAttr:
    attr1 = 1

    def __init__(self):
        self.attr2 = 2

    def __getattr__(self, attr):  # Только для неопределенных атрибутов
        print('get: ' + attr)  # Не attr1: наследуется от класса
        return 3  # Не attr2: хранится в экземпляре


X = GetAttr()
print(X.attr1)
print(X.attr2)
print(X.attr3)

print('-' * 40)


class GetAttribute(object):  # (object) – необходимо только в 2.6
    attr1 = 1

    def __init__(self):
        self.attr2 = 2

    def __getattribute__(self, attr):
        # Вызывается всеми операциями присваивания
        print('get: ' + attr)  # Для предотвращения зацикливания
        if attr == 'attr3':  # используется супер-класс
            return 3
        else:
            return object.__getattribute__(self, attr)


X = GetAttribute()
print(X.attr1)
print(X.attr2)
print(X.attr3)

"""
 Если запустить этот пример, можно будет увидеть, что версия на основе
метода __getattr__ перехватывает только попытки обращения 
к атрибуту attr3, потому что это единственный неопределенный аргумент.
С другой стороны, версия на основе метода __getattribute__ перехватывает
все попытки чтения значений атрибутов и для получения значений 
неуправляемых атрибутов должна вызывать метод супер-класса,
чтобы избежать зацикливания.


 Сравнение приемов управления
 
 Чтобы обобщить различия между всеми четырьмя приемами управления
атрибутами, которые мы рассмотрели в этой главе, пройдемся 
по более полному примеру реализации вычисляемых атрибутов, в котором 
используются все описанные приемы. В следующей версии свойства 
используются для управления доступом к вычисляемым атрибутам с именами 
square и cube. Обратите внимание, что их базовые значения сохраняются 
в атрибутах, имена которых начинаются с символа подчеркивания, – 
благодаря этому исключается конфликты между их именами 
и именами свойств:
"""


# 2 динамически вычисляемых атрибута, реализованные с помощью свойств
class Powers:
    def __init__(self, square, cube):
        self._square = square  # _square – базовое значение
        self._cube = cube  # square – имя свойства

    def getSquare(self):
        return self._square ** 2

    def setSquare(self, value):
        self._square = value

    square = property(getSquare, setSquare)

    def getCube(self):
        return self._cube ** 3

    cube = property(getCube)


X = Powers(3, 4)
print(X.square)  # 3 ** 2 = 9
print(X.cube)  # 4 ** 3 = 64
X.square = 5
print(X.square)  # 5 ** 2 = 25

"""
 Чтобы реализовать то же самое с помощью дескрипторов, мы определили
полноценные классы, экземпляры которых будут представлять вычисляемые
атрибуты. Обратите внимание, что эти дескрипторы сохраняют базовые 
значения в атрибутах экземпляра, поэтому, чтобы избежать конфликтов 
с именами дескрипторов, мы снова использовали имена, начинающиеся 
с символа подчеркивания (как будет показано в заключительном примере 
в конце этой главы, мы могли бы избежать необходимости соблюдать 
это требование, сохранив базовые значения в самих дескрипторах):
"""


# То же самое, но на основе дескрипторов
class DescSquare:
    def __get__(self, instance, owner):
        return instance._square ** 2

    def __set__(self, instance, value):
        instance._square = value


class DescCube:
    def __get__(self, instance, owner):
        return instance._cube ** 3


class Powers:  # Используйте (object) в 2.6
    square = DescSquare()
    cube = DescCube()

    def __init__(self, square, cube):
        self._square = square
        # “self.square = square” также будет работать,
        self._cube = cube
        # потому что вызовет метод __set__ дескриптора!


X = Powers(3, 4)
print(X.square)  # 3 ** 2 = 9
print(X.cube)  # 4 ** 3 = 64
X.square = 5
print(X.square)  # 5 ** 2 = 25

"""
 Для достижения тех же результатов с помощью метода __getattr__ 
нам снова придется сохранять базовые значения в атрибутах с именами, 
начинающимися с символа подчеркивания, чтобы имена управляемых атрибутов 
оказались неопределенными и при обращении к ним вызывался бы наш метод. 
Нам также потребуется реализовать метод __setattrr__, 
чтобы перехватывать операции присваивания и принять меры 
к предотвращению зацикливания:
"""


# То же самое, но на основе обобщенного метода __getattr__
# управления доступом к неопределенным атрибутам
class Powers:
    def __init__(self, square, cube):
        self._square = square
        self._cube = cube

    def __getattr__(self, name):
        if name == 'square':
            return self._square ** 2
        elif name == 'cube':
            return self._cube ** 3
        else:
            raise TypeError('unknown attr:' + name)

    def __setattr__(self, name, value):
        if name == 'square':
            self.__dict__['_square'] = value
        else:
            self.__dict__[name] = value


X = Powers(3, 4)
print(X.square)  # 3 ** 2 = 9
print(X.cube)  # 4 ** 3 = 64
X.square = 5
print(X.square)  # 5 ** 2 = 25

"""
 Последний вариант, основанный на использовании метода __getattribute__,
похож на предыдущую версию. Поскольку теперь мы перехватываем все 
операции чтения значений атрибутов, мы должны переадресовать попытки 
получения базовых значений супер-классу, чтобы избежать зацикливания:
"""


# То же самое, но на основе обобщенного метода __getattribute__
# управления доступом ко всем атрибутам
class Powers:
    def __init__(self, square, cube):
        self._square = square
        self._cube = cube

    def __getattribute__(self, name):
        if name == 'square':
            return object.__getattribute__(self, '_square') ** 2
        elif name == 'cube':
            return object.__getattribute__(self, '_cube') ** 3
        else:
            return object.__getattribute__(self, name)

    def __setattr__(self, name, value):
        if name == 'square':
            self.__dict__['_square'] = value
        else:
            self.__dict__[name] = value


X = Powers(3, 4)
print(X.square)  # 3 ** 2 = 9
print(X.cube)  # 4 ** 3 = 64
X.square = 5
print(X.square)  # 5 ** 2 = 25

"""
 Управление атрибутами встроенных операций
 
 Все вышесказанное справедливо для обычных атрибутов, однако
поведение этих методов требует дополнительных пояснений: при обращении
к атрибутам-методам, которые неявно вызываются встроенными операциями,
эти два метода могут вообще не вызываться. То есть вызов метода 
перегрузки оператора невозможно делегировать обернутому объекту, 
если класс-обертка сам переопределяет их.

 Например, операции обращения к атрибутам методов __str__, __add__,
__getitem__, которые неявно выполняются операциями вывода, оператором + 
и операцией индексирования соответственно, в Python 3.0 
не переадресуются методам __getattr__ и __getattribute__ управления 
атрибутами. Если говорить точнее:

  Для таких атрибутов в Python 3.0 не вызывается ни один из методов
 __getattr__ и __getattribute__.
 
 Другими словами, классы в Python 3.0 (и классы нового стиля 
в Python 2.6) не имеют прямой возможности перехватывать обращения 
к реализациям встроенных операций, таких как вывод или сложение. 
В Python 2.X поиск методов таких операций начинается в экземплярах,
как и всех остальных атрибутов, а в Python 3.0 поиск этих методов 
начинается в классах, минуя экземпляры.

 Это изменение усложняет реализацию шаблона делегирования в Python 3.0,
поскольку в этой версии нет универсального способа перехватить обращения
к методам перегрузки операторов и переадресовать их встроенному объекту.
Но это не является непреодолимым препятствием – класс-обертка может 
обойти это ограничение, определив все необходимые методы перегрузки 
операторов и реализовав в них делегирование вызовов вложенному объекту.
Эти дополнительные методы могут быть добавлены вручную, с помощью 
инструментов, или за счет определения их в общих супер-классах
и наследования их оттуда. Однако это делает реализацию обертки сложнее,
чем раньше, когда методы перегрузки операторов являлись 
частью интерфейса обернутого объекта.

 Имейте в виду, что эта проблема касается только методов __getattr__ 
и __getattribute__. Свойства и дескрипторы могут определяться 
только для конкретных атрибутов, поэтому в действительности они вообще 
не могут использоваться для реализации шаблона делегирования – 
единственное свойство или дескриптор не может использоваться 
для управления доступом к произвольным атрибутам. Кроме того, класс, 
в котором одновременно определяются и методы перегрузки операторов,
и методы управления доступом к атрибутам, будет работать корректно
независимо от типа управляемого атрибута. Здесь нас интересуют
лишь классы, которые не переопределяют методы перегрузки операторов, но
в которых требуется перехватить обращения к ним обобщенным способом.
"""


class GetAttr:
    eggs = 88  # eggs – атрибут класса, spam – атрибут экземпляра

    def __init__(self):
        self.spam = 77

    def __len__(self):  # Реализация операции len, иначе __getattr__
        print('__len__: 42')  # будет вызываться с именем __len__
        return 42

    def __getattr__(self, attr):  # Возвращает реализацию __str__
        # по запросу, иначе – функцию-заглушку
        print('getattr: ' + attr)
        if attr == '__str__':
            return lambda *args: '[Getattr str]'
        else:
            return lambda *args: None


class GetAttribute(object):
    # object – требуется в 2.6, подразумевается в 3.0
    eggs = 88  # В 2.6 для всех классов автоматически

    def __init__(self):  # выполняется условие isinstance(object)
        self.spam = 77  # Но мы вынуждены наследовать object, чтобы

    def __len__(self):  # обрести инструменты, присущие классам нового
        print('__len__: 42')
        # стиля, включая __getattribute__, и некоторые
        return 42  # атрибуты по умолчанию, с именами вида __X__

    def __getattribute__(self, attr):
        print('getattribute: ' + attr)
        if attr == '__str__':
            return lambda *args: '[GetAttribute str]'
        else:
            return lambda *args: None


for Class in GetAttr, GetAttribute:
    print('\n' + Class.__name__.ljust(50, '='))
    X = Class()
    X.eggs  # Атрибут класса
    X.spam  # Атрибут экземпляра
    X.other  # Отсутствующий атрибут
    len(X)  # Метод __len__ определен явно
    try:  # Классы нового стиля должны поддерживать [], +, вызов:
        X[0]  # __getitem__?
    except:
        print('fail []')
    try:
        X + 99  # __add__?
    except:
        print('fail +')
    try:
        X()  # __call__? (неявный вызов, встроенная операция)
    except:
        print('fail ()')
    X.__call__()  # __call__? (явный вызов, нет унаследованного метода)

    print(X.__str__())  # __str__? (явный вызов, унаследован от type)
    print(X)  # __str__? (неявный вызов, встроенная операция)

"""
 Если запустить этот пример под управлением Python 3.0, результаты 
использования метода __getattr__ получатся иными – ни один из неявных 
вызов методов перегрузки операторов, производимых встроенными 
операциями, не будет перехвачен ни одним из методов управления доступом
к атрибутам. При разрешении имен специальных методов Python 3.0 
пропускает этап поиска в экземплярах.

 По полученным результатам мы можем проследить, как работает 
этот пример:
 
  В версии 3.0 обе попытки перехватить обращение к методу __str__ 
 с помощью метода __getattr__ потерпели неудачу; одно из обращений 
 выполняется встроенной функцией print, а второе – явным вызовом метода, 
 потому что по умолчанию он наследуется из класса (в действительности, 
 из встроенного класса object, который является супер-классом
 для любых классов).

  Метод __getattribute__ сумел перехватить только одну попытку 
 обратиться к методу __str__ – явный вызов, который выполняется в обход
 унаследованной версии. Перехватить неявную попытку, выполняемую 
 встроенной функцией print, не удалось.

  В версии 3.0 ни один из методов не смог перехватить обращение 
 к методу __call__, которое выполняется встроенной операцией вызова,
 но оба перехватили явный вызов – в отличие от метода __str__, 
 данные объекты не имеют унаследованного метода __call__, что могло бы 
 повлечь неудачу с методом __getattr__.

  Вызов метода __len__ был перехвачен обоими классами просто потому, 
 что он явно определен в классах – если удалить метод __len__ 
 из классов, при обращении к нему в версии 3.0 не будет вызываться 
 ни метод __getattr__, ни метод __getattribute__.

  Попытки перехватить все остальные встроенные операции в версии 3.0 
 не увенчались успехом.

 Результаты показывают, что в Python 3.0 при неявном вызове методов
перегрузки операторов встроенными операциями ни один из методов 
управления доступом к атрибутам не участвует в этом процессе:
поиск таких атрибутов интерпретатор выполняет в классах, полностью 
пропуская этап поиска в экземплярах.

 Это обстоятельство усложняет реализацию классов-оберток в шаблоне 
делегирования в версии 3.0 – если обертываемый класс может содержать
методы перегрузки операторов, эти методы должны быть переопределены 
в классе-обертке и должны делегировать выполнение операций методам 
обернутого объекта. Вообще, при таком подходе может потребоваться 
создать множество дополнительных методов, чтобы реализовать шаблон 
делегирования.

 Пример того, как это изменение в версии 3.0 отразилось на работе 
самого интерпретатора, вы найдете в обсуждении реализации объекта 
os.popen в версии 3.0 в главе 14. Поскольку в Python 3.0 он реализован 
с применением класса-обертки, в котором для делегирования обращений 
к атрибутам вложенного объекта используется метод __getattr__, 
он не может перехватывать вызовы встроенной функции next(X), 
которая вызывает метод __next__. Однако он перехватывает и делегирует 
явные вызовы метода X.__next__(), потому что они не наследуются 
от супер-класса, как метод __str__, и такие вызовы выполняются
не встроенными операциями.

 Такое поведение похоже на то, как обрабатываются обращения к методу 
__call__ в нашем примере, – неявные обращения, выполняемые встроенными 
функциями, не приводят к вызову метода __getattr__, тогда как явные 
вызовы методов, которые не были унаследованы от типа класса, 
перехватываются. Другими словами, это изменение повлияло не только 
на наши классы-обертки, но даже на классы в стандартной библиотеке
Python! Учитывая размах влияния этого изменения, есть вероятность,
что в будущем оно будет пересмотрено, поэтому не забывайте
проверять наличие этой проблемы в следующих версиях.


 Повторный обзор примера реализации шаблона делегирования
"""


class Person:
    def __init__(self, name, job=None, pay=0):
        self.name = name
        self.job = job
        self.pay = pay

    def lastName(self):
        return self.name.split()[-1]

    def giveRaise(self, percent):
        self.pay = int(self.pay * (1 + percent))

    def __str__(self):
        return '[Person: %s, %s]' % (self.name, self.pay)


class Manager:
    def __init__(self, name, pay):
        self.person = Person(name, 'mgr', pay)
        # Встроенный объект Person

    def giveRaise(self, percent, bonus=.10):
        self.person.giveRaise(percent + bonus)
        # Перехватывает и делегирует

    def __getattr__(self, attr):
        return getattr(self.person, attr)
        # Делегирует остальные атрибуты

    def __str__(self):
        return str(self.person)  # Необходимо переопределить (в 3.0)


if __name__ == '__main__':
    sue = Person('Sue Jones', job='dev', pay=100000)
    print(sue.lastName())
    sue.giveRaise(.10)
    print(sue)
    tom = Manager('Tom Jones', 50000)  # Manager.__init__
    print(tom.lastName())  # Manager.__getattr__ -> Person.lastName
    tom.giveRaise(.10)  # Manager.giveRaise -> Person.giveRais
    print(tom)  # Manager.__str__ -> Person.__str__

"""
 Но, обратите внимание, что происходит, когда мы выводим объект класса 
Manager в конце сценария: функция print вызывает метод __str__ 
класса-обертки, который делегирует выполнение операции методу __str__ 
встроенного объекта класса Person. Помня об этом, посмотрите, 
что получится, если мы удалим метод Manager.__str__:
"""


# Удален метод Manager.__str__
class Manager:
    def __init__(self, name, pay):
        self.person = Person(name, 'mgr', pay)
        # Встроенный объект Person

    def giveRaise(self, percent, bonus=.10):
        self.person.giveRaise(percent + bonus)
        # Перехватывает и делегирует

    def __getattr__(self, attr):
        return getattr(self.person, attr)
        # Делегирует остальные атрибуты


tom = Manager('Tom Heff', 75000)
print(tom.lastName())
print(tom)

"""
 В Python 3.0 при выполнении операции вывода объектов класса Manager 
не происходит обращения к обобщенному методу __getattr__ управления 
доступом к атрибутам. Вместо этого вызывается метод __str__ 
по умолчанию, унаследованный от неявного супер-класса object
(объект sue по-прежнему выводится корректно, потому что класс Person 
явно определяет метод __str__).

 Переход на использование метода __getattribute__ не исправит ситуацию –
как и метод __getattr__, он не вызывается, когда встроенная операция 
пытается обратиться к соответствующему ей методу перегрузки операторов 
ни в Python 2.6, ни в Python 3.0:
"""


# Замена __getattr_ на __getattribute__
class Manager:                              # Используйте (object) в 2.6
    def __init__(self, name, pay):
        self.person = Person(name, 'mgr', pay)
        # Встроенный объект Person

    def giveRaise(self, percent, bonus=.10):
        self.person.giveRaise(percent + bonus)
        # Перехватывает и делегирует

    def __getattribute__(self, attr):
        print('**', attr)
        if attr in ['person', 'giveRaise']:
            return object.__getattribute__(self, attr)
            # Возвращает свой атр.
        else:
            return getattr(self.person, attr)
            # Делегирует остальные атрибуты


tom = Manager('Tom Hemm', 70000)
print(tom.lastName())
print(tom)

"""
 Обратите внимание, что метод __getattribute__ вызывается дважды, 
когда производится попытка получить имя метода: первый раз – с именем 
метода и второй раз – чтобы получить атрибут встроенного объекта 
self.person. Мы могли бы избавиться от такого повторения, прибегнув 
к различным ухищрениям, но мы по-прежнему должны переопределить метод 
__str__, чтобы перехватывать операцию вывода, хотя в следующем фрагменте 
она реализована иначе (использование self.person привело бы к неудаче 
в этой реализации метода __getattribute__):
"""


# Иная реализация __getattribute__ с целью избавиться от лишних вызовов
class Manager:
    def __init__(self, name, pay):
        self.person = Person(name, 'mgr', pay)

    def __getattribute__(self, attr):
        print('**', attr)
        person = object.__getattribute__(self, 'person')
        if attr == 'giveRaise':
            return lambda percent: person.giveRaise(percent+.10)
        else:
            return getattr(person, attr)

    def __str__(self):
        person = object.__getattribute__(self, 'person')
        return str(person)


tom = Manager('Tom Hel', 69000)
print(tom.lastName())
print(tom)

"""
 Если запустить эту альтернативу, наш объект будет выводиться корректно,
но только потому, что мы явно добавили метод __str__ в класс-обертку –
при обращении к этому атрибуту из встроенных операций, обобщенный метод 
управления доступом к атрибутам по-прежнему не вызывается.

 Из всего вышеизложенного следует вывод, что при реализации шаблона 
делегирования в Python 3.0 классы, такие как Manager, должны 
переопределять некоторые методы перегрузки операторов (например, 
__str__), чтобы делегировать выполнение соответствующих им операций 
встроенным объектам. Похоже, что нашими единственными очевидными 
вариантами является использование избыточное переопределение
методов перегрузки операторов в классах-обертках в Python 3.0.

 Замечу еще раз, что все вышеизложенное не является неразрешимой 
проблемой – при создании большинства классов-оберток можно заранее 
определить, какие методы перегрузки операторов потребуются, а применение
дополнительных инструментов и создание супер-классов помогут частично
автоматизировать эту задачу. Кроме того, не во всех классах используются 
методы перегрузки операторов (в действительности, в большинстве 
прикладных классов этого не требуется). Однако об этих особенностях
реализации шаблона делегирования в Python 3.0 следует помнить – когда 
методы перегрузки операторов являются частью интерфейса объектов, 
обертки должны учитывать это обстоятельство и обеспечивать переносимую 
реализацию, переопределяя эти методы локально.
"""

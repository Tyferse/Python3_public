"""
 Пример: добавление методов в классы

 В этом и в следующем разделе мы рассмотрим примеры двух наиболее
типичных случаев использования метаклассов: добавление методов в класс
и автоматическое декорирование всех методов.

 Кроме того, оба примера дают возможность сравнить декораторы классов
и метаклассы – наш первый пример сравнивает реализации расширения класса
и обертывания его экземпляров на основе метакласса и декоратора,
а во втором примере сначала применяется декоратор с метаклассом,
а затем применяется второй декоратор. Как вы увидите,
эти два инструмента часто оказываются взаимозаменяемыми и даже
взаимодополняющими.


 Расширение вручную

 Ранее в этой главе мы рассматривали шаблон программного кода,
расширяющего классы добавлением дополнительных методов различными
способами. Как мы видели, если к моменту написания классов уже известно,
какие методы потребуется добавить, достаточно будет воспользоваться
механизмом наследования. Того же эффекта зачастую можно добиться за счет
внедрения объекта, используя прием композиции. Однако иногда, в более
динамичных случаях, бывает необходимо использовать другие приемы –
вспомогательных функций обычно бывает вполне достаточно, но метаклассы
обеспечивают более очевидное решение и снижают затраты на сопровождение,
когда в будущем потребуется внести изменения.

 Давайте воплотим эти идеи в действующий программный код. Рассмотрим
следующий пример расширения класса вручную – он добавляет два метода
к двум классам после их создания:
"""


# Расширение вручную – добавление новых методов в классы
class Client1:
    def __init__(self, value):
        self.value = value

    def spam(self):
        return self.value * 2


class Client2:
    value = 'ni?'


def eggsfunc(obj):
    return obj.value * 4


def hamfunc(obj, value):
    return value + 'ham'


Client1.eggs = eggsfunc
Client1.ham = hamfunc

Client2.eggs = eggsfunc
Client2.ham = hamfunc
X = Client1('Ni!')
print(X.spam())
print(X.eggs())
print(X.ham('bacon'))
Y = Client2()
print(Y.eggs())
print(Y.ham('bacon'))

"""
 Этот прием действует, потому что методы всегда могут быть добавлены 
к классу после его создания при условии, что присваиваемые функции 
принимают ссылку на экземпляр в первом аргументе self. Этот аргумент 
может использоваться для доступа к информации, хранящейся в экземпляре 
класса, несмотря на то, что сама функция может быть определена 
независимо от класса.

 Если запустить этот пример, мы получим вывод от метода внутри первого
класса, а также от двух методов, добавленных к классам после 
их создания.

 Этот метод с успехом может использоваться в отдельных случаях и может
применяться для добавления методов к произвольным классам во время 
выполнения программы. Однако он имеет один существенный недостаток: 
нам придется многократно выполнять добавление методов ко всем классам, 
нуждающимся в этих методах. В данном примере добавить два метода 
к двум классам было несложно, но в более сложных ситуациях такой подход 
может потребовать больше времени и к тому же он чреват ошибками. Если мы
забудем выполнить расширение какого-либо класса или потребуется 
выполнить расширение как-то иначе, мы рискуем столкнуться с проблемами.


 Расширение с помощью метакласса

 Прием, основанный на расширении вручную, вполне дееспособен, 
но в крупных программах было бы лучше иметь возможность автоматически 
применять расширения сразу ко всему множеству классов. Благодаря этому 
мы смогли бы избежать ошибок при расширении классов. Кроме того, когда 
реализация расширения располагается в одном месте, это упрощает 
возможность внесения изменений в будущем – все классы будут получать 
изменения автоматически. Один из способов достижения этой цели 
заключается в использовании метаклассов. Если мы запрограммируем 
расширения в метаклассе, все классы, объявляющие этот метакласс, 
будут расширены единообразно и корректно и автоматически будут получать
любые изменения, которые могут быть добавлены в будущем. Этот прием 
демонстрирует следующий пример:
"""


# Расширение с помощью метакласса – лучше поддерживает изменения
# в будущем
def eggsfunc(obj):
    return obj.value * 4


def hamfunc(obj, value):
    return value + 'ham'


class Extender(type):
    def __new__(mcs, classname, supers, classdict):
        classdict['eggs'] = eggsfunc
        classdict['ham'] = hamfunc
        return type.__new__(mcs, classname, supers, classdict)


class Client1(metaclass=Extender):
    def __init__(self, value):
        self.value = value

    def spam(self):
        return self.value * 2


class Client2(metaclass=Extender):
    value = 'ni?'


X = Client1('Ni!')
print(X.spam())
print(X.eggs())
print(X.ham('bacon'))
Y = Client2()
print(Y.eggs())
print(Y.ham('bacon'))

"""
 На этот раз оба клиентских класса расширяются новыми методами благодаря
тому, что они являются экземплярами метакласса, который выполняет 
расширение. Если запустить эту версию примера, он выведет 
те же результаты, что и прежде, – мы не изменили реализацию 
дополнительных методов, а просто реструктурировали программный код,
организовав его более очевидным и наглядным способом.

 Обратите внимание, что метакласс в этом примере по-прежнему играет 
достаточно статичную роль: добавляет два известных метода к каждому 
классу, объявляющему метакласс. Фактически если нам всегда требуется 
одно и то же – добавлять одни и те же два метода к множеству классов, 
мы точно так же могли бы определить их в одном общем супер-классе
и наследовать его в подклассах. Однако на практике метаклассы способны 
обеспечить намного более динамичное поведение. Например, расширяемый 
класс мог бы формироваться на основе некоторой произвольной логики 
во время выполнения:


# Класс может формироваться, исходя из некоторых условий
# во время выполнения
class MetaExtend(type):
    def __new__(meta, classname, supers, classdict):
        if sometest():
            classdict[‘eggs’] = eggsfunc1
        else:
            classdict[‘eggs’] = eggsfunc2
        if someothertest():
            classdict[‘ham’] = hamfunc
        else:
            classdict[‘ham’] = lambda *args: ‘Not supported’
            
        return type.__new__(meta, classname, supers, classdict)
        

 Метаклассы против декораторов: раунд 2
 
 Если вы еще способны следить за развитием событий в этой главе, примите
также к сведению, что с функциональной точки зрения, область применения
декораторов классов, рассматривавшихся в предыдущей главе, часто 
пересекается с областью применения метаклассов, которые обсуждаются 
в этой главе.

 Это обусловлено тем, что:
 
  Декораторы классов присваивают оригинальным именам классов результат 
 вызова функции в конце инструкции class.

  Принцип действия метаклассов основан на переадресации процедуры 
 создания объекта класса в конце инструкции class.
 
 Несмотря на некоторые различия в моделях, на практике они обычно 
используются для достижения одних и тех же целей, хотя и разными 
способами. Фактически декораторы классов могут использоваться 
для управления экземплярами классов и самими классами. Однако 
если управление классами с применением декораторов является вполне 
естественным решением, то управление экземплярами с помощью метаклассов
может вызывать некоторые затруднения. Метаклассы лучше приспособлены 
для управлениями объектами классов.


 Расширение с помощью декоратора
 
 Так, метакласс в примере из предыдущего раздела, добавляющий два метода
в класс на этапе его создания, можно было бы реализовать в виде
декоратора класса – в подобных случаях декораторы можно считать 
аналогами метода __init__ метаклассов, так как ко времени вызова 
декоратора объект класса уже существует. Так же, как и при использовании 
метаклассов, в подобных случаях декораторы сохраняют оригинальный тип 
класса, потому что они не добавляют объекты с обертывающей логикой. 
Следующий пример выводит те же результаты, что и предыдущий пример 
с метаклассом:
"""


# Расширение с помощью декоратора: реализует те же действия, что и метод
# __init__ метакласса
def eggsfunc(obj):
    return obj.value * 4


def hamfunc(obj, value):
    return value + 'ham'


def Extender(aClass):
    aClass.eggs = eggsfunc  # Управляет классом, а не экземпляром
    aClass.ham = hamfunc  # Аналог метода __init__ метакласса
    return aClass


@Extender
class Client1:  # Client1 = Extender(Client1)
    def __init__(self, value):  # Повторно присваивает
        # оригинальному имени
        self.value = value  # класса значение функции-декоратора

    def spam(self):  # в конце инструкции class
        return self.value * 2


@Extender
class Client2:
    value = 'ni?'


X = Client1('Ni!')  # X – экземпляр класса Client1
print(X.spam())
print(X.eggs())
print(X.ham('bacon'))

Y = Client2()
print(Y.eggs())
print(Y.ham('bacon'))

"""
 Другими словами, по крайней мере, в некоторых случаях декораторы
способны управлять классами так же легко, как и метаклассы. Однако 
обратное нельзя сказать о метаклассах – метаклассы могут использоваться
для управления экземплярами, но только с применением определенной 
доли магии. Эта возможность демонстрируется в следующем разделе.


 Управление экземплярами вместо классов
 
 Как мы только что видели, декораторы часто могут играть ту же роль 
управления классами, что и метаклассы. Метаклассы, в свою очередь, 
часто могут играть ту же роль управления экземплярами, что и декораторы, 
но реализовать такое управление немного сложнее. То есть:

  Декораторы классов способны управлять и классами, и экземплярами.
  
  Метаклассы также способны управлять и классами, и экземплярами, но
 управление экземплярами реализуется сложнее.
 
 При этом в одних приложениях оказывается удобнее использовать 
один прием, а в других – другой. Например, рассмотрим следующий 
декоратор классов из примера в предыдущей главе. Он используется 
для вывода трассировочных сообщений, когда выполняется попытка получить 
значение атрибута с обычным именем:
"""


# Декоратор классов, используемый для трассировки попыток получить
# значения атрибутов экземпляров извне
def Tracer(aClass):  # На этапе декорирования @
    class Wrapper:
        def __init__(self, *args, **kargs):
            # На этапе создания экземпляра
            self.wrapped = aClass(*args, **kargs)
            # Использует имя в объемлющей области

        def __getattr__(self, attrname):
            print('Trace:', attrname)  # Перехватывает обращения ко
            # всем атр., кроме .wrapped
            return getattr(self.wrapped, attrname)
    
    return Wrapper  # Делегирует обращения обернутому объекту


@Tracer
class Person:  # Person = Tracer(Person)
    def __init__(self, name, hours, rate):  # Wrapper запоминает Person
        self.name = name
        self.hours = hours
        self.rate = rate  # Доступ изнутри методов не трассируется

    def pay(self):
        return self.hours * self.rate


bob = Person('Bob', 40, 50)
# bob – в действительности экземпляр Wrapper
print(bob.name)  # экземпляр Person встраивается во Wrapper
print(bob.pay())  # Вызовет __getattr__

"""
 Если запустить этот пример, декоратор использует прием повторного
присваивания значения оригинальному имени класса, чтобы обернуть объекты 
экземпляров объектом, который выводит трассировочные сообщения.

 Того же эффекта можно добиться с использованием метакласса, однако 
реализация будет выглядеть не такой простой. Метаклассы предназначены
для управления процедурой создания объектов классов, и их интерфейс 
приспособлен для решения этой задачи. Чтобы реализовать управление 
экземплярами с помощью метакласса, нам придется поколдовать. Следующий 
метакласс дает тот же эффект и выводит те же результаты, 
что и предыдущий декоратор:
"""


# Управление экземплярами подобно предыдущему примеру,
# но с помощью метакласса
def Tracer(classname, supers, classdict):  # На этапе создания класса
    aClass = type(classname, supers, classdict)
    # Создать клиентский класс

    class Wrapper:
        def __init__(self, *args, **kargs):
            # На этапе создания экземпляра
            self.wrapped = aClass(*args, **kargs)

        def __getattr__(self, attrname):
            print('Trace:', attrname)  # Перехватывает обращения ко
            # всем атр., кроме .wrapped
            return getattr(self.wrapped, attrname)
            
    return Wrapper  # Делегирует обращения обернутому объекту


class Person(metaclass=Tracer):  # Создать класс Person
    # с метаклассом Tracer
    def __init__(self, name, hours, rate):  # Wrapper запоминает Person
        self.name = name
        self.hours = hours
        self.rate = rate  # Доступ изнутри методов не трассируется

    def pay(self):
        return self.hours * self.rate


bob = Person('Bob', 40, 50)
# bob – в действительности экземпляр Wrapper
print(bob.name)  # экземпляр Person встраивается во Wrapper
print(bob.pay())  # Вызовет __getattr__

"""
 Эта реализация работает, как и ожидалось, но она опирается 
на использование двух хитростей. Во-первых, в этом примере используется 
простая функция вместо класса, потому что подклассы type должны 
придерживаться протокола создания объектов. Во-вторых, целевой класс 
должен создаваться вручную вызовом класса type – это необходимо, чтобы 
вернуть экземпляр обертки, тогда как метаклассы создают и возвращают 
целевой класс. В действительности в этом примере мы использовали 
протокол метаклассов, чтобы имитировать декоратор, а не наоборот. 
Поскольку и метаклассы, и декораторы вызываются в конце инструкции 
class, во многих случаях они оказываются вариациями 
на одну и ту же тему. Эта версия метакласса воспроизводит те же 
результаты, что и декоратор.

 Вообще говоря, метаклассы лучше подходят для управления классами
из-за особенностей их предназначения. Декораторы классов могут 
использоваться для управления и экземплярами, и классами, однако они 
не всегда являются лучшим выбором для замены метаклассов 
в сложных ситуациях. 


 Пример: применение декораторов к методам

 Как мы видели в предыдущем разделе, благодаря тому, что метаклассы 
и декораторы вызываются в конце инструкции class, они часто оказываются
взаимозаменяемыми, несмотря на различия в синтаксисе. Часто выбор 
между ними во многом зависит от личных предпочтений. Кроме того, 
существует возможность использовать их в различных комбинациях 
как взаимодополняющие инструменты. В этом разделе мы как раз исследуем
пример такой комбинации – применение декоратора функции ко всем методам
класса.


 Трассировка с декорированием вручную
 
 В предыдущей главе мы реализовали два декоратора функций, 
один из которых выполняет трассировку и подсчет количества вызовов 
декорированной функции, а другой выполняет хронометраж вызовов. 
Тогда были представлены несколько версий этих декораторов – одни из этих 
версий могут применяться и к функциям, и к методам, а другие – нет.
"""


def tracer(func):
    # Вместо класса с методом __call__ используется функция
    calls = 0  # Иначе “self” будет представлять экземпляр декоратора!

    def onCall(*args, **kwargs):
        nonlocal calls
        
        calls += 1
        print('call %s to %s' % (calls, func.__name__))
        return func(*args, **kwargs)
    
    return onCall


import time


def timer(label='', trace=True):  # Аргументы декоратора: сохраняются
    def onDecorator(func):  # На этапе декорирования сохраняется функция
        def onCall(*args, **kargs):  # При вызове: вызывается оригинал
            start = time.time()  # Информация в области видимости +
            result = func(*args, **kargs)  # атрибуты функции
            elapsed = time.time() - start
            onCall.alltime += elapsed
            if trace:
                frmt = '%s%s: %.5f, %.5f'
                values = (label, func.__name__, elapsed, onCall.alltime)
                print(frmt % values)
                
            return result
        
        onCall.alltime = 0
        return onCall
    
    return onDecorator


class Person:
    @tracer
    def __init__(self, name, pay):
        self.name = name
        self.pay = pay

    @tracer
    def giveRaise(self, percent):  # giveRaise = tracer(giverRaise)
        self.pay *= (1.0 + percent)  # onCall запоминает giveRaise

    @tracer
    def lastName(self):  # lastName = tracer(lastName)
        return self.name.split()[-1]


bob = Person('Bob Smith', 50000)
sue = Person('Sue Jones', 100000)
print(bob.name, sue.name)
sue.giveRaise(.10)  # Вызовет onCall(sue, .10)
print(sue.pay)
print(bob.lastName(), sue.lastName())  # Вызовет onCall(bob),
#                                        запоминает lastName

"""
 Если запустить этот пример, мы получим следующие результаты – вызовы
декорированных методов перехватываются логикой декоратора и затем 
делегируются оригинальным методам, потому что имена оригинальных методов
были связаны с декоратором.


 Трассировка с использованием метаклассов и декораторов
 
 Пример декорирования вручную, представленный в предыдущем разделе, 
действует, как ожидалось, но от нас потребовалось добавить декоратор 
перед каждым методом, для которого требуется выполнить трассировку, 
а позднее нам придется вручную удалять эти декораторы, когда надобность 
в трассировке отпадет. Если у нас возникнет необходимость выполнить 
трассировку всех методов класса, в крупных программах это может 
оказаться достаточно утомительным. Было бы лучше, если бы у нас имелась 
возможность каким-либо образом автоматически применить декоратор tracer 
сразу ко всем методам класса.

 Именно такую возможность дают нам метаклассы – благодаря тому, что они
вызываются уже после того, как класс будет сконструирован, метаклассы 
оказываются естественным инструментом добавления декораторов ко всем 
методам класса. Сканируя словарь с именами атрибутов класса 
и проверяя их на принадлежность к функциям, мы можем автоматически 
вызывать декораторы для методов и присваивать результаты оригинальным 
именам. Этот прием позволяет автоматически присвоить декораторы именам
методов, но при этом мы можем использовать его более глобально:
"""

# Метакласс, применяющий декоратор tracer ко всем методам
# клиентского класса
from types import FunctionType


class MetaTrace(type):
    def __new__(mcs, classname, supers, classdict):
        for attr, attrval in classdict.items():
            if type(attrval) is FunctionType:  # Метод?
                classdict[attr] = tracer(attrval)  # Декорировать
                
        return type.__new__(mcs, classname, supers, classdict)
        # Создать класс


class Person(metaclass=MetaTrace):
    def __init__(self, name, pay):
        self.name = name
        self.pay = pay

    def giveRaise(self, percent):
        self.pay *= (1.0 + percent)

    def lastName(self):
        return self.name.split()[-1]


bob = Person('Bob Smith', 50000)
sue = Person('Sue Jones', 100000)
print(bob.name, sue.name)
sue.giveRaise(.10)
print(sue.pay)
print(bob.lastName(), sue.lastName())

"""
 Если запустить этот пример, он выведет те же результаты, 
что и прежде, – вызовы методов сначала будут перехвачены декоратором 
tracer, а затем будут вызваны оригинальные методы.

 Результаты, которые вы видите здесь, являются результатом совместной 
работы декоратора и метакласса – метакласс автоматически применяет 
декоратор функций к каждому методу на этапе создания класса, а декоратор
функций автоматически перехватывает вызовы методов, чтобы вывести 
трассировочные сообщения. Данная комбинация «просто работает» благодаря 
универсальности обоих инструментов.


 Применение произвольного декоратора к методам
 
 В предыдущем примере метакласс работает с единственным, конкретным 
декоратором функций – tracer. Однако совсем несложно обобщить его, 
чтобы обеспечить возможность применения любого декоратора ко всем 
методам класса. Все, что для этого требуется сделать, – это добавить 
объемлющую область видимости, чтобы сохранить требуемый декоратор, 
практически так же, как мы делали это в декораторах в предыдущей главе.
Ниже приводится пример реализации такого обобщения и затем пример 
применения декоратора tracer:
"""


# Фабрика метаклассов: применяет любой декоратор ко всем методам класса
def decorateAll(decorator):
    class MetaDecorate(type):
        def __new__(mcs, classname, supers, classdict):
            for attr, attrval in classdict.items():
                if type(attrval) is FunctionType:
                    classdict[attr] = decorator(attrval)
                    
            return type.__new__(mcs, classname, supers, classdict)
        
    return MetaDecorate


class Person(metaclass=decorateAll(tracer)):
    # Применить произвольный декоратор
    def __init__(self, name, pay):
        self.name = name
        self.pay = pay

    def giveRaise(self, percent):
        self.pay *= (1.0 + percent)

    def lastName(self):
        return self.name.split()[-1]


bob = Person('Bob Smith', 50000)
sue = Person('Sue Jones', 100000)
print(bob.name, sue.name)
sue.giveRaise(.10)
print(sue.pay)
print(bob.lastName(), sue.lastName())

"""
 Если запустить этот пример, он снова выведет те же результаты,
что и предыдущие примеры, – мы по-прежнему декорируем все методы 
клиентского класса с помощью декоратора функций tracer, но делаем это 
более обобщенным способом.

 Теперь, чтобы применить другой декоратор, нам достаточно будет просто 
заменить имя декоратора в заголовке инструкции class. Например, чтобы 
воспользоваться декоратором функций timer, показанным ранее, мы могли бы
при определении нашего класса использовать любую из двух последних строк 
заголовков, приведенных ниже, – первая из них применяет декоратор timer 
со значениями аргументов по умолчанию, а вторая задает текст в аргументе 
label:

class Person(metaclass=decorateAll(tracer)):  # Применяет tracer

class Person(metaclass=decorateAll(timer())): 
# Применяет timer, со значениями аргументов по умолчанию

class Person(metaclass=decorateAll(timer(label=’**’))): 
# Декоратор с аргументами

 Обратите внимание, что в данном случае отсутствует возможность 
определять значения аргументов декоратора отдельно для каждого метода, 
но имеется возможность передавать аргументы, которые будут применяться 
ко всем методам, как показано выше. Чтобы опробовать такую возможность, 
используйте последнюю строку с объявлением метакласса, применяющего 
декоратор timer, и добавьте следующие строки в конец сценария:
"""


class Person(metaclass=decorateAll(timer(label='**'))):
    def __init__(self, name, pay):
        self.name = name
        self.pay = pay

    def giveRaise(self, percent):
        self.pay *= (1.0 + percent)

    def lastName(self):
        return self.name.split()[-1]


bob = Person('Bob Smith', 50000)
sue = Person('Sue Jones', 100000)
print(bob.name, sue.name)
sue.giveRaise(.10)
print(sue.pay)
print(bob.lastName(), sue.lastName())

# Если используется timer: общее время работы каждого метода
print('-'*40)
print('%.5f' % Person.__init__.alltime)
print('%.5f' % Person.giveRaise.alltime)
print('%.5f' % Person.lastName.alltime)

"""
 Метаклассы против декораторов: раунд 3
 
 Здесь область применения декораторов также пересекается с областью 
применения метаклассов. В следующей версии мы заменили метакласс 
из предыдущего примера декоратором класса. Здесь определяется 
и используется декоратор класса, который применяет декоратор функций 
ко всем методам класса. 

 Хотя предыдущее предложение больше напоминает заклинание, 
чем техническое описание, тем не менее, эта версия действует вполне 
естественным образом – декораторы в языке Python поддерживают 
возможность произвольного вложения и комбинирования:
"""


# Фабрика декораторов классов: применяет любой декоратор
# ко всем методам класса
def decorateAll(decorator):
    def DecoDecorate(aClass):
        for attr, attrval in aClass.__dict__.items():
            if type(attrval) is FunctionType:
                setattr(aClass, attr, decorator(attrval))  # Не __dict__
                
        return aClass
    
    return DecoDecorate


@decorateAll(tracer)  # Используется декоратор класса
class Person:  # Применяет декоратор func к методам
    def __init__(self, name, pay):  # Person = decorateAll(..)(Person)
        self.name = name  # Person = DecoDecorate(Person)
        self.pay = pay

    def giveRaise(self, percent):
        self.pay *= (1.0 + percent)

    def lastName(self):
        return self.name.split()[-1]


bob = Person('Bob Smith', 50000)
sue = Person('Sue Jones', 100000)
print(bob.name, sue.name)
sue.giveRaise(.10)
print(sue.pay)
print(bob.lastName(), sue.lastName())

"""
 Обратите внимание, что декоратор класса возвращает оригинальный, 
расширенный класс, а не обертку для его экземпляров (что характерно 
для приема обертывания). Как и в версии с метаклассом, мы сохраняем тип 
оригинального класса; экземпляр класса Person – это экземпляр класса 
Person, а не некоторого класса-обертки. Фактически этот декоратор класса 
выполняется только на этапе создания класса – он вообще не участвует 
в операциях создания экземпляров.

 Это отличие может иметь значение в программах, требующих, 
чтобы операции проверки типов экземпляров возвращали оригинальный класс,
а не обертку. Расширяя сам класс, а не его экземпляры, декораторы 
классов сохраняют оригинальный тип класса. При этом методы класса уже 
не являются оригинальными функциями, потому что теперь они привязаны 
к декораторам, но на практике это не очень важно. Впрочем, то же самое 
происходит и в версии на основе метакласса.

 Обратите также внимание, что подобно версии с метаклассом 
в этом примере не поддерживается возможность определять аргументы 
декоратора функций отдельно для каждого метода, но имеется возможность 
передавать аргументы, которые будут применяться ко всем методам. 
Чтобы использовать этот же прием для применения декоратора timer, 
например, достаточно использовать любую из двух последних строк, 
следующих ниже, непосредственно перед определением класса, – 
первая из них применяет декоратор со значениями аргументов по умолчанию, 
а вторая явно определяет значение одного из аргументов:

@decorateAll(tracer)  # Декорирует все методы декоратором tracer

@decorateAll(timer())  # Декорирует все методы декоратором timer 
# со значениями аргументов по умолчанию defaults

@decorateAll(timer(label=’@@’)) # То же самое, но определяет
# аргумент декоратора

 Как и прежде, воспользуемся последним объявлением декоратора и добавим
следующие строки в конец сценария, чтобы протестировать наш пример 
с другим декоратором:
"""


@decorateAll(timer(label='@@'))
class Person:  # Применяет декоратор func к методам
    def __init__(self, name, pay):  # Person = decorateAll(..)(Person)
        self.name = name  # Person = DecoDecorate(Person)
        self.pay = pay

    def giveRaise(self, percent):
        self.pay *= (1.0 + percent)

    def lastName(self):
        return self.name.split()[-1]


bob = Person('Bob Smith', 50000)
sue = Person('Sue Jones', 100000)
print(bob.name, sue.name)
sue.giveRaise(.10)
print(sue.pay)
print(bob.lastName(), sue.lastName())

print('-'*40)
print('%.5f' % Person.__init__.alltime)
print('%.5f' % Person.giveRaise.alltime)
print('%.5f' % Person.lastName.alltime)

"""
 Сценарий выведет те же результаты – мы получили результаты хронометража
отдельных вызовов и всех вызовов в сумме для каждого метода, но при этом
мы передали декоратору timer другое значение в аргументе label.

 Как видите, метаклассы и декораторы классов часто оказываются не только
взаимозаменяемыми, но и взаимодополняющими инструментами. И те и другие 
предоставляют дополнительные и мощные возможности управления объектами 
классов и экземпляров, так как оба инструмента в конечном итоге 
позволяют добавлять программный код, который автоматически вызывается
в процессе создания класса. Хотя в некоторых, более сложных случаях 
может оказаться предпочтительнее использовать какой-то определенный 
инструмент, тем не менее, в большинстве ситуаций выбор того или иного 
инструмента или их комбинаций во многом зависит от личных предпочтений.


 «Необязательные» особенности языка

 Тем не менее проблема состоит в том, что в действительности оценка
особенностей, вынесенная в заголовок, относится только к тем, 
кто работает в одиночку и пользуется только тем программным кодом, 
который написан ими самими. Как только подобная «необязательная» 
особенность языка начинает использоваться кем-либо в организации, 
она перестает быть необязательной – она фактически становится 
обязательной для всех в этой организации. То же относится и к стороннему
программному обеспечению, используемому в ваших программах, – если автор 
этого программного обеспечения использует дополнительные возможности 
языка, они перестают быть необязательными для вас, потому что вам
придется изучить эту особенность, чтобы иметь возможность использовать 
или изменять программный код.

 Такое положение вещей касается всех дополнительных инструментов,
перечисленных в начале этой главы, – декораторов, свойств, дескрипторов,
метаклассов и так далее. Если кто-то начинает использовать их 
в программах, с которыми вам придется работать, они автоматически
становятся обязательной частью ваших знаний. То есть никакая 
«необязательная» особенность в действительности не является 
необязательной. Большинству из нас не приходится выбирать.

 С другой стороны, многие читатели могут изучать расширенные темы
по мере необходимости. И, честно признаться, прикладные программисты 
обычно тратят больше времени на изучение библиотек и расширений, 
а не на расширенные, и иногда таинственные особенности языка.
Например, книга «Программирование на Python»1, продолжающая эту
книгу, главным образом обсуждает вопросы применения прикладных
библиотек для решения таких задач, как разработка графического 
интерфейса, работа с базами данных и с Сетью, а не эзотерические 
инструменты языка.

 Обратная сторона такого роста языка состоит в том, что он стал более
мощным. При аккуратном использовании такие инструменты, как декораторы 
и метаклассы, оказываются не только «крутыми» фишками, но и позволяют 
творчески мыслящим программистам создавать более гибкие и удобные 
прикладные интерфейсы для использования другими программистами. 
Как мы уже видели, они позволяют решать проблемы инкапсуляции 
и сопровождения программного кода. Является ли изучение этих расширенных 
особенностей языка необходимым для вас, – решать вам. К сожалению, 
нередко решение принимается исходя из уровня подготовки, – более опытные
программисты применяют более сложные инструменты, забывая о других, 
менее опытных программистах. Однако, к счастью, так бывает не всегда –
хорошие программисты прекрасно понимают, что простота – это искусство,
а дополнительные инструменты должны использоваться, только когда они 
действительно необходимы. Это справедливо для любых языков 
программирования, но для языка Python в особенности, потому что он часто 
предстает перед новыми или начинающими программистами как инструмент 
с расширенными возможностями.

 Если вы все еще не согласны, имейте в виду, что существует множество
пользователей Python, которые с трудом ориентируются даже в основах
ООП и классов. Это правда – я встречал тысячи таких пользователей.
Программы на языке Python, требующие, чтобы их пользователи владели 
всеми тонкостями метаклассов, декораторов и тому подобного, вероятно 
не должны рассчитывать на очень широкий рынок сбыта.
"""

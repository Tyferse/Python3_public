"""
 Метаклассы


 Нужны или не нужны метаклассы

 Метаклассы в первую очередь предназначены для программистов,
занимающихся созданием библиотек и инструментов, которыми будут
пользоваться другие. Во многих (если не в большинстве) случаях
они являются не самым лучшим выбором для использования в прикладных
программах. Это особенно верно, если вы разрабатываете программы,
которые в будущем будут сопровождаться другими людьми. Использование
чего-то «просто потому, что это круто» – не самое веское оправдание,
если только вы не занимаетесь экспериментами или изучением.

 Тем не менее метаклассы могут использоваться в самых разных целях,
и поэтому важно знать, когда они могут быть полезны. Например,
метаклассы могут использоваться для расширения классов такими
возможностями, как трассировка, сохранение в файлах, регистрация
исключений и многими другими. Они могут также использоваться
для конструирования отдельных частей классов во время выполнения,
опираясь на файлы с настройками, позволяют единообразно применять
декораторы функций ко всем методам класса, проверять на соответствие
ожидаемым интерфейсам и так далее.

 В самых грандиозных воплощениях метаклассы могут использоваться даже
для реализации альтернативных шаблонов проектирования, таких как
аспектно-ориентированное программирование, объектно-реляционные
отображения (object/relational mappers, ORM) для баз данных
и многого другого. Несмотря не то, что тех же результатов часто можно
добиться другими способами (как мы увидим далее, области применения
декораторов и метаклассов часто пересекаются), тем не менее, метаклассы
предоставляют формальную модель, приспособленную для решения этих задач.


 Углубляемся в магию

 Основное внимание в этой книге уделялось простым приемам прикладного
программирования, так как большинство программистов решают свои задачи
за счет создания модулей, функций и классов. Они могут использовать
классы и создавать экземпляры и иногда могут даже использовать методы
перегрузки операторов, но едва ли им требуется слишком глубоко вникать
в особенности работы классов.

 Однако в этой книге мы также видели различные инструменты, которые
позволяют разными способами управлять поведением интерпретатора
и которые имеют отношение скорее к внутренней организации Python
или к инструментальным средствам, чем к сфере прикладного
программирования:

 Атрибуты механизма интроспекции

  Специальные атрибуты, такие как __class__ и __dict__, позволяют нам
 получать информацию о внутреннем устройстве объектов Python
 и обрабатывать их обобщенными способами – вывести перечень атрибутов
 объекта, имя класса и так далее.

 Методы перегрузки операторов

  Методы классов со специальными именами, такие как __str__ и __add__,
 позволяют перехватывать и определять поведение экземпляров классов
 при применении к ним встроенных операций, таких как вывод, операторы
 выражений и других. Они вызываются автоматически в ответ на попытку
 выполнить встроенную операцию и позволяют создавать классы,
 соответствующие ожидаемым интерфейсам.

 Методы обработки обращений к атрибутам

  Специальная категория методов перегрузки операторов обеспечивает
 возможность перехватывать попытки доступа к атрибутам экземпляра:
 методы __getattr__, __setattr__ и __getattribute__ позволяют
 классам-оберткам добавлять автоматически вызываемый программный код,
 который может проверять допустимость обращений к атрибутам
 и делегировать их выполнение встроенным объектам. С их помощью можно
 управлять доступом к любому количеству атрибутов – как к отдельным
 атрибутам, так и ко всем сразу, – значения которых могут вычисляться
 непосредственно в момент доступа.

 Свойства классов

  Встроенная функция property позволяет ассоциировать программный код
 с определенным атрибутом, который будет автоматически вызываться
 при попытке получить значение атрибута, присвоить ему новое значение
 или удалить его. Хотя этот инструмент не настолько универсальный,
 как описанные в предыдущем абзаце, тем не менее, свойства позволяют
 организовать автоматический вызов программного кода при попытке
 обращения к отдельным атрибутам.

 Дескрипторы атрибутов классов

  В действительности, функция property – это простейший способ задать
 дескриптор атрибута, который автоматически вызывает функции,
 управляющие доступом к атрибуту. Дескрипторы позволяют определить
 методы-обработчики __get__, __set__ и __delete__ в отдельном классе,
 которые автоматически вызываются при обращении к атрибуту, которому
 присвоен экземпляр этого класса. Они предоставляют способ добавить
 программный код, вызываемый автоматически при обращении к определенному
 атрибуту, и вызываются после того, как атрибут будет найден обычной
 процедурой поиска.

 Декораторы функций и классов

  Как мы уже видели в главе 38, специальный синтаксис @callable
 декораторов позволяет добавлять логику, которая будет запускаться
 автоматически при вызове функции или при выполнении операции создания
 экземпляра. Эта обертывающая логика может выполнять трассировку
 или хронометраж вызовов, проверять аргументы, управлять всеми
 экземплярами класса, добавлять в экземпляры дополнительные особенности,
 такие как управление доступом к атрибутам, и многое другое. Синтаксис
 декораторов вставляет логику повторного присваивания имени, которая
 вызывается в конце инструкций определения функций и классов, – именам
 декорируемых функций и классов присваиваются вызываемые объекты,
 перехватывающие последующие вызовы.

 Как упоминалось во введении к этой главе, метаклассы являются
продолжением этой истории – они позволяют добавлять логику, которая
автоматически вызывается при создании классов, в конце инструкции class.
Эта логика не присваивает оригинальному имени класса вызываемый объект
декоратора, а делегирует операцию создания самого класса
специализированной логике. Другими словами, метаклассы – это всего лишь
другой способ, позволяющий определить автоматически вызываемый
программный код. Посредством метаклассов и других инструментов,
перечисленных выше, Python предоставляет способы вставлять логику
обработки различных операций – вычисление выражений, обращение
к атрибутам, вызовы функций, создание экземпляров классов, а теперь
и создание объектов классов.

 В отличие от декораторов классов, которые обычно добавляют логику,
вызываемую на этапе создания экземпляров, метаклассы выполняются
на этапе создания классов – они представляют собой обработчики, которые
используются для управления классами, а не их экземплярами.

 Например, метаклассы могут использоваться для автоматического
декорирования всех методов классов, регистрации всех классов
для использования в библиотеках, автоматического добавления логики
к классам, создания или расширения классов на основе упрощенных
спецификаций в текстовых файлах и так далее. Благодаря тому,
что метаклассы могут управлять процессом создания классов
(и, как следствие, поведением, которое приобретают их экземпляры),
область их применения чрезвычайно широка.

 Как мы уже видели, многие из этих дополнительных инструментов
языка Python часто имеют пересекающиеся области применения. Например,
управление атрибутами часто может быть реализовано с помощью свойств,
дескрипторов или методов управления атрибутами. Как мы увидим далее
в этой главе, декораторы классов и метаклассы также часто оказываются
взаимозаменяемыми. Декораторы классов чаще всего используются
для управления экземплярами, тем не менее, они могут использоваться
также и для управления классами. Аналогично, метаклассы предназначены
для расширения конструкции классов, но они также часто используются
для добавления программного кода, управляющего экземплярами. Поскольку
выбор той или иной используемой техники иногда зависит исключительно
от личных предпочтений, знание альтернатив может помочь вам выбрать
правильный инструмент для решения той или иной задачи.


 Недостатки «вспомогательных» функций

 Кроме того, подобно декораторам, о которых рассказывалось в предыдущей
главе, с теоретической точки зрения, метаклассы являются
необязательными к применению инструментами. Обычно тех же результатов
можно добиться, передавая объекты классов управляющим функциям
(иногда их называют «вспомогательными»), практически так же, как можно
достичь целей, преследуемых декораторами, передавая управляющим функциям
объекты функций и экземпляров. Однако точно так же, как и декораторы,
метаклассы:

  Обеспечивают более формальный и очевидный способ управления.

  Помогают гарантировать, что прикладные программисты не забудут
 расширить свои классы в соответствии с требованиями прикладного
 интерфейса.

  Снижают избыточность программного кода и упрощают его сопровождение
 за счет переноса логики управления классами в одно место – в метакласс.

 Чтобы проиллюстрировать эти утверждения, предположим, что нам
требуется автоматически добавить метод во множество классов. Конечно,
мы могли бы сделать то же самое за счет наследования, если на этапе
программирования классов известно, какой метод следует добавить.
В этом случае мы можем просто реализовать метод в супер-классе
и унаследовать его во всех классах:


class Extras:
    def extra(self, args):  # Обычное наследование: слишком статично
        ...


class Client1(Extras): ...  # Клиенты наследуют дополнительные методы
class Client2(Extras): ...
class Client3(Extras): ...


X = Client1() # Создать экземпляр
X.extra() # Вызвать дополнительный метод

 Однако иногда бывает невозможно заранее предсказать подобное расширение
на этапе программирования классов. Представьте себе ситуацию, когда
классы должны расширяться в ответ на действия пользователя во время
выполнения программы или когда спецификации определяются в файлах
с настройками. Конечно, мы могли бы реализовать все классы
в воображаемом множестве, вручную проверяя необходимость добавления
подобных методов, но это может существенно усложнить клиентские классы
(в данном случае функция required – это некоторая функция,
выполняющая какие-то проверки):

def extra(self, arg):
    ...


class Client1: ...  # Расширение клиентов: слишком разбросанно
    if required():
        Client1.extra = extra
class Client2: ...
    if required():
        Client2.extra = extra
class Client3: ...
    if required():
        Client3.extra = extra


X = Client1()
X.extra()

 Мы можем также добавить методы в классы за пределами инструкций class,
как показано ниже, благодаря тому, что методы классов – это обычные
функции, которые ассоциированы с классами и принимают экземпляры классов
в первом аргументе self. Это вполне работоспособное решение,
но оно переносит все бремя расширения на сами клиентские классы
(и вообще-то предполагает, что мы не забудем сделать это!).

 С точки зрения простоты сопровождения, было бы гораздо лучше
изолировать логику выбора в одном месте. Мы могли бы инкапсулировать
часть этой работы, передавая классы управляющей функции – эта функция
дополнит класс необходимыми расширениями и выполнит все необходимые
проверки настроек во время выполнения:

def extra(self, arg): ...

def extras(Class):  # Управляющая функция: слишком много ручной работы
    if required():
        Class.extra = extra

class Client1: ...
extras(Client1)

class Client2: ...
extras(Client2)

class Client3: ...
extras(Client3)

X = Client1()
X.extra()

 В этом примере классы передаются управляющей функции сразу после их
создания. Подобное применение управляющих функций позволяет решить
поставленную задачу, тем не менее, этот способ по-прежнему ложится
тяжелым грузом на плечи программистов, которые должны понять
предъявляемые требования и придерживаться их. Было бы лучше иметь более
простой способ принудительного расширения клиентских классов, используя
который программисты не забывали бы добавлять расширения и который
не требовал бы выполнения операций с клиентскими классами. Другими
словами, нам хотелось бы иметь возможность добавлять некоторый
программный код, который автоматически вызывался бы в конце инструкции
class для расширения класса.

 Это именно то, что предлагают метаклассы – объявляя метакласс,
мы сообщаем интерпретатору, что он должен передать создание объекта
класса другому классу, указанному нами:

def extra(self, arg): ...


class Extras(type):
    def __init__(Class, classname, superclasses, attributedict):
        if required():
            Class.extra = extra


class Client1(metaclass=Extras): ...
# Метакласс достаточно просто объявить


class Client2(metaclass=Extras): ...
# Клиентский класс – экземпляр метакласса


class Client3(metaclass=Extras): ...


X = Client1() # X – экземпляр класса Client1
X.extra()

 Поскольку интерпретатор автоматически вызывает метакласс в конце
инструкции class, сразу после создания нового класса, он получает
возможность расширить, зарегистрировать или выполнить другие необходимые
операции над классом. Кроме того, к клиентским классам предъявляется
единственное требование – они должны объявить метакласс. Каждый класс,
в котором имеется такое объявление, автоматически получает
все расширения, предусмотренные метаклассом, – и теперь, и в будущем,
если метакласс изменится. Хотя это и не так заметно в таком маленьком
примере, тем не менее, метаклассы лучше подходят для решения подобных
задач, чем другие инструменты.


 Метаклассы против декораторов классов: раунд 1

 Интересно также отметить, что область применения декораторов классов,
обсуждавшихся в предыдущей главе, иногда пересекается с областью
применения метаклассов. Несмотря на то, что обычно они используются
для управления экземплярами и расширения их возможностей, тем не менее,
декораторы классов могут также использоваться для расширения самих
классов независимо от создаваемых экземпляров.

 Например, предположим, что мы реализовали управляющую функцию так,
что она возвращает расширенную версию класса, вместо того, чтобы просто
модифицировать его экземпляры. Это обеспечило бы более высокую степень
гибкости, так как в этом случае управляющая функция может вернуть объект
любого типа, реализующий ожидаемый интерфейс класса:

def extra(self, arg): ...

def extras(Class):
    if required():
        Class.extra = extra
    return Class


class Client1: ...
Client1 = extras(Client1)

class Client2: ...
Client2 = extras(Client2)

class Client3: ...
Client3 = extras(Client3)

X = Client1()
X.extra()

 Если вам показалось, что это напоминает декораторы классов,
то вы не ошиблись. В предыдущей главе декораторы классов были
представлены как инструмент расширения операции создания экземпляров.
Благодаря тому, что принцип их действия основан на автоматическом
присваивании результата функции оригинальному имени класса, нет никаких
причин считать их лишь экземплярами. То есть декораторы классов могут
выполнять дополнительные операции не только при создании экземпляров,
но и при создании самих классов:

def extra(self, arg): ...

def extras(Class):
    if required():
        Class.extra = extra
    return Class


@extras
class Client1: ...  # Client1 = extras(Client1)


@extras
class Client2: ...
# Присваивает объект имени класса независимо от экземпляров


@extras
class Client3: ...


X = Client1()  # Создать экземпляр расширенного класса
X.extra()  # X – экземпляр оригинального класса Client1

 Применение декораторов позволило автоматизировать предыдущий пример,
в котором присваивание измененной версии класса его оригинальному имени
происходило вручную. Как и в случае с метаклассами, здесь экземпляры
создаются с помощью оригинального класса, а не объекта-обертки,
потому что декоратор возвращает оригинальный класс. Фактически операция
создания экземпляра в этом примере вообще не перехватывается.

 В данном конкретном случае – добавления методов в класс в процессе его
создания – выбор между метаклассами и декораторами достаточно
произволен. Декораторы могут использоваться и для управления
экземплярами, и для управления классами, причем вторая область
их применения пересекается с областью применения метаклассов.

 Однако в действительности декораторы могут выполнять только одну
функцию метаклассов. Как мы увидим далее, в этой своей роли декораторы
являются аналогом метода __init__ метаклассов, но у метаклассов имеются
другие, дополнительные возможности настройки клиентских классов.
Мы также узнаем, что помимо инициализации класса метаклассы способны
решать самые разные задачи, связанные с конструированием классов,
реализовать которые с помощью декораторов может оказаться очень сложно.

 Кроме того, декораторы могут использоваться для управления
и экземплярами, и классами, но то же самое нельзя сказать
о метаклассах – метаклассы предназначены для управления классами
и применять их для управления экземплярами совсем непросто.


 Модель метаклассов


 Классы – экземпляры класса type

 До сих пор в этой книге мы решали свои задачи, создавая экземпляры
встроенных типов, таких как списки и строки, а также экземпляры наших
собственных классов. Как мы уже знаем, экземпляры классов обладают
некоторыми атрибутами с собственными данными, а кроме того,
они наследуют атрибуты поведения от классов, на основе которых
они были созданы. То же самое верно и для встроенных типов – экземпляры
списков, например, обладают собственными значениями и наследуют методы
от типа list.

 Мы многого можем добиться с помощью таких объектов экземпляров, однако
модель типов в языке Python оказывается немного богаче, чем я описал.
В действительности в той модели, которую мы видели до сих пор,
есть белые пятна: экземпляры создаются на основе классов, но на основе
чего создаются сами классы? Оказывается, что классы также являются
экземплярами некоторого класса:

  В Python 3.0 объекты пользовательских классов являются экземплярами
 объекта с именем type, который сам является классом.

  В Python 2.6 классы нового стиля наследуют класс object, который
 является подклассом класса type. Классические классы являются
 экземплярами type и не создаются из класса.

 Понятие типов мы исследовали в главе 9, а отношения между типами
и классами – в главе 31, тем не менее, мы еще раз пройдемся по основам,
чтобы увидеть, как они применяются к метаклассам.

 Напомню, что встроенная функция type возвращает тип любого объекта
(который сам по себе является объектом). Для встроенных типов,
таких как списки, типом экземпляра является встроенный тип list,
а типом типа list является сам тип type. Объект type, находящийся
на вершине иерархии, создает более специализированные типы,
а эти специализированные типы создают экземпляры. Вы можете наблюдать
это в интерактивной оболочке.
"""

print(type([]))
print(type(type([])))
print(type(list))
print(type(type))

"""
 type является уникальным встроенным объектом, который находится 
на вершине иерархии типов и используется для конструирования 
других типов:

 Оказывается, что отношение вида тип/экземпляр сохраняется 
и для классов: экземпляры создаются из классов, а классы создаются 
из объекта type. Однако в Python 3.0 понятие «тип» было объединено 
с понятием «класс». Фактически эти два понятия стали синонимами – классы
являются типами, а типы – классами. То есть:

  Типы определяются классами, а классы являются производными от type.
  
  Пользовательские классы являются экземплярами классов типов.
  
  Пользовательские классы являются типами, которые генерируют 
 собственные экземпляры.

 Как мы видели, эти положения подтверждаются программным кодом выше,
который проверяет типы экземпляров: тип экземпляра – это класс, 
из которого он был получен. Это же справедливо и для классов, 
что является ключом к теме этой главы. Поскольку классы обычно создаются
из корневого класса type, большинству программистов не нужно 
задумываться об эквивалентности понятий тип/класс. Однако это открывает
новые возможности для расширения не только классов, но и их экземпляров.

 Например, классы в Python 3.0 (и классы нового стиля в Python 2.6) 
являются экземплярами класса type, а объекты экземпляров являются 
экземплярами своих классов. Фактически классы теперь имеют атрибут 
__class__, который ссылается на класс type, так же, как экземпляры имеют
атрибут __class__, ссылающийся на классы, из которых они были созданы:
"""


class C:
    pass  # Объект класса в 3.0 (класс нового стиля)


X = C()  # Объект экземпляра класса
print(type(X))  # Экземпляр – это экземпляр класса
print(X.__class__)  # Класс экземпляра
print(type(C))  # Класс – экземпляр класса type
print(C.__class__)  # Класс класса – type

"""
 Обратите особое внимание на две последние строки в примере – классы
являются экземплярами класса type, так же, как обычные экземпляры 
являются экземплярами классов. В версии 3.0 это одинаково справедливо
как для встроенных типов, так и для пользовательских классов. Фактически 
классы не являются каким-то отдельным понятием: они просто являются 
пользовательскими типами, а сам тип определяется классом.


 Метаклассы – подклассы класса type
 
 Итак, где нам может пригодиться знание, что в Python 3.0 классы 
являются экземплярами класса type? Оказывается, это обстоятельство 
позволяет нам создавать метаклассы. Поскольку теперь понятие типа 
совпадает с понятием класса, мы можем создать подкласс класса type
с использованием обычных приемов объектно-ориентированного 
программирования и синтаксиса определения классов, 
чтобы адаптировать его. А так как классы в действительности являются 
экземплярами класса type, создание классов из адаптированных подклассов 
класса type позволит нам реализовать собственные типы классов.

  type – это класс, из которого создаются пользовательские классы.
  
  Метаклассы – это подклассы класса type.
  
  Объекты классов – это экземпляры класса type или его подклассов.
  
  Объекты экземпляров создаются из классов.
  
 Другими словами, чтобы управлять созданием классов и расширять 
их возможности, нам достаточно указать, что пользовательский класс 
создается из пользовательского метакласса, а не из обычного класса type.

 Следует заметить, что отношение между экземпляром класса и типом – 
не то же, что наследование: пользовательские классы могут также иметь 
супер-классы, от которых они и их экземпляры наследуют атрибуты
(наследуемые супер-классы перечисляются в круглых скобках в инструкции
class и сохраняются в атрибуте __bases__ класса в виде кортежа). 
Отношение с типом, из которого создается класс и экземпляром которого 
он является, – это совсем другой вид отношений.


 Протокол инструкции class
 
 Создание производных классов от класса type с целью расширения 
его возможностей – это на самом деле лишь половина магии, происходящей 
за кулисами метаклассов. Нам еще необходим способ передать управление 
процедурой создания класса метаклассу, вместо класса type. 
Чтобы полностью понять, как это делается, нам также необходимо знать,
как действует инструкция class. Мы уже знаем, что когда интерпретатор 
встречает инструкцию class, он выполняет вложенный блок инструкции, 
чтобы создать атрибуты класса, – все операции присваивания,
выполняющиеся на верхнем уровне внутри определения класса, создают
атрибуты объекта класса. Обычно это функции методов, создаваемые 
вложенными инструкциями def, но точно так же это могут быть любые другие 
атрибуты, которые будут служить атрибутами данных, общими 
для всех экземпляров.

 Говоря техническим языком, интерпретатор следует стандартному 
протоколу: в конце инструкции class после выполнения всех вложенных
инструкций и сохранения всех созданных имен в словаре пространства имен 
он вызывает объект type, чтобы создать объект класса:

class = type(classname, superclasses, attributedict)

 Объект type определяет метод __call__ перегрузки операторов, который 
вызывает два других метода, когда вызывается объект type:

type.__new__(typeclass, classname, superclasses, attributedict)
type.__init__(class, classname, superclasses, attributedict)

 Метод __new__ создает и возвращает новый объект класса, а затем этот
вновь созданный объект инициализируется методом __init__. Как мы увидим
чуть ниже, именно эти два метода обычно переопределяются в метаклассах,
адаптирующих класс type, для расширения классов.

 Например, для следующего определения класса:


class Spam(Eggs):  # Наследует класс Eggs
    data = 1  # Атрибут данных класса

    def meth(self, arg):  # Атрибут метода класса
        pass


 интерпретатор выполнит вложенный блок программного кода, создаст два
атрибута класса (data и meth) и затем вызовет объект type, чтобы создать 
объект класса:

Spam = type(‘Spam’, (Eggs,), {‘data’: 1, ‘meth’: meth, 
                             ‘__module__’: ’__main__’})
                             
 Этот вызов выполняется в конце инструкции class, поэтому он является 
идеальным местом, где можно было бы внести дополнения или как-то иначе 
обработать класс. Вся хитрость состоит в том, чтобы заменить type
его подклассом, который перехватит этот вызов. 


 Объявление метаклассов

 Как мы только что видели, по умолчанию классы создаются из класса type.
Чтобы заставить интерпретатор вместо него использовать наш метакласс,
достаточно просто добавить объявление метакласса, после чего он будет 
использоваться для создания класса. Порядок объявления метакласса 
зависит от используемой версии Python. В Python 3.0 нужно указать 
желаемый метакласс в виде именованного аргумента в заголовке инструкции 
class:


class Spam(metaclass=Meta):  # В версии 3.0 и выше


 В заголовке перед объявлением метакласса также могут быть перечислены 
наследуемые супер-классы. Так, в следующем примере новый класс Spam
наследует класс Eggs, но при этом является экземпляром и создается 
метаклассом Meta:


class Spam(Eggs, metaclass=Meta):  # Допускается указывать супер-классы


 При наличии объявления метакласса операция создания объекта класса,
выполняемая в конце инструкции class, изменяется так, что вместо класса
type она вызывает метакласс:

class = Meta(classname, superclasses, attributedict)

 А так как метакласс является подклассом type, он наследует 
метод __call__ класса type, который делегирует вызовы методов создания
и инициализации нового объекта класса метаклассу, если он определяет 
свои версии этих методов:

Meta.__new__(Meta, classname, superclasses, attributedict)
Meta.__init__(class, classname, superclasses, attributedict)

 Для примера ниже еще раз приводится фрагмент из предыдущего раздела, 
дополненный спецификацией метакласса в формате версии 3.0:


class Spam(Eggs, metaclass=Meta):  # Наследует Eggs, экземпляр Meta
    data = 1  # Атрибут данных класса
    def meth(self, arg):  # Атрибут метода класса
        pass
        
        
 В конце этой инструкции class интерпретатор выполнит следующий вызов,
чтобы создать объект класса:

Spam = Meta(‘Spam’, (Eggs,), {‘data’:1, ‘meth’:meth, 
                              ‘__module__’:’__main__’})
                              
 Если в метаклассе определены собственные версии методов __new__ 
или __init__, эти методы будут вызваны унаследованным от type методом 
__call__ для создания и инициализации нового класса. 


 Программирование метаклассов
 
 Единственное их важное отличие от обычных классов состоит в том, 
что метаклассы автоматически вызываются интерпретатором в конце 
инструкции class, и они должны придерживаться интерфейса, ожидаемого 
супер-классом type.


 Основы метаклассов
 
 Самый простой, пожалуй, метакласс, который только можно 
запрограммировать, – это обычный подкласс класса type с методом __new__,
который создает объект класса вызовом метода супер-класса type.
Метод __new__ метакласса, как показано в следующем примере, вызывается
методом __call__, унаследованным от type, – обычно в нем выполняются 
необходимые дополнительные операции по настройке и затем вызывается 
метод __new__ супер-класса type, чтобы создать и вернуть новый
объект класса:
"""


class Meta(type):
    def __new__(mcs, classname, supers, classdict):
        # Вызывается унаследованным методом type.__call__
        return type.__new__(mcs, classname, supers, classdict)


"""
 В действительности этот метакласс ничего не делает (с тем же успехом 
мы могли бы позволить создать класс с помощью класса по умолчанию type),
но он демонстрирует способ, каким можно задействовать метакласс 
в процедуре создания класса для его расширения. Так как метакласс 
вызывается в конце инструкции class и благодаря тому, что метод __call__ 
объекта type вызывает методы __new__ и __init__, реализации этих методов
могут управлять всеми классами, создаваемыми с помощью метакласса.
"""


class MetaOne(type):
    def __new__(mcs, classname, supers, classdict):
        print('In MetaOne.new:', classname, supers, classdict,
              sep='\n...')
        return type.__new__(mcs, classname, supers, classdict)


class Eggs:
    pass


print('making class')


class Spam(Eggs, metaclass=MetaOne):  # Наследует Eggs, экземпляр Meta
    data = 1  # Атрибут данных класса

    def meth(self, arg):  # Атрибут метода класса
        pass


print('making instance')
X = Spam()
print('data:', X.data)

"""
 Здесь класс Spam наследует класс Eggs и является экземпляром класса 
MetaOne, но объект X является экземпляром класса Spam. Запустите этот 
пример под управлением Python 3.0 и обратите внимание, что метакласс
вызывается в конце инструкции class, еще до того, как будет создан 
экземпляр класса, – метаклассы служат для создания классов, а классы – 
для создания экземпляров.


 Расширение операций конструирования и инициализации
 
 Метаклассы могут также переопределять метод __init__, вызываемый 
методом __call__ объекта type: вообще говоря, метод __new__ создает 
и возвращает объект класса, а метод __init__ инициализирует 
уже созданный класс. Метаклассы могут переопределять оба метода
и с их помощью управлять процессом создания класса:
"""


class MetaOne(type):
    def __new__(mcs, classname, supers, classdict):
        print('In MetaOne.new: ', classname, supers, classdict,
              sep='\n...')
        return type.__new__(mcs, classname, supers, classdict)

    def __init__(cls, classname, supers, classdict):
        print('In MetaOne init:', classname, supers, classdict,
              sep='\n...')
        print('...init class object:', list(cls.__dict__.keys()))


print('making class')


class Spam(Eggs, metaclass=MetaOne):  # Наследует Eggs, экземпляр Meta
    data = 1  # Атрибут данных класса

    def meth(self, arg):  # Атрибут метода класса
        pass


print('making instance')
X = Spam()
print('data:', X.data)

"""
 В этом случае метод инициализации класса вызывается после вызова 
метода, конструирующего класс, но оба они вызываются в конце инструкции 
class, перед тем, как будет создан хотя бы один экземпляр.


 Другие приемы программирования метаклассов
 
 Переопределение методов __new__ и __init__ супер-класса type – это
наиболее типичный способ добавить логику в процедуру создания объекта 
класса, но при этом существуют и другие способы.


 Использование простых фабричных функций
 
 Вообще говоря, метакласс в действительности не обязательно должен быть
классом. Как мы уже знаем, чтобы создать класс, инструкция class 
производит простой вызов в конце. Вследствие этого в качестве метакласса 
может использоваться любой вызываемый объект, который принимает 
передаваемые ему аргументы и возвращает объект, совместимый с ожидаемым
классом. Фактически роль метакласса может играть объект простой 
фабричной функции:
"""


# Простая функция также может играть роль метакласса
def MetaFunc(classname, supers, classdict):
    print('In MetaFunc: ', classname, supers, classdict, sep='\n...')
    return type(classname, supers, classdict)


print('making class')


class Spam(Eggs, metaclass=MetaFunc):  # В конце вызовет простую функцию
    data = 1  # Функция возвращает класс

    def meth(self, args):
        pass


print('making instance')
X = Spam()
print('data:', X.data)

"""
 Если запустить этот пример, в конце инструкции class будет вызвана 
функция, которая вернет новый объект ожидаемого класса. Функция 
перехватывает вызов, который обычно предназначается методу __call__ 
объекта type.


 Перегрузка метода вызова процедуры создания класса в метаклассе
 
 При работе с метаклассами интерпретатор использует обычные механизмы
ООП, поэтому метаклассы могут также перехватывать сам вызов процедуры
создания, который выполняется в конце инструкции class, переопределив
метод __call__. Однако при этом реализация метакласса становится немного
сложнее:
"""


# Метод __call__ можно переопределить,
# а метаклассы могут иметь свои метаклассы
class SuperMeta(type):
    def __call__(mcs, classname, supers, classdict):
        print('In SuperMeta.call: ', classname, supers, classdict,
              sep='\n...')
        return type.__call__(mcs, classname, supers, classdict)


class SubMeta(type, metaclass=SuperMeta):
    def __new__(mcs, classname, supers, classdict):
        print('In SubMeta.new: ', classname, supers, classdict,
              sep='\n...')
        return type.__new__(mcs, classname, supers, classdict)

    def __init__(cls, classname, supers, classdict):
        print('In SubMeta init:', classname, supers, classdict,
              sep='\n...')
        print('...init class object:', list(cls.__dict__.keys()))


print('making class')


class Spam(Eggs, metaclass=SubMeta):
    data = 1

    def meth(self, arg):
        pass


print('making instance')
X = Spam()
print('data:', X.data)

"""
 Если запустить этот пример, интерпретатор по очереди вызовет все три 
переопределенных метода. По сути – это то, что делает объект type.


 Перегрузка метода вызова процедуры создания класса в обычных классах
 
 Предыдущий пример осложняется тем фактом, что для создания объектов
классов используются метаклассы, которые не создают собственные 
экземпляры. Вследствие этого правила поиска имен для метаклассов 
несколько отличаются от тех, к которым мы привыкли. Поиск метода
__call__, например, выполняется в классе объекта. Для метаклассов 
это означает – в метаклассе метакласса.

 Чтобы задействовать обычный механизм поиска имен, начиная с экземпляра,
мы можем использовать обычные классы и экземпляры. Следующий пример
выведет те же результаты, что и предыдущая версия, но обратите внимание,
что здесь методы __new__ и __init__ должны иметь другие имена, 
в противном случае они будут вызываться при создании экземпляра SubMeta,
а не когда позднее он будет вызываться как метакласс:
"""


class SuperMeta:
    def __call__(self, classname, supers, classdict):
        print('In SuperMeta.call: ', classname, supers, classdict,
              sep='\n...')
        Class = self.__New__(classname, supers, classdict)
        self.__Init__(Class, classname, supers, classdict)
        return Class


class SubMeta(SuperMeta):
    def __New__(self, classname, supers, classdict):
        print('In SubMeta.new: ', classname, supers, classdict,
              sep='\n...')
        return type(classname, supers, classdict)

    def __Init__(self, Class, classname, supers, classdict):
        print('In SubMeta init:', classname, supers, classdict,
              sep='\n...')
        print('...init class object:', list(Class.__dict__.keys()))


print('making class')


class Spam(Eggs, metaclass=SubMeta()):
    # Метакласс – экземпляр обычного класса
    data = 1  # Вызывается в конце инструкции

    def meth(self, arg):
        pass


print('making instance')
X = Spam()
print('data:', X.data)

"""
 Хотя эти альтернативные формы вполне работоспособны, однако 
в большинстве случаев метаклассы выполняют свою работу, переопределяя 
методы __new__ и __init__ супер-класса type. На практике этого вполне
достаточно, и такой подход гораздо проще других способов. Тем не менее 
ниже мы увидим, что простой метакласс в виде функции часто может 
действовать как декоратор класса, что позволяет метаклассам управлять 
не только классами, но и экземплярами.


 Экземпляры и наследование
 
 Из-за того, что объявления метаклассов напоминают объявления
наследуемых супер-классов, при первом знакомстве это может вводить
в заблуждение. Следующие ключевые моменты помогут вам обобщить 
и прояснить модель метаклассов:

  Метаклассы наследуют класс type. Хотя они и играют свою особую роль,
 но определяются метаклассы с помощью инструкции class и поддерживают 
 обычную модель ООП в языке Python. Например, будучи подклассами 
 класса type, они могут переопределять методы объекта type,
 переопределяя и адаптируя их по мере необходимости. Обычно метаклассы 
 переопределяют методы __new__ и __init__ класса type, настраивая 
 процедуру создания и инициализации, но они также могут переопределять 
 метод __call__, когда требуется перехватить вызов процедуры создания
 класса в конце инструкции class. Хотя это и необычно, но они также 
 могут быть простыми функциями, которые возвращают произвольные объекты
 вместо подклассов класса type.
 
  Объявления метаклассов наследуются подклассами. Объявление metaclass=M 
 в пользовательском классе наследуется подклассами этого класса,
 поэтому метакласс будет вызываться при конструировании любых классов,
 наследующих это объявление в цепочке супер-классов.
 
  Атрибуты метакласса не наследуются экземплярами классов. Объявления 
 метаклассов определяют отношения экземпляров, которые отличаются 
 от отношений наследования. Так как классы являются экземплярами
 метаклассов, поведение, определяемое метаклассом, применяется к классу,
 но не к экземплярам этого класса. Экземпляры приобретают поведение 
 от своих классов и супер-классов, но не от метаклассов. С технической
 точки зрения, поиск атрибутов экземпляров обычно выполняется только 
 в словарях __dict__ экземпляров и во всех классах, наследуемых 
 экземпляром, – метаклассы не включаются в цепочку поиска по дереву 
 наследования.
 
 Чтобы продемонстрировать последние два пункта, рассмотрим следующий
пример:
"""


class MetaOne(type):
    def __new__(mcs, classname, supers, classdict):
        # Переопределяет метод
        print('In MetaOne.new:', classname)  # класса type
        return type.__new__(mcs, classname, supers, classdict)

    def toast(self):
        print('toast')


class Super(metaclass=MetaOne):
    # Объявление метакласса наследуется подклассами
    def spam(self):  # MetaOne вызывается дважды
        print('spam')  # при создании двух классов


class C(Super):  # Супер-класс: наследование – не экземпляр
    def eggs(self):  # Классы наследуют атрибуты супер-классов
        print('eggs')  # Но не наследуют атрибуты метаклассов


X = C()
X.eggs()  # Наследует от класса C
X.spam()  # Наследует от класса Super
# X.toast()  # Не наследует от метакласса
# AttributeError: 'C' object has no attribute 'toast'

"""
 Если запустить этот пример, метакласс примет участие в конструировании
обоих клиентских классов, но экземпляры унаследуют только атрибуты своих
классов и не унаследуют атрибуты метакласса.

 Хотя детали имеют определенное значение, тем не менее, при работе 
с метаклассами важнее держать в уме общую картину. Метаклассы, подобные 
тем, что мы видели в этом примере, будут выполняться автоматически 
для всех классов, в которых они объявляются. В отличие 
от вспомогательных функций, которые мы видели выше, такие классы будут
автоматически приобретать любые расширения, определяемые метаклассом. 
Кроме того, подобные расширения достаточно запрограммировать в одном 
месте – в метаклассе, что упрощает внесение изменений впоследствии, 
по мере изменения наших требований. Подобно многим другим инструментам 
языка Python метаклассы упрощают сопровождение программного кода, 
устраняя его избыточность. Однако чтобы полностью осознать всю мощь 
метаклассов, нам необходимо рассмотреть несколько более крупных 
и практичных примеров их использования.
"""

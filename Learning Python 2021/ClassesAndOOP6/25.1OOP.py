"""
 ООП: общая картина


 Зачем нужны классы?

 Помните, как я говорил вам: «программы выполняют некоторые действия
над чем-то»? Выражаясь простым языком, классы – это всего лишь способ
определить новое «что-то», они являются отражением реальных объектов
в мире программ. Например, предположим, что мы решили реализовать
гипотетическую машину по изготовлению пиццы, которую мы использовали
в качестве примера в главе 16. Если реализовать ее на основе классов,
мы могли бы смоделировать более близкое к реальности строение машины
и взаимосвязь между ее механизмами. Полезными здесь оказываются
два аспекта ООП:

 Наследование

  Машина по изготовлению пиццы – это разновидность машин, поэтому она
 обладает обычными свойствами, характерными для машин. В терминах
 ООП это называется «наследованием» свойств более общей категории машин.
 Эти общие свойства необходимо реализовать всего один раз, после чего
 мы сможем использовать их для моделирования любых типов машин, которые
 нам потребуется создать в будущем.

 Композиция

  Машины по изготовлению пиццы состоят из множества компонентов, которые
 все вместе работают как единое целое. Например, нашей машине необходимы
 манипуляторы, чтобы раскатывать тесто, двигатели, чтобы перемещаться
 к духовке, и так далее. На языке ООП наша машина – это пример
 композиции; она содержит другие объекты, которые активизируются
 для выполнения определенных действий. Каждый компонент может быть
 оформлен как класс, который определяет свое поведение
 и принципы взаимодействия.

 Общие идеи ООП, такие, как наследование и композиция, применимы к любым
приложениям, которые могут быть разложены на ряд объектов. Например,
в типичных программах с графическим интерфейсом сам интерфейс создается
как набор визуальных элементов управления – кнопок, меток и так далее,
которые рисуются на экране в тот момент, когда выполняется рисование их
контейнеров (композиция). Кроме того, мы можем создать свои собственные
визуальные элементы – кнопки с уникальными шрифтами, метки с новыми
цветовыми схемами, которые будут представлять собой специализированные
версии более общих интерфейсных элементов (наследование).

 Если говорить более точно, с точки зрения программирования классы –
это программные компоненты на языке Python, точно такие же, как функции
и модули: они представляют собой еще один способ упаковки выполняемого
кода и данных. Кроме того, классы определяют свои пространства имен,
так же как и модули. Но в отличие от других программных компонентов,
которые мы уже видели, классы имеют три важных отличия,
которые делают их более полезными, когда дело доходит до создания
новых объектов:

 Множество экземпляров

  Классы по своей сути являются фабриками по созданию объектов.
 Каждый раз, когда вызывается класс, создается новый объект со своим
 собственным пространством имен. Каждый объект, созданный из класса,
 имеет доступ к атрибутам класса и получает в свое распоряжение
 собственное пространство имен для своих собственных данных, отличных
 от данных других объектов.

 Адаптация через наследование

  Классы также поддерживают такое понятие ООП, как наследование, –
 мы можем расширять возможности класса, переопределяя его атрибуты
 за пределами самого класса. В более общем смысле классы могут создавать
 иерархии пространств имен, которые определяют имена для использования
 объектами, созданными из классов в иерархии.

 Перегрузка операторов

  Обеспечивая специальный протокол оформления методов, классы могут
 определять объекты, над которыми можно производить какие-то
 из операций, которые мы знаем по работе со встроенными типами.
 Например, объекты, созданные из классов, могут подвергаться операции
 извлечения среза, конкатенации, извлечения элементов по их индексам
 и так далее. Язык Python предоставляет специальные обработчики,
 которые могут использоваться классами для перехвата и реализации любой
 встроенной операции.


 ООП с высоты 30 000 футов


 Поиск унаследованных атрибутов

 Самое интересное, что ООП в языке Python проще в изучении
и использовании, чем в других языках программирования, таких как C++
и Java. Будучи языком сценариев с динамической типизацией, Python
ликвидирует синтаксическую перегруженность и сложность, свойственные ООП
в других языках. Фактически ООП в языке Python сводится к выражению:

object.attribute

 Мы использовали это выражение на протяжении всей книги для организации
доступа к атрибутам модуля, вызова методов объектов и так далее.
Однако, когда подобное выражение применяется к объекту, полученному
с помощью инструкции class, интерпретатор начинает поиск – поиск
в дереве связанных объектов, который заканчивается, как только будет
встречено первое появление атрибута attribute. Когда в дело вступают
классы, это выражение на языке Python можно перевести в следующее
выражение на естественном языке: Найти первое вхождение
атрибута attribute, просмотрев объект object, а потом все классы
в дереве наследования выше его, снизу вверх и слева направо.

 Другими словами, выборка атрибутов производится в результате простого
поиска по дереву. Мы называем эту процедуру поиском в дереве
наследования, потому что объекты, расположенные в дереве ниже, наследуют
атрибуты, имеющиеся у объектов, расположенных в дереве выше.
Так как поиск происходит в направлении снизу вверх, объекты в некотором
смысле оказываются связаны в древовидную структуру, представляющую собой
объединение всех атрибутов, определяемых всеми их родителями в дереве.

 В языке Python все это понимается буквально: с помощью
программного кода мы действительно создаем деревья связанных объектов,
и интерпретатор действительно пробегается вверх по дереву, пытаясь
во время выполнения отыскать атрибуты всякий раз, когда мы используем
выражение object.attribute. Чтобы было более понятно, на рис.
приводится пример одного из таких деревьев.

 На этом рисунке изображено дерево из пяти объектов, помеченных именами
переменных. Каждый из этих объектов обладает набором атрибутов.
Если говорить более точно, это дерево связывает вместе три объекта
классов (в овалах, C1, C2 и C3) и два объекта экземпляров
(в прямоугольниках, I1 и I2) в иерархию наследования. Обратите внимание,
что в модели объектов в языке Python классы и экземпляры порождаются
от двух разных типов объектов:

 Классы

  Играют роль фабрик экземпляров. Их атрибуты обеспечивают поведение –
 данные и функции – то есть наследуются всеми экземплярами, созданными
 от них (например, функция, вычисляющая зарплату служащего, исходя
 из часового тарифа).

 Экземпляры

  Представляют конкретные элементы программы. Их атрибуты хранят данные,
 которые могут отличаться в конкретных объектах (например,
 номер карточки социального страхования служащего).

 В терминах деревьев поиска экземпляры наследуют атрибуты своих классов,
а классы наследуют атрибуты всех других классов, находящихся
в дереве выше. На рис. можно продолжить категоризацию классов
по относительным положениям овалов в дереве. Классы, расположенные
в дереве выше (такие, как C2 и C3), мы обычно называем супер-классами,
а классы, расположенные ниже (такие, как C1), называются подклассами.
Эти термины обозначают относительное положение в дереве
и исполняемые роли. Супер-классы реализуют поведение, общее для всех
их подклассов, но из-за того, что поиск производится снизу верх,
подклассы могут переопределять поведение,
определяемое их супер-классами, переопределяя имена супер-классов
ниже в дереве.

 В других книгах можно также встретить такие термины,
как базовые классы и дочерние классы, которые используются
для обозначения супер-классов и подклассов соответственно.

 Т.к. эти последние несколько слов отражают основную суть адаптации
программного обеспечения в ООП, давайте подробнее рассмотрим
эту концепцию. Предположим, что мы создали дерево, приведенное на рис.,
и затем пишем:

I2.w

 Этот программный код демонстрирует использование механизма
наследования. Так как это выражение вида object.attribute, оно приводит
к запуску поиска в дереве, изображенном на рис. 25.1, – интерпретатор
приступает к поиску атрибута w, начиная с I2, и движется вверх
по дереву. В частности, он будет просматривать объекты в следующем
порядке:

I2, C1, C2, C3

 и остановится, как только будет найден первый атрибут с таким именем
(или возбудит исключение, если атрибут w вообще не будет найден).
В этом случае поиск будет продолжаться, пока не будет достигнут
объект C3, поскольку атрибут w имеется только в этом объекте. Другими
словами, имя I2.w в терминах автоматического поиска будет обнаружено,
как C3.w. В терминологии ООП это называется I2 «наследует»
атрибут w от C3.

 В конечном итоге два экземпляра наследуют от своих классов четыре
атрибута: w, x, y и z. Другие атрибуты будут найдены в различных местах
в дереве. Например:

  Для I1.x и I2.x атрибут x будет найден в C1, где поиск остановится,
 потому что C1 находится в дереве ниже, чем C2.

  Для I1.y и I2.y атрибут y будет найден в C1, где поиск остановится,
 потому что это единственное место, где он появляется.

  Для I1.z и I2.z атрибут z будет найден в C2, потому что C2 находится
 в дереве левее, чем C3.

  Для I2.name атрибут name будет найден в I2, в этом случае поиск
 по дереву вообще осуществляться не будет.

 Проследите эти пути поиска в дереве на рис., чтобы понять,
как выполняется поиск по дереву наследования в языке Python.

 Первый элемент в предыдущем списке является, пожалуй, самым важным,
потому что C1 переопределяет атрибут x ниже в дереве, тем самым замещая
версию атрибута, расположенную выше, в C2. Как вы увидите
через мгновение, такие переопределения составляют основу адаптации
программного обеспечения в ООП – переопределяя и замещая атрибут,
C1 эффективно изменяет свое поведение, унаследованное
от своего супер-класса.


 Классы и экземпляры

 Являясь отдельными типами объектов в модели языка Python, классы
и экземпляры, которые мы объединили в иерархические деревья, выполняют
практически одну и ту же роль: каждый из этих типов служит некоторым
представлением пространства имен – пакета переменных и места,
где определяются атрибуты. Если вследствие этого классы и экземпляры
покажутся вам похожими на модули, то можно считать и так,
но при этом объекты в деревьях классов содержат автоматически
определяемые ссылки на другие объекты пространств имен, и классы
соответствуют инструкциям, а не файлам.

 Основное различие между классами и экземплярами состоит в том,
что классы представляют собой своего рода фабрики по производству
экземпляров. Например, в реалистичном приложении у нас мог бы быть
класс Employee, определяющий характеристики служащего, – из этого класса
мы можем создавать фактические экземпляры класса Employee. Это еще одно
различие между классами и модулями: у нас всегда имеется всего один
экземпляр заданного модуля в памяти (именно по этой причине приходится
перезагружать модуль, чтобы загрузить в память новый программный код),
но в случае с классами можно создать столько экземпляров,
сколько потребуется.

 В оперативном отношении, у классов обычно имеются функции,
присоединенные к ним (например, computeSalary), а у экземпляров –
элементы данных, используемые функциями класса (например, hoursWorked).
Фактически объектно-ориентированная модель не так сильно отличается
от классической модели обработки данных, основанной на программах
и записях, – в ООП экземпляры подобны записям с «данными»,
а классы – «программам», обрабатывающими эти записи. Однако в ООП
имеется также понятие иерархии наследования, которая обеспечивает более
широкие возможности адаптации программного обеспечения,
чем более ранние модели.


 Вызовы методов классов

 В предыдущем разделе мы видели, как атрибут I2.w в нашем примере дерева
классов транслируется в C2.w при выполнении поиска
в дереве наследования. Не менее важно понять, что точно так же
наследуются и методы (то есть функции, присоединенные к классам
в виде атрибутов).

 Если ссылка I2.w – это вызов функции, тогда в действительности
это выражение означает: «вызвать функцию С3.w для обработки I2».
То есть интерпретатор Python автоматически отобразит вызов I2.w()
на вызов C3.w(), передав унаследованной функции экземпляр в виде
первого аргумента.

 Фактически всякий раз, когда вызывается функция, присоединенная
к классу, подразумевается не класс целиком, а экземпляр класса.
Этот подразумеваемый экземпляр, или контекст, является одной из причин,
почему данная модель называется объектно-ориентированной, –
всегда существует объект, над которым выполняются действия.
В более реалистичном примере мы могли бы вызывать метод с именем
giveRaise, присоединенный как атрибут к классу Employee, – вызов этого
метода был бы бессмысленным без указания служащего, которому дается
надбавка к зарплате.

 Как мы увидим позднее, Python передает методам подразумеваемый
экземпляр в виде специального первого аргумента, в соответствии
с соглашением именуемого self. Мы также узнаем, что методы могут
вызываться как через экземпляры (например, bob.giveRaise()),
так и через классы (например, Employee. giveRaise(bob)), причем
обе формы играют одну и ту же роль в наших сценариях. Чтобы увидеть,
как методы принимают свои подразумеваемые экземпляры, нам необходимо
рассмотреть примеры программного кода.


 Создание деревьев классов

 Несмотря на всю отвлеченность наших разговоров, тем не менее за всеми
этими идеями стоит реальный программный код. Мы создаем деревья
и объекты в них с помощью инструкций class и вызовов классов, которые
позднее мы рассмотрим более подробно. В двух словах:

  Каждая инструкция class создает новый объект класса.

  Каждый раз, когда вызывается класс, он создает новый объект
 экземпляра.

  Экземпляры автоматически связываются с классами, из которых
 они были созданы.

  Классы связаны со своими супер-классами, перечисленными в круглых
 скобках в заголовке инструкции class, – порядок следования в списке
 определяет порядок расположения в дереве.

 Чтобы создать дерево, изображенное на рис. 25.1, например, мы могли бы
использовать следующий программный код (здесь я опустил реализацию
классов):

class C2: ...          # Создать объекты классов (овалы)
class C3: ...
class C1(C2, C3): ...  # Связанные с супер-классами

I1 = C1()  # Создать объекты экземпляров (прямоугольники),
I2 = C1()  # связанные со своими классами

 Здесь мы построили дерево объектов классов, выполнив три инструкции
class и сконструировав два объекта экземпляров, вызвав класс C1 дважды,
как если бы это была обычная функция. Экземпляры помнят класс,
из которого они были созданы, а класс C1 помнит о своих супер-классах.

 С технической точки зрения в этом примере используется то,
что называется множественным наследованием, которое означает,
что некий класс имеет более одного супер-класса над собой
в дереве классов. В языке Python, если в инструкции class в круглых
скобках перечислено более одного супер-класса (как в случае с классом C1
в данном примере), их порядок следования слева направо определяет
порядок поиска атрибутов в супер-классах.

 Из-за особенностей поиска в дереве наследования большое значение имеет,
к какому из объектов присоединяется тот или иной атрибут, – тем самым
определяется его область видимости. Атрибуты, присоединяемые
к экземплярам, принадлежат только этим конкретным экземплярам,
но атрибуты, присоединяемые к классам, совместно используются всеми
подклассами и экземплярами. Позднее мы подробно изучим программный код,
выполняющий присоединение атрибутов к этим объектам. Мы увидим, что:

  Атрибуты обычно присоединяются к классам с помощью инструкций
 присваивания внутри инструкции class, а не во вложенных
 инструкциях def, определяющих функции.

  Атрибуты обычно присоединяются к экземплярам с помощью присваивания
 значений специальному аргументу с именем self, передаваемому функциям
 внутри классов.

 Например, классы определяют поведение своих экземпляров с помощью
функций, создаваемых инструкциями def внутри инструкции class.
Поскольку такие вложенные инструкции def выполняют присваивание именам
внутри класса, они присоединяются к объектам классов в виде атрибутов
и будут унаследованы всеми экземплярами и подклассами:
"""


class C2:
    x = 2
    z = 4


class C3:
    w = 1
    z = 40


class C1(C2, C3):  # Создать и связать класс C1
    def setname(self, who):  # Присвоить: C1.setname
        self.name = who  # self – либо I1, либо I2


I1 = C1()  # Создать два экземпляра
I2 = C1()
I1.setname('bob')  # Записать ‘bob’ в I1.name
I2.setname('mel')  # Записать ‘mel’ в I2.name
print(I1.name)

"""
 Синтаксис инструкции def в этом контексте – совершенно обычный.
С функциональной точки зрения, когда инструкция def появляется внутри 
инструкции class, как в этом примере, она обычно называется методом 
и автоматически принимает специальный первый аргумент с именем self,
который содержит ссылку на обрабатываемый экземпляр.

 Так как классы являются фабриками, способными производить множество 
экземпляров, их методы обычно используют этот, получаемый автоматически, 
аргумент self для получения или изменения значений атрибутов конкретного
экземпляра, который обрабатывается методом. В предыдущем фрагменте 
программного кода имя self используется для сохранения имени служащего
в конкретном экземпляре.

 Подобно простым переменным, атрибуты классов и экземпляров 
не объявляются заранее, а появляются, когда им впервые выполняется 
присваивание значений. Когда метод присваивает значение атрибуту 
с помощью имени self, он тем самым создает атрибут экземпляра, 
находящегося в нижнем уровне дерева классов (то есть в одном 
из прямоугольников), потому что имя self автоматически ссылается
на обрабатываемый экземпляр.

 Фактически благодаря тому, что все объекты в дереве классов – 
это всего лишь объекты пространств имен, мы можем получать 
или устанавливать любой из их атрибутов, используя соответствующие 
имена. Например, выражение C1.setname является таким же допустимым,
как и I1.setname, при условии, что имена C1 и I1 находятся в области 
видимости программного кода.

 В настоящий момент класс C1 не присоединяет атрибут name к экземплярам,
пока не будет вызван метод setname. Фактически попытка обратиться 
к имени I1.name до вызова I1.setname приведет к появлению сообщения 
об ошибке, извещающего о неопределенном имени. Если в классе потребуется
гарантировать, что атрибут, такой как name, всегда будет присутствовать
в экземплярах, то такой атрибут должен создаваться на этапе создания 
класса, как показано ниже:
"""


class C1(C2, C3):
    def __init__(self, who):  # Создать имя при создании класса
        self.name = who  # Self – либо I1, либо I2


I1 = C1('bob')  # Записать ‘bob’ в I1.name
I2 = C1('mel')  # Записать ‘mel’ в I2.name
print(I2.name)

"""
 В этом случае интерпретатор Python автоматически будет вызывать метод
с именем __init__ каждый раз при создании экземпляра класса. Новый 
экземпляр будет передаваться методу __init__ в виде первого 
аргумента self, а любые значения, перечисленные в круглых скобках 
при вызове класса, будут передаваться во втором и последующих 
за ним аргументах. В результате инициализация экземпляров будет 
выполняться в момент их создания, без необходимости вызывать 
дополнительные методы.

 Метод __init__ известен как конструктор, так как он запускается 
на этапе конструирования экземпляра. Этот метод является типичным 
представителем большого класса методов, которые называются методами 
перегрузки операторов. Более подробно эти методы будут рассматриваться
в последующих главах. Такие методы наследуются в дереве классов
как обычно, а их имена начинаются и заканчиваются двумя символами 
подчеркивания, чтобы подчеркнуть их особенное назначение. Интерпретатор
Python вызывает их автоматически, когда экземпляры, поддерживающие их,
участвуют в соответствующих операциях, и они, главным образом, являются
альтернативой вызовам простых методов. Кроме того, они являются 
необязательными: при их отсутствии соответствующие операции экземплярами
не поддерживаются.

 Например, чтобы реализовать пересечение множеств, класс может 
предусмотреть реализацию метода intersect или перегрузить оператор &, 
описав логику его работы в методе с именем __and__. Поскольку 
использование операторов делает экземпляры более похожими на встроенные
типы, это позволяет определенным классам обеспечивать непротиворечивый
и естественный интерфейс и быть совместимыми с программным кодом, 
который предполагает выполнение операций над объектами встроенных типов.


 ООП – это многократное использование программного кода

 Вот, в основном, и все описание ООП в языке Python, за исключением
некоторых синтаксических особенностей. Конечно, в ООП присутствует
не только наследование. Например, перегрузка операторов может 
применяться гораздо шире, чем описывалось до сих пор, – классы могут 
предоставлять собственные реализации таких операций, как доступ 
к элементам по их индексам, получение значений атрибутов, 
вывод и многие другие. Но, вообще говоря, ООП реализует поиск атрибутов
в деревьях.

 Тогда зачем нам погружаться в тонкости создания деревьев объектов 
и выполнения поиска в них? Нужно накопить некоторый опыт, чтобы увидеть,
как при грамотном использовании классы поддерживают возможность 
многократного использования программного кода способами, 
которые недоступны в других программных компонентах. Используя классы, 
мы программируем, адаптируя написанное программное обеспечение, 
вместо того, чтобы изменять существующий программный код или писать 
новый код в каждом новом проекте.

 С фундаментальной точки зрения, классы – это действительно всего лишь 
пакеты функций и других имен, которые во многом напоминают модули.
Однако автоматический поиск атрибутов в дереве наследования, который 
мы получаем при использовании классов, обеспечивает возможности 
по адаптации программного обеспечения более широкие, чем это возможно 
с помощью модулей и функций. Кроме того, классы представляют собой 
удобную структуру, обеспечивающую компактное размещение выполняемого 
кода и переменных, что помогает в отладке.

 Например, методы – это обычные функции со специальным первым
аргументом, поэтому мы можем подражать некоторым чертам их поведения, 
вручную передавая объекты для обработки обычным функциям. Однако участие
методов в наследовании классов позволяет нам естественным образом 
адаптировать существующее программное обеспечение, создавая новые
подклассы, определяющие новые методы, вместо того, чтобы изменять
существующий программный код. Подобное невозможно в случае с модулями
и функциями.

 В качестве примера предположим, что вас привлекли к реализации
приложения базы данных, где хранится информация о служащих. 
Как программист, использующий объектно-ориентированные особенности языка
Python, вы могли бы начать работу с реализации общего супер-класса,
который определяет поведение, общее для всех категорий служащих
в вашей организации:

class Employee:  # Общий супер-класс
    def computeSalary(self): ...  # Общее поведение
    def giveRaise(self): ...
    def promote(self): ...
    def retire(self): ...

 Реализовав это общее поведение, можно специализировать его для каждой 
категории служащих, чтобы отразить отличия разных категорий 
от стандарта. То есть можно создать подклассы, которые изменяют лишь ту
часть поведения, которая отличает их от типового представления 
служащего, – остальное поведение будет унаследовано от общего класса. 
Например, если зарплата инженеров начисляется в соответствии с какими-то
особыми правилами (то есть не по почасовому тарифу), в подклассе можно 
переопределить всего один метод:

class Engineer(Employee):   # Специализированный подкласс
    def computeSalary(self): ...  # Особенная реализация

 Поскольку эта версия computeSalary находится в дереве классов ниже, 
она будет замещать (переопределять) общую версию метода 
в классе Employee. Затем можно создать экземпляры разновидностей классов
служащих в соответствии с принадлежностью имеющихся служащих классам, 
чтобы обеспечить корректное поведение:

bob = Employee()  # Поведение по умолчанию
mel = Engineer()  # Особые правила начисления зарплаты

 Обратите внимание, что существует возможность создавать экземпляры
любых классов в дереве, а не только тех, что находятся внизу, – класс, 
экземпляр которого создается, определяет уровень, откуда будет 
начинаться поиск атрибутов. В перспективе эти два объекта экземпляров 
могли бы быть встроены в больший контейнерный объект (например, 
в список или в экземпляр другого класса), который представляет отдел 
или компанию, реализуя идею композиции, упомянутую в начале главы.

 Когда позднее вам потребуется узнать размер зарплаты этих служащих, 
их можно будет вычислить в соответствии с правилами классов, из которых
были созданы объекты, благодаря поиску в дереве наследования:

company = [bob, mel]  # Составной объект
for emp in company:
    print(emp.computeSalary())  # Вызвать версию метода для данного 
    # объекта

 Это еще одна разновидность полиморфизма – идеи, которая была 
представлена в главе 4 и повторно рассматривалась в главе 16. Вспомните,
полиморфизм означает, что смысл операции зависит от объекта, над которым 
она выполняется. Здесь метод computeSalary определяется в ходе поиска 
в каждом объекте в дереве наследования, прежде чем он будет вызван. 
В других приложениях полиморфизм может также использоваться для сокрытия
(то есть для инкапсуляции) различий интерфейсов. Например, программа,
которая обрабатывает потоки данных, может работать с объектами, имеющими
методы ввода и вывода, не заботясь о том, что эти методы делают 
в действительности:

def processor(reader, converter, writer):
    while 1:
        data = reader.read()
        if not data: break
        data = converter(data)
        writer.write(data)

 Передавая экземпляры классов с необходимыми интерфейсными методами
read и write, специализированными под различные источники данных, 
мы можем использовать одну и ту же функцию processor для работы 
с любыми источниками данных, как уже существующими, так и с теми, 
что появятся в будущем:

class Reader:
    def read(self): ...  # Поведение и инструменты по умолчанию
    def other(self): ...
    
class FileReader(Reader):
    def read(self): ...  # Чтение из локального файла

class SocketReader(Reader):
    def read(self): ...  # Чтение из сокета
...
processor(FileReader(...), Converter, FileWriter(...))
processor(SocketReader(...), Converter, TapeWriter(...))
processor(FtpReader(...), Converter, XmlWriter(...))

 Кроме того, благодаря тому, что внутренняя реализация этих методов read
и write была разделена по типам источников данных, их можно изменять, 
не трогая программный код, подобный приведенному, который использует их.
Фактически функция processor сама может быть классом, реализующим логику
работы функции преобразования converter, которую могут унаследовать
подклассы, и позволяющим встраивать экземпляры, выполняющие чтение 
и запись, в соответствии с принципом композиции (далее в этой 
части книги будет показано, как это реализуется).

 Когда вы привыкнете программировать в этом стиле (адаптации 
программного обеспечения), то, начиная писать новую программу, 
обнаружите, что большая часть вашей задачи уже реализована, 
и ваша задача в основном сводится к тому, чтобы подобрать уже имеющиеся
супер-классы, которые реализуют поведение, требуемое вашей программе.
Например, возможно, кто-то другой, для совершенно другой программы, 
уже написал классы Employee, Reader и Writer из данного примера. 
В этом случае вы сможете воспользоваться уже готовым программным кодом 
«за так».

 На практике во многих прикладных областях вы можете получить или купить
библиотеки супер-классов, известных как фреймворки, в которых реализованы
наиболее часто встречающиеся задачи программирования на основе классов,
готовые к использованию в ваших приложениях. Такие фреймворки могут
предоставлять интерфейсы к базам данных, протоколы тестирования, 
средства создания графического интерфейса и так далее. В среде такого 
фреймворка вам часто будет достаточно создать свой подкласс, добавив 
в него один-два своих метода, а основная работа будет выполняться
классами фреймворка, расположенными выше в дереве наследования. 
Программирование в мире ООП – это лишь вопрос сборки уже отлаженного
программного кода и настройки его путем написания своих собственных
подклассов.

 Безусловно, чтобы понять, как использовать классы для достижения такого 
объектно-ориентированного идеала, потребуется время. На практике ООП 
влечет за собой большой объем предварительного проектирования, 
на этапе которого осмысливаются преимущества, получаемые 
от использования классов; с этой целью программисты начали составлять 
список наиболее часто встречающихся решений в ООП, известных как шаблоны 
проектирования, – помогающих решать проблемы проектирования. При этом 
объектно-ориентированный программный код на языке настолько прост, 
что он сам по себе не будет препятствием в освоении ООП. Чтобы убедиться
в этом, вам следует перейти к главе 26.
"""

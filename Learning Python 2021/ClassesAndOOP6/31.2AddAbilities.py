"""
 Другие расширения в классах нового стиля

 Помимо изменений, описанных в предыдущем разделе (которые, честно
признаться, имеют скорее академический интерес и могут не иметь большого
значения для большинства читателей этой книги), классы нового стиля
предлагают некоторый набор расширенных возможностей, которые имеют
более явное практическое применение. Ниже приводится краткий обзор
каждой из таких особенностей, присущих классам нового стиля в Python 2.6
и всем классам в Python 3.0.


 Слоты экземпляров

 Присваивая список имен атрибутов в виде строк специальному атрибуту
__slots__ класса, в классах нового стиля можно ограничить множество
разрешенных атрибутов для экземпляров класса и оптимизировать
использование памяти и производительность.

 Обычно этот атрибут устанавливается присваиванием последовательности
имен строк переменной __slots__ на верхнем уровне в инструкции class:
только имена, перечисленные в списке __slots__, смогут использоваться
как атрибуты экземпляра. Однако, как и в случае с любыми именами
в языке Python, прежде чем получить доступ к атрибутам экземпляра,
им должны быть присвоены значения, даже если они перечислены в списке
__slots__. Например:
"""


class limiter(object):
    __slots__ = ['age', 'name', 'job']


x = limiter()
# print(x.age)  # Присваивание должно быть выполнено
#               раньше использования
x.age = 40
print(x.age)

# x.ape = 1000  # Недопустимое имя: отсутствует в списке __slots__

"""
 Слоты – это своего рода нарушение динамической природы языка Python,
которая диктует, что операция присваивания может создавать любые имена.
Однако предполагается, что эта особенность поможет ликвидировать ошибки,
обусловленные простыми «опечатками» (обнаруживается попытка
присваивания атрибутам, отсутствующим в списке __slots__), и обеспечит
некоторую оптимизацию. Выделение памяти для словаря с именами атрибутов
в каждом экземпляре может оказаться слишком дорогим удовольствием, 
когда требуется создать большое количество экземпляров, каждый 
из которых обладает небольшим числом атрибутов. Для экономии 
пространства в памяти и повышения производительности (получающийся 
выигрыш в значительной степени зависит от самой программы) атрибуты,
перечисленные в слотах, сохраняются не в словаре, а в виде
последовательности, что обеспечивает более высокую скорость их поиска.


 Слоты и обобщенные инструменты
 
 Фактически некоторые экземпляры со слотами вообще могут не иметь 
атрибут словаря __dict__, что может сделать некоторые метапрограммы
намного более сложными (включая некоторые из тех, что представлены
в этой книге). Обобщенные инструменты, которые получают списки атрибутов
или обращаются к атрибутам, используя имена в виде строк, например, 
должны использовать более универсальные механизмы, чем атрибут __dict__.
К таким механизмам можно отнести встроенные функции getattr,
setattr и dir, способные отыскивать атрибуты в обоих хранилищах,
__dict__ и __slots__. В некоторых случаях для полноты картины
может потребоваться проверить оба источника атрибутов.

 Например, экземпляры классов, где используются слоты, обычно не имеют
атрибут словаря __dict__ – вместо него пространство для атрибутов 
в экземпляре выделяется с применением дескрипторов класса, которые будут
рассматриваться в главе 37. Только имена, перечисленные в списке 
__slots__, смогут использоваться как атрибуты экземпляра, однако
значения этих атрибутов могут извлекаться и изменяться обычными 
способами. В Python 3.0 (и в 2.6, в случае классов, наследующих object):

>>> class C:
...     __slots__ = [‘a’, ‘b’]  # По умолчанию наличие __slots__ 
...                             # означает отсутствие __dict__
>>> X = C()
>>> X.a = 1
>>> X.a
1
>>> X.__dict__
AttributeError: ‘C’ object has no attribute ‘__dict__’
>>> getattr(X, ‘a’)
1
>>> setattr(X, ‘b’, 2)  # Однако функции getattr() и setattr()
>>> X.b                 # по-прежнему работают
2
>>> ‘a’ in dir(X)  # И dir() также отыскивает атрибуты в слотах
True
>>> ‘b’ in dir(X)
True

 В отсутствие словаря с пространством имен невозможно присвоить значения
атрибутам экземпляра, имена которых отсутствуют в списке слотов:

>>> class D:
...     __slots__ = [‘a’, ‘b’]
...     def __init__(self): 
            self.d = 4  # Невозможно добавить новый атрибут,...
>>> X = D()             # когда отсутствует атрибут __dict__
AttributeError: ‘D’ object has no attribute ‘d’

 Однако возможность добавлять новые атрибуты все-таки существует – 
для этого необходимо включить имя __dict__ в список __slots__, разрешив
тем самым создать словарь с пространством имен. В этом случае 
действовать будут оба механизма хранения имен, однако обобщенные
инструменты, такие как getattr, будут воспринимать их, как единое 
множество атрибутов:

>>> class D:
...     __slots__ = [‘a’, ‘b’, ‘__dict__’]  # Добавить __dict__ в слоты
...     c = 3  # Атрибуты класса действуют как обычно
...     def __init__(self): 
            self.d = 4  # Имя d будет добавлено в __dict__,
...                     # а не в __slots__
>>> X = D()
>>> X.d
4
>>> X.__dict__  # Некоторые объекты имеют оба атрибута, __dict__ 
{‘d’: 4}  # getattr() может извлекать атрибуты любого типа   и __slots__
>>> X.__slots__
[‘a’, ‘b’, ‘__dict__’]
>>> X.c
3
>>> X.a            # Все атрибуты экземпляра не определены,
AttributeError: a  # пока им не будет присвоено значение
>>> X.a = 1
>>> getattr(X, ‘a’,), getattr(X, ‘c’), getattr(X, ‘d’)
(1, 3, 4)

 Если потребуется реализовать универсальный способ получения значений
всех атрибутов экземпляра, необходимо учесть наличие двух форм хранения
атрибутов или использовать функцию dir, которая дополнительно возвращает
все унаследованные атрибуты (для получения ключей в следующем примере
используется итератор словаря):

>>> for attr in list(X.__dict__) + X.__slots__:
...     print(attr, ‘=>’, getattr(X, attr))
d => 4
a => 1
b => 2
__dict__ => {‘d’: 4}

 Поскольку любой из этих атрибутов может отсутствовать, более правильный
способ выглядит, как показано ниже (функция getattr позволяет определять
возвращаемое значение по умолчанию):

>>> for attr in list(getattr(X,’__dict__’, [])) 
                  + getattr(X, ‘__slots__’, []):
...     print(attr, ‘=>’, getattr(X, attr))
d => 4
a => 1
b => 2
__dict__ => {‘d’: 4}


 Несколько супер-классов со списками __slot__
 
 Обратите внимание, что в этой реализации просматривается содержимое 
атрибута __slots__ только самого нижнего в дереве класса, наследуемого 
экземпляром. Если в дереве имеется несколько классов, обладающих 
собственными атрибутами __slots__, универсальные инструменты должны 
иначе подходить к получению списка атрибутов (например, рассматривать 
имена слотов, как атрибуты классов, а не экземпляров).

 Объявления слотов могут присутствовать сразу в нескольких классах
в дереве, но они имеют дополнительные ограничения, которые будет
слишком сложно объяснить, пока вы еще не знаете, что слоты реализованы 
в виде дескрипторов на уровне класса (эту особенность мы детально будем
рассматривать в последней части книги):

  Если подкласс наследует супер-класс, который не имеет атрибута
 __slots__, атрибут __dict__ супер-класса будет доступен всегда,
 что делает бессмысленным использование атрибута __slots__ в подклассе.

  Если класс определяет слот с тем же именем, что и супер-класс, версия
 имени, объявленная в супер-классе, будет доступна только
 при непосредственном обращении к дескриптору в супер-классе.

  Поскольку объявление __slots__ имеет значение только для класса, 
 в котором оно присутствует, подклассы автоматически получат 
 атрибут __dict__, если не определят свой атрибут __slots__.

 В общем для получения списка атрибутов экземпляра при использовании
слотов в нескольких классах может потребоваться: подъем 
по дереву классов вручную, использование функции dir или подход,
при котором имена слотов рассматриваются, как совершенно отдельная 
категория имен:

>>> class E:
...     __slots__ = [‘c’, ‘d’] # Супер-класс имеет слоты
...
>>> class D(E):
...     __slots__ = [‘a’, ‘__dict__’]  # Его подкласс также имеет слоты
...
>>> X = D()
>>> X.a = 1; X.b = 2; X.c = 3  # Экземпляр объединяет слоты в себе
>>> X.a, X.c
(1, 3)
>>> E.__slots__  # Но в классах слоты не объединяются
[‘c’, ‘d’]
>>> D.__slots__
[‘a’, ‘__dict__’]
>>> X.__slots__    # Экземпляр наследует __slots__
[‘a’, ‘__dict__’]  # *ближайшего* класса
>>> X.__dict__     # И имеет собственный атрибут __dict__
{‘b’: 2}
>>> for attr in list(getattr(X,’__dict__’, [])) 
                  + getattr(X, ‘__slots__’, []):
...     print(attr, ‘=>’, getattr(X, attr))
...
b => 2  # Слоты супер-класса отсутствуют!
a => 1
__dict__ => {‘b’: 2}
>>> dir(X)  # dir() включает имена всех слотов
[...множество имен опущено... ‘a’, ‘b’, ‘c’, ‘d’]

 Когда требуется выработать универсальное решение, слоты, вероятно,
лучше рассматривать как атрибуты класса, а не пытаться представлять их,
как обычные атрибуты экземпляра. Дополнительную общую информацию
о слотах вы найдете в стандартном руководстве по языку Python. 
Кроме того, ознакомьтесь с примерами использования атрибутов на основе
обоих механизмов хранения, __slots__ и __dict__, которые приводятся 
в обсуждении декоратора Private, в главе 38.

 В качестве показательного примера, с какой стороны могут возникнуть 
проблемы со слотами при создании универсальных инструментов, посмотрите 
в предыдущей главе реализацию примесных классов lister.py, в разделе, 
посвященном множественному наследованию, – там, в примечании,
описываются проблемы в примере, имеющие отношение к слотам. 
В таких инструментах, пытающихся обобщить процесс получения списка 
атрибутов, для работы со слотами потребуется либо написать 
дополнительный программный код, либо вообще выработать собственную 
политику обращения с атрибутами в слотах.


 Свойства класса
 
 Механизм, известный как свойства, обеспечивает в классах нового стиля 
еще один способ определения методов, вызываемых автоматически 
при обращении или присваивании атрибутам экземпляра. Эта особенность 
во многих случаях представляет собой альтернативу методам перегрузки
операторов __getattr__ и __setattr__, которые мы рассматривали 
в главе 29. Свойства обладают тем же эффектом, что и эти два метода,
только в этом случае выполняется вызов метода даже при простом обращении
к атрибуту, что бывает полезно для атрибутов, значения которых 
вычисляются динамически. Свойства (и слоты) основаны на новом понятии 
дескрипторов атрибутов – темы слишком сложной, чтобы обсуждать ее здесь.

 Проще говоря, свойства – это тип объектов, который присваивается именам
атрибутов класса. Они создаются вызовом встроенной функции property, 
которой передаются три метода (обработчики операций чтения, присваивания
и удаления), и строкой документирования – если в каком-либо аргументе 
передается значение None, следовательно, эта операция не поддерживается.
Определение свойств обычно производится на верхнем уровне в инструкции
class (например, name = property(...)). Когда выполняется такое
присваивание, при попытке доступа к атрибуту класса (то есть, obj.name) 
автоматически будет вызываться один из методов доступа. Например,
метод __getattr__ позволяет классам перехватывать попытки доступа 
к неопределенным атрибутам класса:

>>> class classic:
...     def __getattr__(self, name):
...         if name == ‘age’:
...             return 40
...         else:
...             raise AttributeError
...
>>> x = classic()
>>> x.age   # Вызовет метод __getattr__
40
>>> x.name  # Вызовет метод __getattr__
AttributeError

 Ниже тот же пример, но уже с использованием свойств (обратите внимание,
что свойства могут использоваться в любых классах, но для корректной 
работы операции присваивания в версии 2.6 необходимо, чтобы классы 
или косвенно наследовали класс object):
"""


class newprops(object):
    def getage(self):
        return 40
    age = property(getage, None, None, None)  # get,set,del,docs


x = newprops()
print(x.age)  # Вызовет метод getage

# print(x.name)  # Нормальная операция извлечения

"""
 В некоторых случаях свойства могут быть менее сложными и работать 
быстрее, чем при использовании традиционных подходов. Например, когда 
добавляется поддержка операции присваивания атрибуту, свойства 
становятся более привлекательными – программный код выглядит компактнее
и в операцию присваивания не вовлекаются дополнительные вызовы методов,
если не требуется производить дополнительных вычислений:
"""


class newprops(object):
    def getage(self):
        return 40

    def setage(self, value):
        print('set age:', value)
        self._age = value
        
    age = property(getage, setage, None, None)


x = newprops()
print(x.age)  # Вызовет метод getage

x.age = 42  # Вызовет метод setage

print(x._age)  # Нормальная операция извлечения; нет вызова getage

x.job = 'trainer'  # Нормальная операция присваивания; нет вызова setage
print(x.job)  # Нормальная операция извлечения; нет вызова getage

"""
 При эквивалентном классическом решении проблемы класс мог бы
производить лишние вызовы метода и, возможно, выполнять присваивание 
значения атрибуту с использованием словаря (или с помощью нового метода
__setattr__, наследуемого классами нового стиля от супер-класса object),
чтобы избежать зацикливания:
"""


class classic:
    def __getattr__(self, name):  # При ссылке на неопределенный атрибут
        if name == 'age':
            return 40
        else:
            raise AttributeError

    def __setattr__(self, name, value):  # Для всех операций
        #                                  присваивания
        print('set:', name, value)
        if name == 'age':
            self.__dict__['_age'] = value
        else:
            self.__dict__[name] = value


x = classic()
print(x.age)  # Вызовет метод __getattr__

x.age = 41  # Вызовет метод __setattr__

print(x._age)  # Определен: нет вызова __getattr__

x.job = 'trainer'  # Запустит метод __setattr__ опять
print(x.job)  # Определен: нет вызова __getattr__

"""
 Для этого примера свойства обладают неоспоримым преимуществом. Однако
в некоторых приложениях методы __getattr__ и __setattr__ по-прежнему 
могут быть востребованы для обеспечения более динамичных 
или универсальных интерфейсов, чем можно реализовать с помощью свойств. 
Например, во многих случаях невозможно заранее определить набор
поддерживаемых атрибутов, которые могут даже не существовать вообще 
в каком-либо виде на момент написания класса (например, 
при делегировании ссылок на произвольные методы в обернутых/встроенных 
объектах). В таких случаях использование более универсальных методов 
обслуживания атрибутов __getattr__ и __setattr__, которым передаются
имена атрибутов, может оказаться предпочтительнее. Кроме того, 
простейшие ситуации могут обслуживаться этими обработчиками, поэтому 
свойства следует рассматривать как дополнительное и необязательное 
к использованию расширение.

 В заключительной части книги, в главе 37, приводится дополнительная 
информация по этим двум возможностям. Там вы узнаете, что существует 
возможность определять свойства с помощью декораторов функций, о которых
мы поговорим ниже, в этой главе.


 Метод __getattribute__ и дескрипторы

 Метод __getattribute__ имеется только в классах нового стиля 
и позволяет классам перехватывать все попытки обращения к атрибутам, 
а не только к неопределенным (как метод __getattr__). Кроме того, 
этот метод более сложен в обращении, чем __getattr__, из-за 
более высокой вероятности зацикливания, и чем __setattr__, но уже 
по другим причинам.

 В дополнение к свойствам и методам перегрузки операторов в языке Python
поддерживается понятие дескрипторов атрибутов – классов, с методами
__get__ и __set__, которые присваиваются атрибутам классов. Они 
наследуются экземплярами и перехватывают попытки доступа к определенным
атрибутамДескрипторы представляют собой, в некотором смысле, более
обобщенную форму свойств. Фактически свойства – это упрощенный вариант 
определения дескрипторов специфического типа, основанных на вызовах 
функций, управляющих доступом к атрибутам. Кроме того, дескрипторы 
используются для реализации слотов, с которыми мы познакомились выше.

 Поскольку свойства, метод __getattribute__ и дескрипторы – 
это достаточно сложные темы, мы отложим их дальнейшее обсуждение 
до главы 37, в заключительной части книги, пока поближе не познакомимся
со свойствами.


 Метаклассы

 Большинство изменений и дополнительных особенностей в классах нового 
стиля связано с возможностью наследования типов, о чем говорилось выше
в этой главе, потому что возможность наследования типов и классы нового
стиля были введены одновременно с объединением понятий тип/класс 
в Python 2.2. Как мы уже видели, в версии 3.0 это объединение было 
завершено: теперь классы – это типы, а типы – классы.

 Наряду с этими изменениями в языке Python был выработан более 
согласованный протокол метаклассов, которые являются подклассами объекта 
type и реализуют операции создания классов. Они обеспечивают отличную 
возможность управления объектами классов и их расширения. Тема 
метаклассов достаточно сложна, а кроме того, они не являются 
необходимыми для большинства программистов, поэтому здесь мы не будем 
углубляться в детали. Мы еще столкнемся с метаклассами ниже, 
в этой главе, когда будем знакомиться с декораторами классов, 
и исследуем их во всех подробностях в главе 39, в заключительной
части книги.


 Статические методы и методы класса
 
 Начиная с версии Python 2.2, появилась возможность определять методы 
класса, которые могут вызываться без участия экземпляра: статические 
методы работают почти так же, как обычные функции, только расположенные 
внутри класса, а методы класса получают сам класс вместо экземпляра.
Несмотря на то что эта особенность была добавлена вместе с классами
нового стиля, обсуждавшимися в предыдущих разделах, статические методы 
и методы класса можно использовать и в классических классах тоже.

 Чтобы сделать возможными эти режимы работы методов, внутри класса 
должны вызываться специальные встроенные функции staticmethod 
и classmethod или использоваться декораторы, с которыми мы познакомимся 
ниже, в этой главе. В Python 3.0 методы, которым не передается ссылка 
на экземпляр и которые вызываются только через имя класса, не требуют
объявления с помощью функции staticmethod, но такое объявление 
обязательно для методов, которые предполагается вызывать 
через экземпляры.


 Зачем нужны специальные методы?
 
 Как мы уже знаем, обычно методы получают объект экземпляра в первом
аргументе, который играет роль подразумеваемого объекта вызова метода. 
При этом на сегодняшний день существует две возможности изменить 
эту модель. Прежде чем я расскажу о них, я должен пояснить, почему это 
может быть важным для нас.

 Иногда в программах бывает необходимо организовать обработку данных,
связанных с классами, а не с экземплярами. Например, следить за числом 
экземпляров класса или вести список всех экземпляров класса, находящихся
в настоящий момент в памяти. Такого рода информация связана с классами
и должна обрабатываться на уровне класса, а не экземпляров. 
То есть такая информация обычно сохраняется в самом классе 
и обрабатывается, независимо от наличия экземпляров класса.

 Для решения таких задач часто бывает достаточно простых функций, 
определения которых находятся за пределами классов. Такие функции могут 
обращаться к атрибутам класса через его имя – им требуется доступ только 
к данным класса и никогда – к экземплярам. Однако, чтобы теснее связать
такой программный с классом и обеспечить возможность его адаптации 
с помощью механизма наследования, будет лучше помещать такого рода 
функции внутрь самого класса. Для этого нам и нужны методы класса, 
которые не ожидают получить аргумент self с экземпляром.

 В языке Python для этих целей поддерживаются статические методы – 
простые функции без аргумента self, вложенные в определение класса 
и предназначенные для работы с атрибутами класса, а не экземпляра. 
Статические методы никогда автоматически не получают ссылку self 
на экземпляр, независимо от того, вызываются они через имя класса 
или через экземпляр. Такие методы обычно используются для обработки 
информации, имеющей отношение ко всем экземплярам, а не для реализации 
поведения экземпляров.

 Кроме того, в языке Python поддерживается также понятие методов класса.
На практике методы класса используются реже, и в первом аргументе 
им автоматически передается объект класса, независимо от того, 
вызываются они через имя класса или через экземпляр. Такие методы могут 
получить доступ к данным класса через аргумент self, даже когда они 
вызываются относительно экземпляра. Обычные методы (которые формально 
называются методами экземпляра) при вызове получают подразумеваемый 
экземпляр, а статические методы и методы класса – нет.


 Статические методы в 2.6 и 3.0
 
 Статические методы поддерживаются в обеих версиях Python, 2.6 и 3.0,
но в версии 3.0 требования к их реализации несколько изменились. 
Поскольку в этой книге рассматриваются обе версии, я должен объяснить 
основные различия между моделями, лежащими в основе, прежде чем перейти
к программному коду.

 В действительности мы уже начинали поднимать эту тему в предыдущей 
главе, когда говорили о несвязанных методах. Напомню, что в Python 2.6
и 3.0, когда метод вызывается относительно экземпляра, ему всегда 
передается ссылка на этот экземпляр. Однако в Python 3.0 извлечение 
методов через имя класса интерпретируется иначе, чем в 2.6:

  В Python 2.6 операция извлечения метода по имени класса возвращает 
 несвязанный метод, при вызове которого требуется вручную передавать 
 экземпляр.
 
  В Python 3.0 операция извлечения метода по имени класса возвращает 
 простую функцию, которой не требуется передавать ссылку на экземпляр.
 
 Другими словами, в Python 2.6 методам всегда необходимо передавать 
экземпляр, независимо от того, вызываются они через имя класса 
или через экземпляр. В Python 3.0, напротив, экземпляр требуется 
передавать методам, только если они ожидают получить его, – методы 
без аргумента self могут вызываться через имя класса без передачи им 
ссылки на экземпляр. То есть в версии 3.0 допускается объявлять простые
функции внутри класса, при условии, что они не ожидают получить и им 
не будет передаваться аргумент со ссылкой на экземпляр. В результате:

  В Python 2.6 мы всегда должны объявлять метод как статический, чтобы
 иметь возможность вызывать его без передачи ссылки на экземпляр, 
 независимо от того, вызываются он через имя класса или через экземпляр.
 
  В Python 3.0 от нас не требуется объявлять метод, как статический, 
 если он будет вызываться только через имя класса, но мы обязаны 
 объявлять его статическим, если он может вызываться через экземпляр.

 В качестве примера предположим, что необходимо использовать атрибуты
класса для подсчета числа экземпляров, созданных из класса. В следующем
файле spam.py представлена первая попытка – класс содержит счетчик 
в виде атрибута класса, конструктор, который наращивает счетчик 
при создании нового экземпляра, и метод, который выводит значение 
счетчика. Не забывайте, что атрибуты класса совместно используются всеми
экземплярами. Поэтому наличие счетчика непосредственно в объекте класса 
гарантирует, что он будет хранить число всех экземпляров:
"""


class Spam:
    numInstances = 0

    def __init__(self):
        Spam.numInstances = Spam.numInstances + 1

    def print_num_instances():
        print('Number of instances created: ', Spam.numInstances)


"""
 Метод printNumInstances предназначен для обработки данных класса, 
а не экземпляров – эти данные являются общими для всех экземпляров. 
Вследствие этого нам необходима возможность вызывать его, не передавая
ссылку на экземпляр. Действительно, зачем нам создавать новый экземпляр 
для получения числа экземпляров, ведь это изменит число экземпляров, 
которое мы пытаемся получить! Другими словами, нам нужен «статический» 
метод, не имеющий аргумента self.

 Будет ли работать такая реализация, зависит от версии интерпретатора 
и от способа вызова метода – через имя класса или через экземпляр. 
В версии 2.6 (да и в любой версии 2.X) такая реализация не будет 
работать – вызов метода printNumInstances без аргумента self, 
как через имя класса, так и через экземпляр, будет терпеть неудачу.
"""

a = Spam()  # В 2.6 невозможно вызывать несвязанные методы
b = Spam()  # По умолчанию методы ожидают получить self
c = Spam()

Spam.print_num_instances()

# a.print_num_instances()

"""
 Проблема состоит в том, что в версии 2.6 несвязанные методы экземпляра 
– это не то же самое, что простые функции. То есть вызов метода, 
такого как printNumInstances, через имя класса и без передачи ему
экземпляра будет терпеть неудачу в Python 2.6, но будет работать 
в Python 3.0. С другой стороны, попытка вызвать метод относительно
экземпляра будет терпеть неудачу в обеих версиях Python, потому что 
в этом случае интерпретатор автоматически передаст экземпляр методу, 
который не имеет соответствующего аргумента, чтобы принять его:

Spam.printNumInstances()  # Ошибка в 2.6, работает в 3.0
instance.printNumInstances()  # Ошибка в обеих версиях, 2.6 и 3.0

 Если вы используете версию 3.0 и предполагаете вызывать метод
без аргумента self только через имя класса, можете считать, что вы 
уже создали статический метод. Однако, чтобы иметь возможность вызывать
методы без аргумента self через имя класса в версии 2.6 
и через экземпляры в обеих версиях, 2.6 и 3.0, вам необходимо 
либо использовать иной подход к реализации, либо каким-то образом 
пометить подобные методы, как специальные. Рассмотрим обе возможности
по порядку.


 Альтернативы статическим методам
 
 Кроме возможности пометить метод, как специальный, существуют и другие
приемы, которые можно попробовать. Если для доступа к атрибутам класса
требуется вызывать функции, которые не принимают ссылку на экземпляр,
самая простая мысль, которая приходит в голову, – сделать метод обычной
функцией, а не методом класса. При таком способе функции не требуется 
передавать экземпляр класса. Например, следующая версия spam.py 
действует одинаково в Python 3.0 и 2.6 (правда, в этой версии инструкция
print отображает лишние круглые скобки при выполнении под управлением 
Python 2.6):
"""


def printNumInstances():
    print('Number of instances created: ', Spam.numInstances)


class Spam:
    numInstances = 0

    def __init__(self):
        Spam.numInstances = Spam.numInstances + 1


# import spam
a = Spam()
b = Spam()
c = Spam()
printNumInstances()       # Но функция может находиться слишком далеко
#                           от определения класса и не может
print(Spam.numInstances)  # адаптироваться в подклассах

"""
 Поскольку имя класса доступно простой функции в виде глобальной 
переменной, все работает прекрасно. Кроме того, обратите внимание, 
что имя самой функции также является глобальным, но только в этом
единственном модуле – оно не будет конфликтовать с именами в других 
модулях программы.

 До появления статических методов в Python такой способ 
был единственным. Поскольку в языке Python уже имеются модули, которые
играют роль инструмента разделения пространства имен, можно было бы 
утверждать, что обычно нет никакой необходимости упаковывать функции
в классы, если они не реализуют функциональность объектов. Простые 
функции внутри модуля, как в данном примере, способны решать большую 
часть задач, которые возлагаются на методы класса, не имеющие аргумента
self, и уже связаны с классом, потому что располагаются в том же самом 
модуле.

 К сожалению, такой подход далек от идеала. С одной стороны, в область 
видимости файла добавляется лишнее имя, которое используется для работы
с единственным классом. С другой – функция не имеет тесной связи 
с классом. Фактически определение функции может находиться 
за сотни строк от определения класса. Но самое неприятное, пожалуй,
состоит в том, что простые функции, как в данном примере, не могут
адаптироваться в подклассах, потому что они располагаются за пределами 
пространства имен класса: подклассы не могут непосредственно 
переопределять или замещать такие функции.

 Мы могли бы попытаться обеспечить работоспособность этого примера 
в обеих версиях интерпретатора, используя обычный метод, и всегда
вызывать его через (или передавать вручную) экземпляр:
"""


class Spam:
    numInstances = 0

    def __init__(self):
        Spam.numInstances = Spam.numInstances + 1

    def printNumInstances(self):
        print('Number of instances created: ', Spam.numInstances)


# from spam import Spam
a, b, c = Spam(), Spam(), Spam()
a.printNumInstances()

Spam.printNumInstances(a)

Spam().printNumInstances()  # Эта попытка извлечь счетчик изменяет его!

"""
 К сожалению, как уже упоминалось выше, такой подход полностью 
непригоден в случае отсутствия доступного экземпляра, а создание нового
экземпляра изменяет данные класса, как видно в последней строке 
этого примера. Лучшее решение заключается в том, чтобы каким-либо
способом пометить метод класса, который не требует передавать ему ссылку
на экземпляр. Как это сделать, демонстрируется в следующем разделе.


 Использование статических методов и методов класса
 
 На сегодняшний день существует еще одна возможность писать простые 
функции, связанные с классом, которые могут вызываться через имя класса 
или через экземпляры. Начиная с версии Python 2.2, имеется возможность 
создавать классы со статическими методами и с методами класса,
ни один из которых не требует передачи экземпляра класса в виде 
аргумента. Чтобы определить такие методы, в классах необходимо вызывать
встроенные функции staticmethod и classmethod, как упоминалось 
в обсуждении классов нового стиля. Обе функции помечают объект функции 
как специальный, то есть как не требующий передачи экземпляра, в случае 
применения функции staticmethod, и как требующий передачи класса, 
в случае применения функции classmethod. Например:
"""


class Methods:
    def imeth(self, x):  # Обычный метод экземпляра
        print(self, x)

    def smeth(x):  # Статический метод: экземпляр не передается
        print(x)

    def cmeth(cls, x):  # Метод класса: получает класс, но не экземпляр
        print(cls, x)

    smeth = staticmethod(smeth)  # Сделать smeth статическим методом
    cmeth = classmethod(cmeth)  # Сделать cmeth методом класса


"""
 Обратите внимание, как две последние операции присваивания в этом 
фрагменте просто переприсваивают имена методов smeth и cmeth. Атрибуты
создаются и изменяются с помощью операции присваивания в инструкции 
class, поэтому эти заключительные операции присваивания переопределяют 
инструкции def, выполненные ранее.

 С технической точки зрения, язык Python теперь поддерживает три
разновидности методов: методы экземпляра, статические методы и методы
класса. Кроме того, в Python 3.0 эта модель дополнена возможностью 
без лишних сложностей создавать в классах простые функции, которые 
играют роль статических методов при обращении к ним через имя класса.

 Методы экземпляра – это обычные (и используемые по умолчанию) методы,
которые мы видели в этой книге. Для воздействия на объект экземпляра
всегда следует вызывать методы экземпляра. Когда методы вызываются 
через экземпляр, интерпретатор автоматически передает экземпляр в первом
аргументе – когда метод вызывается через имя класса, экземпляр 
необходимо передавать методам вручную (для простоты я опустил инструкции
импортирования некоторых классов):
"""


obj = Methods()  # Создать экземпляр
obj.imeth(1)  # Обычный вызов, через экземпляр
# Будет преобразован в вызов imeth(obj, 1)
Methods.imeth(obj, 2)  # Обычный вызов, через класс

"""
 Статические методы, напротив, вызываются без аргумента с экземпляром.
В отличие от простых функций, за пределами класса их имена ограничены 
областью видимости класса, в котором они определяются и могут 
отыскиваться механизмом наследования. Функции, которым не передаются 
ссылки на экземпляры, в Python 3.0 могут вызываться обычным образом 
через имя класса, но в Python 2.6 по умолчанию – никогда. Применение 
встроенной функции staticmethod обеспечивает возможность вызывать такие 
методы через экземпляр в версии 3.0, и через имя класса 
и через экземпляр – в Python 2.6 (в версии 3.0 вызов через имя класса 
возможен и без применения staticmethod, но вызов через экземпляр – нет):
"""

Methods.smeth(3)  # Вызов статического метода, через имя класса
# Экземпляр не передается и не ожидается
obj.smeth(4)  # Вызов статического метода, через экземпляр
# Экземпляр не передается

"""
 Методы класса похожи на них, но интерпретатор автоматически передает
методам класса сам класс (а не экземпляр) в первом аргументе, 
независимо от того, вызываются они через имя класса или через экземпляр:
"""

Methods.cmeth(5)  # Вызов метода класса, через имя класса
# Будет преобразован в вызов cmeth(Methods, 5)
obj.cmeth(6)  # Вызов метода класса, через экземпляр
# Будет преобразован в вызов cmeth(Methods, 6)

"""
 Подсчет количества экземпляров с помощью статических методов

 Теперь, зная о существовании встроенных функций, можно реализовать 
статический метод, эквивалентный оригинальному примеру этого раздела, – 
он помечен, как специальный, поэтому ему никогда автоматически не будет 
передаваться ссылка на экземпляр:
"""


class Spam:            # Для доступа к данным класса используется
    numInstances = 0   # статический метод

    def __init__(self):
        Spam.numInstances += 1

    def printNumInstances():
        print('Number of instances:', Spam.numInstances)

    printNumInstances = staticmethod(printNumInstances)


"""
 Использование встроенной функции staticmethod позволяет вызывать метод,
не принимающий аргумент self, через имя класса или через любой экземпляр
в обеих версиях Python, 2.6 и 3.0:
"""

a = Spam()
b = Spam()
c = Spam()
Spam.printNumInstances()  # Вызывается, как простая функция

a.printNumInstances()  # Аргумент с экземпляром не передается

"""
 По сравнению с простым перемещением printNumInstances за пределы
класса, как описывалось ранее, эта версия требует дополнительный вызов 
функции staticmethod. При этом здесь область видимости имени функции 
ограничена классом (имя не будет вступать в конфликт с другими именами
в модуле), программный код перемещен туда, где он используется 
(внутрь инструкции class), и подклассы получают возможность адаптировать
статический метод наследованием – этот подход более удобен, 
чем импортирование функций из файлов, в которых находятся определения 
супер-классов. Это иллюстрирует следующий подкласс и листинг нового
интерактивного сеанса:
"""


class Sub(Spam):
    def printNumInstances():  # Переопределяет статический метод
        print('Extra stuff...')  # Который вызывает оригинал
        Spam.printNumInstances()
    printNumInstances = staticmethod(printNumInstances)


a = Sub()
b = Sub()
a.printNumInstances()  # Вызов через экземпляр подкласса

Sub.printNumInstances()  # Вызов через имя подкласса

Spam.printNumInstances()

"""
 Кроме того, классы могут наследовать статические методы, 
не переопределяя их, – они будут вызываться без передачи им ссылки 
на экземпляр, независимо от их местоположения в дереве классов:
"""


class Other(Spam):
    pass  # Наследует оригинальный статический метод


c = Other()
c.printNumInstances()

"""
 Подсчет экземпляров с помощью методов класса
 
 Интересно отметить, что аналогичные действия можно реализовать 
с помощью метода класса – следующий класс обладает тем же поведением, 
что и класс со статическим методом, представленный выше, но в нем 
используется метод класса, который в первом аргументе принимает класс 
экземпляра. Методы класса автоматически получают объект класса:
"""


class Spam:
    numInstances = 0  # Вместо статического метода используется
    #                   метод класса

    def __init__(self):
        Spam.numInstances += 1

    def printNumInstances(cls):
        print('Number of instances:', cls.numInstances)

    printNumInstances = classmethod(printNumInstances)


"""
 Используется этот класс точно так же, как и предыдущая версия, 
но его метод printNumInstances принимает объект класса, а не экземпляра,
независимо от того, вызывается он через имя класса или через экземпляр:
"""

a, b = Spam(), Spam()
a.printNumInstances()  # В первом аргументе передается класс

Spam.printNumInstances()  # Также в первом аргументе передается класс

"""
 Однако, используя методы класса, имейте в виду, что они принимают 
класс, самый близкий к объекту вызова. Это влечет за собой ряд важных 
последствий, который оказывают влияние на попытки изменить данные класса
через переданный методу класс. Например, если в модуле test.py 
мы определим подкласс, адаптирующий предыдущую версию метода 
Spam.printNumInstances так, чтобы он дополнительно выводил свой аргумент
cls, и запустим новый сеанс:
"""


class Spam:
    numInstances = 0  # Отслеживает количество экземпляров

    def __init__(self):
        Spam.numInstances += 1

    def printNumInstances(cls):
        print('Number of instances:', cls.numInstances, cls)
    printNumInstances = classmethod(printNumInstances)


class Sub(Spam):
    def printNumInstances(cls):  # Переопределяет метод класса
        print('Extra stuff...', cls)  # Но вызывает оригинал
        Spam.printNumInstances()
    printNumInstances = classmethod(printNumInstances)


class Other(Spam):
    pass  # Наследует метод класса


"""
 всякий раз, когда будет вызываться метод класса, интерпретатор будет
передавать ему самый близкий класс, даже для подклассов, не имеющих 
собственной реализации метода класса:
"""

x, y = Sub(), Spam()
x.printNumInstances()  # Вызов через экземпляр подкласса

Sub.printNumInstances()  # Вызов через сам подкласс

y.printNumInstances()

"""
 В первом случае здесь метод класса вызывается через экземпляр подкласса
Sub, и интерпретатор передает методу ближайший к экземпляру класс Sub. 
В данном случае никаких проблем не возникает, так как версия метода,
переопределенная в классе Sub, явно вызывает оригинальную версию метода
в супер-классе Spam, при этом метод супер-класса принимает класс Spam
в первом аргументе. Но посмотрите, что произойдет в случае обращения 
к объекту, который просто наследует метод класса:
"""

z = Other()
z.printNumInstances()

"""
 Здесь в последнем вызове методу класса Spam передается класс Other. 
В данном случае метод работает потому, что он всего лишь извлекает 
значение счетчика, который обнаруживает в классе Spam, благодаря
механизму наследования. Однако если бы этот метод попытался присвоить 
новое значение атрибуту класса, он изменил бы атрибут класса Other,
а не Spam! В данном конкретном случае, вероятно, было бы лучше жестко 
указать имя класса, в котором производится изменение данных, 
чем полагаться на передаваемый аргумент класса.


 Подсчет экземпляров для каждого класса с помощью методов класса

 Фактически методы класса всегда получают ближайший класс в дереве
наследования, поэтому:

  Применение статических методов, в которых явно указывается имя класса,
 может оказаться более удачным решением для обработки данных класса.
 
  Методы классов лучше подходят для обработки данных, которые могут 
 отличаться для каждого конкретного класса в иерархии.

 Например, для реализации счетчиков экземпляров каждого класса
в отдельности лучше подошли бы методы класса. В следующем примере 
супер-класс определяет метод класса, управляющий информацией о состоянии,
которая отличается для разных классов в дереве, – подобно тому, 
как методы экземпляра управляют информацией о состоянии экземпляров:
"""


class Spam:
    numInstances = 0

    def count(cls):  # Счетчик экземпляров для каждого отдельного класса
        cls.numInstances += 1  # cls – ближайший к экземпляру класс

    def __init__(self):
        self.count()  # Передаст self.__class__ для подсчета
    count = classmethod(count)


class Sub(Spam):
    numInstances = 0

    def __init__(self):  # Переопределяет __init__
        Spam.__init__(self)


class Other(Spam):  # Наследует __init__
    numInstances = 0


x = Spam()
y1, y2 = Sub(), Sub()
z1, z2, z3 = Other(), Other(), Other()
print(x.numInstances, y1.numInstances, z1.numInstances)

print(Spam.numInstances, Sub.numInstances, Other.numInstances)

"""
 Статические методы и методы класса могут использоваться и в других 
ситуациях, которые мы не будем рассматривать здесь, – ищите 
дополнительную информацию в других источниках. Однако в последних 
версиях Python создание статических методов и методов класса можно 
упростить, воспользовавшись декораторами функций – способом применения
одной функции к другой. Вообще декораторы функций имеют более широкую 
область применения, чем простое объявление статических методов, которое,
впрочем, стало основной причиной их появления. Синтаксис декораторов
позволяет нам также расширять классы в Python 2.6 и 3.0 – 
инициализировать данные, такие как счетчик numInstances в последнем
примере. Как это делается, описывается в следующем разделе.
"""

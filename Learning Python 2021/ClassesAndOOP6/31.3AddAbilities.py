"""
 Декораторы и метаклассы: часть 1

 Прием с вызовом функции staticmethod, описанный в предыдущем разделе,
выглядит малопонятным для некоторых пользователей, поэтому была
добавлена возможность, упрощающая эту операцию. Декораторы функций
обеспечивают способ определения специальных режимов работы функций,
обертывая их дополнительным слоем логики, реализованной в виде
других функций. Декораторы функций представляют собой более
универсальные инструменты: их удобно использовать для добавления
самой разной логики не только к статическим методам, но и к любым другим
функциям. Например, их можно использовать для расширения функций
программным кодом, выполняющим регистрацию вызовов этих функций,
проверяющим типы передаваемых аргументов в процессе отладки и так далее.
В некоторой степени декораторы функций напоминают шаблон проектирования
делегирования, исследованный нами в главе 30, но их главная цель состоит
в том, чтобы расширять определенные функции или методы,
а не весь интерфейс объекта.

 Язык Python предоставляет несколько встроенных декораторов функций для
выполнения таких действий, как создание статических методов,
но программисты также имеют возможность создавать свои собственные
декораторы. Несмотря на то, что они строго не привязаны к классам,
тем не менее пользовательские декораторы функций часто оформляются
как классы, в которых сохраняется оригинальная функция наряду с другими
данными, такими как информация о состоянии. Кроме того, недавно
появилось похожее расширение, доступное в Python 2.6 и 3.0: декораторы
классов, непосредственно связанные с моделью классов, и метаклассы,
играющие похожую роль.


 Основы декораторов функций

 Синтаксически декоратор функции – это разновидность объявления функции
времени выполнения. Декоратор функции записывается в строке,
непосредственно перед строкой с инструкцией def, которая определяет
функцию или метод, и состоит из символа @, за которым следует то,
что называется мета функцией, – функция (или другой вызываемый объект),
которая управляет другой функцией. В настоящее время статические методы,
к примеру, могут быть оформлены в виде декораторов, как показано ниже:

class C:
    @staticmethod  # Синтаксис декорирования
    def meth():
        ...

 С технической точки зрения, это объявление имеет тот же эффект,
что и фрагмент ниже (передача функции декоратору и присваивание
результата первоначальному имени функции):

class C:
    def meth():
        ...
    meth = staticmethod(meth)  # Повторное присваивание имени

 Результат, возвращаемый функцией-декоратором, повторно присваивается
имени метода. В результате вызов метода по имени функции фактически
будет приводить к вызову результата, полученному от декоратора
staticmethod. Декоратор может возвращать объекты любого типа, поэтому
данный прием позволяет декоратору вставлять дополнительный уровень
логики, который будет запускаться при каждом вызове. Декоратор функции
может возвращать как оригинальную функцию, так и новый объект, в котором
хранится оригинальная функция, переданная декоратору, которая будет
вызываться косвенно после того, как будет выполнен дополнительный
слой логики.

 Благодаря этому расширению мы располагаем более удачным способом
объявить статический метод в примере из предыдущего раздела в обеих
версиях Python, 2.6 и 3.0 (декоратор classmethod используется
точно так же):
"""


class Spam:
    numInstances = 0

    def __init__(self):
        Spam.numInstances = Spam.numInstances + 1

    @staticmethod
    def printNumInstances():
        print('Number of instances created: ', Spam.numInstances)


a = Spam()
b = Spam()
c = Spam()
Spam.printNumInstances()  # Теперь вызовы могут производиться
#                           как через класс, так и через экземпляр!
a.printNumInstances()  # В обоих случаях будет выведено
#                        “Number of instances created: 3”

"""
 Имейте в виду, что staticmethod – это все та же встроенная функция. 
Она может использоваться как декоратор просто потому, что принимает
другую функцию в виде аргумента и возвращает вызываемый объект. 
Фактически любая такая функция может использоваться в качестве 
декоратора, даже пользовательские функции, которые мы пишем сами,
как описывается в следующем разделе.


 Первый пример декоратора функций

 В языке Python уже имеется несколько удобных встроенных функций, 
которые можно использовать как декораторы, но при этом мы также можем
писать свои собственные декораторы. Из-за широты применения декораторов
мы посвятим их созданию целую главу, в следующей части книги. А пока,
в качестве предварительного знакомства, рассмотрим простой пример
декоратора, определяемого пользователем.

 Вспомните, как в главе 29 говорилось, что метод перегрузки оператора 
__call__ реализует в экземплярах классов интерфейс вызова функций.
В следующем примере этот метод используется в определении класса, 
который сохраняет декорируемую функцию в экземпляре и перехватывает 
вызовы по оригинальному имени. А так как это класс, кроме всего прочего
в нем имеется возможность хранить информацию о состоянии (счетчик 
произведенных вызовов):
"""


class tracer:
    def __init__(self, func):
        self.calls = 0
        self.func = func

    def __call__(self, *args):
        self.calls += 1
        print('call %s to %s' % (self.calls, self.func.__name__))
        self.func(*args)


@tracer  # То же, что и spam = tracer(spam)
def spam(a, b, c):  # Обертывает spam в объект-декоратор
    print(a, b, c)


spam(1, 2, 3)  # В действительности вызывается объект-обертка
spam('a', 'b', 'c')  # То есть вызывается метод __call__ в классе
spam(4, 5, 6)  # Метод __call__ выполняет дополнительные действия
# и вызывает оригинальную функцию

"""
 Функция spam передается декоратору tracer, поэтому, когда производится
обращение к оригинальному имени spam, в действительности вызывается
метод __call__ в классе. Этот метод подсчитывает и регистрирует вызовы, 
а затем вызывает оригинальную обернутую функцию. Обратите внимание, 
как используется синтаксис аргумента *name для упаковывания 
и распаковывания аргументов, передаваемых функции, – благодаря этому 
данный декоратор может использоваться для обертывания любой функции, 
с любым числом позиционных аргументов.

 В результате к оригинальной функции spam добавляется слой 
дополнительной логики. Ниже приводится вывод, полученный от сценария, – 
первая строка создана классом tracer, а вторая – функцией spam:

call 1 to spam
1 2 3
call 2 to spam
a b c
call 3 to spam
4 5 6

 Исследуйте программный код этого примера повнимательнее, чтобы вникнуть
в его суть. Итак, данный декоратор действует, как обычная функция, 
принимающая позиционные аргументы, но он не возвращает результат вызова
декорируемой функции, не обрабатывает именованные аргументы и не может
декорировать методы классов (при декорировании методов метод __call__ 
мог бы передавать только экземпляр класса tracer). Как мы узнаем
в восьмой части книги, существует множество способов декорирования 
функций, включая вложенные инструкции def, – некоторые из них лучше 
подходят для декорирования методов, чем способ, представленный здесь.


 Декораторы классов и метаклассы
 
 Декораторы функций оказались настолько удобны в обращении, 
что эта модель была расширена в Python 2.6 и 3.0 и теперь она позволяет
применять декораторы не только к функциям, но и к классам.
В двух словах, декораторы классов похожи на декораторы функций, 
но они запускаются после инструкции class, чтобы повторно присвоить 
имя класса вызываемому объекту. Кроме того, они могут использоваться
для изменения классов сразу после их создания или добавлять 
дополнительный слой логики уже после создания экземпляров. 
При применении декоратора к классу программный код вида:

def decorator(aClass): ...

@decorator
class C: ...

 отображается в следующий эквивалент:
 
def decorator(aClass): ...

class C: ...
C = decorator(C)

 Декоратор класса может расширить функциональность самого класса 
или вернуть объект, который будет перехватывать последующие попытки 
конструирования экземпляров. Так, в примере из раздела «Подсчет 
экземпляров для каждого класса с помощью методов класса» выше, 
мы могли бы использовать этот прием для автоматического добавления
в классы счетчика экземпляров и любых других необходимых данных:
"""


def count(aClass):
    aClass.numInstances = 0
    return aClass  # Возвращает сам класс, а не обертку


@count
class Spam:
    pass  # То же, что и Spam = count(Spam)


@count
class Sub(Spam):
    pass  # Инструкция numInstances = 0 не нужна здесь


@count
class Other(Spam):
    pass


"""
 Метаклассы представляют собой похожий инструмент на основе классов,
область применения которого отчасти перекрывает область применения 
декораторов классов. Они предоставляют альтернативную модель управления
созданием объектов классов за счет создания подклассов класса type 
и включения их в инструкцию class:


class Meta(type):
    def __new__(meta, classname, supers, classdict): ...
    
    
class C(metaclass=Meta): ...


 В Python 2.6 результат получается тем же, но способ включения 
метакласса отличается – вместо именованного аргумента в заголовке
инструкции class для этих целей используется атрибут metaclass:


class C:
    __metaclass__ = Meta
    ...
    
    
 Обычно метакласс переопределяет метод __new__ или __init__ класса type, 
с целью взять на себя управление созданием или инициализацией нового 
объекта класса. Как и при использовании декораторов классов, 
суть состоит в том, чтобы определить программный код, который будет 
вызываться автоматически на этапе создания класса. Оба способа позволяют
расширять классы или возвращать произвольные объекты для его замены –
протокол с практически неограниченными возможностями.


 Изменение атрибутов класса может приводить к побочным эффектам
 
 Теоретически классы (и экземпляры классов) относятся к категории
изменяемых объектов. Подобно таким встроенным типам, как списки
и словари, они могут изменяться непосредственно, путем присваивания 
значений атрибутам, и как и в случае со списками и словарями, 
это означает, что изменение класса или экземпляра может оказывать 
влияние на множественные ссылки на них. 

 Обычно это именно то, что нам требуется (так объекты изменяют свое 
состояние), но, изменяя атрибуты, об этом необходимо помнить. 
Все экземпляры класса совместно используют одно и то же пространство
имен класса, поэтому любые изменения на уровне класса будут отражаться 
на всех экземплярах, если, конечно, они не имеют собственных версий 
атрибутов класса.

 Классы, модули и экземпляры – это всего лишь объекты с пространствами
имен атрибутов, поэтому во время выполнения они обычно изменяются 
с помощью операций присваивания. Рассмотрим следующий класс. 
В теле класса выполняется присваивание имени a, в результате чего 
создается атрибут X.a, который во время выполнения располагается 
в объекте класса и будет унаследован всеми экземплярами класса X:

>>> class X:
...     a = 1  # Атрибут класса
...
>>> I = X()
>>> I.a  # Унаследован экземпляром
1
>>> X.a
1

 Пока все неплохо – это обычный случай. Но обратите внимание, 
что происходит, когда атрибут класса изменяется динамически,
за пределами инструкции class: это приводит к одновременному изменению 
атрибута во всех объектах, наследующих его от класса. Кроме того, 
новые экземпляры класса, созданные в ходе интерактивного сеанса 
или во время работы программы, получают динамически установленное 
значение, независимо от того, что написано в исходном программном коде 
класса:

>>> X.a = 2  # Может измениться не только в классе X
>>> I.a  # Объект I тоже изменился
2
>>> J = X()  # J наследует значение, установленное во время выполнения
>>> J.a  # (но присваивание имени J.a изменяет a в J, но не в X или I)
2

 Что это – полезная особенность или опасная ловушка? Решать вам. 
Фактически вы можете выполнять все необходимые действия по изменению 
атрибутов класса, не создавая ни единого экземпляра, – с помощью этого
приема можно имитировать «записи» и «структуры» данных, имеющиеся
в других языках программирования. Чтобы освежить воспоминания, 
рассмотрим следующую, не совсем обычную, но вполне допустимую программу 
на языке Python:
"""


class X:
    pass  # Создать несколько пространств имен атрибутов


class Y:
    pass


X.a = 1  # Использовать атрибуты класса как переменные
X.b = 2  # В программе нет ни одного экземпляра класса
X.c = 3
Y.a = X.a + X.b + X.c
for X.i in range(Y.a):
    print(X.i)  # Выведет 0..5

"""
 Здесь классы X и Y действуют как модули «без файлов» – пространства 
имен для хранения переменных, которые не конфликтуют между собой. 
Это совершенно допустимый прием на языке Python, но он не подходит
для применения к классам, написанным другими программистами, – 
вы не всегда можете быть уверены, что атрибуты класса, которые 
вы изменяете, не являются критически важными для внутренних механизмов
класса. Если вы имитируете структуру на языке C, лучше изменять
экземпляры, а не класс, поскольку в этом случае изменения будут касаться 
единственного объекта:
"""


class Record:
    pass


X = Record()
X.name = 'bob'
X.job = 'Pizza maker'
print(X.__dict__)

"""
 Модификация изменяемых атрибутов класса 
также может иметь побочные эффекты

 Данная проблема в действительности является продолжением предыдущей.
Атрибуты класса совместно используются всеми его экземплярами, поэтому,
если атрибут класса ссылается на изменяемый объект, изменение этого 
объекта из любого экземпляра отразится сразу на всех экземплярах:
"""


class C:
    shared = []  # Атрибут класса

    def __init__(self):
        self.perobj = []  # Атрибут экземпляра


x = C()  # Два экземпляра
y = C()  # неявно используют один и тот же атрибут класса
print(y.shared, y.perobj)

x.shared.append('spam')  # Окажет влияние на объект y также!

x.perobj.append('spam')  # Изменит данные, принадлежащие только
#                          объекту x
print(x.shared, x.perobj)

print(y.shared, y.perobj)  # В объекте y наблюдаются изменения,
#                            произведенные через объект x
print(C.shared)  # Сохраненный в классе и совместно используемый

"""
 Этот случай ничем не отличается от многих других, представленных в этой
книге: разделяемые объекты, на которые ссылаются несколько простых
переменных, глобальные объекты, которые совместно используются
несколькими функциями, объекты уровня модуля, которые совместно
используются несколькими импортирующими модулями, и изменяемые аргументы
функций, которые совместно используются вызывающим и вызываемым 
программным кодом. Все эти случаи являются разновидностями ситуации 
наличия нескольких ссылок на изменяемый объект – изменения в объекте,
выполненные с помощью любой из этих ссылок, можно будет наблюдать
с помощью всех остальных. В данном случае всеми экземплярами совместно
используются атрибуты класса, через механизм наследования, но по сути 
это тот же самый феномен, который может осложняться различными способами
присваивания атрибутам экземпляров:
"""

x.shared.append('spam')  # Изменит разделяемый объект, присоединенный
#                          к классу
x.shared = 'spam'  # Изменит или создаст атрибут экземпляра x

"""
 Но опять-таки это не является проблемой, это всего лишь 
одна из особенностей использования изменяемых объектов в атрибутах 
классов, о которой следует помнить, – разделяемые, изменяемые атрибуты 
класса вполне могут найти применение в программах на языке Python.


 Множественное наследование: порядок имеет значение
 
 Это достаточно очевидно, но тем не менее стоит подчеркнуть: в случае 
использования множественного наследования порядок, в котором перечислены
супер-классы в строке заголовка инструкции class,
может иметь критическое значение. В ходе поиска интерпретатор
всегда просматривает супер-классы слева направо,
в соответствии с порядком их следования в заголовке инструкции.
Например, в примере множественного наследования,
который был продемонстрирован в главе 30, предположим,
что класс Super тоже реализует метод __str__:


class ListTree:
    def __str__(self): ...
    
    
class Super:
    def __str__(self): ...
    
    
class Sub(ListTree, Super):  # Будет унаследован метод __str__ 
                     # класса ListTree, так как он стоит в списке первым
x = Sub()  # Поиск сначала будет выполняться в классе
           # ListTree, а затем в классе Super
           
 От какого класса мы унаследовали бы метод – от класса Lister или Super?
Это зависело бы от того, какой класс стоит первым в заголовке объявления 
класса Sub, так как поиск унаследованных атрибутов производится слева 
направо. 

 Очевидно, мы поставили бы класс ListTree первым в списке, потому что
его основная цель состоит в предоставлении метода __str__
(в действительности, мы сделали нечто похожее в главе 30, смешав 
этот класс с классом Button из библиотеки tkinter, который имеет 
собственный метод __str__).

 А теперь предположим, что классы Super и ListTree имеют 
свои собственные версии еще одного одноименного атрибута. 
Если необходимо, чтобы одно имя наследовалось от класса Super, 
а другое от класса ListTree, изменение порядка их расположения 
в заголовке инструкции определения подкласса уже не поможет – мы должны 
вручную переопределить результат наследования, явно выполнив 
присваивание имени атрибута в классе Sub:


class ListTree:
    def __str__(self): ...
    def other(self): ...
    
    
class Super:
    def __str__(self): ...
    def other(self): ...
    
    
class Sub(ListTree, Super): # Унаследует __str__ класса ListTree, 
    #                         так как он первый в списке
    other = Super.other  # Явно выбирается версия атрибута
    def __init__(self):    из класса Super
        ...
        
        
x = Sub()  # Поиск сначала выполняется в Sub и только потом
             в ListTree/Super

 Здесь присваивание атрибуту с именем other в классе Sub создает атрибут 
Sub.other – ссылку на объект Super.other. Поскольку данная ссылка 
находится ниже в дереве классов, это не позволит механизму наследования
выбрать версию атрибута ListTree.other, который был обнаружен первым 
при обычных обстоятельствах. Точно так же, если бы класс Super стоял
первым в списке, то чтобы атрибут other наследовался обычным образом, 
нам могло бы потребоваться явно выбрать методы класса ListTree:

class Sub(Super, ListTree):  # Получить Super.other по наследованию
    __str__ = ListTree.__str__  # Явно выбрать ListTree.__str__

 Множественное наследование – это довольно сложная тема. 
Даже если вы поняли предыдущий абзац, все равно этот прием лучше
использовать осторожно и только в случае крайней необходимости. 
В противном случае могут возникать ситуации, когда значение имени 
атрибута будет зависеть от порядка следования классов в инструкции 
определения подкласса. (Еще один пример этого приема в действии 
приводится в этой же главе в разделе «Классы нового стиля», 
где обсуждалось явное разрешение конфликтов имен.)

 Как правило, множественное наследование дает лучшие результаты, когда
супер-классы являются максимально автономными, – поскольку они могут
использоваться в разных контекстах, они не должны делать каких-либо 
предположений об именах, связанных с другими классами в дереве. 
Псевдочастные атрибуты с именами вида __X, которые рассматривались
в главе 30, могут помочь в локализации имен, на владение которыми 
опирается класс, и ограничить вероятность появления конфликтов имен 
в супер-классах, которые вы добавляете в список наследуемых классов.
Например, в данном случае класс ListTree служит только для того, 
чтобы экспортировать метод __str__, поэтому он мог бы дать своему
второму методу имя __other, чтобы избежать конфликтов с именами 
в других классах.


 Методы, классы и вложенные области видимости

 Эта проблема была ликвидирована в Python 2.2 введением областей 
видимости вложенных функций, но я сохранил это описание исключительно
ради истории, для тех из вас, кому приходилось работать с более старыми
версиями Python и с целью продемонстрировать, что происходит в случае
вложения функций, когда один из уровней вложенности является классом.

 Классы, как и функции, обладают своими локальными областями видимости,
поэтому области видимости обладают сходными проявлениями в теле 
инструкции class. Кроме того, методы, по сути, являются вложенными
функциями, поэтому здесь имеют место те же самые проблемы. Похоже, 
что путаница особенно часто возникает, когда имеются классы, вложенные 
друг в друга.

 В следующем примере (файл nester.py) функция generate возвращает 
экземпляр вложенного класса Spam. Внутри этой функции имя класса Spam 
находится в локальной области видимости функции generate. Но в версиях 
Python, появившихся до версии 2.2, внутри метода method имя класса Spam 
недоступно – method имеет доступ только к своей локальной области 
видимости, к области видимости модуля, вмещающего окружающую функцию
generate, и к встроенным именам:
"""


def generate():  # Терпит неудачу при выполнении под управлением
    class Spam:  # Python до версии 2.2
        count = 1

        def method(self):      # Имя Spam недоступно:
            print(Spam.count)  # Не локальное (def),
            #                    не глобальное (модуль),
            #                    не встроенное
            
    return Spam()


generate().method()

"""
 C:\python\examples> python nester.py
...текст сообщения об ошибке опущен...
  print(Spam.count)       # Не локальное (def), не глобальное (модуль),
NameError: Spam           # не встроенное

 Этот пример будет работать в версии Python 2.2 и выше, потому что
все локальные области вмещающих функций автоматически видимы 
для вложенных функций (включая и вложенные методы, как в данном 
примере). Но он не работал в версиях Python, вышедших до версии 2.2 
(некоторые возможные решения приводятся ниже).

 Обратите внимание, что даже в версии 2.2 методам недоступна локальная 
область видимости вмещающего класса – им доступны только области 
видимости вмещающих функций. Именно по этой причине методы должны 
использовать аргумент self с экземпляром или имя класса, чтобы вызывать
другие методы или обращаться к другим атрибутам, определенным 
во вмещающей инструкции class. Например, программный код метода 
не может использовать простое имя count, он должен использовать 
имя self.count или Spam.count. Если вам приходится работать с версией
ниже 2.2, скажу, что существует несколько способов заставить предыдущий 
пример работать. Самый простой заключается в том, чтобы переместить 
имя Spam в область видимости вмещающего модуля с помощью глобального 
объявления. Поскольку методу method доступны глобальные имена в модуле, 
попытка сослаться на Spam уже не будет вызывать ошибку:

def generate():
    global Spam #  Перенести имя Spam в область видимости модуля
    
    class Spam:
        count = 1
        
        def method(self):
            print(Spam.count)  # Работает: глобальное имя 
    return Spam()                (вмещающий модуль)
    
generate().method()  # Выведет 1

 Лучше было бы реструктурировать программный код так, чтобы вместо 
использования объявления global определение класса Spam находилось 
на верхнем уровне модуля. После этого вложенный метод method и функция 
generate будут отыскивать класс Spam в глобальной области видимости:

def generate():
    return Spam()
    
    
class Spam:  # Определение на верхнем уровне в модуле
    count = 1
    
    def method(self):
        print(Spam.count)  # Работает: глобальное имя (вмещающий модуль)
        
generate().method()

 В действительности такой подход рекомендуется использовать 
во всех версиях Python – программный код выглядит проще, если в нем 
отсутствуют вложенные классы и функции.

 Если вам требуется нечто более сложное и замысловатое, то можно 
просто избавиться от ссылки на имя Spam в методе method, используя 
специальный атрибут __class__, который возвращает класс объекта
экземпляра:

def generate():

    class Spam:
    
        count = 1
        def method(self):
            print(self.__class__.count)  # Работает: используется 
    return Spam()                        # атрибут для получения класса
    
generate().method()


 Делегирование в версии 3.0: __getattr__ и встроенные операции

 Мы сталкивались с этой проблемой в главе 27, когда изучали практический
пример программирования классов и когда рассматривали прием
делегирования в главе 30: классы, использующие метод __getattr__ 
для делегирования обернутым объектам операций обращения к атрибутам,
будут терпеть неудачу в Python 3.0, если методы перегрузки операторов
не будут переопределены в классе-обертке. В Python 3.0 (и в 2.6,
при использовании классов нового стиля) обращения к методам перегрузки
операторов производятся встроенными операциями неявно, минуя обычную 
схему выбора методов-обработчиков. Например, метод __str__, используемый 
для вывода, никогда не вызывает __getattr__. Вместо этого в Python 3.0 
интерпретатор пытается отыскать требуемые имена в классах, пропуская 
этап поиска в экземпляре. Чтобы решить эту проблему, подобные методы
должны быть переопределены в классах-обертках (вручную, с помощью других
инструментов или с помощью супер-классов). Мы еще вернемся
к этой проблеме в главах 37 и 38.


 «Многослойное обертывание»
 
 При грамотном использовании способность объектно-ориентированного
программного кода к многократному использованию поможет существенно 
снизить затраты времени на его разработку. Однако иногда неправильное 
использование потенциала абстракции ООП может серьезно осложнить
понимание программного кода. Если классы наслоены друг на друга слишком
глубоко, программный код становится малопонятным – возможно, 
вам придется изучить множество классов, чтобы выяснить, что делает 
единственная операция. 

 Например, однажды мне пришлось работать с библиотекой, написанной 
на языке C++, содержащей тысячи классов  (часть которых была 
сгенерирована машиной) и до 15 уровней наследования. Расшифровка вызовов
методов в такой сложной системе классов часто оказывалась неподъемной 
задачей: даже в простейшую операцию оказывались вовлеченными сразу 
несколько классов. Логика системы оказалась такой многослойной, 
что в некоторых случаях, чтобы понять принцип действия какого-либо 
участка программного кода, требовалось несколько дней копаться
в нескольких файлах.

 Здесь также вполне применимо одно из самых универсальных правил языка
Python: не усложняйте решение задачи, если оно не является таковым.
Обертывание программного кода несколькими слоями классов на грани 
непостижимости – всегда плохая идея. Абстракция – это основа 
полиморфизма и инкапсуляции, и при грамотном использовании 
она может быть весьма эффективным инструментом. Однако вы упростите
отладку и сопровождение, если сделаете интерфейсы своих классов
интуитивно понятными. Избегайте чрезмерной абстракции и сохраняйте
иерархии своих классов короткими и плоскими, если не существует веских
причин сделать иначе.
"""

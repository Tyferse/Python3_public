"""
 Перегрузка операторов


 Основы

 В действительности термин «перегрузка операторов» означает всего лишь
перехватывание встроенных операций с помощью методов классов –
интерпретатор автоматически вызывает эти методы при выполнении
встроенных операций над экземплярами классов, а методы должны возвращать
значения, которые будут интерпретироваться как результаты
соответствующих операций. Ниже приводится краткий обзор ключевых идей,
лежащих в основе механизма перегрузки:

  Перегрузка операторов в языке Python позволяет классам участвовать
 в обычных операциях.

  Классы в языке Python могут перегружать все операторы выражений.

  Классы могут также перегружать такие операции, как вывод,
 вызов функций, обращение к атрибутам и так далее.

  Перегрузка делает экземпляры классов более похожими
 на встроенные типы.

  Перегрузка заключается в реализации в классах методов
 со специальными именами.

 Другими словами, если в классе определен метод со специальным именем,
интерпретатор автоматически будет вызывать его при выполнении
соответствующей методу операции над экземплярами этого класса.
Как мы уже знаем, методы перегрузки операторов никогда не являются
обязательными, и обычно для них не предусматривается реализация
по умолчанию – если метод не реализован в классе и не унаследован,
это всего лишь означает, что класс не поддерживает соответствующую
операцию. Однако если эти методы используются, то они позволяют классам
имитировать интерфейсы встроенных объектов и обеспечивают их
единообразие.


 Конструкторы и выражения: __init__ and __sub__

 Рассмотрим простой пример: класс Number в файле number.py, реализующий
метод перегрузки операции создания экземпляра (__init__), а также метод
реализации операции вычитания (__sub__). Специальные методы,
такие как эти, позволяют перехватывать и выполнять встроенные операции:
"""


class Number:
    def __init__(self, start):  # Вызов Number(start)
        self.data = start

    def __sub__(self, other):  # Выражение: экземпляр - other
        return Number(self.data - other)  # Результат – новый экземпляр


X = Number(5)  # Number.__init__(X, 5)
Y = X - 2  # Number.__sub__(X, 2)
print(Y.data)  # Y - новый экземпляр класса Number

"""
 Как уже обсуждалось ранее, конструктор __init__, присутствующий в этом
примере, – это наиболее часто используемый метод перегрузки операторов
в языке Python, потому что он присутствует в большинстве классов. 
В этой главе мы изучим некоторые другие инструменты, связанные 
с перегрузкой, и рассмотрим наиболее типичные примеры их использования.


 Общие методы перегрузки операторов
 
 Почти все, что можно делать с объектами встроенных типов, такими как 
целые числа и списки, можно реализовать и в классах – с помощью 
специальных методов перегрузки операторов. В табл. 29.1 перечислены 
наиболее часто используемые, но на самом деле их намного больше. 
В действительности многие методы перегрузки существуют в нескольких 
версиях (например, __add__, __radd__ и __iadd__ для операции сложения),
и в этом заключается основная причина такого большого их количества. 
Исчерпывающий список имен специальных методов вы найдете
в других книгах, посвященных языку Python, и в справочных руководствах.

  Метод             Перегружает          Вызывается
  __init__          Конструктор          При создании объекта:
                                         X = Class(args)
                                         
  __del__           Деструктор           При уничтожении объекта
  
  __add__           Оператор +           X + Y, X += Y,
                                         если отсутствует метод __iadd__
                                         
  __or__            Оператор |           X | Y, X |= Y,
                    (побитовое ИЛИ)      если отсутствует метод __ior__

  __repr__,         Вывод,               print(X), repr(X), str(X)
  __str__           преобразование

  __call__          Вызовы функции       X(*args, **kargs)
  
  __getattr__       Обращение к атрибуту X.undefined
  
  __setattr__       Присваивание         X.any = value
                    атрибуту

  __delattr__       Удаление атрибута    del X.any
  
  __getattribute__  Обращение к атрибуту X.any
  
  __getitem__       Доступ к элементу    X[key], X[i:j], циклы for 
                    по индексу,          и другие конструкции итерации, 
                    извлечение среза,    при отсутствии метода __iter__
                    итерации

  __setitem__       Присваивание         X[key] = value, 
                    элементу по индексу  X[i:j] = sequence
                    или срезу

  __delitem__       Удаление элемента    del X[key], del X[i:j]
                    по индексу 
                    или среза
                    
  __len__           Длина                len(X), проверка истинности, 
                                         если отсутствует метод __bool__
                                         
  __bool__          Проверка логического bool(X), проверка истинности 
                    значения             (в версии 2.6 называется
                                         __nonzero__)
                                         
  __lt__, __gt__,   Сравнивание          X < Y, X > Y, X <= Y, X >= Y,
  __le__, __ge__,                        X == Y, X != Y (или __cmp__, 
  __eq__, __ne__                         но только в 2.6)

  __radd__          Правосторонний       Не_экземпляр + X
                    оператор +

  __iadd__          Добавление           X += Y (в ином случае __add__)
                    (увеличение)

  __iter__,         Итерационный         I=iter(X), next(I); циклы for,
  __next__          контекст             оператор in (если не определен 
                                         метод __contains__), 
                                         все типы генераторов, map(F, X)
                                         и другие (в версии 2.6 
                                         метод __next__ называется 
                                         next))
                                         
  __contains__     Проверка              item in X (где X – любой 
                   на вхождение          итерируемый объект)

  __index__        Целое число           hex(X), bin(X), oct(X), O[X], 
                                         O[X:] (замещает методы __oct__,
                                         __hex__ в Python 2)
                                         
  __enter__,       Менеджеры контекстов  with obj as var:
  __exit__         (глава 33)

  __get__,         Дескрипторы           X.attr, X.attr = value, 
  __set__,         атрибутов (глава 37)  del X.attr
  __delete__

  __new__          Создание (глава 39)   Вызывается при создании
                                         объектов, перед вызовом
                                         метода __init__
                                         
 Все методы перегрузки имеют имена, начинающиеся и заканчивающиеся двумя
символами подчеркивания, что отличает их от других имен, которые вы
обычно определяете в своих классах. Отображение операторов выражений
или операций на методы со специальными именами предопределяется 
языком Python (и описывается в стандартном руководстве по языку). 
Например, по определению языка оператор + всегда отображается 
на имя __add__ независимо от того, что в действительности делает
метод __add__.

 Методы перегрузки операторов могут наследоваться от супер-классов,
если они отсутствуют в самом классе, как и любые другие методы.
Кроме того, методы перегрузки операторов являются необязательными – если
какой-то метод не реализован, это лишь означает, что соответствующая ему
операция не поддерживается классом, а при попытке применить 
такую операцию возбуждается исключение. Некоторые встроенные операции,
такие как вывод, имеют реализацию по умолчанию (в Python 3.0
они наследуются от класса object, являющегося супер-классом для всех
объектов), но большинство операций будут вызывать исключение, 
если класс не предусматривает реализацию соответствующего метода.

 Большинство методов перегрузки операторов используются только 
при решении специальных задач, когда необходимо, чтобы объекты 
имитировали поведение встроенных типов, однако конструктор __init__
присутствует в большинстве классов, поэтому мы уделим ему особое 
внимание. Мы уже познакомились с конструктором __init__, который
вызывается на этапе инициализации, и с несколькими другими, 
перечисленными в табл. 29.1. Теперь мы исследуем примеры использования 
некоторых других методов из таблицы.


 Доступ к элементам по индексу и извлечение срезов: 
__getitem__ и __setitem__                      

 Если метод __getitem__ присутствует в определении класса 
(или наследуется им), он автоматически будет вызываться интерпретатором
в случае применения операций индексирования к экземплярам. 
Когда экземпляр X появляется в выражении извлечения элемента по индексу, 
таком как X[i], интерпретатор Python вызывает метод __getitem__,
наследуемый этим экземпляром, передавая методу объект X в первом 
аргументе и индекс, указанный в квадратных скобках, во втором аргументе. 
Например, следующий класс возвращает квадрат значения индекса:

>>> class Indexer:
...     def __getitem__(self, index): 
            return index ** 2
...
>>> X = Indexer()
>>> X[2]  # Выражение X[i] вызывает X.__getitem__(i)
4
>>> for i in range(5):
...     print(X[i], end=’ ‘) 
        # Вызывает __getitem__(X, i) в каждой итерации
...
0 1 4 9 16    


 Извлечение срезов
 
 Интересно отметить, что метод __getitem__ вызывается не только 
при выполнении операции обращения к элементу по индексу, 
но и при извлечении срезов. Формально, встроенные типы обрабатывают 
операцию извлечения среза одинаково. Ниже приводится пример применения
операции извлечения среза к списку, при этом используются верхняя
и нижняя границы среза, а также шаг (подробно операция извлечения среза 
рассматривается в главе 7):

>>> L = [5, 6, 7, 8, 9]
>>> L[2:4]  # Извлечение среза с использованием синтаксиса срезов
[7, 8]
>>> L[1:]
[6, 7, 8, 9]
>>> L[:-1]
[5, 6, 7, 8]
>>> L[::2]
[5, 7, 9]

 Однако в действительности параметры среза определяются с помощью
объекта среза, который и передается реализации операции индексирования 
списка. Фактически вы всегда можете передать объект среза вручную –
синтаксис срезов в значительной степени является всего лишь 
синтаксическим подсластителем для операции индексирования с применением
объекта среза:

>>> L[slice(2, 4)]  # Извлечение среза с помощью объекта среза
[7, 8]
>>> L[slice(1, None)]
[6, 7, 8, 9]
>>> L[slice(None, -1)]
[5, 6, 7, 8]
>>> L[slice(None, None, 2)]
[5, 7, 9]

 Эта особенность имеет значение для классов, реализующих метод
__getitem__, – этот метод будет вызываться и для выполнения операций 
обращения к элементам по индексам (с целочисленным индексом),
и для выполнения операций извлечения срезов (с объектом среза).
Наш класс в предыдущем примере не способен обрабатывать операцию
извлечения среза, потому что его логика принимает лишь целочисленные 
индексы, однако такую возможность поддерживает следующий класс. 
Когда метод вызывается для выполнения операции обращения к элементу
по индексу, в аргументе передается целое число, как и прежде:

>>> class Indexer:
...     data = [5, 6, 7, 8, 9]
...     def __getitem__(self, index):  # Вызывается при индексировании
...         print(‘getitem:’, index)  # или извлечении среза
...         return self.data[index]  # Выполняет индексирование
...         # или извлекает срез


>>> X = Indexer()
>>> X[0]  # При индексировании __getitem__
getitem: 0  # получает целое число
5
>>> X[1]
getitem: 1
6
>>> X[-1]
getitem: -1
9

 Однако, когда метод вызывается для извлечения среза, он получает объект 
среза, который просто передается списку, встроенному в класс Indexer,
в виде выражения обращения по индексу:

>>> X[2:4]  # При извлечении среза __getitem__ получает объект среза
getitem: slice(2, 4, None)
[7, 8]
>>> X[1:]
getitem: slice(1, None, None)
[6, 7, 8, 9]
>>> X[:-1]
getitem: slice(None, -1, None)
[5, 6, 7, 8]
>>> X[::2]
getitem: slice(None, None, 2)
[5, 7, 9]

 Метод __setitem__ присваивания элементу по индексу точно так же 
обслуживает обе операции – присваивания элементу по индексу 
и присваивание срезу. В последнем случае он получает объект среза, 
который может передаваться другим операциям присваивания по индексу:

def __setitem__(self, index, value):  # Реализует присваивание
... # по индексу или по срезу
    self.data[index] = value  # Приcваивание по индексу или по срезу
    
 Фактически метод __getitem__ может автоматически вызываться не только 
при выполнении операций индексирования или извлечения срезов, 
как описывается в следующем разделе.


 Извлечение срезов и элементов по индексу в Python 2.6
 
 До появления Python 3.0 в классах можно было также определять методы 
__getslice__ и __setslice__, предназначенные для выполнения операций 
извлечения среза и присваивания срезу, – они получали границы среза 
и были предпочтительными способами реализации операций над срезами
перед __getitem__ и __setitem__.

 версии 3.0 эти методы перегрузки операций над срезами были удалены, 
поэтому теперь для реализации обоих типов операций, с индексами
и со срезами, должны использоваться методы __getitem__ и __setitem__,
которые должны принимать в качестве аргументов не только целочисленные 
индексы, но и объекты срезов. В большинстве классов для этого
не придется прибегать к каким-либо специальным приемам, потому что
внутри этих методов допускается подставлять объекты срезов в квадратных 
скобках внутри других выражений с операцией индексирования 
(как в нашем примере). Еще один пример реализации операций над срезами 
вы найдете в разделе «Проверка на вхождение: __contains__, __iter__ 
и __getitem__».

 Кроме того, не следует считать, что (возможно, неудачно названный)
метод __index__ в Python 3.0 имеет отношение к операции индексирования,
– этот метод возвращает целое число, представляющее экземпляр, 
и используется встроенными типами, которые выполняют преобразование 
целых чисел в строку цифр:

>>> class C:
...     def __index__(self):
...         return 255
...
>>> X = C()
>>> hex(X)  # Целочисленное значение
‘0xff’
>>> bin(X)
‘0b11111111’
>>> oct(X)
‘0o377’

 Хотя этот метод не имеет отношения к реализации операции 
индексирования, как метод __getitem__, тем не менее он также 
используется в операциях, требующих целое число, включая и операции
индексирования:

>>> (‘C’ * 256)[255]
‘C’
>>> (‘C’ * 256)[X]  # X используется как индекс (не X[i])
‘C’
>>> (‘C’ * 256)[X:]  # X используется как индекс (не X[i:])
‘C’

 В Python 2.6 этот метод действует точно так же, за исключением того,
что он не вызывается встроенными функциями hex и oct
(вместо этого в версии 2.6 данные функции используют методы перегрузки 
операторов __hex__ и __oct__).


 Итерации по индексам: __getitem__
 
 Здесь описывается прием, который не всегда очевиден для начинающих
программистов, но на практике может оказаться необычайно полезным.
Инструкция for многократно применяет операцию индексирования 
к последовательности, используя индексы от нуля и выше, пока не будет 
получено исключение выхода за границы. Благодаря этому метод __getitem__
представляет собой один из способов перегрузки итераций в языке Python – 
если этот метод реализован, инструкции циклов for будут вызывать его 
на каждом шаге цикла, с постоянно увеличивающимся значением смещения.
Это один из случаев, когда «купив один предмет, другой получаешь
в подарок», – любой встроенный или определяемый пользователем объект, 
к которому применима операция индексирования, также может участвовать
в итерациях:
"""


class stepper:
    def __getitem__(self, i):
        return self.data[i]


X = stepper()  # X - это экземпляр класса stepper
X.data = 'Spam'

print(X[1])  # Индексирование, вызывается __getitem__

for item in X:  # Циклы for вызывают __getitem__
    print(item, end=' ')  # Инструкция for индексирует элементы 0...N

"""
 Фактически это случай, когда, «купив один предмет, в подарок получаешь
целую связку». Любой класс, поддерживающий циклы for, автоматически
поддерживает все итерационные контексты, имеющиеся в языке Python, 
многие из которых мы видели в более ранних главах (другие итерационные
контексты описываются в главе 14). Например, оператор проверки 
на принадлежность in, генераторы списков, встроенная функция map, 
присваивание списков и кортежей и конструкторы типов также автоматически
вызывают метод __getitem__, если он определен:
"""

print('p' in X)  # Во всех этих случаях вызывается __getitem__

print([c for c in X])  # Генератор списков

print(list(map(str.upper, X)))  # Функция map (в версии 3.0
#                                 требуется использовать функцию list)
(a, b, c, d) = X  # Присваивание последовательностей
print(a, c, d)

print(list(X), tuple(X), ''.join(X))

print(X)

"""
 На практике этот прием может использоваться для создания объектов, 
которые реализуют интерфейс последовательностей, и для добавления логики
к операциям над встроенными типами – мы рассмотрим эту идею, когда будем
расширять встроенные типы в главе 31.


 Итераторы: __iter__ и __next__
 
 Прием, основанный на использовании метода __getitem__, представленный
в предыдущем разделе, действительно работает, однако он используется
операциями, выполняющими итерации, в самом крайнем случае. В настоящее
время все итерационные контексты в языке Python пытаются сначала
использовать метод __iter__, и только потом – метод __getitem__.
То есть при выполнении обхода элементов объекта предпочтение отдается
итерационному протоколу, с которым мы познакомились в главе 14, – если 
итерационный протокол не поддерживается объектом, вместо него 
используется операция индексирования. Вообще говоря, вы также должны 
отдавать предпочтение методу __iter__ – он обеспечивает более
оптимальную поддержку итерационных контекстов, чем метод __getitem__.

 С технической точки зрения итерационные контексты вызывают встроенную
функцию iter, чтобы определить наличие метода __iter__, который должен 
возвращать объект итератора. Если он предоставляется, то интерпретатор 
Python будет вызывать метод __next__ объекта итератора для получения
элементов до тех пор, пока не будет возбуждено исключение StopIteration.
Если метод __iter__ отсутствует, интерпретатор переходит 
на использование схемы с применением метода __getitem__ и начинает
извлекать элементы по индексам, пока не будет возбуждено исключение
IndexError. Кроме того, для удобства предоставляется встроенная функция
next, позволяющая выполнять итерации вручную: вызов next(I) – 
это то же самое, что вызов I.__next__().


 Итераторы, определяемые пользователями
 
 В схеме с применением метода __iter__ классы реализуют итераторы 
простой реализацией итерационного протокола, представленного 
в главах 14 и 20 (за дополнительной информацией об итераторах
возвращайтесь к этим главам). Например, в следующем файле iters.py
определяется класс итератора, который возвращает квадраты чисел:
"""


class Squares:
    def __init__(self, start, stop):  # Сохранить состояние при создании
        self.value = start - 1
        self.stop = stop

    def __iter__(self):  # Возвращает итератор в iter()
        return self

    def __next__(self):  # Возвращает квадрат в каждой итерации
        if self.value == self.stop:  # Также вызывается функцией next
            raise StopIteration
        self.value += 1
        return self.value ** 2


for i in Squares(1, 5):  # for вызывает iter(),
    #                      который вызывает __iter__()
    print(i, end=' ')  # на каждой итерации вызывается __next__()

"""
 Здесь объект итератора – это просто экземпляр self, поэтому
метод __next__ является частью этого класса. В более сложных ситуациях
объект итератора может быть определен как отдельный класс и объект
со своей собственной информацией о состоянии, с целью поддержки 
нескольких активных итераций на одних и тех же данных (совсем скоро мы 
рассмотрим это на примере). Об окончании итераций интерпретатору 
сообщается с помощью инструкции raise (подробнее о возбуждении 
исключений рассказывается в следующей части книги). Итерации 
по встроенным типам можно также выполнять вручную:
"""

X = Squares(1, 5)  # Выполнение итераций вручную: эти действия выполняет
# инструкция цикла
I = iter(X)  # iter вызовет __iter__
print(next(I))  # next вызовет __next__
print(next(I))
print(next(I))
print(next(I))
print(next(I))
try:
    print(next(I))  # Исключение можно перехватить
    #                 с помощью инструкции try
except StopIteration:
    pass

"""
 Эквивалентная реализация с использованием __getitem__ может оказаться 
менее естественной, потому что цикл for явно выполняет перебор всех 
смещений от нуля и выше; смещения, передаваемые методу, могут оказаться
связаны с диапазоном воспроизводимых значений лишь косвенно 
(диапазон 0..N может потребоваться отображать на диапазон start..stop).
Поскольку объекты, возвращаемые методом __iter__, явно манипулируют 
информацией о своем состоянии и сохраняют ее между вызовами функции
next, такая реализация может быть более универсальной, чем использование
метода __getitem__.

 C другой стороны, итераторы, реализованные на основе метода __iter__, 
иногда могут оказаться более сложными и менее удобными, 
чем метод __getitem__. Но они действительно предназначены для итераций,
а не для случайной индексации, – фактически они вообще не перегружают
операцию индексирования:

>>> X = Squares(1, 5)
>>> X[1]
AttributeError: Squares instance has no attribute ‘__getitem__’
(AttributeError: экземпляр Squares не имеет атрибута ‘__getitem__’)

 Схема на основе метода __iter__ реализована также во всех остальных
итерационных контекстах, к которым применим метод __getitem__ (проверка 
на вхождение, конструкторы, присваивание последовательностей
и так далее). Однако, в отличие от __getitem__, схема на основе метода 
__iter__ предназначена для выполнения обхода элементов один раз,
а не несколько. Например, элементы класса Squares можно обойти всего 
один раз – для каждой последующей итерации необходимо будет создавать
новый объект итератора:
"""

X = Squares(1, 5)
print([n for n in X])  # Получить все элементы

print([n for n in X])  # Теперь объект пуст

print([n for n in Squares(1, 5)])  # Создать новый объект итератора

print(list(Squares(1, 3)))

"""
 Примечательно, что этот пример можно было бы реализовать проще, 
применив функции-генераторы (которые имеют отношение к итераторам 
и были представлены в главе 20):

>>> def gsquares(start, stop):
...     for i in range(start, stop+1):
...         yield i ** 2
...
>>> for i in gsquares(1, 5): # или: (x ** 2 for x in range(1, 5))
...     print(i, end=’ ‘)
...
1 4 9 16 25

 В отличие от класса, функция автоматически сохраняет информацию о своем
состоянии между итерациями. Конечно, для реализации такого
искусственного примера можно было бы вообще не использовать ни один 
из этих приемов, а просто использовать цикл for, функцию map 
или генератор списков, чтобы создать сразу весь список. Нередко самый
лучший и самый быстрый способ в языке Python оказывается еще и
самым простым:

>>> [x ** 2 for x in range(1, 6)]
[1, 4, 9, 16, 25]

 Однако реализация на базе классов может оказаться лучше 
при моделировании более сложных итераций, особенно когда возможность 
сохранения информации о состоянии и наследование могут принести 
существенную выгоду. Один из таких случаев исследуется
в следующем разделе.


 Несколько итераторов в одном объекте
 
 Ранее я упоминал, что объект итератора может быть определен 
как отдельный класс, со своей собственной информацией о состоянии, 
что обеспечивает поддержку протекания нескольких итерационных процессов
с одним и тем же набором данных. Посмотрим, что происходит 
при выполнении обхода элементов встроенных типов, таких как строка:

>>> S = ‘ace’
>>> for x in S:
...     for y in S:
...         print(x + y, end=’ ‘)
...
aa ac ae ca cc ce ea ec ee

 Здесь внешний цикл получает итератор строки вызовом функции iter 
и каждый вложенный цикл делает то же самое, чтобы получить независимый
итератор. Так как каждый итератор хранит свою собственную информацию 
о состоянии, каждый цикл управляет своим собственным положением
в строке, независимо от любых других активных циклов.

 В главах 14 и 20 мы видели похожие примеры. Например, 
функции-генераторы и выражения-генераторы, а также встроенные функции,
такие как map и zip, возвращают итераторы однократного применения.
Напротив, встроенная функция range и другие встроенные типы, 
такие как списки, поддерживают возможность создания множества
независимых итераторов.

 При создании собственных итераторов мы можем выбирать между поддержкой 
единственного итератора или множества независимых итераторов. 
Чтобы обеспечить поддержку множества независимых итераторов,
метод __iter__ должен не просто возвращать аргумент self, а создавать 
новый объект итератора со своей информацией о состоянии.

 Например, в следующем примере определяется класс итератора, 
который пропускает каждый второй элемент. Поскольку объект итератора
создается заново для каждой итерации, он обеспечивает поддержку 
нескольких активных циклов одновременно:
"""


class SkipIterator:
    def __init__(self, wrapped):
        self.wrapped = wrapped  # Информация о состоянии
        self.offset = 0

    def __next__(self):
        if self.offset >= len(self.wrapped):  # Завершить итерации
            raise StopIteration
        else:
            item = self.wrapped[self.offset]
            # Иначе перешагнуть и вернуть
            self.offset += 2
            return item


class SkipObject:
    def __init__(self, wrapped):  # Сохранить используемый элемент
        self.wrapped = wrapped

    def __iter__(self):
        return SkipIterator(self.wrapped)  # Каждый раз новый итератор


if __name__ == '__main__':
    alpha = 'abcdef'
    skipper = SkipObject(alpha)  # Создать объект-контейнер
    I = iter(skipper)  # Создать итератор для него
    print(next(I), next(I), next(I))  # Обойти элементы 0, 2, 4

    for x in skipper:  # for вызывает __iter__ автоматически
        for y in skipper:  # Вложенные циклы for также вызывают __iter__
            print(x + y, end=' ')
            # Каждый итератор помнит свое состояние, смещение

"""
 Этот пример работает подобно вложенным циклам с обычными строками –
каждый активный цикл запоминает свое положение в строке,
потому что каждый из них получает независимый объект итератора, 
который хранит свою собственную информацию о состоянии:

% python skipper.py
a c e
aa ac ae ca cc ce ea ec 

 Наш более ранний пример класса Squares, напротив, поддерживал 
всего одну активную итерацию, нужно было во вложенных циклах вызывать 
Squares снова, чтобы получить новый объект. Здесь у нас имеется 
единственный объект SkipObject, который создает множество объектов
итераторов.

 Как и прежде, подобных результатов можно было бы достичь 
с использованием встроенных инструментов, например с помощью операции 
получения среза с третьим граничным значением, чтобы организовать 
пропуск элементов:
"""

S = 'abcdef'
for x in S[::2]:
    for y in S[::2]:  # Новые объекты в каждой итерации
        print(x + y, end=' ')

"""
 Однако это далеко не то же самое по двум причинам. Во-первых, каждое 
выражение извлечения среза физически сохраняет весь список
с результатами в памяти, тогда как итераторы воспроизводят по одному
значению за раз, что позволяет существенно экономить память в случае
большого объема результатов. Во-вторых, операции извлечения среза 
создают новые объекты, поэтому в действительности итерации не протекают 
одновременно в одном и том же объекте. Чтобы оказаться ближе 
к реализации на основе классов, нам необходимо было бы создать 
единственный объект для обхода, заранее выполнив операцию извлечения
среза:

>>> S = ‘abcdef’
>>> S = S[::2]
>>> S
‘ace’
>>> for x in S:
...     for y in S:  # Тот же самый объект, новые итераторы
...         print(x + y, end=’ ‘)
...
aa ac ae ca cc ce ea ec ee

 Эта реализация больше похожа на наше решение, выполненное с помощью
классов, но здесь по-прежнему список с результатами целиком хранится 
в памяти (на сегодняшний день не существует генераторов, способных 
формировать срезы), и эта реализация эквивалентна только для данного 
конкретного случая пропуска каждого второго элемента.

 Итераторы могут выполнять любые действия, которые можно реализовать
в классах, поэтому они обладают более широкими возможностями, 
чем предполагается в данном примере. Независимо от того, требуется ли 
такая широта возможностей в наших приложениях, итераторы, определяемые
пользователем, представляют собой мощный инструмент – они позволяют
создавать произвольные объекты, которые выглядят и ведут себя подобно 
другим последовательностям и итерируемым объектам, с которыми 
мы встречались в этой книге. Мы могли бы использовать этот механизм, 
например, для создания объекта базы данных, чтобы одновременно выполнять
несколько итераций в одном и том же наборе данных, извлеченном 
в результате запроса к базе данных.


 Проверка на вхождение: __contains__, __iter__ и __getitem__

 Область применения итераций значительно шире, чем мы могли видеть 
до сих пор. Перегрузка операторов нередко образует многослойную 
архитектуру: классы могут предоставлять реализацию специфических методов 
или обобщенные альтернативы, используемые в крайнем случае. Например:

  Операции сравнения в Python 2.6 используют специальные методы, такие
 как __lt__, если они присутствуют, или более обобщенный метод __cmp__.
 В Python 3.0 используются только специализированные методы, а метод
 __cmp__ не используется, как уже объяснялось в этой главе.

  Операция проверки логического значения также сначала пытается вызвать
 специализированный метод __bool__ (возвращающий явное значение True
 или False), а в случае его отсутствия вызывает более обобщенный метод
 __len__ (ненулевое возвращаемое значение интерпретируется как True). 
 Как будет показано ниже в этой главе, интерпретатор версии 2.6 
 действует точно так же, но вместо метода __bool__ использует метод
 __nonzero__.

 Что касается итераций, обычно классы реализуют поддержку оператора in 
проверки на вхождение с помощью итераций – либо в виде метода __iter__, 
либо __getitem__. Однако классы могут обеспечить более 
специализированную поддержку операции проверки на членство, реализовав
метод __contains__, – этот метод имеет преимущество перед методом 
__iter__, который в свою очередь пользуется преимуществом перед методом
__getitem__. В случае отображений метод __contains__ должен определять
членство, применяя ключи (и может использовать быструю операцию поиска), 
а в случае последовательностей – производить поиск.

 Рассмотрим следующий пример класса, который реализует все три метода,
и выполним проверку на вхождение, а также попробуем использовать 
экземпляр этого класса в различных итерационных контекстах. Его методы 
выводят сообщения при вызове, позволяющие отслеживать ход выполнения 
операций:
"""


class Iters:
    def __init__(self, value):
        self.data = value

    def __getitem__(self, i):  # Крайний случай для итераций
        print('get[%s]:' % i,
              end='')  # А также для индексирования и срезов
        return self.data[i]

    def __iter__(self):  # Предпочтительный для итераций
        print('iter=> ', end='')  # Возможен только 1 активный итератор
        self.ix = 0
        return self

    def __next__(self):
        print('next:', end='')
        if self.ix == len(self.data):
            raise StopIteration
        
        item = self.data[self.ix]
        self.ix += 1
        return item

    def __contains__(self, x):  # Предпочтительный для оператора ‘in’
        print('contains: ', end='')
        return x in self.data


X = Iters([1, 2, 3, 4, 5])  # Создать экземпляр
print(3 in X)  # Проверка на вхождение
for i in X:  # Циклы
    print(i, end=' | ')

print()
print([i ** 2 for i in X])  # Другие итерационные контексты
print(list(map(bin, X)))
I = iter(X)  # Обход вручную (именно так действуют
while True:  # другие итерационные контексты)
    try:
        print(next(I), end=' @ ')
    except StopIteration:
        break

"""
 Если запустить этот сценарий, произойдет следующее: специализированный
метод __contains__ будет вызван операцией проверки на вхождение, 
обобщенный метод __iter__ будет вызываться в контексте итераций, 
в ходе которых многократно вызывается метод __next__, 
а метод __getitem__ не будет вызван ни разу:

contains: True
iter=> next:1 | next:2 | next:3 | next:4 | next:5 | next:
iter=> next:next:next:next:next:next:[1, 4, 9, 16, 25]
iter=> next:next:next:next:next:next:[‘0b1’, ‘0b10’, ‘0b11’,
                                      ‘0b100’, ‘0b101’]
iter=> next:1 @ next:2 @ next:3 @ next:4 @ next:5 @ next:

Но взгляните, что произойдет, если мы закомментируем метод __contains__,
– теперь операция проверки на вхождение будет использовать обобщенный 
метод __iter__:

iter=> next:next:next:True
iter=> next:1 | next:2 | next:3 | next:4 | next:5 | next:
iter=> next:next:next:next:next:next:[1, 4, 9, 16, 25]
iter=> next:next:next:next:next:next:[‘0b1’, ‘0b10’, ‘0b11’, 
                                      ‘0b100’, ‘0b101’]
iter=> next:1 @ next:2 @ next:3 @ next:4 @ next:5 @ next:

 И наконец, ниже приводятся результаты работы сценария, 
когда оба метода, __contains__ и __iter__, были закомментированы, –
при проверке на вхождение и в других итерационных контекстах 
используется метод __getitem__, которому последовательно передаются
индексы в порядке возрастания:

get[0]:get[1]:get[2]:True
get[0]:1 | get[1]:2 | get[2]:3 | get[3]:4 | get[4]:5 | get[5]:
get[0]:get[1]:get[2]:get[3]:get[4]:get[5]:[1, 4, 9, 16, 25]
get[0]:get[1]:get[2]:get[3]:get[4]:get[5]:[‘0b1’, ‘0b10’, ‘0b11’, 
                                           ‘0b100’,’0b101’]
get[0]:1 @ get[1]:2 @ get[2]:3 @ get[3]:4 @ get[4]:5 @ get[5]:

 Как видите, метод __getitem__ является еще более обобщенным: 
помимо итераций он также используется операциями индексирования 
и извлечения срезов. При выполнении операции извлечения среза методу
__getitem__ передается объект, содержащий параметры среза, как в случае
встроенных типов, так и в случае пользовательских классов, 
благодаря этому наш класс автоматически поддерживает операцию
извлечения среза:

>>> X = Iters(‘spam’)  # Индексирование
>>> X[0]  # __getitem__(0)
get[0]:’s’
>>> ‘spam’[1:]  # Извлечение среза
‘pam’
>>> ‘spam’[slice(1, None)]  # Объект среза
‘pam’
>>> X[1:]  # __getitem__(slice(..))
get[slice(1, None, None)]:’pam’
>>> X[:-1]
get[slice(None, -1, None)]:’spa’

 В более реалистичных случаях использования итераций, когда класс 
не является последовательностью, реализация метода __iter__ 
может оказаться еще проще, потому что в этом случае нет необходимости
управлять целочисленными индексами, а метод __contains__ позволяет
реализовать более оптимальный способ проверки на вхождение.
"""

"""
 Дополнительные возможности классов


 Расширение встроенных типов

 Помимо реализации объектов новых типов, классы иногда используются
для расширения функциональных возможностей встроенных типов языка
Python, с целью обеспечения поддержки более экзотических
структур данных. Например, чтобы добавить в списки дополнительные методы
вставки и удаления, можно создать класс, который обертывает (встраивает)
объект списка и экспортирует методы вставки и удаления, которые особым
образом обрабатывают список, подобно тому, как реализуется прием
делегирования, рассмотренный в главе 30. Начиная с версии Python 2.2,
для специализации встроенных типов можно также использовать
наследование. Следующие два раздела демонстрируют оба приема в действии.


 Расширение типов встраиванием

 Помните те функции для работы со множествами, которые мы написали
в главах 16 и 18? Ниже показано, как они выглядят, реанимированные
в виде класса на языке Python. Следующий пример (файл setwrapper.py)
реализует новый тип объектов за счет перемещения нескольких функций
в методы и добавления перегрузки нескольких основных операторов.
По большей части этот класс просто обертывает список, добавляя
дополнительные операции. Поскольку это класс, он также поддерживает
возможность создания множества экземпляров и адаптацию своего поведения
наследованием в подклассах. Использование классов вместо функций
позволяет создавать множество независимых объектов с предопределенными
наборами данных и поведением, а не передавать списки в функции вручную:
"""


class Set:
    def __init__(self, value=[]):  # Конструктор
        self.data = []  # Управляет списком
        self.concat(value)

    def intersect(self, other):  # other – любая последовательность
        res = [x for x in self.data if x in other]
        # self – подразумеваемый объект. Выбрать общие элементы
        return Set(res)  # Вернуть новый экземпляр Set

    def union(self, other):  # other – любая последовательность
        res = self.data[:]  # Копировать список
        res += [x for x in other if x not in res]  # Добавить элементы
        #                                            из other
        return Set(res)

    def concat(self, value):  # Аргумент value: список, Set...
        self.data += [x for x in value if x not in self.data]  # Удалить
        #                                                      дубликаты

    def __len__(self):
        return len(self.data)  # len(self)

    def __getitem__(self, key):
        return self.data[key]  # self[i]

    def __and__(self, other):
        return self.intersect(other)  # self & other

    def __or__(self, other):
        return self.union(other)  # self | other

    def __repr__(self):
        return 'Set:' + repr(self.data)  # Вывод


"""
 Используется этот класс как обычно – после создания экземпляра мы можем
вызывать его методы и выполнять поддерживаемые операции:
"""

x = Set([1, 3, 5, 7])
print(x.union(Set([1, 4, 7])))  # Выведет: Set:[1, 3, 5, 7, 4]
print(x | Set([1, 4, 6]))  # Выведет: Set:[1, 3, 5, 7, 4, 6]

"""
 Расширение типов наследованием
 
 Начиная с версии Python 2.2 все встроенные типы данных можно 
наследовать. Функции преобразования типов, такие как list, str, dict 
и tuple, превратились в имена встроенных типов. Теперь вызов функции 
преобразования типа (например, list(‘spam’)) в действительности является 
вызовом конструктора типа. Это изменение позволяет адаптировать 
или расширять поведение встроенных типов с помощью инструкций class: 
достаточно просто создать подклассы с новыми именами типов, 
где реализовать необходимые изменения. Экземпляры такого нового 
подкласса могут использоваться везде, где допускается использовать
оригинальный встроенный тип. Например, предположим, вас не устраивает
тот факт, что стандартные списки начинают отсчет элементов с 0, 
а не с 1. Это не проблема – вы всегда можете создать свой подкласс,
который изменит эту характерную особенность списков. 
В файле typesubclass.py показано, как это делается:
"""


# Подкласс встроенного типа/класса list.
# Отображает диапазон 1..N на 0..N-1; вызывает встроенную версию.
class MyList(list):
    def __getitem__(self, offset):
        print('(indexing %s at %s)' % (self, offset))
        return list.__getitem__(self, offset - 1)


if __name__ == '__main__':
    print(list('abc'))
    x = MyList('abc')  # __init__ наследуется из списка
    print(x)  # __repr__ наследуется из списка
    print(x[1])  # MyList.__getitem__
    print(x[3])  # Изменяет поведение метода супер-класса

    x.append('spam')
    print(x)  # Атрибуты, унаследованные от супер-класса list

    x.reverse()
    print(x)

"""
 В этом файле подкласс MyList расширяет метод __getitem__ встроенных 
списков простым отображением диапазона значений от 1 до N на необходимый
спискам диапазон от 0 до N-1. Уменьшение индекса на единицу и вызов 
версии метода из супер-класса – вот все, что в действительности
делается, но этого вполне достаточно для достижения поставленной цели:

% python typesubclass.py
[‘a’, ‘b’, ‘c’]
[‘a’, ‘b’, ‘c’]
(indexing [‘a’, ‘b’, ‘c’] at 1)
a
(indexing [‘a’, ‘b’, ‘c’] at 3)
c
[‘a’, ‘b’, ‘c’, ‘spam’]
[‘spam’, ‘c’, ‘b’, ‘a’]

 В эти результаты включен текст, который выводит метод класса 
при выполнении индексирования. Является ли изменение способа
индексирования универсально хорошей идеей, это уже другой вопрос: 
пользователи вашего класса MyList могут быть повергнуты в недоумение 
таким отступлением от общепринятого поведения последовательностей 
в языке Python. Однако возможность адаптировать встроенные типы подобным
образом может оказаться мощным инструментом.

 Например, такой шаблон порождает альтернативный способ реализации
множества – в виде подкласса встроенного списка, а не в виде 
самостоятельного класса, который управляет встроенным в него объектом 
списка. Как мы узнали в главе 5, в настоящее время язык Python не только
обладает мощным встроенным объектом множества, но и позволяет определять
новые множества с использованием синтаксиса литералов и генераторов
множеств. Тем не менее попытка реализовать собственный класс множеств
является отличным способом изучить особенности наследования типов 
вообще.

 Следующий пример реализации класса в файле setsubclass.py адаптирует 
списки, добавляя методы и операторы, используемые для работы 
с множествами. Все остальное поведение наследуется от встроенного
супер-класса list, поэтому альтернатива получилась более короткой
и простой:
"""


class Set(list):
    def __init__(self, value=[]):  # Конструктор
        list.__init__([])  # Адаптирует список
        self.concat(
            value)  # Копировать изменяемый аргумент по умолчанию

    def intersect(self, other):  # other – любая последовательность
        res = [x for x in self if x in other]
        # self – подразумеваемый объект. Выбрать общие элементы
        return Set(res)  # Вернуть новый экземпляр Set

    def union(self, other):  # other – любая последовательность
        res = Set(self)  # Копировать меня и мой список
        res.concat(other)
        return res

    def concat(self, value):  # аргумент value: list, Set...
        self += [x for x in value if x not in self]  # Удалить дубликаты

    def __and__(self, other):
        return self.intersect(other)

    def __or__(self, other):
        return self.union(other)

    def __repr__(self):
        return 'Set:' + list.__repr__(self)


if __name__ == '__main__':
    x = Set([1, 3, 5, 7])
    y = Set([2, 1, 4, 5, 6])
    print(x, y, len(x))
    print(x.intersect(y), y.union(x))
    print(x & y, x | y)
    x.reverse()
    print(x)


"""
 Ниже приводится вывод, полученный в результате выполнения кода 
самопроверки, находящегося в конце файла. Поскольку проблема 
наследования встроенных типов достаточно сложна, я опущу дальнейшие 
подробности, на предлагаю внимательно посмотреть на полученные 
результаты, чтобы изучить поведение подкласса:

% python setsubclass.py
Set:[1, 3, 5, 7] Set:[2, 1, 4, 5, 6] 4
Set:[1, 5] Set:[2, 1, 4, 5, 6, 3, 7]
Set:[1, 5] Set:[1, 3, 5, 7, 2, 4, 6]
Set:[7, 5, 3, 1]

 Существуют более эффективные способы реализации множеств – с помощью
словарей, которые позволяют заменить последовательное сканирование, 
используемое в данной реализации, на операцию обращения по ключу 
(хеширование) и тем самым повысить скорость работы. (За дополнительной 
информацией обращайтесь к книге «Программирование на Python».) Если вас
заинтересовали множества, тогда вам также стоит взглянуть 
на тип объектов set, который рассматривался в главе 5, – этот встроенный
тип реализует большое количество разнообразных операций над множествами.
Реализация операций над множествами прекрасно подходит 
для нужд обучения, но создавать такие реализации в современных версиях 
Python больше не требуется.

 В качестве другого примера наследования можно привести новый тип bool,
появившийся в Python 2.3. Как упоминалось ранее в этой книге, bool – это
подкласс типа int с двумя экземплярами (True и False), 
которые ведут себя как целые числа 1 и 0, но наследуют измененные версии 
методов вывода, особым образом отображающие их имена.


 Классы «нового стиля»
 
 В версии Python 2.2 появилась новая разновидность классов, известная 
как классы «нового стиля». Классы, следующие оригинальной модели,
называют «классическими классами», когда сравнивают их с новой 
разновидностью. В версии 3.0 осталась только одна разновидность классов,
но для пользователей Python 2.X классы по-прежнему делятся 
на две категории:

  В Python 3.0 все классы автоматически относятся к категории классов 
 «нового стиля», независимо от того, наследуют ли они явно класс object 
 или нет. Все классы наследуют object, явно или неявно, и все объекты 
 являются экземплярами класса object.
 
  В Python 2.6 и в более ранних версиях классы должны явно наследовать
 класс object (или другой встроенный тип), чтобы считаться классами
 «нового стиля» и получить в свое распоряжение все особенности классов 
 нового стиля.
 
 Поскольку в Python 3.0 все классы автоматически считаются классами 
нового стиля, особенности классов нового стиля стали обычными 
особенностями классов. Однако из уважения к пользователям Python 2.X 
я решил дать их описание в этом разделе отдельно – классы в этой версии
приобретают черты классов нового стиля, только если они явно наследуют
класс object.

 Другими словами, когда пользователи Python 3.0 увидят в этом разделе 
описание особенностей классов «нового стиля», они должны считать его 
описанием существующих особенностей классов. Для пользователей 
Python 2.6 такие описания являются описанием дополнительных 
усовершенствований. В Python 2.6 и в более ранних версиях единственное 
синтаксическое отличие классов нового стиля состоит в том, что они 
наследуют либо встроенный тип, такой как list, либо специальный 
встроенный класс object. Встроенный класс object играет роль
супер-класса для классов нового стиля, когда ни один другой
встроенный тип не подходит на эту роль:


class newstyle(object):
    ...обычный программный код...


 Любые классы, наследующие класс object или любой другой встроенный тип,
автоматически интерпретируются как классы нового стиля. Если где-то 
в дереве наследования класса присутствует какой-нибудь встроенный тип, 
этот класс будет считаться классом нового стиля. Классы, не наследующие
встроенный класс, такой как object, считаются классическими.

 Классы нового стиля лишь немного отличаются от классических классов,
и эти отличия совершенно незаметны для подавляющего большинства 
пользователей Python. Кроме того, классическая модель классов, доступная
в Python 2.6 и используемая на протяжении последних двух десятилетий,
по-прежнему работает именно так, как было описано выше.

 Классы нового стиля практически сохраняют обратную совместимость 
с классическими классами в синтаксисе и в поведении – они привносят лишь
несколько новых особенностей. Однако, т. к. они некоторым образом 
изменили поведение классов, их следует представлять как отдельный 
инструмент, чтобы избежать нежелательных воздействий на любой 
существующий программный код, работоспособность которого зависит 
от прежнего поведения классов. Например, некоторые малозаметные отличия,
такие как ромбоидальная схема поиска в дереве наследования и особенности 
выполнения встроенных операций над атрибутами, доступ к которым 
контролируется методами, такими как __getattr__, могут привести 
к нарушениям в работе устаревшего программного кода, если не внести
в него соответствующие изменения.

 В следующих двух разделах приводится краткий обзор основных отличий
классов нового стиля и их новых возможностей. Отмечу еще раз, так как 
на сегодняшний день все классы являются классами нового стиля, 
пользователи Python 2.X могут считать эти разделы описанием изменений
в языке Python, а пользователи Python 3.0 – описанием дополнительных 
возможностей классов.


 Изменения в классах нового стиля
 
 Классы нового стиля имеют отличия от классических классов в различных 
категориях; часть этих отличий малозаметна, но может оказывать 
воздействие и на существующий программный код, написанный для работы
под управлением Python 2.X, и на стиль программирования. Ниже 
перечислены наиболее заметные отличия:

 Классы и типы были объединены
 
  Классы теперь являются типами, а типы – классами. Фактически эти два
 термина стали синонимами. Вызов встроенной функции type(I) теперь 
 возвращает класс, из которого был получен экземпляр; обычно тот, 
 что указан в атрибуте I.__class__, а не обобщенный тип «instance».
 Кроме того, сами классы являются экземплярами класса type, который 
 можно наследовать в подклассах для изменения процедуры создания 
 классов, и все классы (а, следовательно, и типы) наследуют класс 
 object.

 Порядок поиска в дереве наследования

  Принятая ромбоидальная схема множественного наследования немного 
 изменила порядок поиска – грубо говоря, в этой схеме поиск сначала 
 производится в ширину и только потом в высоту.

 Извлечение атрибутов встроенными операциями

  Встроенные операции больше не используют методы __getattr__ 
 и __getattribute__ для неявного извлечения атрибутов. Это означает,
 что данные методы не вызываются для получения ссылок на методы 
 перегрузки операторов с именами вида __X__ – поиск таких имен 
 начинается с класса, а не с экземпляра.

 Новые особенности

  Классы нового стиля приобрели ряд новых особенностей, включая слоты,
 свойства, дескрипторы и новый метод __getattribute__. В большинстве 
 своем они предназначены для использования разработчиками, создающими
 инструментальные средства.


 Изменения в модели типов
 
 С принятием модели классов нового стиля различия между типами 
и классами полностью исчезли. Теперь классы также являются типами: сами 
классы являются экземплярами класса type, а типами экземпляров классов
являются их классы. Фактически между встроенными типами, такими как 
списки и строки, и пользовательскими типами, определенными 
в виде классов, нет никаких отличий. Именно поэтому имеется возможность 
наследовать встроенные типы в своих классах, как было показано выше 
в этой главе, – поскольку подкласс, наследующий встроенный тип, 
такой как list, квалифицируется, как класс нового стиля, он становится
пользовательским типом данных.

 Кроме появившейся возможности наследовать встроенные типы, 
это изменение становится наиболее очевидным, когда появляется
необходимость явно выполнить проверку типа. В модели классических 
классов, в Python 2.6, экземпляры классов автоматически относятся
к обобщенному типу «instance», тогда как встроенные объекты имеют более 
определенные типы:

C:\misc> c:\python26\python
>>> class C: pass  # Классические классы в 2.6
...
>>> I = C()
>>> type(I)  # Экземпляры классов
<type ‘instance’>
>>> I.__class__
<class __main__.C at 0x025085A0>
>>> type(C)  # Но классы не являются типами
<type ‘classobj’>
>>> C.__class__
AttributeError: class C has no attribute ‘__class__’
>>> type([1, 2, 3])
<type ‘list’>
>>> type(list)
<type ‘type’>
>>> list.__class__
<type ‘type’>

 С появлением классов нового стиля типом экземпляра класса является сам
класс, из которого он был создан, то есть классы являются обычными 
пользовательскими типами данных, – типом экземпляра является его класс, 
а пользовательские классы имеют тот же тип, что и встроенные объекты 
типов. Теперь классы тоже имеют атрибут __class__, потому что они 
являются экземплярами класса type:

C:\misc> c:\python26\python
>>> class C(object): pass # Классы нового стиля в 2.6
...
>>> I = C()
>>> type(I)  # Типом экземпляра является его класс
<class ‘__main__.C’>
>>> I.__class__
<class ‘__main__.C’>
>>> type(C)  # Классы являются пользовательскими типами данных
<type ‘type’>
>>> C.__class__
<type ‘type’>
>>> type([1, 2, 3])  # Для встроенных типов ничего не изменилось
<type ‘list’>
>>> type(list)
<type ‘type’>
>>> list.__class__
<type ‘type’>

 То же самое справедливо для всех классов в Python 3.0, потому что 
в этой версии все классы автоматически считаются классами нового стиля,
даже если они явно не наследуют никаких супер-классов. Фактически
в версии 3.0 различия между встроенными типами и пользовательскими 
классами полностью исчезли:

C:\misc> c:\python30\python
>>> class C: pass  # Все классы являются классами нового стиля в 3.0
...
>>> I = C()
>>> type(I)  # Типом экземпляра является его класс
<class ‘__main__.C’>
>>> I.__class__
<class ‘__main__.C’>
>>> type(C)  # Классы – это типы, а типы – это классы
<class ‘type’>
>>> C.__class__
<class ‘type’>
>>> type([1, 2, 3])  # Классы и встроенные типы ничем не отличаются
<class ‘list’>
>>> type(list)
<class ‘type’>
>>> list.__class__
<class ‘type’>

 Как видите, в Python 3.0 классы являются типами, а типы являются 
классами. С технической точки зрения каждый класс создается
из метакласса – класса с именем type или его подкласса, адаптирующего
или управляющего процедурой создания классов. Помимо того, 
что это изменение оказывает влияние на программный код, выполняющий 
проверку типов, оно оказывается принципиальным для разработчиков
инструментальных средств. Далее в этой главе мы познакомимся 
с метаклассами поближе и более детально будем рассматривать их 
в главе 39.


 Значимость для операций проверки типа
 
 Помимо возможности создания метаклассов и адаптированных версий
встроенных типов, объединение классов и типов в модель классов
нового стиля может оказывать влияние на реализацию операций
проверки типов. В Python 3.0, например, типы экземпляров классов
можно сравнивать непосредственно, точно так же, как сравниваются
встроенные объекты типов. Это обусловлено тем, что теперь классы
являются типами, а типом экземпляра является его класс:

C:\misc> c:\python30\python
>>> class C: pass
...
>>> class D: pass
...
>>> c = C()
>>> d = D()
>>> type(c) == type(d)  # 3.0: сравниваются классы экземпляров
False
>>> type(c), type(d)
(<class ‘__main__.C’>, <class ‘__main__.D’>)
>>> c.__class__, d.__class__
(<class ‘__main__.C’>, <class ‘__main__.D’>)
>>> c1, c2 = C(), C()
>>> type(c1) == type(c2)
True

 Однако, в случае с классическими классами в Python 2.6 и в более ранних
версиях, сравнивать типы экземпляров практически бессмысленно, 
потому что все экземпляры в этой модели имеют один и тот же 
тип «instance». Чтобы действительно сравнить типы экземпляров, 
необходимо сравнить значения их атрибутов __class__ (если вас волнует 
проблема переносимости, отмечу, что в версии 3.0 этот прием действует
точно так же, хотя надобность в нем отпала):

C:\misc> c:\python26\python
>>> class C: pass
...
>>> class D: pass
...
>>> c = C()
>>> d = D()
>>> type(c) == type(d)  # 2.6: все экземпляры имеют один и тот же тип
True
>>> c.__class__ == d.__class__  # Следует явно сравнивать классы
False
>>> type(c), type(d)
(<type ‘instance’>, <type ‘instance’>)
>>> c.__class__, d.__class__
(<class __main__.C at 0x024585A0>, <class __main__.D at 0x024588D0>)

 Как и следовало ожидать, классы нового стиля в 2.6 в этом отношении
действуют точно так же, как и все классы в 3.0, – при сравнивании типов
экземпляров автоматически сравниваются их классы:

C:\misc> c:\python26\python
>>> class C(object): pass
...
>>> class D(object): pass
...
>>> c = C()
>>> d = D()
>>> type(c) == type(d)  # Классы нового стиля в 2.6: действуют так же,
False # как и в 3.0
>>> type(c), type(d)
(<class ‘__main__.C’>, <class ‘__main__.D’>)
>>> c.__class__, d.__class__
(<class ‘__main__.C’>, <class ‘__main__.D’>)

 Конечно, как уже неоднократно отмечалось в этой книге, проверка типа 
в программах на языке Python обычно не является правильным решением
(для нас важны интерфейсы объектов, а не их типы), а в тех редких 
случаях, когда действительно необходимо проверить тип экземпляра класса,
вероятно, лучше использовать более универсальную встроенную функцию
isinstance. Тем не менее знакомство с моделью типов в языке Python 
поможет вам пролить свет на модель классов вообще.


 Все объекты наследуют класс «object»
 
 Еще одно следствие изменений в типах, вызванных появлением модели 
классов нового стиля, заключается в том, что теперь все классы наследуют 
(являются производными) класс object, явно или неявно. То есть все типы 
теперь являются классами, поэтому каждый объект наследует встроенный
класс object, прямо или косвенно, через свой супер-класс. Рассмотрим
следующий сеанс работы с интерактивной оболочкой Python 3.0 (чтобы этот
программный код действовал точно так же в 2.6, укажите явно класс object
в списке супер-классов):

>>> class C: pass
...
>>> X = C()
>>> type(X)  # Теперь типом является класс экземпляра
<class ‘__main__.C’>
>>> type(C)
<class ‘type’>

 Как и прежде, типом экземпляра класса является его класс, а типом
класса является класс type, что является следствием объединения классов 
и типов. Однако также верно, что экземпляры и классы наследуют 
встроенный класс object, поскольку он явно или неявно является 
супер-классом любого класса:

>>> isinstance(X, object)
True
>>> isinstance(C, object)  # Классы всегда наследуют класс object
True

 То же относится и к встроенным типам, таким как списки и строки, 
потому что в модели классов нового стиля типы являются классами; теперь
встроенные типы – это классы, и их экземпляры тоже наследуют класс 
object:

>>> type(‘spam’)
<class ‘str’>
>>> type(str)
<class ‘type’>
>>> isinstance(‘spam’, object)  # То же относится и к встроенным типам
True # (классам)
>>> isinstance(str, object)
True

 Фактически сам класс type наследует класс object, а класс object 
наследует класс type, даже при том, что оба они являются совершенно
различными объектами, – циклическая связь, венчающая объектную модель 
и вытекающая из того факта, что типы являются классами, которые
генерируют другие классы:

>>> type(type)  # Все классы – это типы, и наоборот
<class ‘type’>
>>> type(object)
<class ‘type’>
>>> isinstance(type, object)  # Все классы наследуют object, 
                                даже класс type
True
>>> isinstance(object, type)  # Типы создают классы,
                                и type является классом
True
>>> type is object
False

 С практической точки зрения эта модель создает меньше особых случаев, 
чем прежняя модель классических классов, различающая типы и классы, 
и это позволяет писать программный код, который предполагает наличие
супер-класса object и использует его. Примеры такого подхода мы увидим
далее в этой книге, а пока перейдем к изучению других отличий в модели 
классов нового стиля.


 Ромбоидальное наследование
 
 Пожалуй, самым ощутимым изменением в классах нового стиля является 
немного отличная интерпретация наследования – так называемая 
ромбоидальная схема в деревьях множественного наследования, когда более
одного супер-класса наследуют один и тот же супер-класс более высокого
уровня. Ромбоидальная схема – это сложная концепция проектирования, 
не обсуждавшаяся в этой книге ранее. Она крайне редко используется 
на практике, поэтому мы не будем подробно останавливаться на этой теме.

 В двух словах, в классической модели процедура поиска в дереве
наследования сначала движется строго вверх по дереву, а потом слева 
направо – сначала интерпретатор поднимается вверх всеми возможными 
путями по левой стороне дерева, затем возвращается назад и начинает 
поиск с первого супер-класса, расположенного правее предыдущего. В новой
модели в таких случаях поиск сначала производится в ширину – 
интерпретатор сначала просматривает все супер-классы, стоящие
правее того, где поиск уже произведен, и только потом начинает подъем 
всеми возможными путями к общему супер-классу. Другими словами, поиск
выполняется по уровням дерева наследования. В действительности 
интерпретатор использует немного более сложный алгоритм поиска, 
чем описано здесь, но этого упрощенного представления вполне достаточно
для большинства программистов.

 Вследствие такого изменения супер-классы, расположенные ниже, получают
возможность переопределять атрибуты супер-классов, стоящих выше,
независимо от вида деревьев множественного наследования. Кроме того,
согласно правилам поиска в новой модели каждый супер-класс
просматривается не более одного раза, даже если он наследуется 
несколькими подклассами.


 Пример ромбоидального наследования

 В качестве иллюстрации рассмотрим следующую упрощенную реализацию
ромбоидального наследования для классических классов. Здесь оба
супер-класса, B и C, которые наследуются классом D,
имеют общего предка – класс A:

>>> class A:  # Классическая модель (Python 2.6)
attr = 1
>>> class B(A):  # B и C имеют общего предка – A
pass
>>> class C(A):
attr = 2
>>> class D(B,C):  # Сначала поиск дойдет до A, потом до C
pass
>>> x = D()
>>> x.attr  # Порядок поиска: x,D,B,A
1

 В этом случае атрибут attr будет найден в супер-классе A, потому что
в классической модели поиск в дереве наследования сначала производится 
в высоту, и только потом происходит смещение вправо – интерпретатор 
будет выполнять поиск в следующем порядке: D, B, A и затем C, впрочем, 
поиск прекратится, как только атрибут attr будет найден
в супер-классе A, расположенном выше супер-класса B.

 В классах нового стиля, наследующих встроенный тип, такой как object, 
и во всех классах в Python 3.0 поиск будет выполняться в другом порядке:
прежде чем просмотреть супер-класс A, интерпретатор сначала выполнит
поиск в супер-классе C (правее супер-класса B), то есть в следующем
порядке: D, B, C и затем A, но в этом случае поиск остановится 
в супер-классе C:

>>> class A(object):  # Новый стиль
attr = 1
>>> class B(A):
pass
>>> class C(A):
attr = 2
>>> class D(B,C):  # Сначала поиск дойдет до C, потом до A
pass
>>> x = D()  # Порядок поиска: x,D,B,С
>>> x.attr
2

 Это изменение процедуры поиска основано на предположении, что если вы 
добавляете класс C в дерево ниже, это значит, что вы хотите получить его 
атрибуты раньше, чем атрибуты класса A. Кроме того, это изменение 
предполагает, что класс C всегда будет иметь возможность переопределить
атрибуты класса A, что, скорее всего, верно, когда пишется 
самостоятельный класс, но совсем неверно, когда в ромбоидальной схеме
принимают участие классические классы, – вы можете даже не подозревать,
что класс C может участвовать в подобной схеме наследования, 
когда пишете его.

 Поскольку в подобной ситуации наиболее вероятно, что программист 
подразумевал, что класс C будет переопределять атрибуты класса A, 
новая модель гарантирует, что класс C будет просматриваться первым. 
В противном случае класс C мог бы оказаться практически бесполезным 
при использовании ромбоидальной схемы наследования: он был бы лишен 
возможности адаптировать класс A и мог бы использоваться только 
для экспортирования имен, присутствующих только в классе C.


 Явное разрешение конфликтов имен
 
 Проблема с предположениями в том, что они всего лишь предположения. 
Если такое отклонение в процедуре поиска кажется вам слишком трудным
для запоминания, или вам требуется более полное управление процедурой 
поиска, вы всегда можете произвести выбор желаемого атрибута из любого
места в дереве, выполнив присваивание или как-то иначе обозначив 
его там, где может возникнуть смешение классов:

>>> class A:  # Классическая модель
attr = 1
>>> class B(A):
pass
>>> class C(A):
attr = 2
>>> class D(B,C):  # Выбрать C, справа
attr = C.attr
>>> x = D()
>>> x.attr  # Работает как класс нового стиля
2  # (все классы в 3.0)

 Здесь дерево классических классов имитирует порядок поиска, принятый 
в модели классов нового стиля: присваивание атрибуту attr в классе D 
явно выбирает версию атрибута из класса C, благодаря чему нарушается 
обычный порядок поиска в дереве наследования (атрибут D.attr находится 
ниже в дереве). Точно так же классы нового стиля могут имитировать 
порядок поиска в классической модели, выбирая требуемый атрибут там,
где может происходить смешение:

>>> class A(object):  # Новый стиль
attr = 1
>>> class B(A):
pass
>>> class C(A):
attr = 2
>>> class D(B,C): # Выбрать A.attr, выше
attr = B.attr
>>> x = D()
>>> x.attr  # Работает как классический класс
1  # (по умолчанию в 2.6)

 Если вам необходимо всегда явно разрешать конфликты, подобные этим, 
вы можете просто игнорировать различия в порядке поиска и не полагаться
на предположения о том, что имеется в виду, когда вы пишете свои классы.
Естественно, такой способ выбора атрибутов может также применяться 
и к методам, потому что методы – это обычные объекты:

>>> class A:
def meth(s): print(‘A.meth’)
>>> class C(A):
def meth(s): print(‘C.meth’)
>>> class B(A):
pass
>>> class D(B,C): pass  # Использовать порядок поиска по умолчанию
>>> x = D()  # Зависит от типа класса
>>> x.meth()  # По умолчанию – классический порядок поиска в 2.6
A.meth
>>> class D(B,C): meth = C.meth  # Выбрать метод класса C: 
                                   новый стиль (и 3.0)
>>> x = D()
>>> x.meth()
C.meth
>>> class D(B,C): meth = B.meth  # Выбрать метод класса B: 
                                   классическая модель
>>> x = D()
>>> x.meth()
A.meth

 Здесь мы явно выбираем методы, выполняя присваивание именам, 
находящимся ниже в дереве. Мы могли бы просто вызвать метод желаемого 
класса явно – на практике этот подход, возможно, является более
общепринятым, в особенности при работе с конструкторами:


class D(B,C):
    def meth(self):  # Переопределяется ниже
    ...
    C.meth(self)  # Вызовом выбрать метод класса C


 Такой выбор путем присваивания или вызова в точках смешения может 
эффективно обезопасить ваш программный код от возможных различий между
разными моделями классов. Явное разрешение конфликтов таким способом
гарантирует, что правильная работа вашего программного кода не будет 
зависеть от версии Python в будущем (независимо от необходимости 
наследоватЬ класс object или встроенные типы, чтобы использовать 
новую модель).

 Даже если не учитывать расхождения между классической и новой моделями,
данная методика иногда может пригодиться в случаях множественного 
наследования. Например, если вам необходимо получить часть атрибутов
от суперкласса слева, а часть – от суперкласса справа, вам может
потребоваться ука- зать интерпретатору Python, какие именно атрибуты 
следует выбирать, выполняя явное присваивание в подклассах. 
Мы еще вернемся к этому вопросу в разделе с описанием типичных проблем 
в конце этой главы.

 Кроме того, обратите внимание, что ромбоидальные схемы наследования 
в некоторых случаях могут доставлять еще больше хлопот,
чем я описал здесь (например, что если оба конструктора классов B и C 
вызывают конструктор класса A, и при этом необходимо вызывать оба 
наследуемых конструктора в подклассе?). Поскольку в практике такие 
ситуации встречаются крайне редко, мы оставим эту тему за рамками 
данной книги (однако обратите внимание на встроенную функцию super –
она не только обобщает доступ к суперклассам в деревьях с простым 
наследованием, но и поддерживает кооперативный режим разрешения 
некоторых конфликтов, возникающих в деревьях множественного 
наследования).


 Пределы влияния изменений в порядке поиска
 
 Итак, поиск в ромбоидальной схеме наследования выполняется по-разному
в классической и в новой моделях, и это изменение нарушает обратную
совместимость. Однако имейте в виду, что это изменение затрагивает 
только ромбоидальные схемы множественного наследования – во всех других
схемах принцип действия модели наследования нового стиля не изменился.
Кроме того, вполне возможно, что вся эта проблема будет носить скорее 
теоретический характер, чем практический, – с выходом версии Python 2.2 
эти изменения не оказали достаточно существенного влияния и не приобрели
масштабного значения к появлению Python 3.0, потому маловероятно, 
что они затронут значительную часть программного кода на языке Python.

 Кроме того, следует отметить, что даже если вы не будете применять 
ромбоидальную схему наследования в своих классах, все равно суперкласс
object в версии 3.0 всегда будет находиться выше любого класса, 
вследствие чего любой случай множественного наследования будет 
соответствовать ромбоидальной схеме. То есть в новой модели класс object
автоматически играет ту же самую роль, какую играет класс A в только что
рассмотренном примере. Отсюда следует, что новые правила поиска 
не только изменили логическую семантику, но и оптимизировали 
производительность, так как исключают возможность посещения одного 
и того же класса более чем один раз.

 Не менее важно то обстоятельство, что суперкласс object в новой модели 
предоставляет методы по умолчанию, реализующие различные встроенные 
операции, включая методы вывода __str__ и __repr__. Вызовите функцию 
dir(object), чтобы увидеть, какие методы им предоставляются. 
Без изменений в правилах поиска при множественном наследовании методы 
по умолчанию в классе object всегда имели бы преимущество перед 
переопределенными версиями в пользовательских классах, если только 
переопределенные версии не находились бы в самом первом унаследованном
суперклассе. Другими словами, новая модель сама делает новый порядок 
поиска более важным!

 Более наглядные примеры постоянного присутствия суперкласса object 
в версии 3.0 и другие примеры ромбоидальной схемы наследования, 
создаваемой им, вы найдете в результатах работы класса ListTree,
в примере lister.py, в предыдущей главе, а также в примере classtree.py, 
в главе 28, где реализован обход дерева классов.
"""

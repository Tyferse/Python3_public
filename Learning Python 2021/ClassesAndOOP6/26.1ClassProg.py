"""
 Основы программирования классов


 Классы генерируют множество экземпляров объектов

 Чтобы понять, каким образом обеспечивается возможность создания
множества объектов, для начала нужно понять, что
в объектно-ориентированной модели языка Python существует две
разновидности объектов: объекты классов и объекты экземпляров. Объекты
классов реализуют поведение по умолчанию и играют роль фабрик
по производству объектов экземпляров. Объекты экземпляров –
это настоящие объекты, обрабатываемые программой, – каждый представляет
собой самостоятельное пространство имен, но наследует имена (то есть
автоматически имеет доступ к ним) класса, из которого он был создан.
Объекты классов создаются инструкциями, а объекты экземпляров –
вызовами. Каждый раз, когда вы вызываете класс, вы получаете новый
экземпляр этого класса.

 Эта объектная концепция существенно отличается от любых других
программных конструкций, которые мы видели до сих пор в этой книге.
В действительности классы – это фабрики, способные производить
множество экземпляров. В противоположность этому каждый модуль
в программе может присутствовать в единственном экземпляре.
(Фактически это одна из причин, почему необходимо использовать функцию
importlib.reload для обновления объекта модуля, чтобы отразить внесенные
в модуль изменения.)

 Ниже приводится краткий обзор основных особенностей ООП в языке Python.
Как вы увидите, классы в языке Python сочетают в себе черты,
напоминающие функции и модули, но они совершенно не похожи на классы
в других языках программирования.


 Объекты классов реализуют поведение по умолчанию

 Когда выполняется инструкция class, она создает объект класса. Ниже
приводятся несколько основных отличительных характеристик классов
в языке Python.

  Инструкция class создает объект класса и присваивает ему имя. Так же
как и инструкция def, инструкция class является выполняемой инструкцией.
Когда она выполняется, она создает новый объект класса и присваивает
его имени, указанному в заголовке инструкции class. Кроме того,
как и инструкции def, инструкции class обычно выполняются при первом
импортировании содержащих их файлов.

  Операции присваивания внутри инструкции class создают атрибуты класса.
Так же как и в модулях, инструкции присваивания на верхнем уровне внутри
инструкции class (не вложенные в инструкции def) создают атрибуты
объекта класса. С технической точки зрения инструкция class преобразует
свою область видимости в пространство имен атрибутов объекта класса,
так же как глобальная область видимости модуля преобразуется в его
пространство имен. После выполнения инструкции class атрибуты класса
становятся доступны по их составным (полным) именам: object.name.

  Атрибуты класса описывают состояние объекта и его поведение. Атрибуты
объекта класса хранят информацию о состоянии и описывают поведение,
которым обладают все экземпляры класса, – инструкции def, вложенные
в инструкцию class, создают методы, которые обрабатывают экземпляры.


 Объекты экземпляров – это конкретные элементы

 Когда вызывается объект класса, возвращается объект экземпляра.
Ниже приводятся несколько отличительных характеристик экземпляров
классов:

  Вызов объекта класса как функции создает новый объект экземпляра.
 Всякий раз, когда вызывается класс, создается и возвращается новый
 объект экземпляра. Экземпляры представляют собой конкретные элементы
 данных в вашей программе.

  Каждый объект экземпляра наследует атрибуты класса и приобретает свое
 собственное пространство имен. Объекты экземпляров создаются из классов
 и представляют собой новые пространства имен; они первоначально пустые,
 но наследуют атрибуты классов, из которых были созданы.

  Операции присваивания значений атрибутам через ссылку self в методах
 создают атрибуты в каждом отдельном экземпляре. Методы класса получают
 в первом аргументе (с именем self в соответствии с соглашениями)
 ссылку на обрабатываемый объект экземпляра – присваивание атрибутам
 через ссылку self создает или изменяет данные экземпляра, а не класса.


 Первый пример

 Обратимся к первому примеру, демонстрирующему работу этих идей
на практике. Для начала определим класс с именем FirstClass, выполнив
инструкцию class в интерактивной оболочке интерпретатора Python:
"""


class FirstClass:  # Определяет объект класса
    def setdata(self, value):  # Определяет метод класса
        self.data = value  # self – это экземпляр

    def display(self):
        print(self.data)  # self.data: данные экземпляров


"""
 Здесь мы работаем в интерактивной оболочке, но обычно такие инструкции
выполняются во время импортирования вмещающего файла модуля. Подобно
функциям, создаваемым с помощью инструкции def, классы не существуют,
пока интерпретатор Python не достигнет этих инструкций и не выполнит их.
Как и все составные инструкции, инструкция class начинается со строки 
заголовка, содержащей имя класса, за которой следует тело класса
из одной или более вложенных инструкций (обычно) с отступами. Здесь
вложенными инструкциями являются инструкции def – они определяют 
функции, реализующие поведение класса.

 Как мы уже знаем, инструкции def в действительности являются операциями
присваивания – в данном случае они присваивают объекты функций именам
setdata и display в области видимости инструкции class и тем самым 
создают атрибуты, присоединяемые к классу: FirstClass.setdata 
и FirstClass.display. Фактически любое имя, которому присваивается
значение на верхнем уровне во вложенном блоке класса, становится 
атрибутом этого класса. Функции внутри классов обычно называются
методами. Это обычные инструкции def, и для них верно все, 
что мы уже знаем о функциях (они могут иметь аргументы со значениями
по умолчанию, возвращать значения и так далее). Но в первом аргументе 
методы автоматически получают подразумеваемый объект экземпляра – 
контекст вызова метода. Нам необходимо создать пару экземпляров, 
чтобы понять, как это делается:
"""

x = FirstClass()  # Создаются два экземпляра
y = FirstClass()  # Каждый является отдельным пространством имен

"""
 Вызывая класс таким способом (обратите внимание на круглые скобки), 
мы создаем объекты экземпляров, которые являются всего лишь 
пространствами имен и обладают доступом к атрибутам класса. Собственно 
говоря, к настоящему моменту у нас имеется три объекта – два экземпляра 
и один класс. В действительности у нас имеется три связанных 
пространства имен, как показано на рис. 26.1. В терминах ООП мы говорим, 
что объект x «наследует» класс FirstClass, как и y.

 Изначально оба экземпляра пустые, но они связаны с классом, из которого 
были созданы. Если через имя экземпляра обратиться к атрибуту объекта
класса, то в результате поиска по дереву наследования интерпретатор 
вернет значение атрибута класса (при условии, что в экземпляре 
отсутствует одноименный атрибут):
"""

x.setdata("King Arthur")  # Вызов метода: self – это x
y.setdata(3.14159)  # Эквивалентно: FirstClass.setdata(y, 3.14159)

"""
 Ни x, ни y не имеют собственного атрибута setdata, поэтому, чтобы
отыскать его, интерпретатор следует по ссылке от экземпляра к классу. 
В этом заключается суть наследования в языке Python: механизм 
наследования привлекается в момент разрешения имени атрибута, 
и вся его работа заключается лишь в поиске имен в связанных объектах
(например, следуя по ссылкам «наследует», как показано на рис.).

 В функции setdata внутри класса FirstClass значение аргумента 
записывается в self.data. Имя self внутри метода – имя самого первого
аргумента, в соответствии с общепринятыми соглашениями, – автоматически 
ссылается на обрабатываемый экземпляр (x или y), поэтому операция 
присваивания сохраняет значения в пространстве имен экземпляра, 
а не класса (так создаются имена data, показанные на рис.).

 Поскольку классы способны генерировать множество экземпляров, методы
должны использовать аргумент self, чтобы получить доступ 
к обрабатываемому экземпляру. Когда мы вызываем метод класса display, 
чтобы вывести значения атрибутов self.data, мы видим, что для каждого 
экземпляра они разные; с другой стороны, имя display само по себе 
одинаковое в x и y, так как оно пришло (унаследовано) из класса:
"""

x.display()
y.display()

"""
 Обратите внимание, что в атрибутах data экземпляров мы сохранили 
объекты различных типов (строку и вещественное число). Как и повсюду
в языке Python, атрибуты экземпляров (иногда называются членами) никак
не объявляются – они появляются, как только будет выполнена первая
операция присваивания, точно так же, как и в случае с переменными. 
Фактически если вызвать метод display до вызова метода setdata, 
будет получено сообщение об ошибке обращения к неопределенному имени – 
атрибут с именем data не существует в памяти, пока ему не будет
присвоено какое-либо значение в методе setdata. Еще один способ,
дающий возможность оценить, насколько динамична эта модель, позволяет
изменять атрибуты экземпляров в самом классе, выполняя присваивание
как с помощью аргумента self внутри методов, так и за пределами класса,
когда экземпляр явно участвует в операции присваивания:
"""

x.data = "New value"  # Можно получать/записывать значения атрибутов
x.display()

"""
 Хотя это и нечасто применяется, тем не менее существует возможность
создания новых атрибутов в пространстве имен экземпляра, присваивая 
значения именам за пределами методов класса:
"""

x.anothername = "spam"  # Здесь также можно создавать новые атрибуты

"""
 Эта операция присоединит новый атрибут с именем anothername, который 
затем сможет использоваться любыми методами класса в объекте
экземпляра x. Обычно классы создают все атрибуты экземпляров за счет
присваивания значений аргументу self, но это не обязательно – программы 
могут получать, изменять или создавать атрибуты в любых объектах,
к которым они имеют доступ.


 Классы адаптируются посредством наследования
 
 Помимо роли фабрик по созданию объектов экземпляров, классы также 
позволяют нам вносить изменения за счет введения новых компонентов 
(которые называются подклассами), а не за счет изменения существующего
программного кода. Объекты экземпляров, созданные из класса, наследуют
атрибуты класса. В языке Python классы также могут наследовать другие 
классы, что открывает дверь к созданию иерархий классов, поведение 
которых специализируется за счет переопределения более обобщенных 
атрибутов, находящихся выше в дереве иерархии, в подклассах, 
находящихся ниже в иерархии. В результате, чем ниже мы опускаемся
в дереве иерархии, тем более специализированными становятся классы. 
Здесь также нет никакого сходства с модулями: их атрибуты находятся
в едином плоском пространстве имен, которое не поддается адаптации.

 В языке Python экземпляры наследуют классы, а классы наследуют 
супер-классы. Ниже приводятся основные идеи, лежащие в основе механизма
наследования атрибутов:

  Супер-классы перечисляются в круглых скобках в заголовке инструкции
 class. Чтобы унаследовать атрибуты другого класса, достаточно указать
 этот класс в круглых скобках в заголовке инструкции class. Наследующий
 класс называется подклассом, а наследуемый класс называется 
 его супер-классом.

  Классы наследуют атрибуты своих супер-классов. Как экземпляры наследуют
 имена атрибутов, определяемых их классами, так же и классы  наследуют 
 все имена атрибутов, определяемые в их супер-классах, – интерпретатор
 автоматически отыскивает их, когда к ним выполняется обращение, 
 если эти атрибуты отсутствуют в подклассах.

  Экземпляры наследуют атрибуты всех доступных классов. Каждый экземпляр
 наследует имена из своего класса, а также из всех его супер-классов.
 Во время поиска имен интерпретатор проверяет сначала экземпляр, потом 
 его класс, а потом все супер-классы.

  Каждое обращение object.attribute вызывает новый независимый поиск.
 Интерпретатор выполняет отдельную процедуру поиска в дереве классов
 для каждого атрибута, который ему встречается в выражении запроса.
 Сюда входят ссылки на экземпляры и классы из инструкции class 
 (например, X.attr), а также ссылки на атрибуты аргумента 
 экземпляра self в методах класса. Каждое выражение self.attr в методе
 вызывает поиск attr в self и выше.

  Изменения в подклассах не затрагивают супер-классы. Замещение имен
 супер-класса в подклассах ниже в иерархии (в дереве классов) изменяет
 подклассы и тем самым изменяет унаследованное поведение.

 Результат и главная цель такой процедуры поиска состоит в том, 
что классы обеспечивают разложение на отдельные операции и адаптацию
программного кода лучше, чем это могут сделать другие компоненты языка, 
которые мы рассматривали ранее. С одной стороны, классы позволяют
минимизировать избыточность программного кода (и тем самым снизить 
стоимость обслуживания) за счет создания единой и общей реализации 
операций, а с другой – они обеспечивают возможность адаптировать уже
существующий программный код вместо того, чтобы изменять его 
или писать заново.


 Второй пример
 
 Проиллюстрируем роль механизма на втором примере, который основан 
на предыдущем. Для начала определим новый класс, SecondClass, который
наследует все имена из класса FirstClass и добавляет свои собственные:
"""


class SecondClass(FirstClass):  # Наследует setdata
    def display(self):  # Изменяет display
        print('Current value = “%s”' % self.data)


"""
 Класс SecondClass определяет метод display, осуществляющий вывод 
в другом формате. Определяя атрибут с тем же именем, что и атрибут
в классе FirstClass, класс SecondClass замещает атрибут display 
своего супер-класса.

 Вспомните, что поиск в дереве наследования выполняется снизу вверх – 
от экземпляров к классам и далее к супер-классам и останавливается,
как только будет найдено первое вхождение искомого имени атрибута. 
В данном случае имя display в классе SecondClass будет найдено раньше, 
чем это же имя в классе FirstClass. В этом случае мы говорим, 
что класс SecondClass переопределяет метод display класса FirstClass. 
Иногда такая замена атрибутов за счет их переопределения ниже в дереве 
классов называется перегрузкой.

 Главный результат здесь состоит в том, что класс SecondClass 
специализирует класс FirstClass, изменяя поведение метода display.
С другой стороны, класс SecondClass (и все экземпляры, созданные 
из него) по-прежнему наследует из класса FirstClass метод setdata. 
Создадим экземпляр, чтобы продемонстрировать это:
"""

z = SecondClass()
z.setdata(42)  # Найдет setdata в FirstClass
z.display()  # Найдет переопределенный метод в SecondClass

"""
 Как и прежде, мы создали объект экземпляра, вызвав класс SecondClass. 
При обращении к setdata все так же вызывается версия метода
из FirstClass, но при обращении к атрибуту display вызывается версия
метода из SecondClass, которая выводит измененный текст сообщения.

 Здесь очень важно заметить следующее: специализация, выполненная 
в классе SecondClass, находится полностью за пределами класса 
FirstClass. Как следствие, она не оказывает влияния на уже созданные
или создаваемые впоследствии объекты класса FirstClass, 
такие как x в предыдущем примере:
"""

x.display()  # x по-прежнему экземпляр FirstClass (старое сообщение)

"""
 Вместо того, чтобы изменять класс FirstClass, мы адаптировали его. 
Безусловно, это достаточно искусственный пример, но он демонстрирует,
как наследование позволяет вносить изменения с помощью внешних 
компонентов (то есть с помощью подклассов). Часто классы поддерживают
возможность расширения и повторного использования гораздо лучше, 
чем функции или модули.


 Классы – это атрибуты в модулях
 
 Прежде чем двинуться дальше, вспомним, что в именах классах нет ничего
необычного. Это всего лишь переменные, которым присваиваются объекты 
во время выполнения инструкций class, а ссылки на объекты можно получить
с помощью обычных выражений. Например, если бы определение класса
FirstClass находилось в файле модуля, а не было введено в интерактивной 
оболочке, мы могли бы импортировать этот модуль и использовать имя
в строке заголовка инструкции class:

from modulename import FirstClass  # Скопировать имя в мою область 
class SecondClass(FirstClass):  # Использовать имя класса      видимости
def display(self): ...  #                 непосредственно

 Или эквивалентный вариант:
 
import modulename  # Доступ ко всему модулю целиком
class SecondClass(modulename.FirstClass):  # Указать полное имя
def display(self): ...

 Имена классов, как и все остальное, всегда находятся в модулях, 
и потому при их употреблении необходимо следовать правилам, которые 
мы рассматривали в пятой части книги. Например, в одном файле модуля 
могут находиться определения сразу нескольких классов – подобно другим
инструкциям в модуле, инструкции class выполняются в ходе операции 
импортирования и определяют имена, которые в свою очередь становятся
атрибутами модуля. Вообще, любой модуль может содержать самые 
произвольные сочетания из любого числа переменных, функций и классов, 
и все эти имена будут вести себя в модуле одинаково. Это демонстрирует
файл food.py:

# food.py
var = 1  # food.var
def func():  # food.func
...
class spam:  # food.spam
...
class ham:  # food.ham
...
class eggs: # food.eggs
...

 Это правило остается справедливым, даже если модуль и класс имеют 
одинаковые имена. Например, пусть имеется следующий файл person.py:

class person:
...

 Чтобы получить доступ к классу, нам необходимо обратиться к модулю,
как обычно:

import person  # Импортировать модуль
x = person.person() #  Класс внутри модуля

 Хотя этот способ может показаться избыточным, он совершенно необходим:
имя person.person ссылается на класс person внутри модуля person. 
Если использовать просто имя person, мы обратимся к модулю, 
а не к классу; кроме случая, когда используется инструкция from:

from person import person  # Получить класс из модуля
x = person()  # Использовать имя класса

 Как и любые другие переменные, мы не увидим класс в файле модуля, 
пока не импортируем его или как-то иначе не извлечем класс из вмещающего 
файла. Если вам это кажется сложным, то не используйте одинаковые имена
для модулей и классов в них. Согласно общепринятым соглашениям, имена 
классов в языке Python должны начинаться с заглавной буквы, 
чтобы обеспечить визуальное отличие:

import person  # Имена модулей начинаются с прописных букв
x = person.Person()  # Имена классов – с заглавных

 Кроме того, имейте в виду, несмотря на то, что классы и модули являются
пространствами имен для подключения атрибутов, они представляют собой
совершенно разные структуры: модуль является отражением целого файла,
а класс – это лишь инструкция внутри файла. Подробнее об этих различиях
мы поговорим позднее в этой части книги.


 Классы могут переопределять операторы языка Python
 
 Теперь давайте рассмотрим третье основное отличие классов и модулей:
перегрузку операторов. Говоря простым языком, перегрузка операторов
позволяет объектам, созданным из классов, перехватывать и участвовать
в операциях, которые применяются к встроенным типам: сложение, получение
среза, вывод, квалификация имен и так далее. По большей части 
это автоматический механизм: при выполнении выражений и других 
встроенных операций интерпретатор передает управление реализации
классов. В модулях нет ничего подобного: модули могут реализовать 
функции, но не операторы выражений.

 Мы можем полностью реализовать поведение класса в виде методов,
однако перегрузка операторов позволяет объектам теснее интегрироваться 
в объектную модель языка Python. Кроме того, перегрузка операторов 
помогает нашим объектам действовать так же, как действуют встроенные
объекты, потому что она позволяет создавать менее противоречивые 
и более простые в изучении интерфейсы объектов и обеспечивает 
возможность обрабатывать объекты, созданные из классов, программным
кодом, который предполагает взаимодействие со встроенными типами. 
Ниже перечислены основные идеи, лежащие в основе механизма перегрузки
операторов:

  Имена методов, начинающиеся и заканчивающиеся двумя символами
 подчеркивания (__X__), имеют специальное назначение. Перегрузка 
 операторов в языке Python реализуется за счет создания методов
 со специальными именами для перехватывания операций. Язык Python 
 определяет фиксированные и неизменяемые имена методов для каждой 
 из операций.

  Такие методы вызываются автоматически, когда экземпляр участвует
 во встроенных операциях. Например, если объект экземпляра наследует
 метод __add__, этот метод будет вызываться всякий раз, когда объект
 будет появляться в операции сложения (+). Возвращаемое значение метода
 становится результатом соответствующей операции.

  Классы могут переопределять большинство встроенных операторов. 
 Существует множество специальных имен методов для реализации перегрузки
 почти всех операторов, доступных для встроенных типов. Сюда входят
 операторы выражений, а также такие базовые операции, как вывод 
 и создание объекта.

  В методах перегрузки операторов не существует аргументов со значениями
 по умолчанию, и ни один из таких методов не является обязательным
 для реализации. Если класс не определяет и не наследует методы 
 перегрузки операторов, это означает лишь, что экземпляры класса 
 не поддерживают эти операции. Например, если отсутствует метод __add__, 
 попытка выполнить операцию сложения + будет приводить к возбуждению 
 исключения.

  Операторы позволяют интегрировать классы в объектную модель языка
 Python. Благодаря перегрузке операторов, объекты, реализованные на базе
 классов, действуют подобно встроенным типам и тем самым обеспечивают
 непротиворечивые и совместимые интерфейсы.

 Перегрузка операторов является необязательной функциональной
особенностью – она используется в основном специалистами, создающими 
инструментальные средства для других программистов, а не разработчиками
прикладных программ. И честно говоря, вам не стоит использовать ее 
только потому, что это «круто». Если не требуется, чтобы класс 
имитировал поведение встроенных типов, лучше ограничиться использованием
простых методов. Например, зачем приложению, работающему с базой данных
служащих, поддержка таких операторов, как * и +? Методы 
с обычными именами, такими как giveRaise и promote, обычно
более уместны.

 Вследствие этого мы не будем далее углубляться в подробности реализации
методов перегрузки каждого оператора, доступного в языке Python. Однако
имеется один метод перегрузки оператора, который можно встретить 
практически в любом классе: метод __init__, который известен 
как конструктор и используется для инициализации состояния объектов. 
Методу __init__ следует уделить особое внимание, потому что он, наряду 
с аргументом self, является одним из ключей к пониманию ООП 
в языке Python.


 Третий пример
 
 На этот раз мы определим подкласс, производный от SecondClass 
и реализующий три специальных метода, которые будут вызываться 
интерпретатором автоматически:

  Метод __init__ вызывается, когда создается новый объект экземпляра 
 (аргумент self представляет новый объект ThirdClass).
 
  Метод __add__ вызывается, когда экземпляр ThirdClass участвует 
 в операции +.
 
  Метод __str__ вызывается при выводе объекта (точнее, когда он 
 преобразуется в строку для вывода вызовом встроенной функции str 
 или ее эквивалентом внутри интерпретатора).
 
 Кроме того, новый подкласс определяет метод с обычным именем mul, 
который изменяет сам объект в памяти. Ниже приводится определение
нового подкласса:
"""


class ThirdClass(SecondClass):  # Наследует SecondClass
    def __init__(self, value):  # Вызывается из ThirdClass(value)
        self.data = value

    def __add__(self, other):  # Для выражения “self + other”
        return ThirdClass(self.data + other)

    def __str__(self):  # Вызывается из print(self), str()
        return '[ThirdClass: %s]' % self.data

    def mul(self, other):  # Изменяет сам объект: обычный метод
        self.data *= other


a = ThirdClass('abc')  # Вызывается новый метод
print(a)  # __str__: возвращает строку

b = a + 'xyz'  # Новый __add__: создается новый экземпляр
b.display()
print(b)  # __str__: возвращает строку

a.mul(3)  # mul: изменяется сам экземпляр
print(a)

"""
 Класс ThirdClass «наследует» класс SecondClass, поэтому его экземпляры 
наследуют метод display от SecondClass. Но теперь при создании 
экземпляра класса ThirdClass ему передается дополнительный аргумент 
(например, «abc»). Это значение передается конструктору __init__ 
в аргументе value, где присваивается атрибуту self.data. В результате 
при создании экземпляра класса ThirdClass значение атрибута data 
устанавливается автоматически, благодаря чему отпадает необходимость 
вызывать метод setdata после создания экземпляра.

 Далее, объекты ThirdClass могут участвовать в операциях + и в вызовах 
функции print. При выполнении операции сложения объект экземпляра 
слева от оператора передается методу __add__ в виде аргумента self, 
а значение справа – в виде аргумента other, как показано на рис. 
Независимо от того, что вернет метод __add__, это значение будет 
интерпретироваться, как результат операции сложения. Когда объект 
участвует в вызове функции print, интерпретатор вызывает метод __str__
объекта и передает ему сам объект – любая строка, которую вернет этот 
метод, будет расцениваться, как строковое представление объекта 
для вывода. Переопределив метод __str__, мы получаем возможность 
использовать обычную функцию print для отображения объектов 
этого класса, вместо того чтобы вызывать метод display.


 Методы со специальными именами, такими как __init__, __add__ 
и __str__, наследуются подклассами и экземплярами, как любые другие
имена, которым выполняется присваивание в инструкции class. 
Если методы отсутствуют в классе, интерпретатор, как обычно,
продолжит их поиск в супер-классах. Кроме того, имена методов перегрузки
операторов не являются встроенными именами или зарезервированными 
словами – это обычные атрибуты, которые отыскиваются интерпретатором 
в случае появления объектов в различных контекстах. Как правило,
интерпретатор вызывает их автоматически, но они могут вызываться 
и вашим программным кодом – метод __init__, например, часто вызывается 
вручную, с целью запустить конструктор супер-класса (подробнее об этом
мы поговорим позднее).

 Обратите внимание, что метод __add__ создает и возвращает новый объект
экземпляра этого класса (вызывая ThirdClass, которому передается 
значение результата), а метод mul изменяет текущий объект экземпляра
(выполняя присваивание атрибуту аргумента self). Мы могли бы перегрузить
оператор *, вместо того, чтобы создавать этот метод, но такое поведение 
отличается от поведения встроенных типов, таких как числа и строки, 
которые всегда создают новые объекты при выполнении оператора *. 
Поскольку перегрузка операторов – это в действительности всего лишь 
механизм отображения выражений на методы, вы можете интерпретировать 
операторы в своих объектах классов, как вам будет угодно.


 Когда следует использовать перегрузку операторов?
 
 Создавая свои классы, вы можете выбирать – использовать перегрузку
операторов или нет. Выбор зависит от того, насколько близко ваш класс 
должен имитировать поведение встроенных типов. Как упоминалось выше, 
если метод перегрузки оператора отсутствует в определении класса 
и не наследуется из супер-класса, соответствующая операция не будет
поддерживаться экземплярами этого класса – если попытаться выполнить 
такую операцию, интерпретатор возбудит исключение (или будет выполнено 
действие, предусмотренное по умолчанию).

 Откровенно говоря, методы перегрузки операторов в большинстве своем 
используются только при реализации объектов с математической природой –
класс вектора или матрицы может, например, перегружать оператор 
сложения, а класс служащего, скорее всего, нет. Чтобы упростить классы, 
вы можете вообще не использовать перегрузку и опираться на явные вызовы
методов. C другой стороны, вы могли бы использовать перегрузку 
операторов, чтобы иметь возможность передавать объекты, определяемые 
пользователем, в функцию, которая выполняет операции, поддерживаемые
встроенными типами, такими как списки или словари. Наличие реализации 
того же самого набора операторов в вашем классе обеспечит поддержку 
вашими объектами тех же самых интерфейсов и, как следствие, 
совместимость с используемой функцией.

 Один из методов перегрузки присутствует практически во всех 
реалистичных классах: метод-конструктор __init__. Он позволяет классам 
немедленно заполнять атрибуты вновь созданных экземпляров, поэтому
конструктор полезно использовать практически во всех разновидностях
ваших классов. Фактически даже при том, что в языке Python атрибуты
не объявляются, вы без труда сможете определить, какие атрибуты
принадлежат экземплярам, просмотрев программный код метода __init__.


 Самый простой в мире класс на языке Python
 
 В этой главе мы приступили к детальному изучению синтаксиса инструкции
class, но я еще раз хотел бы напомнить, что сама модель наследования,
на которой основаны классы, очень проста – суть ее заключается 
всего лишь в организации поиска атрибутов в деревьях взаимосвязанных 
объектов. Фактически мы можем создавать вообще пустые классы. Следующая 
инструкция создает класс без присоединенных к нему атрибутов (объект
пустого пространства имен):
"""


class rec:
    pass  # Объект пустого пространства имен


"""
 Инструкция пустой операции pass (обсуждавшаяся в главе 13) необходима
потому, что здесь у нас нет никаких методов с программным кодом. После 
создания класса, выполнив инструкцию в интерактивной оболочке, 
мы можем приступать к присоединению атрибутов, выполняя операции
присваивания из-за пределов класса:
"""

rec.name = 'Bob'  # Так же для объектов с атрибутами
rec.age = 40

"""
 После того как атрибуты будут созданы, мы можем обращаться к ним 
с помощью обычного синтаксиса. Когда класс используется таким способом, 
он напоминает структуры в языке C или записи в языке Pascal – объект, 
с присоединенными к нему полями (то же самое можно проделывать с ключами
словарей, но для этого потребуется вводить дополнительные символы):
"""

print(rec.name)  # Как структура в языке C или запись

"""
 Обратите внимание: такой подход будет работать даже в случае, 
когда еще не было создано ни одного экземпляра класса. Классы – 
это полноценные объекты, даже если нет ни одного экземпляра. Фактически
они всего лишь самостоятельные пространства имен, поэтому, пока у нас 
имеется ссылка на класс, мы можем в любое время добавлять или изменять 
его атрибуты по своему усмотрению. Однако посмотрим, что произойдет,
когда будут созданы два экземпляра класса:
"""

x = rec()  # Экземпляры наследуют имена из класса
y = rec()

"""
 Эти экземпляры начинают свое существование как объекты абсолютно пустых
пространств имен. Однако из-за того, что они помнят класс, из которого 
были созданы, они по наследству получат атрибуты, которые 
мы присоединили к классу:
"""

print(x.name, y.name)  # Сейчас имена хранятся только в классе

"""
 В действительности у этих экземпляров нет собственных атрибутов – 
они просто получают атрибут name из класса. Тем не менее если выполнить 
присваивание атрибуту экземпляра, будет создан (или изменен) атрибут 
этого объекта, а не другого – атрибуты обнаруживаются в результате 
поиска по дереву наследования, но операция присваивания значения
атрибуту воздействует только на тот объект, к которому эта операция
применяется. Ниже экземпляр x получает свой собственный атрибут name, 
а экземпляр y по-прежнему наследует атрибут name, присоединенный 
к классу выше его:
"""

x.name = 'Sue'  # Но присваивание изменит только объект x
print(rec.name, x.name, y.name)

"""
 Фактически, как будет более подробно рассказано в главе 28, атрибут
объекта пространства имен обычно реализованы в виде словарей, и деревья 
наследования классов (вообще говоря) тоже всего лишь словари со ссылками
на другие словари. Если знать, куда смотреть, в этом можно 
убедиться явно.

 Например, в большинстве объектов, созданных на базе классов, имеется 
атрибут __dict__, который является словарем пространства имен (некоторые 
классы могут также определять атрибуты в __slots__ – с этой
дополнительной и нечасто используемой особенностью мы познакомимся
в главах 30 и 31). Ниже приводится пример интерактивного сеанса 
в Python 3.0 – порядок следования имен и перечень внутренних имен вида
__X__ может изменяться от версии к версии, но имена, которые
использовали, присутствуют во всех версиях:
"""

print(rec.__dict__.keys())

print(list(x.__dict__.keys()))

print(list(y.__dict__.keys()))  # В Python 2.6 функцию list()
#                                 можно не использовать

"""
 Здесь в словаре класса присутствуют атрибуты name и age, которые 
мы создали ранее, объект x имеет свой собственный атрибут name, 
а объект y по-прежнему пуст. Каждый экземпляр имеет ссылку на свой 
наследуемый класс, она называется __class__, если вам захочется
проверить ее:
"""

print(x.__class__)

"""
 Классы также имеют атрибут __bases__, который представляет собой кортеж
его супер-классов:
"""

print(rec.__bases__)  # () пустой кортеж в Python 2.6

"""
 Эти два атрибута описывают, как деревья классов размещаются в памяти.
 
 Главное, что следует из этого взгляда на внутреннее устройство, это то,
что модель классов в языке Python чрезвычайно динамична. Классы 
и экземпляры – это всего лишь объекты пространств имен с атрибутами, 
создаваемыми на лету с помощью операции присваивания. Обычно 
эти операции присваивания выполняются внутри инструкции class, 
но они могут находиться в любом другом месте, где имеется ссылка
на один из объектов в дереве.

 Даже методы, которые обычно создаются инструкциями def, вложенными
в инструкцию class, могут создаваться совершенно независимо от объекта 
класса. Например, ниже определяется простая функция вне какого-либо
класса, которая принимает единственный аргумент:
"""


def upper_name(self):
    return self.name.upper()  # Аргумент self по-прежнему необходим


"""
 Здесь еще ничего не говорится о классе – это простая функция
и она может вызываться как обычная функция при условии, что объект,
получаемый ею, имеет атрибут name (в данном случае имя аргумента self
не имеет никакого особого смысла).
"""

print(upper_name(x))  # Вызов, как обычной функции

"""
 Однако, если эту простую функцию присвоить атрибуту нашего класса, она
станет методом, вызываемым из любого экземпляра (а также через имя 
самого класса при условии, что функции вручную будет передан экземпляр):

 Фактически это одна из причин, почему в языке Python аргумент self 
всегда должен явно объявляться в методах, – потому что методы могут 
создаваться как простые функции, независимо от классов, и им необходим 
явный аргумент со ссылкой на подразумеваемый экземпляр. В противном 
случае интерпретатор не смог бы обеспечить превращение простой функции 
в метод класса. Однако основная причина, по которой аргумент self 
объявляется явно, заключается в том, чтобы сделать назначение имен 
более очевидным. Имена, к которым обращаются не через аргумент self, 
являются простыми переменными, тогда как имена, обращение к которым 
происходит через аргумент self, очевидно являются атрибутами экземпляра.
"""

rec.method = upper_name  # Вызов, как обычной функции


print(x.method())  # Вызвать метод для обработки x

print(y.method())  # То же самое, но в self передается y

print(rec.method(x))  # Можно вызвать через имя экземпляра или класса

"""
 Обычно заполнение классов производится внутри инструкции class, 
а атрибуты экземпляров создаются в результате присваивания значений 
атрибутам аргумента self в методах. Однако отметим снова, что все это 
не является обязательным, поскольку ООП в языке Python – это в основном
поиск атрибутов во взаимосвязанных объектах пространств имен.


 Классы и словари
 
 Простые классы из предыдущего раздела призваны лишь проиллюстрировать
основные особенности модели классов. Тем не менее представленные приемы
могут также использоваться в настоящих программах. Например, в главе 8
демонстрировалось, как использовать словари для хранения записей свойств
сущностей в программах. Как оказывается, классы тоже способны играть эту
роль – они могут хранить информацию, как словари, но при этом могут
включать логику обработки этой информации в виде методов. Для справки 
ниже приводится пример использования записи на основе словаря, 
использовавшийся ранее:

>>> rec = {}
>>> rec[‘name’] = ‘mel’  # Запись на основе словаря
>>> rec[‘age’] = 40
>>> rec[‘job’] = ‘trainer/writer’
>>>
>>> print rec[‘name’]
mel

 Этот фрагмент имитирует инструмент, напоминающий записи и структуры
в других языках программирования. Однако, как мы уже видели, существует
еще множество способов сделать то же самое с помощью классов.
Ниже приводится, пожалуй, самый простой из них – замена ключей 
атрибутами:

>>> class rec: pass
...
>>> rec.name = ‘mel’  # Запись на основе класса
>>> rec.age = 40
>>> rec.job = ‘trainer/writer’
>>>
>>> print rec.age
40

 Этот вариант существенно компактнее, чем эквивалент на базе словаря. 
Здесь для создания объекта пустого пространства имен используется 
пустая инструкция class. Создав пустой класс, мы заполняем его, 
присваивая значения его атрибутам.

 Этот прием работает, но для каждой отдельной записи придется писать 
новую инструкцию class. Пожалуй, более удобным будет создавать 
экземпляры класса всякий раз, когда нам потребуется новая запись:

>>> class rec: pass
...
>>> pers1 = rec()  # Запись на основе экземпляра
>>> pers1.name = ‘mel’
>>> pers1.job = ‘trainer’
>>> pers1.age = 40
>>>
>>> pers2 = rec()
>>> pers2.name = ‘dave’
>>> pers2.job = ‘developer’
>>>
>>> pers1.name, pers2.name
(‘mel’, ‘dave’)

 Здесь из одного и того же класса были созданы две записи – экземпляры
класса начинают свое существование пустыми, как и классы. После этого 
производится заполнение записей путем присваивания значений атрибутам.
Однако на этот раз существует два отдельных объекта и, соответственно, 
два разных атрибута name. Фактически у экземпляров одного и того же 
класса не обязательно должны быть одинаковые наборы имен атрибутов.
В данном примере один из экземпляров имеет уникальный атрибут age. 
Экземпляры класса действительно являются разными пространствами имен:
каждый из них имеет свой словарь атрибутов. Обычно экземпляры 
единообразно наполняются атрибутами в методах класса, тем не менее
они обладают большей гибкостью, чем можно было бы ожидать.
 
 Наконец, для реализации записи мы могли бы написать более полноценный
класс:
"""


class Person:
    def __init__(self, name, job):  # Класс = данные + логика
        self.name = name
        self.job = job

    def info(self):
        return self.name, self.job


rec1 = Person('mel', 'trainer')
rec2 = Person('vls', 'developer')

print(rec1.job, rec2.info())

"""
 Такая схема также допускает создание множества экземпляров, но на этот
 раз класс уже не пустой: мы добавили в него логику (методы) 
инициализации экземпляров на этапе создания и сбора атрибутов в кортеж. 
Конструктор налагает некоторые ограничения целостности, требуя значения
для двух атрибутов – name и job. Методы класса и атрибуты экземпляра 
вместе образуют пакет, объединяющий данные и логику.

 Мы могли бы продолжить расширение этой реализации, добавляя методы
для вычисления зарплаты, разбора имен и так далее. В конце концов, 
мы могли бы связать класс в иерархию, чтобы обеспечить наследование 
набора существующих методов через процедуру автоматического поиска
атрибутов классов, и даже записывать экземпляры класса в файл, 
чтобы обеспечить их постоянное хранение. И мы действительно сделаем это 
– в следующей главе мы дополним эту аналогию между классами и записями
более реалистичным примером, демонстрирующим основы использования
классов.

 Наконец, несмотря на всю гибкость таких типов, как словари, классы 
позволяют наделять объекты поведением таким способом, который
встроенными типами и простыми функциями напрямую не поддерживается.
Хотя мы и можем сохранять функции в словарях, тем не менее использование
их для обработки данных в словарях не выглядит столь же естественным, 
как такое их использование в классах.
"""

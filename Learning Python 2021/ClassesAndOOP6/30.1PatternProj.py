"""
 Шаблоны проектирования с классами


 Python и ООП

 Начнем с краткого обзора. Реализацию ООП в языке Python можно свести
к трем следующим идеям:

 Наследование

  Наследование основано на механизме поиска атрибутов в языке Python
 (в выражении X.name).

 Полиморфизм

  Назначение метода method в выражении X.method зависит от типа
 (класса) X.

 Инкапсуляция

  Методы и операторы реализуют поведение; сокрытие данных –
 это соглашение по умолчанию.

 К настоящему времени вы уже должны иметь представление о том,
что такое наследование в языке Python, о полиморфизме в языке Python
– он произрастает из отсутствия объявления типов в языке Python.
Поскольку разрешение имен атрибутов производится на этапе выполнения,
объекты, реализующие одинаковые интерфейсы, являются взаимозаменяемыми –
клиентам не требуется знать тип объекта, реализующего вызываемый метод.

 Инкапсуляция в языке Python означает упаковывание – то есть сокрытие
подробностей реализации за интерфейсом объекта. Это не означает
принудительное сокрытие, но оно может быть реализовано, о чем будет
рассказано в главе 38. Инкапсуляция позволяет изменять реализацию
интерфейсов объекта, не оказывая влияния на пользователей этого объекта.


 Перегрузка посредством сигнатур вызова (точнее, ее невозможность)

 В некоторых объектно-ориентированных языках под полиморфизмом также
понимается возможность перегрузки функций, основанной на сигнатурах
типов их аргументов. Но так как в языке Python отсутствуют объявления
типов, эта концепция в действительности здесь неприменима – полиморфизм
в языке Python основан на интерфейсах объектов, а не на типах.

 Вы можете попробовать выполнить перегрузку методов, изменяя списки
их аргументов, как показано ниже:

class C:
    def meth(self, x):
        ...
    def meth(self, x, y, z):
        ...

 Это вполне работоспособный программный код, но так как инструкция def
просто присваивает объект некоторому имени в области видимости класса,
сохранено будет только последнее определение метода (это все равно,
что записать две инструкции подряд: X = 1, а затем X = 2,
в результате чего X будет иметь значение 2).

 Выбор на основе типа всегда можно реализовать с помощью идеи проверки
типа, с которой мы встречались в главах 4 и 9, или с помощью возможности
передачи списка аргументов, обсуждавшейся в главе 18:


class C:
    def meth(self, *args):
        if len(args) == 1:
            ...
        elif type(arg[0]) == int:
            ...


 Однако обычно этого следует избегать, потому что, как описывалось
в главе 16, следует писать такой код, который опирается на интерфейс
объекта, а не на конкретный тип данных. Такой подход полезнее,
так как охватывает более широкие категории типов и приложений,
как нынешних, так и тех, что появятся в будущем:


class C:
    def meth(self, x):
        x.operation()  # Предполагается, что x работает правильно


 Кроме того, считается, что лучше выбирать разные имена для методов,
выполняющих разные операции, и не полагаться на сигнатуры вызова
(при этом неважно, какой язык программирования вы используете).

 Объектная модель в языке Python достаточно проста, поэтому основное
мастерство владения ООП заключается в умении комбинировать классы
в программе для достижения поставленных целей. В следующем разделе
мы начинаем экскурс по некоторым приемам использования классов
в крупных программах.


 ООП и наследование: взаимосвязи типа «является»

 Мы уже достаточно подробно исследовали механизм наследования,
но мне хотелось бы показать пример того, как может использоваться модель
отношений реального мира. С точки зрения программиста, наследование
вступает в игру с момента появления квалифицированного имени атрибута,
при разрешении которого запускается поиск имен в экземплярах,
в их классах и затем в супер-классах. С точки зрения проектировщика,
наследование – это способ указать принадлежность к некоторому набору:
класс определяет набор свойств, которые могут быть унаследованы
и адаптированы более специализированными наборами (то есть подклассами).

 Чтобы проиллюстрировать сказанное, давайте вернемся к машине
по изготовлению пиццы, о которой мы говорили в начале этой части книги.
Предположим, что мы исследовали альтернативные варианты развития своей
карьеры и решили открыть пиццерию. Первое, что нам предстоит сделать,
это нанять работников для обслуживания клиентов, для приготовления блюд
и так далее. Будучи в глубине души инженерами, мы решили сконструировать
робота по приготовлению пиццы, но, будучи также политически
и кибернетически корректными, мы решили сделать нашего робота
полноправным служащим, которому выплачивается заработная плата.

 Наш коллектив работников пиццерии можно определить четырьмя классами
из файла примера employees.py. Самый общий класс, Employee, реализует
поведение, общее для всех работников, такое как повышение заработной
платы (giveRaise) и вывод на экран (__repr__). Существует две категории
служащих и соответственно, два подкласса, наследующих класс Employee:
Chef (повар) и Server (официант). Оба подкласса переопределяют
унаследованный метод work, чтобы обеспечить вывод более
специализированных сообщений. Наконец, наш робот по приготовлению пиццы
моделируется еще более специализированным классом PizzaRobot,
наследующим класс Chef, который в свою очередь наследует класс Employee.
В терминах ООП мы называем такие взаимоотношения «является»: робот
является поваром, а повар является служащим. Ниже приводится содержимое
файла employees.py:
"""


class Employee:
    def __init__(self, name, salary=0):
        self.name = name
        self.salary = salary

    def giveRaise(self, percent):
        self.salary = self.salary + (self.salary * percent)

    def work(self):
        print(self.name, 'does stuff')

    def __repr__(self):
        return '<Employee: name=%s, salary=%s>' % (self.name,
                                                   self.salary)


class Chef(Employee):
    def __init__(self, name):
        Employee.__init__(self, name, 50000)

    def work(self):
        print(self.name, 'makes food')


class Server(Employee):
    def __init__(self, name):
        Employee.__init__(self, name, 40000)

    def work(self):
        print(self.name, 'interfaces with customer')


class PizzaRobot(Chef):
    def __init__(self, name):
        Chef.__init__(self, name)

    def work(self):
        print(self.name, 'makes pizza')


if __name__ == '__main__':
    bob = PizzaRobot('bob')  # Создать робота с именем bob
    print(bob)  # Вызвать унаследованный метод __repr__
    bob.work()  # Выполнить действие, зависящее от типа
    bob.giveRaise(0.20)  # Увеличить роботу зарплату на 20%
    print(bob)
    print()
    for klass in Employee, Chef, Server, PizzaRobot:
        obj = klass(klass.__name__)
        obj.work()

"""
 Когда выполняется программный код самопроверки, включенный в состав 
модуля, создается робот по приготовлению пиццы с именем bob, который 
наследует атрибуты трех классов: PizzaRobot, Chef и Employee. Например,
при попытке вывести экземпляр bob вызывается метод Employee.__repr__,
а прибавка зарплаты производится методом Employee.giveRaise, потому что
этот метод обнаруживается в процессе поиска в дереве наследования именно
в этом классе:

C:\python\examples> python employees.py
<Employee: name=bob, salary=50000>
bob makes pizza
<Employee: name=bob, salary=60000.0>

Employee does stuff
Chef makes food
Server interfaces with customer
PizzaRobot makes pizza

 В иерархиях классов, подобных этой, обычно можно создавать экземпляры 
любого класса, а не только того, что находится в самом низу. Например, 
в коде самопроверки этого модуля в цикле for создаются экземпляры всех
четырех классов, каждый из которых работает по-разному, потому что все
они имеют различные методы work. В действительности эти классы пока лишь 
имитируют объекты реального мира – в текущей реализации метод work 
просто выводит сообщение, но позднее его можно расширить так, что он
будет выполнять настоящую работу.


 ООП и композиция: взаимосвязи типа «имеет»
 
 Понятие композиции в этой книге было введено в главе 25. С точки зрения
программиста, композиция – это прием встраивания других объектов 
в объект-контейнер и использование их для реализации методов контейнера. 
Для проектировщика композиция – это один из способов представить 
взаимоотношения в прикладной области. Но вместо того, чтобы определять 
принадлежность к множеству, при композиционном подходе все части
объединяются в единое целое.

 Кроме того, композиция отражает взаимоотношения между частями, которые
обычно называются отношениями типа «имеет». В некоторых книгах,
посвященных объектно-ориентированному проектированию, композиция
называется агрегированием (и различие между терминами состоит в том, 
что термин «агрегирование» используется для описания более слабой
зависимости между контейнером и его содержимым); в этой книге термин 
«композиция» используется лишь для обозначения коллекции встраиваемых 
объектов. Вообще составные классы реализуют все свои интерфейсы, 
управляя работой встраиваемых объектов.

 Теперь, когда у нас имеются реализации классов работников, объединим их
в коллектив пиццерии и позволим им приступить к работе. Наша пиццерия –
это составной объект: в нем имеется печь и работники, такие как
официанты и повара. Когда приходит клиент и делает заказ, все компоненты 
пиццерии начинают действовать – официант принимает заказ, повар готовит 
пиццу и так далее. Следующий пример (файл pizzashop.py) имитирует 
все объекты и взаимоотношения между ними:
"""


class Customer:
    def __init__(self, name):
        self.name = name

    def order(self, server):
        print(self.name, 'orders from', server)

    def pay(self, server):
        print(self.name, 'pays for item to', server)


class Oven:
    def bake(self):
        print('oven bakes')


class PizzaShop:
    def __init__(self):
        self.server = Server('Pat')  # Встроить другие объекты
        self.chef = PizzaRobot('Bob')  # Робот по имени Bob
        self.oven = Oven()

    def order(self, name):
        customer = Customer(name)  # Активизировать другие объекты
        customer.order(self.server)  # Клиент делает заказ официанту
        self.chef.work()
        self.oven.bake()
        customer.pay(self.server)


if __name__ == '__main__':
    scene = PizzaShop()  # Создать составной объект
    scene.order('Homer')  # Имитировать заказ клиента Homer
    print('...')
    scene.order('Shaggy')  # Имитировать заказ клиента Shaggy

"""
 Класс PizzaShop – это контейнер и контроллер – это конструктор, который
создает и встраивает экземпляры классов работников, написанные нами
в предыдущем разделе, а также экземпляры класса Oven, который определен
здесь. Когда программный код самопроверки этого модуля вызывает метод 
order класса PizzaShop, встроенным объектам предлагается приступить 
к выполнению своих обязанностей. Обратите внимание, что для каждого 
клиента мы создаем новый экземпляр класса Customer и передаем встроенный
объект Server (официант) методам класса Customer (клиент) – клиенты 
приходят и уходят, а официант остается частью коллектива пиццерии. 
Кроме того, обратите внимание, что работники по-прежнему вовлечены 
во взаимосвязи наследования – композиция и наследование – 
это взаимодополняющие инструменты.

 Если запустить этот модуль, наша пиццерия обслужит два заказа – 
один от Гомера (Homer) и другой от Шэгги (Shaggy):

C:\python\examples> python pizzashop.py
Homer orders from <Employee: name=Pat, salary=40000>
Bob makes pizza
oven bakes
Homer pays for item to <Employee: name=Pat, salary=40000>
...
Shaggy orders from <Employee: name=Pat, salary=40000>
Bob makes pizza
oven bakes
Shaggy pays for item to <Employee: name=Pat, salary=40000>

 Это всего лишь игрушечная имитация, но объекты и взаимодействия между
ними наглядно демонстрируют составные объекты в действии. Классы могут
представлять практически любые объекты и взаимоотношения между ними,
которые можно выразить словами; для этого просто замените имена 
существительные классами, глаголы – методами, и вы получите
первый черновой набросок проекта.
 
 
 Еще раз об обработке потоков
 
 Рассмотрим более реалистичный пример использования приема композиции.
Вспомните универсальную функцию обработки потоков данных, 
которая частично была реализована во введении в ООП в главе 25:

def processor(reader, converter, writer):
    while 1:
        data = reader.read()
        if not data: break
        data = converter(data)
        writer.write(data)
        
 Однако вместо простой функции мы могли бы реализовать обработку в виде
класса, который использует прием композиции, чтобы обеспечить поддержку
наследования и более удобную конструкцию программного кода. 
Одна из возможных реализаций этого класса содержится в файле streams.py
и приводится в ниже:
"""


class Processor:
    def __init__(self, reader, writer):
        self.reader = reader
        self.writer = writer

    def process(self):
        while 1:
            data = self.reader.readline()
            if not data:
                break
            data = self.converter(data)
            self.writer.write(data)

    def converter(self, data):
        assert False, 'converter must be defined'
        # Или возбудить исключение


"""
 Этот класс определяет метод converter, который, как ожидается, будет 
переопределен в подклассах. Это пример использования абстрактных 
супер-классов, с которыми мы познакомились в главе 28 (подробнее
об инструкции assert рассказывается в седьмой части книги).
При таком подходе объекты чтения (reader) и записи (writer) встраиваются 
в экземпляр класса (композиция), а логика преобразования поставляется 
в виде подкласса (наследование), а не в виде отдельной функции.
Ниже приводится содержимое файла converters.py:
"""


class Uppercase(Processor):
    def converter(self, data):
        return data.upper()


if __name__ == '__main__':
    import sys
    obj = Uppercase(open('spam.txt'), sys.stdout)
    obj.process()

"""
 Здесь класс Uppercase наследует логику цикла обработки потока данных
(и все остальное, что может присутствовать в супер-классах).
В нем необходимо  определить лишь то, что будет уникальным для него, – 
логику преобразования данных. Если запустить этот файл, он создаст 
и запустит экземпляр класса Uppercase, который прочитает содержимое 
файла spam.txt, преобразует все символы в верхний регистр и выведет их 
в поток stdout:

C:\lp4e> type spam.txt
spam
Spam
SPAM!
C:\lp4e> python converters.py
SPAM
SPAM
SPAM!

 Для обработки потоков различных видов достаточно передать конструктору
класса объекты требуемых типов. Ниже приводится пример реализации вывода 
в файл вместо стандартного потока вывода:

C:\lp4e> python
>>> import converters
>>> prog = converters.Uppercase(open(‘spam.txt’), 
                                open(‘spamup.txt’, ‘w’))
>>> prog.process()

C:\lp4e> type spamup.txt
SPAM
SPAM
SPAM!

 Но, как предлагалось ранее, мы могли бы также реализовать объекты,
обернутые в классы, которые определяют необходимые интерфейсные методы
ввода и вывода. Ниже приводится простой пример, где вывод осуществляется
через класс, который обертывает выводимый текст в теги HTML:

C:\lp4e> python
>>> from converters import Uppercase
>>>
>>> class HTMLize:
...     def write(self, line):
...         print(‘<PRE>%s</PRE>’ % line.rstrip())
...
>>> Uppercase(open(‘spam.txt’), HTMLize()).process()
<PRE>SPAM</PRE>
<PRE>SPAM</PRE>
<PRE>SPAM!</PRE>

 Если проследить порядок выполнения этого примера, можно заметить, что
было получено два варианта преобразований – приведение символов 
к верхнему регистру (наследованием) и преобразование в формат HTML 
(композицией), хотя основная логика обработки
в оригинальном супер-классе Processor ничего не знает
ни об одном из них. Программному коду, выполняющему обработку,
нужны только метод write – в классах, выполняющих запись,
и метод convert. Его совершенно не интересует, что делают эти методы.
Такой полиморфизм и инкапсуляция логики составляют основу
такой мощи классов.

 В этом примере супер-класс Processor реализует только цикл сканирования
файла. Для выполнения более существенных действий его 
можно было бы расширить, чтобы обеспечить поддержку дополнительных
инструментов в его подклассах и постепенно превратить все это
в полноценный фреймворк. Создав такой инструмент один раз, вы сможете 
многократно использовать его во всех своих программах.
Даже в этом простом примере благодаря тому, что с помощью классов 
можно упаковать и унаследовать так много, все, что нам пришлось сделать, 
– это реализовать этап преобразования в формат HTML, а все остальное 
у нас уже и так имелось.

 Еще один пример композиции в действии приводится в упражнении 9 в конце
главы 31, а его решение – в приложении B. Он напоминает пример
с пиццерией. В этой книге мы сосредоточились на наследовании, 
потому что это основной инструмент, который обеспечивает 
объектно-ориентированные возможности в языке Python. Однако на практике 
прием композиции используется ничуть не реже, чем наследование,
в качестве способа организации классов, особенно в крупных системах.
Как мы видели, наследование и композиция – часто взаимодополняющие 
(а иногда и альтернативные) приемы. Композиция – это проблема 
проектирования, которая далеко выходит за рамки языка Python 
и этой книги, поэтому полный охват этой темы я оставляю за другими
источниками информации.


 Придется держать в уме: классы и их хранение
 
 В этой части книги я уже несколько раз упоминал о возможности 
сохранения объектов с помощью модулей pickle и shelve, потому что 
этот метод особенно хорошо работает с экземплярами классов. 
Эти инструменты достаточно привлекательны, чтобы послужить мотивацией
к использованию классов, – возможность сохранения экземпляров классов
позволяет организовать хранилища, содержащие в себе данные и логику 
ее обработки.

 Например, помимо возможности имитировать взаимодействия 
в реальном мире, классы, разработанные для пиццерии, могли бы также
использоваться как основа базы данных пиццерии. Экземпляры классов
могут сохраняться на диск за одно действие – с помощью модулей pickle
или shelve. В главе 27 мы уже использовали модуль shelve для сохранения 
экземпляров классов, однако интерфейс модуля pickle ничуть не сложнее 
в использовании:

import pickle
object = someClass()
file = open(filename, ‘wb’)  # Создать внешний файл
pickle.dump(object, file)  # Сохранить объект в файле

import pickle
file = open(filename, ‘rb’)
object = pickle.load(file)  # Позднее извлечь обратно

 Модуль pickle преобразует объекты, находящиеся в памяти,
в последовательности байтов (в действительности – в строки), которые 
можно сохранять в файлах, передавать по сети и так далее. При извлечении
объектов происходит обратное преобразование: из последовательности
байтов в идентичные объекты в памяти. Модуль shelve реализует похожую 
возможность, но он автоматически сохраняет объекты в базе данных
с доступом по ключу, которая предоставляет интерфейс, похожий 
на интерфейс словаря:

import shelve
object = someClass()
dbase = shelve.open(‘filename’)
dbase[‘key’] = object  # Сохранить под ключом key

import shelve
dbase = shelve.open(‘filename’)
object = dbase[‘key’]  # Позднее извлечь обратно

 В нашем примере использование классов для моделирования работников 
означает, что можно достаточно легко создать простую базу данных
сотрудников и пиццерий: записывая экземпляры объектов в файл, мы сможем
сохранять их между запусками программы:

>>> from pizzashop import PizzaShop
>>> shop = PizzaShop()
>>> shop.server, shop.chef
(<Employee: name=Pat, salary=40000>, <Employee: name=Bob, salary=50000>)
>>> import pickle
>>> pickle.dump(shop, open(‘shopfile.dat’, ‘wb’))

 Мы можем сохранить в файле весь составной объект, представляющий
пиццерию, одной инструкцией. Чтобы восстановить его в следующем сеансе 
или при очередном запуске программы, также достаточно единственной 
инструкции. При этом после восстановления таким способом объекты 
получают обратно и свои данные, и свою логику работы:

>>> import pickle
>>> obj = pickle.load(open(‘shopfile.dat’, ‘rb’))
>>> obj.server, obj.chef
(<Employee: name=Pat, salary=40000>, <Employee: name=Bob, salary=50000>)
>>> obj.order(‘Sue’)
Sue orders from <Employee: name=Pat, salary=40000>
Bob makes pizza
oven bakes
Sue pays for item to <Employee: name=Pat, salary=40000>

 Более подробную информацию о сохранении ищите в руководстве 
к стандартной библиотеке.
"""

"""
 Более реалистичный пример


 Шаг 1: создание экземпляров

 Итак, все, что требовалось сказать о наших целях, уже сказано, поэтому
теперь перейдем к реализации. Наша первая задача – начать создание
главного класса Person. Откройте в своем любимом текстовом редакторе
новый файл, куда мы будем записывать программный код. В языке Python
существует соглашение, согласно которому имена модулей начинаются
со строчной буквы, а имена классов – с прописной. Точно так же,
в соответствии с соглашениями, первому аргументу методов присваивается
имя self. Эти соглашения не являются обязательными, но они получили
настолько широкое распространение, что отказ от следования им может
ввести в заблуждение тех, кто позднее будет читать ваш программный код.
В соответствии с этими соглашениями мы назовем наш файл person.py,
а классу дадим имя Person, как показано ниже:

# Файл person.py (начало)
class Person:

 До определенного момента в данной главе мы будем работать
с этим файлом. Мы можем запрограммировать в одном файле любое количество
функций и классов, поэтому название person.py может потерять свой смысл,
если позднее мы добавим в него дополнительные компоненты,
никак не связанные с его начальным предназначением. Но пока мы будем
полагать, что все, что находится в этом файле, так или иначе связано
с классом Person. В идеале так и должно быть – как мы уже знаем,
модуль только выигрывает, когда он создан ради единственной, логически
связной цели.


 Конструкторы

 Первое, что нам требуется сделать с классом Person, – это записать
основные сведения о человеке, то есть заполнить поля записи.
На языке Python они называются атрибутами объекта и обычно создаются
с помощью операций присваивания значений атрибутам аргумента self
в методах класса. Обычно первые значения атрибутам экземпляра
присваиваются в методе конструктора __init__, который вызывается
автоматически всякий раз, когда создается новый экземпляр.
Давайте добавим этот конструктор к нашему классу:
"""


# Добавим инициализацию полей записи

class Person:
    def __init__(self, name, job, pay):
        # Конструктор принимает 3 аргумента
        self.name = name  # Заполняет поля при создании
        self.job = job  # self – новый экземпляр класса
        self.pay = pay


"""
 Это достаточно распространенный прием: мы передаем конструктору 
аргументы с данными, которые будут храниться экземпляром, и присваиваем
их атрибутам аргумента self. В терминах ООП аргумент self представляет 
вновь созданный экземпляр, а аргументы name, job и pay превращаются 
в информацию о состоянии – данные, сохраняемые в объекте 
для последующего использования. Для сохранения информации могут
использоваться и другие приемы (такие как ссылки на объемлющую область 
видимости), но атрибуты экземпляра являются более очевидными и простыми
для понимания.

 Обратите внимание, что имена аргументов дважды используются в операциях
присваивания. Этот программный код может на первый взгляд показаться
избыточным, но это не так. Аргумент job, например, – это локальная 
переменная в области видимости функции __init__, а self.job – 
это атрибут экземпляра, который является подразумеваемым контекстом
вызова метода. Это две разные переменные, которые по совпадению имеют 
одно и то же имя. Присваивая значение локальной переменной job атрибуту
self.job с помощью операции self.job=job, мы сохраняем его в экземпляре
для последующего использования. Как обычно, место, где выполняется
присваивание значения имени, определяет смысл этого имени.

 Продолжая разговор об аргументах, отмечу, что в методе __init__ 
нет ничего необычного, кроме того, что он вызывается автоматически 
в момент создания экземпляра и первый его аргумент имеет специальное 
значение. Несмотря на непривычное название, это самая обычная функция, 
обладающая всеми особенностями функций, о которых мы уже знаем. 
Мы можем, например, определить значения по умолчанию для некоторых 
аргументов, чтобы их можно было не указывать в тех случаях,
когда какие-то определенные значения недоступны или бессмысленны.

 Для демонстрации сделаем аргумент job необязательным – по умолчанию 
используем значение None, означающее, что данный человек (в настоящий 
момент) является безработным. Если аргумент job получает значение 
по умолчанию None, вероятно, имеет смысл дать аргументу pay (зарплата) 
значение 0 (если только у вас нет знакомых, которые, 
будучи безработными, получают зарплату!). В действительности,
мы вынуждены указать значение по умолчанию для аргумента pay, потому что
этого требует синтаксис языка Python, – любые аргументы в заголовке 
функции, следующие за первым аргументом, имеющим значение по умолчанию, 
также должны иметь значения по умолчанию:
"""


# Добавим значения по умолчанию для аргументов конструктора
class Person:
    def __init__(self, name, job=None, pay=0):  # Normal function args
        self.name = name
        self.job = job
        self.pay = pay


"""
 Этот программный код означает, что при создании экземпляров класса 
Person нам достаточно будет передавать только значение аргумента name,
а аргументы job и pay теперь являются необязательными – они по умолчанию 
будут получать значения None и 0. Аргумент self, как обычно, 
будет заполняться интерпретатором автоматически, и в нем будет
передаваться ссылка на экземпляр созданного объекта – присваивание 
значений атрибутам объекта self будет присоединять их 
к новому экземпляру.


 Тестирование в процессе разработки
 
 Этот класс пока может не очень много – по сути, он всего лишь заполняет 
поля новой записи, – но это настоящий действующий класс. Теперь 
мы могли бы добавить в него реализацию дополнительных особенностей, 
но пока мы остановимся на достигнутом. Как вы уже, вероятно, начинаете 
понимать, программирование на языке Python в действительности сводится 
к постепенному наращиванию возможностей – вы пишете некоторый 
программный код, тестируете его, добавляете еще программный код,
снова тестируете и так далее. Поскольку Python предоставляет
интерактивную оболочку и возможность практически сразу опробовать 
изменения в программном коде, более естественным представляется 
выполнять тестирование по мере движения вперед, а не после создания 
огромного объема программного кода.

 Прежде чем добавлять дополнительные возможности, давайте протестируем 
то, что у нас уже получилось, создав несколько экземпляров нашего класса
и посмотрев содержимое их атрибутов, созданных конструктором. Мы могли
бы выполнить такое тестирование в интерактивном сеансе, но, как вы уже
наверняка понимаете, тестирование в интерактивном сеансе имеет свои 
ограничения – достаточно утомительно всякий раз при запуске нового 
сеанса выполнять повторное импортирование модулей и повторно вводить 
инструкции. Программисты на языке Python используют интерактивный сеанс 
лишь для простых тестов, а для проведения более полного тестирования 
предпочитают добавлять программный код в конец файла, содержащего 
тестируемые объекты, например:
"""

# Добавляем программный код для самопроверки

bob = Person('Bob Smith')  # Тестирование класса
sue = Person('Sue Jones', job='dev', pay=100000)  # Запустит __init__
#                                                   автоматически
print(bob.name, bob.pay)  # Извлечет атрибуты
print(sue.name, sue.pay)  # Атрибуты в объектах sue и отличаются

"""
 Обратите внимание, что объект bob получает значения атрибутов job и pay
по умолчанию, а для объекта sue значения всех атрибутов указываются 
явно. Отметьте также, что при создании объекта sue мы использовали 
именованные аргументы, – мы могли бы передать значения в виде
позиционных аргументов, однако именованные аргументы позволят нам
позднее вспомнить, какие данные передавались (кроме того, они позволяют
нам указывать аргументы в любом порядке). Напомню еще раз, 
что за исключением необычного имени, метод __init__ – это самая обычная
функция, поддерживающая все особенности функций, которые нам известны,
включая возможность определения значений аргументов по умолчанию
и передачу именованных аргументов.

 Если запустить этот файл как сценарий, программный код в конце файла 
создаст два экземпляра нашего класса и выведет значения двух атрибутов 
для каждого из них (name и pay):

C:\misc> person.py
Bob Smith 0
Sue Jones 100000

 Этот же программный код, выполняющий тестирование, можно было бы ввести 
в интерактивном сеансе (предварительно импортировав класс Person),
но оформление тестов внутри модуля, как в данном примере, существенно
упрощает повторный запуск тестов в будущем.

 Хотя это достаточно простой программный код, тем не менее 
он демонстрирует некоторые важные моменты. Обратите внимание,
что значение атрибута name в объекте bob не совпадает со значением 
атрибута name в объекте sue, а значение атрибута pay в объекте sue 
не совпадает со значением атрибута pay в объекте bob. Каждый из объектов
является независимой записью с собственной информацией. Технически bob 
и sue являются пространствами имен – подобно всем экземплярам класса, 
каждый из них обладает собственной копией информации о состоянии.
Так как каждый экземпляр класса обладает собственным набором атрибутов, 
классы обеспечивают естественный способ сохранения информации 
о множестве объектов – так же, как и встроенные типы, классы играют роль 
своеобразной фабрики объектов. Другие программные конструкции
в языке Python, такие как функции и модули, не обладают такой 
возможностью.


Двоякое использование программного кода

 Тестовый программный код в конце файла работает без нареканий, но здесь
кроется одно большое неудобство – инструкции print на верхнем уровне
будут выполняться и при запуске файла как сценария, и при импортировании
его как модуля. Это означает, что если мы решим импортировать класс 
из этого файла в какой-нибудь программе (что мы и сделаем далее
в этой главе), мы будем наблюдать результаты тестирования всякий раз, 
когда будем импортировать этот файл. Однако это не очень хорошо
для модулей: клиентская программа, вероятно, не должна заботиться 
о внутреннем тестировании, и было бы нежелательно, чтобы выводимые
программой данные перемежались результатами тестирования модуля.

 Мы могли бы поместить программный код тестов в отдельный файл, однако
гораздо удобнее, когда тесты находятся в одном файле с тестируемыми
компонентами. Гораздо лучше оформить тесты так, чтобы они выполнялись, 
только когда файл запускается как сценарий для тестирования,
а не при его импортировании. Как вы уже знаете из предыдущей
части книги, для этой цели можно использовать проверку атрибута __name__
модуля. Соответствующие изменения в файле приводятся ниже:

"""

# Предусмотреть возможность импортировать файл и запускать его,
# как самостоятельный сценарий для самотестирования

if __name__ == '__main__':  # Только когда файл запускается
    # для тестирования. Реализация самотестирования
    bob = Person('Bob Smith')
    sue = Person('Sue Jones', job='dev', pay=100000)
    print(bob.name, bob.pay)
    print(sue.name, sue.pay)

"""
 Теперь мы получили именно то поведение, которого добивались, – 
тестирование выполняется, когда файл запускается как самостоятельный 
сценарий, потому что атрибут __name__ модуля получает значение 
‘__main__’, а при импортировании этого не происходит:

C:\misc> person.py
Bob Smith 0
Sue Jones 100000

c:\misc> python
Python 3.0.1 (r301:69561, Feb 13 2009, 20:04:18) ...
>>> import person
>>>

 Теперь при импортировании файла интерпретатор создаст новый класс,
но не будет использовать его. При запуске файла в качестве сценария 
интерпретатор создаст два экземпляра класса и выведет значения 
двух атрибутов для каждого из них – напомню еще раз, что каждый 
экземпляр является независимым пространством имен, поэтому их атрибуты 
могут иметь различающиеся значения.


 Шаг 2: добавление методов, определяющих поведение
 
 Пока все идет неплохо – к настоящему моменту наш класс фактически 
играет роль фабрики записей – он создает записи и заполняет их поля 
(атрибуты экземпляров, если говорить на языке Python). Однако даже 
при такой ограниченной реализации мы уже можем применять к таким записям 
некоторые операции над объектами. Хотя классы и добавляют дополнительный
структурный уро- вень, тем не менее большую часть своей работы 
они выполняют за счет внедрения и обработки данных базовых типов,
таких как списки и строки. Другими словами, если вы уже знаете
как использовать простые базовые типы данных языка Python, значит,
вы уже многое знаете о классах – в действительности классы являются 
лишь небольшой структурной надстройкой.

 Например, поле name в наших объектах является обычной строкой,
поэтому мы в состоянии извлекать фамилии людей из наших объектов, 
разбивая значение атрибута по пробелам и используя операцию 
индексирования. Все это – операции над базовыми типами данных, 
которые работают независимо от того, входит ли объект операции в состав 
экземпляра класса или нет:

>>> name = ‘Bob Smith’  # Простая строка, за пределами класса
>>> name.split()  # Извлечение фамилии
[‘Bob’, ‘Smith’]
>>> name.split()[-1]  # Или [1], если имя всегда состоит 
‘Smith’               # из 2 компонентов

 Точно так же мы можем увеличить зарплату, изменив значение поля pay, – 
то есть, изменив информацию о состоянии с помощью присваивания. Данная 
операция также относится к базовым операциям в языке Python, действие
которой не зависит от того, является объект операции самостоятельным 
объектом или частью структуры класса:

>>> pay = 100000  # Простая переменная, за пределами класса
>>> pay *= 1.10  # Поднять на 10%. Или: pay = pay * 1.10,
>>> print(pay)  # Или: pay = pay * 1.10, если вы любите вводить 
110000.0  # Или: pay = pay + (pay * .10),                   с клавиатуры
          # если быть более точными!

Чтобы применить те же самые операции к объектам класса Person, созданным
нашим сценарием, просто подставьте имена bob.name и sue.pay на место 
name и pay. Операции останутся теми же самыми, но в качестве объектов
операций будут использоваться атрибуты нашего класса:
"""

# Обработка встроенных типов: строки, изменяемость

if __name__ == '__main__':
    print(bob.name.split()[-1])  # Извлечь фамилию
    sue.pay *= 1.10  # Повысить зарплату
    print(round(sue.pay))

"""
 Здесь мы добавили в конец три новые строки – они извлекают фамилию 
из объекта bob, используя простые операции над строками и списками, 
и поднимают зарплату sue, изменяя значение атрибута pay с помощью 
простой числовой операции. В некотором смысле объект sue является 
изменяемым – он допускает непосредственное изменение своей информации 
о состоянии, подобно списку, при вызове метода append:

Bob Smith 0
Sue Jones 100000
Smith
110000.0

 Предыдущий программный код действует именно так, как и задумывалось,
но если показать его опытному программисту, он наверняка сообщит, 
что такой подход нежелательно применять на практике. Выполнение операций
за пределами класса, как в данном примере, может привести к проблемам 
при сопровождении.

 Например, представьте, что в самых разных местах программы присутствуют
одинаковые фрагменты, извлекающие фамилию. Если вам потребуется изменить 
их (например, в случае изменения структуры поля name), вам придется
отыскать и изменить все такие фрагменты. То же относится и к операции
изменения заработной платы (например, в случае, когда такое изменение 
потребует подтверждения или обновления базы данных) – вам придется
изменить множество копий одного и того же фрагмента. Один только поиск 
всех фрагментов в крупных программах может оказаться весьма 
проблематичной задачей – они могут быть разбросаны по разным файлам, 
разбиты на отдельные операции и так далее.


 Методы реализации
 
 Что нам действительно сейчас необходимо, так это реализовать концепцию
проектирования, которая называется инкапсуляцией. Идея инкапсуляции
заключается в том, чтобы спрятать логику операций за интерфейсами 
и тем самым добиться, чтобы каждая операция имела единственную
реализацию в нашей программе. Благодаря такому подходу, 
если в дальнейшем нам потребуется вносить какие-либо изменения,
модифицировать программный код придется только в одном месте.
Кроме того, мы сможем изменять внутреннюю реализацию операции 
практически как угодно, не рискуя нарушить работоспособность 
программного кода, использующего ее.

 В терминах языка Python это означает, что мы должны реализовать 
операции над объектами в виде методов класса, а не разбрасывать их
по всей программе. Фактически возможность сосредоточить программный код
в одном месте, устранить избыточность и тем самым упростить
его сопровождение является одной из самых сильных сторон классов.
Как дополнительное преимущество, оформление операций в виде методов
позволяет применять их к любым экземплярам класса, а не только к тем, 
которые явно задействованы в обработке. На практике все это выглядит
гораздо проще, чем в теории. В следующем листинге мы переместили 
реализацию двух операций из программы в методы класса, добившись
инкапсуляции. Давайте попутно изменим программный код самопроверки внизу 
файла и заменим в нем жестко запрограммированные операции вызовами 
методов:
"""


# Добавлены методы, инкапсулирующие операции,
# для удобства в сопровождении
class Person:
    def __init__(self, name, job=None, pay=0):
        self.name = name
        self.job = job
        self.pay = pay

    def lastName(self):  # Методы, реализующие поведение экземпляров
        return self.name.split()[-1]  # self – подразумеваемый экземпляр

    def giveRaise(self, percent):
        self.pay = int(self.pay * (1 + percent))  # Изменения придется
        #                                 вносить только в одном месте


if __name__ == '__main__':
    bob = Person('Bob Smith')
    sue = Person('Sue Jones', job='dev', pay=100000)
    print(bob.lastName(), sue.lastName())  # Вместо жестко определенных
    sue.giveRaise(.10)  # операций используются методы
    print(sue.pay)

"""
 Как мы уже знаем, методы – это самые обычные функции, которые
присоединяются к классам и предназначены для обработки экземпляров
этих классов. Экземпляр – это подразумеваемый контекст вызова метода, 
который автоматически передается методу в виде аргумента self.

 Преобразование операций в методы в данной версии программы оказалось 
достаточно простым делом. Новый метод lastName, например,
просто выполняет над объектом self ту же операцию, которая в предыдущей
версии выполнялась над объектом bob. Здесь self – это подразумеваемый
объект, являющийся контекстом вызова метода. Кроме того, метод lastName
возвращает результат. Данная операция фактически является вызовом
функции – она вычисляет значение, которое затем может использоваться 
вызывающей программой, пусть даже просто для вывода. Точно так же
новый метод giveRaise выполняет над объектом self операцию, которая 
в предыдущей версии выполнялась над объектом sue.

 Если теперь запустить наш сценарий, он выведет те же результаты,
что и прежде, – мы всего лишь реструктурировали программный код, 
чтобы упростить возможность его модификации в будущем, не изменяя
его поведения:

Bob Smith 0
Sue Jones 100000
Smith Jones
110000

 Здесь следует отметить несколько интересных особенностей. Во-первых,
обратите внимание, что поле pay (заработная плата) в объекте sue 
по-прежнему получает целочисленное значение после его увеличения – 
внутри метода мы преобразовали результат арифметической операции 
в целое число с помощью встроенной функции int. Выбор типа значения int
или float, вероятно, не имеет существенного значения в большинстве
случаев (целые и вещественные числа обладают одинаковыми интерфейсами 
и могут смешиваться в выражениях), но в действующей системе мы должны 
позаботиться о проблеме округления (деньги все-таки имеют определенную
значимость для людей!).

 Из главы 5 мы знаем, что могли бы также реализовать округление 
до центов с помощью встроенной функции round(N, 2), использовать 
тип decimal для обеспечения фиксированной точности или хранить денежные
суммы в виде вещественных чисел и отображать их с применением строки 
формата %.2f или {0:.2f}. В нашем примере мы просто отсекаем центы 
с помощью функции int. (Еще один способ можно увидеть в модуле 
formats.py, в главе 24, – вы можете импортировать функцию money
и с ее помощью отображать сумму заработной платы с запятыми, центами
и знаком доллара.)

 Во-вторых, обратите также внимание, что на этот раз мы добавили вывод 
фамилии из объекта sue, – поскольку теперь логика получения фамилии была
инкапсулирована в виде метода, мы можем применить ее к любому экземпляру
класса. Как видно из примера, интерпретатор сообщает методу, какой 
экземпляр должен обрабатываться, автоматически передавая его в первом 
аргументе, которому обычно дается имя self. В частности:

  В первом вызове, bob.lastName(), в аргументе self передается 
 подразумеваемый объект bob.
 
  Во втором вызове, sue.lastName(), в аргументе self передается 
 уже объект sue.

 Проследите, как выполняются эти вызовы, чтобы увидеть, как экземпляры
оказываются в аргументе self. Суть заключается в том, что каждый раз
метод извлекает значение атрибута name подразумеваемого объекта. 
То же относится и к методу giveRaise. Мы могли бы попытаться поднять 
зарплату и персоне, представленной объектом bob, вызвав метод giveRaise
для обоих экземпляров, но, к сожалению, нулевая зарплата в объекте bob 
сведет на нет наши усилия, поскольку именно так реализована программа
в настоящее время (возможно, мы пожелаем решить эту проблему в будущей
версии 2.0 нашей программы).

 Наконец, обратите внимание, что метод giveRaise предполагает, 
что в аргументе percent он получит вещественное число в диапазоне 
от нуля до единицы. Возможно, это слишком радикальное предположение 
(хотя увеличение зарплаты на 1000%, вероятно, было бы воспринято 
как ошибка большинством из нас!); в нашем прототипе мы позволим 
передавать числа, выходящие за этот диапазон, но на следующем этапе 
разработки программы было бы желательно добавить проверку значения 
аргумента или хотя бы описать эту особенность в документации. 
В одной из следующих глав мы познакомимся с одним из способов решения 
этой проблемы, когда будем рассматривать декораторы функций 
и исследовать инструкцию assert – альтернативы, позволяющие реализовать
автоматическую проверку в ходе разработки.


 Шаг 3: перегрузка операторов

 К настоящему моменту у нас имеется полноценный класс, позволяющий 
создавать и инициализировать экземпляры и обладающий двумя новыми 
методами, выполняющими обработку экземпляров. Пока все идет 
очень неплохо. Однако тестирование все еще выполняется не так удобно,
как могло бы, – для проверки объектов нам приходится вручную извлекать 
и выводить значения отдельных атрибутов (например, bob.name, sue.pay). 
Было бы совсем неплохо, если бы вывод экземпляра целиком предоставлял
нам некоторую нужную информацию. К сожалению, формат вывода объектов 
экземпляров, используемый по умолчанию, выглядит не очень удобочитаемо – 
он предусматривает вывод имени класса объекта и его адреса в памяти 
(который в языке Python не имеет практической ценности, кроме того,
что идентифицирует объект уникальным образом).

 Чтобы увидеть, как выглядит вывод объектов в этом формате, замените 
последнюю строку в сценарии на вызов print(sue), который отобразит 
объект целиком, Ниже приводится результат запуска измененного сценария 
(здесь видно, что sue – это «object» в версии 3.0 и «instance» 
в версии 2.6):

Bob Smith 0
Sue Jones 100000
Smith Jones
<__main__.Person object at 0x02614430>

 Реализация отображения

 К счастью, большего успеха можно добиться, задействовав возможность
перегрузки операторов, – добавив в класс метод, который перехватывает 
и выполняет встроенную операцию, когда она применяется к экземплярам 
класса. В частности, мы могли бы реализовать метод перегрузки 
операторов, занимающий, пожалуй, второе место по частоте использования
после метода __init__: метод __str__, представленный в предыдущей главе.
Метод __str__ вызывается автоматически всякий раз, когда экземпляр
преобразуется в строку для вывода. Поскольку этот метод используется 
для вывода объекта, фактически все, что мы получаем при выводе объекта,
является возвращаемым значением метода __str__ этого объекта, который 
может быть определен в классе объекта или унаследован от супер-класса
(методы, имена которых начинаются и оканчиваются двумя символами
подчеркивания, наследуются точно так же, как любые другие).

 С технической точки зрения метод конструктора __init__, который мы уже
реализовали, также является методом перегрузки операторов – 
он автоматически вызывается на этапе конструирования для инициализации
вновь созданного экземпляра. Конструкторы используются настолько часто,
что они практически не выглядят, как нечто особенное. Более 
специализированные методы, такие как __str__, позволяют нам 
перехватывать определенные операции и предусматривать специфическую 
реализацию поведения объектов, участвующих в этих операциях.

 Давайте добавим реализацию этого метода в наш класс. Ниже приводится
расширенная версия класса, который выводит список атрибутов 
при отображении экземпляров целиком и не полагается на менее полезную
реализацию вывода по умолчанию:
"""


# Добавлен метод __str__, реализующий вывод объектов
class Person:
    def __init__(self, name, job=None, pay=0):
        self.name = name
        self.job = job
        self.pay = pay

    def lastName(self):
        return self.name.split()[-1]

    def giveRaise(self, percent):
        self.pay = int(self.pay * (1 + percent))

    def __str__(self):  # Добавленный метод
        return '[Person: %s, %s]' % (self.name, self.pay)
        # Строка для вывода


if __name__ == '__main__':
    bob = Person('Bob Smith')
    sue = Person('Sue Jones', job='dev', pay=100000)
    print(bob)
    print(sue)
    sue.giveRaise(.10)
    print(sue)

"""
 Обратите внимание, что здесь в методе __str__ для создания строки 
вывода мы применили оператор форматирования %, – для реализации 
необходимых действий классы могут использовать встроенные типы объектов 
и операции, как в данном случае. Напомню еще раз, все, что мы уже знаем 
о встроенных типах данных и функциях, может применяться при создании
классов. По большому счету, классы всего лишь добавляют дополнительный 
структурный уровень, позволяющий организовать функции и данные в виде 
единого объекта и обеспечивающий возможность расширения.

 Мы также изменили программный код самопроверки – теперь он выводит 
не отдельные атрибуты объектов, а объекты целиком. Если теперь запустить 
этот сценарий, мы получим более понятные и осмысленные результаты – 
функции print автоматически будут вызывать наш новый метод __str__, 
возвращающий строки вида «[...]»:

[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
Smith Jones
[Person: Sue Jones, 110000]

 Несколько важных замечаний: как мы узнаем в следующей главе,
родственный метод __repr__ перегрузки операторов возвращает 
представление объекта в виде программного кода. Иногда классы 
переопределяют оба метода: __str__ – для отображения объектов 
в удобочитаемом формате, для пользователя, и __repr__ – для вывода 
дополнительных сведений об объектах, которые могут представлять интерес 
для разработчика. Поскольку операция вывода автоматически вызывает метод
__str__, а интерактивная оболочка выводит результаты с помощью метода
__repr__, подходящие варианты вывода могут предоставляться обеим 
категориям потенциальных клиентов. Так как нас не интересует 
представление объектов в виде программного кода, нам вполне будет 
достаточно одного метода __str__.


 Шаг 4: адаптация поведения с помощью подклассов
 
 В настоящий момент в нашем классе задействовано большинство механизмов
ООП, имеющихся в языке Python: класс создает экземпляры, обеспечивает
особенности поведения с помощью методов и даже использует перегрузку
операторов, перехватывая операции вывода с помощью метода __str__. 
Он фактически объединяет логику и данные в единый самостоятельный 
программный компонент, упрощая поиск и модификацию программного кода, 
что может потребоваться в будущем. Возможность инкапсуляции также 
позволяет нам организовать программный код так, чтобы избежать 
избыточности и связанных с ней проблем при сопровождении.

 Единственное основное понятие ООП, которое еще не было задействовано, – 
это адаптация программного кода за счет наследования. В некотором смысле 
мы уже использовали наследование – экземпляры наследуют методы своего
класса. Однако для демонстрации истинной мощи ООП нам следует определить
отношение типа супер-класс/подкласс, которое позволит нам расширить
возможности нашего программного обеспечения и немного изменить 
унаследованное поведение. В конце концов, в этом заключается основная
идея ООП –  возможность адаптации уже имеющегося и действующего 
программного кода позволяет существенно сократить время, затрачиваемое 
на разработку.


 Создание подклассов
 
 В качестве следующего шага попробуем применить методологию ООП 
и адаптировать наш класс Person, расширив иерархию объектов. Для этого 
мы определим подкласс с именем Manager, наследующий класс Person, 
в котором мы заместим унаследованный метод giveRaise более
узкоспециализированной версией. Ниже приводится начало определения 
нашего нового класса: class Manager(Person): # Определить подкласс
класса Person Это объявление означает, что мы определяем новый класс 
с именем Manager, который наследует и может адаптировать супер-класс
Person. Говоря простыми словами, класс Manager во многом схож с классом
Person (слишком долгое вступление для маленькой особенности...), 
но при этом класс Manager реализует свой способ увеличения зарплаты.

 Предположим, что из некоторых соображений менеджер (экземпляр класса
Manager) получает не только прибавку, которая передается 
в виде процентов, как обычно, но еще и дополнительную премию, 
по умолчанию составляющую 10%. Например, если прибавка к зарплате 
менеджера составляет 10%, то в действительно, зарплата будет увеличена 
на 20%. (Любое совпадение с реальными лицами, конечно, абсолютно 
случайно.) Наш новый метод начинается, как показано ниже, – поскольку
переопределенный метод giveRaise в дереве наследования оказывается ближе
к экземплярам класса Manager, чем оригинальная реализация
в классе Person, он фактически замещает и тем самым адаптирует операцию.
Напомню, что согласно правилам, поиск в дереве наследования 
оканчивается, как только будет найден первый метод с подходящим именем:

class Manager(Person):  # Наследует атрибута класса Person
    def giveRaise(self, percent, bonus=.10): 
    # Переопределить для адаптации
    
    
 Расширение методов: неправильный способ
 
 Далее, у нас имеется два способа адаптации программного кода в классе
Manager: правильный и неправильный. Начнем с неправильного способа,
потому что он проще для понимания. Неправильный способ заключается
в простом копировании реализации метода giveRaise из класса Person
и его изменении в классе Manager, как показано ниже:

class Manager(Person):
    def giveRaise(self, percent, bonus=.10):
        self.pay = int(self.pay * (1 + percent + bonus))  # Неправильно:
                                                          #  копирование

 Этот метод будет действовать, как и предполагалось, – когда позднее 
мы будем вызывать метод giveRaise относительно экземпляра класса 
Manager, будет выполняться адаптированная версия, которая добавляет
дополнительную премию. Но что же здесь неправильного?

 Проблема здесь самая обычная: всякий раз, когда вы копируете
программный код, вы фактически усложняете его сопровождение в будущем.
Представьте себе: из-за того, что мы скопировали оригинальную версию,
нам придется изменять программный код уже не в одном, а в двух местах,
если позднее нам потребуется (а это наверняка произойдет) изменить
способ увеличения зарплаты. Это достаточно маленький и достаточно 
искусственный пример, тем не менее он наглядно демонстрирует 
общую проблему – всякий раз, когда у вас появляется соблазн скопировать 
программный код, вам наверняка стоит поискать более правильный подход


 Расширение методов: правильный способ
 
 В действительности нам требуется лишь дополнить оригинальный метод
giveRaise, а не заменить его полностью. Правильный способ состоит в том,
чтобы вызвать оригинальную версию с измененными аргументами, 
как показано ниже:
"""


class Manager(Person):
    def giveRaise(self, percent, bonus=.10):
        Person.giveRaise(self, percent + bonus)   # Правильно: дополняет
#                                                   оригинал


"""
 Данная реализация учитывает то обстоятельство, что методы класса могут
вызываться либо обращением к экземпляру (обычный способ, когда 
интерпретатор автоматически передает экземпляр в аргументе self), либо
обращением к классу (менее распространенный способ, когда экземпляр 
передается вручную). Вспомним, что вызов метода:

instance.method(args...)

 автоматически транслируется интерпретатором в эквивалентную форму:
 
class.method(instance, args...)

 где класс, содержащий вызываемый метод, определяется в соответствии
с теми правилами поиска в дереве наследования, которые действуют 
и для методов. В своих сценариях вы можете использовать любую форму 
вызова, но не забывайте о различиях между ними – при обращении
непосредственно к классу вы должны передавать объект экземпляра вручную. 
Метод всегда должен получать объект экземпляра тем или иным способом, 
однако интерпретатор обеспечивает автоматическую его передачу только 
при вызове метода через обращение к экземпляру. При вызове метода через 
обращение к классу вы сами должны передавать экземпляр в аргументе 
self – внутри метода, такого как giveRaise, аргумент self уже содержит 
подразумеваемый объект вызова, то есть сам экземпляр.

 Вызов через обращение к классу фактически отменяет поиск в дереве 
наследования, начиная с экземпляра, и запускает поиск, начиная 
с определенного класса и выше по дереву классов. В нашем случае 
мы можем использовать этот прием для вызова метода giveRaise 
по умолчанию, находящегося в классе Person, невзирая на то, что он был
переопределен в классе Manager. Строго говоря, мы должны были вызвать 
этот метод именно через обращение к классу Person, потому что инструкция 
self.giveRaise() внутри метода giveRaise класса Manager привела бы 
к рекурсии – так как self уже является экземпляром класса Manager, 
инструкция self.giveRaise() интерпретировалась бы, как вызов метода
Manager. giveRaise, и так далее, и так далее, пока не исчерпалась бы 
доступная память. На первый взгляд «правильная» версия мало чем 
отличается от предыдущей, «неправильной», но это может иметь огромное
значение для сопровождения в будущем – поскольку основная логика работы
метода giveRaise теперь находится только в одном месте (метод класса 
Person), в случае необходимости нам придется изменять всего одну версию.
И действительно, такой способ расширения метода более четко отражает
наши намерения – нам требуется выполнить стандартную операцию giveRaise
и просто добавить дополнительную премию. Ниже приводится полное
содержимое файла модуля после выполнения этого последнего шага:
"""

tom = Manager('Tom Jones', 'mgr', 50000)  # Экземпляр Manager: __init__

if __name__ == '__main__':
    tom.giveRaise(.10)  # Вызов адаптированной версии
    print(tom.lastName())  # Вызов унаследованного метода
    print(tom)

"""
 Чтобы проверить работу класса Manager, мы добавили код самопроверки, 
который создает экземпляр класса Manager, вызывает его методы и выводит
этот экземпляр. Ниже приводятся результаты работы обновленной версии 
модуля:

[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
Smith Jones
[Person: Sue Jones, 110000]
Jones
[Person: Tom Jones, 60000]

 Все выглядит совсем неплохо: результаты тестирования с участием 
объектов bob и sue выглядят, как и прежде, а когда для экземпляра tom
класса Manager производится повышение зарплаты на 10%, действительное 
повышение составляет 20% (его зарплата увеличилась с $50K до $60K), 
потому что адаптированная версия метода giveRaise в классе Manager 
вызывается только для этого объекта. Обратите также внимание, 
что при выводе информации об объекте tom используется форматирование, 
определенное в методе __str__ Person: экземпляры класса Manager 
наследуют его, а также методы lastName и __init__ от класса Person.


 Полиморфизм в действии
 
 Чтобы еще более полно задействовать механизм наследования, мы можем 
добавить в конец файла следующий программный код:
"""

if __name__ == '__main__':
    print('--All three--')
    for obj in (bob, sue, tom):
        # Обработка объектов обобщенным способом
        obj.giveRaise(.10)  # Вызовет метод giveRaise этого объекта
        print(obj)  # Вызовет общий метод __str__

"""
 Ниже приводятся результаты его работы:
 
[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
Smith Jones
[Person: Sue Jones, 110000]
Jones
[Person: Tom Jones, 60000]
--All three—
[Person: Bob Smith, 0]
[Person: Sue Jones, 121000]
[Person: Tom Jones, 72000]

 В добавленном программном коде переменная object может ссылаться либо 
на экземпляр класса Person, либо на экземпляр класса Manager, 
а интерпретатор автоматически вызовет соответствующий метод giveRaise –
для объектов bob и sue будет вызвана оригинальная версия метода 
из класса Person, а для объекта tom – адаптированная версия из класса 
Manager. Проследите сами, как интерпретатор выбирает нужную версию
метода giveRaise для каждого объекта. Этот пример демонстрирует действие
понятия полиморфизма в языке Python, с которым мы познакомились ранее, –
действие операции giveRaise зависит от того, к какому объекту 
она применяется. Проявление полиморфизма особенно очевидно, когда его
можно наблюдать на примере выбора метода из классов, написанных нами.
Так как выбор версии метода giveRaise основывается на типе объекта, 
в результате sue получает прибавку в 10%, а tom – прибавку в 20%. 
Как мы уже знаем, полиморфизм составляет основную долю гибкости языка
Python. Передача любого из трех объектов в функцию, вызывающую метод
giveRaise, например, привела бы к тем же самым результатам:
в зависимости от типа полученного объекта автоматически была бы вызвана
соответствующая версия метода.

 С другой стороны, операция вывода вызывает одну и ту же версию метода
__str__ для всех трех объектов, потому что в программном коде 
присутствует только одна его версия – в классе Person. Класс Manager 
может не только адаптировать, но и использовать оригинальную реализацию
в классе Person. Несмотря на небольшой объем, этот пример наглядно 
демонстрирует широкие возможности ООП в адаптации и многократном 
использовании программного кода – при использовании классов это 
в большинстве случаев выполняется автоматически.


 Наследование, адаптация и расширение
 
 В действительности классы могут обладать еще более высокой гибкостью,
чем можно было бы предположить, исходя из нашего примера. В общем случае
классы могут наследовать, адаптировать и расширять существующую 
реализацию супер-классов. В нашем примере мы все свое внимание
сосредоточили на адаптации имеющегося программного кода, однако 
мы точно так же могли бы добавить в класс Manager уникальные методы, 
отсутствующие в классе Person, если бы для класса Manager потребовалось 
реализовать нечто совсем иное (что естественно вытекает из имени 
класса). Такую возможность иллюстрирует следующий фрагмент. Здесь метод 
giveRaise переопределяет метод супер-класса, адаптируя его, а метод
someThingElse является совершенно новым дополнением к классу Manager:


class Person:
    def lastName(self): ...
    def giveRaise(self): ...
    def __str__(self): ...
    
    
class Manager(Person):  # Наследование
    def giveRaise(self, ...): ...  # Адаптация
    def someThingElse(self, ...): ...  # Расширение
    
    
tom = Manager()
tom.lastName()  # Унаследованный метод
tom.giveRaise()  # Адаптированная версия
tom.someThingElse()  # Дополнительный метод
print(tom)  # Унаследованный метод перегрузки

 Дополнительные методы, такие как метод someThingElse в этом примере, 
расширяют возможности существующего программного обеспечения и доступны
только для объектов класса Manager. Для нужд обучения мы ограничились
адаптацией некоторых методов класса Person за счет их переопределения, 
но отказались от добавления новых методов.


 ООП: основная идея
 
 Несмотря на небольшой объем, наш программный код достаточно
функционален. И в действительности он иллюстрирует основное преимущество 
ООП: используя объектно-ориентированный стиль, мы адаптируем имеющийся
программный код, а не копируем и не изменяем его. Это преимущество 
не всегда очевидно для начинающих программистов, особенно на фоне 
дополнительных требований, предъявляемых при создании классов. 
Но в целом применение объектно-ориентированного стиля программирования
способно существенно сократить время разработки, по сравнению 
с другими подходами.

 Так, в нашем примере мы теоретически могли бы реализовать отдельную 
операцию giveRaise, не прибегая к созданию подкласса, но ни один 
из других способов не позволил бы нам получить настолько же оптимальный 
программный код:

  Мы могли бы создать совершенно новый, независимый класс Manager, 
 но при этом нам пришлось бы повторно реализовать все методы, 
 уже присутствующие в классе Person и действующие одинаково
 в классе Manager.

  Мы могли бы просто изменить существующий класс Person, 
 чтобы удовлетворить требованиям, предъявляемым к методу giveRaise 
 класса Manager, но при этом нарушилась бы корректная работа там,
 где требуется оригинальное поведение класса Person.

  Мы могли бы просто скопировать класс Person целиком, присвоить копии
 имя Manager и изменить метод giveRaise, но при этом наш программный код
 стал бы избыточным, что усложнило бы его сопровождение в будущем –
 изменения в классе Person не будут автоматически отражаться на классе
 Manager, и нам придется вручную переносить эти изменения в реализацию
 класса Manager. Прием, основанный на копировании, может показаться
 самым быстрым, но он удваивает объем работы, которую придется 
 проделывать в будущем.

 Адаптируемые иерархии, которые мы можем конструировать с помощью 
классов, обеспечивают более оптимальное решение для программного 
обеспечения, которое предполагается развивать в течение длительного 
времени. Никакие другие средства языка Python не поддерживают подобный 
режим разработки. Благодаря тому, что мы можем адаптировать и расширять 
наши предыдущие наработки с помощью новых подклассов, мы можем
использовать то, что уже действует, и не создавать каждый раз 
все заново, ломая то, что уже работает, или добавляя множество копий 
программного кода, которые придется обновлять в будущем. При правильном
применении ООП становится сильным союзником программиста.
"""

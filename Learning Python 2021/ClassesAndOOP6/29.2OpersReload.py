"""
 Обращения к атрибутам: __getattr__ и __setattr__

 Метод __getattr__ выполняет операцию получения ссылки на атрибут.
Если говорить более определенно, он вызывается с именем атрибута в виде
строки всякий раз, когда обнаруживается попытка получить ссылку
на неопределенный (несуществующий) атрибут. Этот метод не вызывается,
если интерпретатор может обнаружить атрибут посредством выполнения
процедуры поиска в дереве наследования. Вследствие этого метод
__getattr__ удобно использовать для обобщенной обработки запросов
к атрибутам. Например:

\>>> class empty:
...     def __getattr__(self, attrname):
...         if attrname == “age”:
...             return 40
...         else:
...             raise AttributeError, attrname
...
\>>> X = empty()
\>>> X.age
40
\>>> X.name
...текст сообщения об ошибке опущен...
AttributeError: name

 В этом примере класс empty и его экземпляр X не имеют своих собственных
атрибутов, поэтому при обращении к атрибуту X.age вызывается метод
__getattr__ – в аргументе self передается экземпляр (X)
а в аргументе attrname – строка с именем неопределенного атрибута
(“age”). Класс выглядит так, как если бы он действительно имел атрибут
age, возвращая результат обращения к имени X.age(40). В результате
получается атрибут, вычисляемый динамически. Для атрибутов, обработка
которых классом не предусматривается, метод __setattr__ возбуждает
встроенное исключение AttributeError, чтобы сообщить интерпретатору,
что это действительно неопределенные имена, – попытка обращения
к имени X.name приводит к появлению ошибки. Вы еще раз встретитесь
с методом __getattr__, когда мы будем рассматривать делегирование
и свойства в действии в следующих двух главах, а об исключениях
я подробно буду рассказывать в седьмой части книги.

 Родственный ему метод перегрузки __setattr__ перехватывает все попытки
присваивания значений атрибутам. Если этот метод определен,
выражение self.attr = value будет преобразовано в вызов метода
self.__setattr_(‘attr’, value). Работать с этим методом немного сложнее,
потому что любая попытка выполнить присваивание любому атрибуту
аргумента self приводит к повторному вызову метода __setattr__, вызывая
бесконечный цикл рекурсивных вызовов (и, в конечном итоге, исключение
переполнения стека!). Если вам потребуется использовать этот метод,
все присваивания в нем придется выполнять посредством словаря атрибутов,
как описывается в следующем разделе. Используйте
self.__dict__[‘name’] = x, а не self.name = x:
"""


class accesscontrol:
    def __setattr__(self, attr, value):
        if attr == 'age':
            self.__dict__[attr] = value
        else:
            raise AttributeError('%s not allowed' % attr)


X = accesscontrol()
X.age = 40  # Вызовет метод __setattr__
print(X.age)

# X.name = 'mel'

"""
 Эти два метода перегрузки операций доступа к атрибутам позволяют 
контролировать или специализировать доступ к атрибутам в ваших объектах.
Они могут играть весьма специфические роли, часть из которых 
мы рассмотрим далее в этой книге.


 Имитация частных атрибутов экземпляра: часть 1
 
 Следующий фрагмент является обобщением предыдущего примера и позволяет 
каждому подклассу иметь свой перечень частных имен атрибутов, которым
нельзя присваивать значения в экземплярах:
"""


class PrivateExc(Exception):
    pass  # Подробнее об исключениях позднее


class Privacy:
    def __setattr__(self, attrname, value):
        # Вызывается self.attrname = value
        if attrname in self.privates:
            raise PrivateExc(attrname, self)
        else:
            self.__dict__[attrname] = value  # Self.attrname = value
            #                                  вызовет зацикливание!


class Test1(Privacy):
    privates = ['age']


class Test2(Privacy):
    privates = ['name', 'pay']

    def __init__(self):
        self.__dict__['name'] = 'Tom'


x = Test1()
y = Test2()
x.name = 'Bob'
# y.name = 'Sue'  # <== ошибка
y.age = 30
# x.age = 40  # <== ошибка

"""
 Фактически это лишь первая прикидочная реализация частных атрибутов
в языке Python (то есть запрет на изменение атрибутов вне класса).
Несмотря на то что язык Python не поддерживает возможность объявления
частных атрибутов, такие приемы, как этот, могут их имитировать. 
Однако это лишь половинчатое решение – чтобы сделать его более 
эффективным, его необходимо дополнить возможностью изменять значения
частных атрибутов из подклассов и использовать метод __getattr__ 
и класс-обертку (иногда называется прокси-классом), чтобы контролировать
получение значений частных атрибутов.

 Рассмотрение полной реализации мы отложим до главы 38, 
где для выполнения операций над атрибутами и проверки их значений 
мы будем использовать более универсальный способ, основанный 
на применении декораторов классов. Однако, хотя таким способом можно 
имитировать сокрытие атрибутов, тем не менее он почти никогда 
не используется на практике. Программисты, использующие язык Python,
способны писать крупные объектно-ориентированные системы без частных 
объявлений, но существующие интересные решения по управлению доступом 
выходят далеко за рамки нашего обсуждения.

 Перехват операций обращения к атрибутам и присваивания им значений –
вообще очень полезный прием. Он обеспечивает возможность делегирования –
способ, позволяющий обертывать встроенные объекты 
объектами-контроллерами, добавлять новое поведение и делегировать
выполнение операций обернутым объектам (подробнее о делегировании 
и классах-обертках рассказывается в главе 30).


 Строковое представление объектов: __repr__ и __str__
 
 В следующем примере реализованы конструктор __init__ и метод перегрузки
__add__, которые мы уже видели, но в нем также реализован 
метод __repr__, который возвращает строковое представление экземпляров. 
Здесь этот метод используется для преобразования объекта self.data 
в строку. Если метод __repr__ (или родственный ему метод __str__) 
определен, он автоматически будет вызываться при попытках вывести 
экземпляр класса или преобразовать его в строку. Эти методы позволяют
определить более удобочитаемый формат вывода ваших объектов.

 Строковое представление объектов по умолчанию не содержит полезной 
информации и имеет неудобочитаемый внешний вид:
"""


class adder:
    def __init__(self, value=0):
        self.data = value  # Инициализировать атрибут data

    def __add__(self, other):
        self.data += other  # Прибавить другое значение


x = adder()  # Формат отображения по умолчанию
print(x)

repr(x)

"""
 Но возможность реализовать или унаследовать методы преобразования 
экземпляров в строковое представление позволяет нам обеспечить вывод
дополнительной информации и предусмотреть ее форматирование:

>>> class addrepr(adder):  # Наследует __init__, __add__
...     def __repr__(self):  # Добавляет строковое представление
...         return ‘addrepr(%s)’ % self.data  # Преобразует в строку
...         #                                   программного кода
>>> x = addrepr(2)  # Вызовет __init__
>>> x + 1  # Вызовет __add__
>>> x  # Вызовет __repr__
addrepr(3)
>>> print x  # Вызовет __repr__
addrepr(3)
>>> str(x), repr(x)  # Вызовет __repr__
(‘addrepr(3)’, ‘addrepr(3)’)

 Почему имеется два метода вывода? Дело вот в чем:

  Встроенные функции print и str (а также ее внутренний эквивалент, 
 который используется функцией print) сначала пытаются использовать 
 метод __str__. Вообще этот метод должен возвращать строковое 
 представление объекта в удобном для пользователя виде.

  Во всех остальных случаях используется метод __repr__:
 функцией автоматического вывода в интерактивной оболочке, функцией 
 repr, при выводе вложенных объектов, а также функциями print и str, 
 когда в классе отсутствует метод __str__. Вообще этот метод должен 
 возвращать строку, которая могла бы использоваться как программный код 
 для воссоздания объекта или содержать информацию, полезную
 для разработчиков.
 
 Проще говоря, метод __repr__ используется везде, за исключением функций
print и str, если определен метод __str__. Однако, если метод __str__ 
отсутствует, операции вывода будут использовать метод __repr__, 
но не наоборот – в остальных случаях, например, функцией автоматического 
вывода в интерактивной оболочке всегда используется только 
метод __repr__; попытка использовать метод __str__
даже не предпринимается:

>>> class addstr(adder):
...     def __str__(self):  # есть __str__, но нет __repr__
...         return ‘[Value: %s]’ % self.data 
            # Преобразовать в красивую строку
...
>>> x = addstr(3)
>>> x + 1
>>> x  # По умолчанию вызывается __repr__
<__main__.addstr instance at 0x00B35EF0>
>>> print x  # Вызовет __str__
[Value: 4]
>>> str(x), repr(x)
(‘[Value: 4]’, ‘<__main__.addstr instance at 0x00B35EF0>’)

 Вследствие этого, если вам необходимо обеспечить единое отображение 
во всех контекстах, лучше использовать метод __repr__. Однако, определив
оба метода, вы обеспечите поддержку вывода в различных контекстах. 
Например, перед конечным пользователем объект будет отображаться 
с помощью метода __str__, а перед программистом будет выводиться 
информация более низкого уровня с помощью метода __repr__:
"""


class addboth(adder):
    def __str__(self):
        return '[Value: %s]' % self.data  # Удобочитаемая строка

    def __repr__(self):
        return 'addboth(%s)' % self.data  # Строка программного кода


x = addboth(4)
x + 1
print(repr(x))  # Вызовет __repr__

print(x)  # Вызовет __str__

print(str(x))
print(repr(x))


"""
 Здесь я должен сделать два примечания, касающиеся использования. 
Во-первых, имейте в виду, что оба метода, __str__ и __repr__, должны 
возвращать строки – возвращаемые значения других типов не преобразуются
в строки и вызывают ошибку, поэтому не забывайте выполнять 
преобразование в случае необходимости. Во-вторых, в зависимости 
от логики преобразования в строковое представление, реализованной 
в контейнерном объекте, операция вывода может вызывать метод __str__ 
только для объектов верхнего уровня - вложенные объекты по-прежнему
могут выводиться с применением их методов __repr__ или метода 
по умолчанию. Оба эти примечания иллюстрируются в следующем примере:
"""


class Printer:
    def __init__(self, val):
        self.val = val

    def __str__(self):  # Используется для вывода самого экземпляра
        return str(self.val)  # Преобразует результат в строку


objs = [Printer(2), Printer(3)]
for x in objs:
    print(x)  # При выводе экземпляра будет вызван
# __str__, но не тогда, когда экземпляр 2
# находится в списке!

print(objs)

print(repr(objs))

"""
 Чтобы обеспечить вызов адаптированной версии метода во всех случаях, 
независимо от реализации контейнера, реализуйте метод __repr__, 
а не __str__ – первый из них вызывается во всех случаях, где последний 
не может быть применен:
"""


class Printer:
    def __init__(self, val):
        self.val = val

    def __repr__(self):  # __repr__ используется print, если нет __str__
        return str(self.val)  # __repr__ используется интерактивной
#                             оболочкой и для вывода вложенных объектов


objs = [Printer(2), Printer(3)]
for x in objs:
    print(x)  # Нет __str__: вызовет __repr__


print(objs)  # Вызовет __repr__, а не ___str__

print(repr(objs))

"""
 На практике метод __str__ (и его низкоуровневый родственник __repr__) 
является вторым по частоте использования после __init__ среди методов 
перегрузки операторов в сценариях на языке Python. Всякий раз, 
когда вам приходится видеть адаптированное отображение при выводе
объекта, это значит, что скорее всего был использован один 
из этих методов.


 Правостороннее сложение и операция приращения: __radd__ и __iadd__

 C технической точки зрения метод __add__, который использовался 
в примерах выше, не поддерживает использование объектов экземпляров 
справа от оператора +. Чтобы реализовать поддержку таких выражений 
и тем самым обеспечить допустимость перестановки операндов, необходимо
реализовать метод __radd__. Интерпретатор вызывает метод __radd__, 
только когда экземпляр вашего класса появляется справа от оператора +, 
а объект слева не является экземпляром вашего класса. Во всех других 
случаях, когда объект появляется слева, вызывается метод __add__:
"""


class Commuter:
    def __init__(self, val):
        self.val = val

    def __add__(self, other):
        print('add', self.val, other)
        return self.val + other

    def __radd__(self, other):
        print('radd', self.val, other)
        return other + self.val


x = Commuter(88)
y = Commuter(99)
x + 1  # __add__: экземпляр + не_экземпляр
1 + y  # __radd__: не_экземпляр + экземпляр
p = x + y  # __add__: экземпляр + экземпляр
print(repr(p))

"""
 Обратите внимание на изменение порядка следования операндов в вызове 
метода __radd__: аргумент self в действительности находится справа 
от оператора +, а аргумент other – слева. Кроме того, следует заметить,
что здесь x и y – это экземпляры одного и того же класса, – когда 
в выражении участвуют экземпляры разных классов, интерпретатор 
предпочитает вызывать метод экземпляра, расположенного слева. Когда 
выполняется операция сложения двух экземпляров, интерпретатор вызывает
метод __add__, который в свою очередь вызывает метод __radd__, упрощая 
левый операнд.

 На практике, когда требуется распространить тип класса на результат, 
реализация может оказаться сложнее: может оказаться необходимым 
выполнить проверку типа, чтобы убедиться в безопасности операции 
преобразовании и избежать вложенности. Так, если в следующем примере 
не выполнять проверку типа с помощью функции isinstance, дело может 
закончиться тем, что мы получим экземпляр класса Commuter, значением
атрибута val которого является другой экземпляр класса Commuter, –
при сложении двух экземпляров, когда метод __add__ вызывает метод
__radd__:
"""


class Commuter:  # Тип класса распространяется на результат
    def __init__(self, val):
        self.val = val

    def __add__(self, other):
        if isinstance(other, Commuter):
            other = other.val
            
        return Commuter(self.val + other)

    def __radd__(self, other):
        return Commuter(other + self.val)

    def __str__(self):
        return '<Commuter: %s>' % self.val


x = Commuter(88)
y = Commuter(99)
print(x + 10)  # Результат – другой экземпляр класса Commuter

print(10 + y)

z = x + y  # Нет вложения: не происходит рекурсивный вызов __radd__
print(z)

print(z + 10)

print(z + z)

"""
 Комбинированная операция сложения
 
 Чтобы обеспечить поддержку комбинированной операции сложения +=, 
увеличивающей значение экземпляра, необходимо реализовать метод __iadd__ 
или __add__. Последний из них используется в случае отсутствия первого.
Фактически класс Commuter, представленный в предыдущем разделе, 
уже поддерживает операцию +=, однако с помощью метода __iadd__ можно 
реализовать более эффективную операцию изменения самого экземпляра:
"""


class Number:
    def __init__(self, val):
        self.val = val

    def __iadd__(self, other):  # __iadd__ явно реализует
        #                         операцию x += y
        self.val += other  # Обычно возвращает self
        return self


x = Number(5)
x += 1
x += 1
print(x.val)


class Number:
    def __init__(self, val):
        self.val = val

    def __add__(self, other):  # __add__ - как крайнее средство:
        #                        x = (x + y)
        return Number(self.val + other)  # Распространяет тип класса


x = Number(5)
x += 1
x += 1
print(x.val)

"""
 Любой двухместный оператор имеет похожий правосторонний метод 
перегрузки и метод, реализующий комбинированную операцию присваивания 
(например, __mul__, __rmul__ и __imul__). Правосторонние методы –
это достаточно сложная тема, и на практике они используются очень редко 
– к ним требуется обращаться только в том случае, когда необходимо 
обеспечить для оператора возможность перестановки операндов, 
и если вообще необходима реализация поддержки этого оператора. Например, 
эти методы могут использоваться в классе Vector, но в таких классах, 
как Employee или Button, скорее всего, они не нужны.


 Операция вызова: __call__
 
 Метод __call__ вызывается при обращении к экземпляру как к функции. 
Это не повторяющееся определение – если метод __call__ присутствует,
интерпретатор будет вызывать его, когда экземпляр вызывается
как функция, передавая ему любые позиционные и именованные аргументы:

>>> class Callee:
...     def __call__(self, *pargs, **kargs):  # Реализует вызов 
                                                экземпляра
...         print(‘Called:’, pargs, kargs) #  Принимает любые аргументы
...
>>> C = Callee()
>>> C(1, 2, 3)  # C – вызываемый объект
Called: (1, 2, 3) {}
>>> C(1, 2, 3, x=4, y=5)
Called: (1, 2, 3) {‘y’: 5, ‘x’: 4}

 Выражаясь более формальным языком, метод __call__ поддерживает все 
схемы передачи аргументов, обсуждавшиеся в главе 18, – все, 
что передается экземпляру, передается этому методу наряду с обычным
аргументом self, в котором передается сам экземпляр. Например, следующие
определения метода:


class C:
    def __call__(self, a, b, c=5, d=6): ... # Обычные и со значениями
# по умолчанию


class C:
    def __call__(self, *pargs, **kargs): ... # Произвольные аргументы
    
    
class C:
    def __call__(self, *pargs, d=6, **kargs): ... # Аргументы, которые 
                       # могут передаваться только по имени в версии 3.0
                       
                       
 соответствуют следующим вызовам экземпляра:
 
X = C()
X(1, 2)  # Аргументы со значениями по умолчанию опущены
X(1, 2, 3, 4)  # Позиционные
X(a=1, b=2, d=4)  # Именованные
X(*[1, 2], **dict(c=3, d=4))  # Распаковывание произвольных аргументов
X(1, *(2,), c=3, **dict(d=4))  # Смешанные режимы

 Суть состоит в том, что классы и экземпляры, имеющие метод __call__, 
поддерживают тот же синтаксис и семантику передачи аргументов,
что и обычные функции и методы.

 Реализация операции вызова, как в данном примере, позволяет экземплярам
классов имитировать поведение функций, а также сохранять информацию
о состоянии между вызовами (похожий пример мы видели в главе 17, 
когда исследовали области видимости, но теперь вы больше знаете
о перегрузке операторов):
"""


class Prod:
    def __init__(self, value):  # Принимает единственный аргумент
        self.value = value

    def __call__(self, other):
        return self.value * other


x = Prod(2)  # “Запоминает” 2 в своей области видимости
x(3)  # 3 (передано) * 2 (сохраненное значение)

x(4)

"""
 В этом примере реализация метода __call__ может показаться ненужной.
То же самое поведение можно реализовать с помощью простого метода:

>>> class Prod:
...     def __init__(self, value):
...         self.value = value
...     def comp(self, other):
...         return self.value * other
...
>>> x = Prod(3)
>>> x.comp(3)
9
>>> x.comp(4)
12

 Однако метод __call__ может оказаться удобнее при взаимодействии
с прикладными интерфейсами, где ожидается функция, – это позволяет 
создавать объекты, совместимые с интерфейсами, ожидающими получить 
функцию, которые к тому же способны сохранять информацию о своем 
состоянии между вызовами. Фактически этот метод занимает третье место 
среди наиболее часто используемых методов перегрузки операторов –
после конструктора __init__ и методов форматирования __str__ и __repr__.


 Функциональные интерфейсы и программный код обратного вызова
 
 Инструментальный набор для создания графического интерфейса tkinter
(Tkinter, в Python 2.6) позволяет регистрировать функции как обработчики
событий (они же – функции обратного вызова); когда возникают какие-либо
события, tkinter вызывает зарегистрированные объекты. Если вам 
необходимо реализовать обработчик событий, способный сохранять свое 
состояние между вызовами, вы можете либо зарегистрировать связанный 
метод класса, либо экземпляр класса, который с помощью метода __call__ 
обеспечивает совместимость с функциональным интерфейсом. В программном 
коде этого раздела оба варианта – x.comp из второго примера 
и экземпляр x из первого – могут передаваться в виде объектов функций.

 В следующей главе я более подробно расскажу о связанных методах, а пока
разберем гипотетический пример использования метода __call__ 
для построения графического интерфейса. Следующий класс определяет 
объект, поддерживающий функциональный интерфейс, и, кроме того, имеет 
информацию о состоянии, сохраняя цвет, в который должна окрашиваться 
нажатая кнопка:
"""

from tkinter import Button


class Callback:
    def __init__(self, color):  # Функция + информация о состоянии
        self.color = color

    def __call__(self):  # Поддерживает вызовы без аргументов
        print('turn', self.color)


"""
 Теперь мы можем зарегистрировать экземпляры этого класса в контексте 
графического интерфейса, как обработчики событий для кнопок, 
несмотря на то, что реализация графического интерфейса предполагает 
вызывать обработчики событий как обычные функции без аргументов:
"""

cb1 = Callback('blue')  # ‘Запомнить’ голубой цвет
cb2 = Callback('green')
B1 = Button(command=cb1)  # Зарегистрировать обработчик
B2 = Button(command=cb2)  # Зарегистрировать обработчик

"""
 Когда позднее кнопка будет нажата, объект экземпляра будет вызван как 
простая функция, точно как в следующих ниже вызовах. А поскольку он 
сохраняет информацию о состоянии в атрибутах экземпляра, он помнит, 
что необходимо сделать:
"""

cb1()  # По событию: выведет ‘blue’
cb2()  # Выведет ‘green

"""
 Фактически это один из лучших способов сохранения информации 
о состоянии в языке Python – он намного лучше способов, обсуждавшихся
ранее и применявшихся к функциям (глобальные переменные, ссылки 
в область видимости объемлющей функции и изменяемые аргументы
со значениями по умолчанию). Благодаря ООП состояние можно сохранять 
явно, посредством присваивания значений атрибутам.

 Прежде чем двинуться дальше, рассмотрим еще два способа, которые 
используются программистами для сохранения информации о состоянии 
в функциях обратного вызова. В первом варианте используется
lambda-функция с аргументами, имеющими значения по умолчанию:
"""

cb3 = (lambda color='red': 'turn ' + color)  # Или: по умолчанию
print(cb3())

"""
 Во втором – используются связанные методы класса. Объект связанного 
метода – это объект, который запоминает экземпляр self и ссылку 
на функцию, так что потом можно вызывать простую функцию 
без использования экземпляра:
"""


class Callback:
    def __init__(self, color):  # Класс с информацией о состоянии
        self.color = color

    def changeColor(self):  # Обычный метод
        print('turn', self.color)


cb1 = Callback('blue')
cb2 = Callback('yellow')

B1 = Button(command=cb1.changeColor)  # Ссылка, не вызов
B2 = Button(command=cb2.changeColor)  # Запоминаются функция+self

"""
 Когда позднее кнопка будет нажата, имитируется поведение графического
интерфейса и вызывается метод changeColor, который обработает информацию
о состоянии объекта:
"""

obj = Callback('blue')
cb = obj.changeColor  # Регистрация обработчика событий
cb()  # По событию выведет ‘blue’

"""
 Кроме того, в главе 31 будет представлен еще один пример использования 
метода __call__, который будет использоваться для реализации 
так называемого декоратора функции – вызываемого объекта, добавляющего
уровень логики поверх самой функции. Поскольку метод __call__ позволяет
присоединять информацию о состоянии к вызываемым объектам, этот прием
является естественным для реализации функций, которые должны запоминать 
и вызывать другие функции.


 Сравнение: __lt__, __gt__ и другие
 
 Как следует из табл. 29.1, классы могут определять методы, реализующие
все шесть операций сравнения: <, >, <=, >=, == и !=. Обычно эти методы 
достаточно просты в реализации, но имейте в виду следующее:

  В отличие от методов __add__/__radd__, обсуждавшихся выше, методы 
 сравнения не имеют правосторонних версий. Вместо этого, когда операцию
 сравнения поддерживает только один операнд, используются зеркальные
 методы сравнивания (например, методы __lt__ и __gt__ являются 
 зеркальными по отношению друг к другу).

  Среди операторов сравнения нет неявных взаимоотношений. Суть в том,
 что истинность операции == не предполагает ложность операции !=, 
 например, чтобы гарантировать корректное поведение обоих операторов, 
 требуется реализовать оба метода, __eq__ и __ne__.

  В Python 2.6 все операции сравнения можно было реализовать в виде 
 одного метода __cmp__ – он должен выполнить сравнивание (self с другим 
 операндом) и вернуть число меньшее, равное или большее нуля, чтобы 
 показать, что аргумент self меньше, равен или больше второго аргумента
 соответственно. На практике для получения результата в этом методе
 часто используется встроенная функция cmp(x, y). В Python 3.0 
 метод __cmp__ и встроенная функция cmp были удалены: вместо них следует
 использовать более специализированные методы.

 Из-за экономии места в книге мы не имеем возможности провести полное 
обсуждение всех особенностей методов сравнения, однако, в качестве 
краткого введения, исследуем следующий класс и программный код 
его проверки:
"""


class C:
    data = 'spam'

    def __gt__(self, other):  # версии 3.0 и 2.6
        return self.data > other

    def __lt__(self, other):
        return self.data < other


X = C()
print(X > 'ham')  # Выведет True (вызовет __gt__)
print(X < 'ham')  # Выведет False (вызовет __lt__)

"""
 Этот сценарий выведет одинаковые результаты в Python 3.0 и 2.6, 
инструкции print в конце сценария выведут вполне ожидаемые результаты,
как отмечено в комментариях, потому что класс реализует 
специализированные методы сравнения.


Проверка логического значения: __bool__ и __len__

 Как уже упоминалось выше, классы могут также определять методы, 
выражающие логическую природу их экземпляров, – в логическом контексте 
интерпретатор сначала пытается напрямую получить логическое значение
с помощью метода __bool__ и только потом, если этот метод не реализован,
пытается вызвать метод __len__ , чтобы выяснить истинность объекта, 
исходя из его длины. Обычно первый из них возвращает логическое 
значение, исходя из значений атрибутов объекта или другой информации:
"""


class Truth:
    def __bool__(self): return True


X = Truth()
if X:
    print('yes!')


class Truth:
    def __bool__(self): return False


X = Truth()
print(bool(X))

"""
 Если этот метод отсутствует, интерпретатор пытается определить длину 
объекта, поскольку непустой объект интерпретируется как истинный 
(то есть, если длина не равна нулю, в логическом контексте такому
объекту соответствует значение True, в противном случае – False):
"""


class Truth:
    def __len__(self): return 0


X = Truth()
if not X:
    print('no!')

"""
 Если в классе реализованы оба метода, предпочтение отдается методу
__bool__, потому что он является более специализированным:
"""


class Truth:
    def __bool__(self): return True  # в 3.0 первым опробуется __bool__
    def __len__(self): return 0  # в 2.6 первым опробуется __len__


X = Truth()
if X:
    print('yes!')

"""
 Если ни один из методов не определен, объект просто считается истинным 
(в чем вполне можно усмотреть смысл, особенно если вы склонны 
к метафизическим рассуждениям!):
"""


class Truth:
    pass


X = Truth()
print(bool(X))

"""
 Теперь, после того, как нам пришлось соприкоснуться 
с областью философии, обратим свой взгляд на последний метод перегрузки
операторов, который реализует уничтожение объектов.


 Уничтожение объектов: __del__
 
 Конструктор __init__ вызывается во время создания экземпляра. 
Противоположный ему метод __del__ вызывается автоматически, когда
освобождается память, занятая объектом (то есть во время 
"сборки мусора"):
"""


class Life:
    def __init__(self, name='unknown'):
        print('Hello', name)
        self.name = name

    def __del__(self):
        print('Goodbye', self.name)


brian = Life('Brian')

brian = 'loretta'

"""
 Здесь, когда переменной brian присваивается строка, теряется последняя
ссылка на экземпляр класса Life, что приводит к вызову деструктора. 
Этот метод удобно использовать для реализации некоторых заключительных 
действий (таких как завершение соединения с сервером). Однако в языке 
Python по целому ряду причин деструкторы используются не так часто, 
как в других объектно-ориентированных языках программирования.

 С одной стороны, интерпретатор автоматически освобождает память, 
занятую экземпляром, поэтому нет нужды выполнять очистку памяти 
в деструкторах. С другой стороны, не всегда бывает возможным
предсказать, когда произойдет уничтожение экземпляра, поэтому часто 
лучше выполнять завершающие действия в явно вызываемом методе 
(или в инструкции try/finally, которая описывается в следующей части 
книги) – в некоторых случаях в системных таблицах могут сохраняться
ссылки на ваши объекты, что будет препятствовать вызову деструктора.

 В текущей реализации Python на языке C, кроме всего прочего,
нет необходимости закрывать файлы в деструкторах, потому что они
автоматически закрываются при уничтожении объектов файлов. Однако,
как упоминалось в главе 9, лучше все-таки явно закрывать файлы, 
потому что «автоматическое закрытие при уничтожении объекта» – 
это особенность реализации, а не самого языка (в Jython это поведение
может отличаться).

 Фактически использование метода __del__ может осложняться еще целым 
рядом причин. Например, исключения, возникшие внутри этого метода, 
просто выводят сообщения в поток sys. stderr (поток стандартного вывода 
сообщений об ошибках), а не вызывают событие исключения, что вызвано 
непредсказуемостью контекста, в котором метод запускается сборщиком
мусора. Кроме того, перекрестные (они же – циклические) ссылки между
объектами могут препятствовать сборке мусора, когда вы ожидаете ее, –
механизм определения циклических ссылок, который по умолчанию включен, 
способен автоматически собирать такие объекты, но только если они 
не имеют методов __del__. Поскольку в этом вопросе возникает слишком 
неясностей, мы не будем дальше погружаться в детали – полный охват 
особенностей метода __del__ и модуля сборки мусора gc 
(garbage collector) вы найдете в стандартном руководстве 
по языку Python.
"""

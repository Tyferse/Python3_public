"""
 Подробнее о программировании классов


 Инструкция class

 Несмотря на то, что на первый взгляд инструкция class в языке Python
напоминает похожие инструменты в других языках программирования,
при более близком рассмотрении видно, что она существенно отличается
от того, к чему привыкли некоторые программисты. Например,
как и инструкция class в языке C++, инструкция class в языке Python
является основным инструментом ООП, но в отличие от инструкции в C++,
в языке Python она не является объявлением. Подобно инструкции def,
инструкция class создает объект и является неявной инструкцией
присваивания – когда она выполняется, создается объект класса, ссылка
на который сохраняется в имени, использованном в заголовке инструкции.
Кроме того, как и инструкция def, инструкция class является настоящим
выполняемым программным кодом – класс не существует, пока поток
выполнения не достигнет инструкции class, которая определяет его
(обычно при импортировании модуля, в котором она находится,
но не ранее).


 Общая форма

 Инструкция class – это составная инструкция, с блоком операторов,
обычно под строкой заголовка. В заголовке после имени в круглых скобках
через запятую перечисляются супер-классы. Наличие более одного
супер-класса в списке означает множественное наследование (которое
более формально будет обсуждаться в главе 30). Ниже показана общая
форма инструкции:

class <name>(superclass,...):  # Присваивание имени
    data = value  # Совместно используемые данные класса
    def method(self,...):  # Методы
        self.member = value  # Данные экземпляров

 Внутри инструкции class любая операция присваивания создает атрибут
класса, а методы со специальными именами перегружают операторы.
Например, функция с именем __init__, если она определена, вызывается
во время создания объекта экземпляра.


 Пример

 Как мы уже видели, классы – это всего лишь пространства имен,
то есть инструменты, определяющие имена (атрибуты), с помощью которых
клиентам экспортируются данные и логика. Так как же инструкция class
порождает пространство имен?

 А вот как. Так же как и в модулях, инструкции, вложенные в тело
инструкции class, создают атрибуты класса. Когда интерпретатор достигает
инструкции class (а не тогда, когда происходит вызов класса),
он выполняет все инструкции в ее теле от начала и до конца.
Все присваивания, которые производятся в ходе этого процесса, создают
имена в локальной области видимости класса, которые становятся
атрибутами объекта класса. Благодаря этому классы напоминают модули
и функции:

  Подобно функциям, инструкции class являются локальными областями
 видимости, где располагаются имена, созданные вложенными операциями
 присваивания.

  Подобно именам в модуле, имена, созданные внутри инструкции class,
 становятся атрибутами объекта класса.

 Основное отличие классов состоит в том, что их пространства имен
также составляют основу механизма наследования в языке Python, – ссылки
на атрибуты, отсутствующие в классе или в объекте экземпляра, будут
получены из других классов.

 Поскольку инструкция class – это составная инструкция, в ее тело могут
быть вложены любые инструкции – print, =, if, def и так далее.
Все инструкции внутри инструкции class выполняются, когда выполняется
сама инструкция class (а не когда позднее класс вызывается для создания
экземпляра). Операции присваивания именам внутри инструкции class
создают атрибуты класса, а вложенные инструкции def создают методы
класса; кроме этого, атрибуты класса создаются и другими инструкциями,
выполняющими присваивание. Например, присваивание объекта,
не являющегося функцией, атрибутам создает атрибуты данных, совместно
используемых всеми экземплярами:

class SharedData:
    spam = 42  # Создает атрибут данных класса
    x = SharedData()  # Создать два экземпляра

y = SharedData()
x.spam, y.spam  # Они наследуют и совместно используют атрибут spam
(42, 42)

 В данном случае из-за того, что имя spam создается на верхнем уровне
в инструкции class, оно присоединяется к классу и поэтому совместно
используется всеми экземплярами. Мы можем изменять значение атрибута,
выполняя присваивание через имя класса, и обращаться к нему через имена
экземпляров или класса.

\>>> SharedData.spam = 99
\>>> x.spam, y.spam, SharedData.spam
(99, 99, 99)

 Такие атрибуты класса могут использоваться для хранения информации,
доступной всем экземплярам, например для хранения счетчика количества
созданных экземпляров (эту идею мы рассмотрим в главе 31). Теперь
посмотрим, что произойдет, если присвоить значение атрибуту spam
не через имя класса, а через имя экземпляра:

\>>> x.spam = 88
\>>> x.spam, y.spam, SharedData.spam
(88, 99, 99)

 Операция присваивания, применяемая к атрибуту экземпляра, создает
или изменяет имя в экземпляре, а не в классе. Вообще говоря, поиск
в дереве наследования производится только при попытке чтения атрибута,
но не при присваивании: операция присваивания атрибуту объекта всегда
изменяет сам объект, а не что-то другое.2 Например, атрибут y.spam
будет найден в наследуемом классе, а операция присваивания атрибуту
x.spam присоединит имя непосредственно к объекту x.

 Ниже приводится более понятный пример этого поведения, где одно
и то же имя создается в двух местах. Предположим, что мы используем
следующий класс:
"""


class MixedNames:  # Определение класса
    data = 'spam'  # Присваивание атрибуту класса

    def __init__(self, value):  # Присваивание имени метода
        self.data = value  # Присваивание атрибуту экземпляра

    def display(self):
        print(self.data, MixedNames.data)  # Атрибут экземпляра,
        #                                    атрибут класса


"""
 Этот класс содержит две инструкции def, которые связывают атрибуты
класса с методами. Здесь также присутствует инструкция присваивания =.
Так как эта инструкция выполняет присваивание имени data внутри 
инструкции class, оно создается в локальной области видимости класса
и становится атрибутом объекта класса. Как и все атрибуты класса,
атрибут data наследуется и используется всеми экземплярами класса, 
которые не имеют собственного атрибута data.

 Когда создаются экземпляры этого класса, имя data присоединяется 
к этим экземплярам через присваивание атрибуту self.data в конструкторе:
"""

x = MixedNames(1)  # Создаются два объекта экземпляров,
y = MixedNames(2)  # каждый из которых имеет свой атрибут data
x.display()  # self.data - это другие атрибуты,
y.display()  # а MixedNames.data - тот же самый

"""
 Суть этого примера состоит в том, что атрибут data находится в двух
разных местах: в объектах экземпляров (создаются присваиванием атрибуту
self.data в методе __init__) и в классе, от которого они наследуют имена
(создается присваиванием имени data в инструкции class). Метод класса 
display выводит обе версии – сначала атрибут экземпляра self, а затем
атрибут класса.

 Используя этот прием сохранения атрибутов в различных объектах, 
мы определяем их области видимости. Атрибуты классов совместно 
используются всеми экземплярами, а атрибуты экземпляров уникальны 
для каждого экземпляра – ни данные, ни поведение экземпляра недоступны 
для совместного использования. Несмотря на то что операция поиска 
в дереве наследования позволяет отыскивать имена, мы всегда можем 
получить доступ к ним в любой точке дерева, обратившись непосредственно 
к нужному объекту.

 В предыдущем примере, например, выражения x.data и self.data возвращают
атрибут экземпляра, которые переопределяют то же самое имя в классе. 
Однако выражение MixedNames.data явно обращается к атрибуту класса. 
Позднее мы еще встретим подобные шаблоны программирования, например 
следующий раздел описывает один из наиболее часто используемых.


 Методы
 
 Вы уже знакомы с функциями и знаете о методах в классах. Методы –
это обычные объекты функций, которые создаются инструкциями def в теле 
инструкции class. Говоря вкратце, методы реализуют поведение, 
наследуемое объектами экземпляров. С точки зрения программирования 
методы работают точно так же, как и обычные функции, с одним важным 
исключением: в первом аргументе методам всегда передается 
подразумеваемый объект экземпляра. Другими словами, интерпретатор 
автоматически отображает вызов метода экземпляра на метод класса
следующим образом. Вызов метода экземпляра:

instance.method(args...)

 автоматически преобразуется в вызов метода класса:
 
class.method(instance, args...)

 где класс определяется в результате поиска имени метода по дереву 
наследования. Фактически в языке Python обе формы вызова метода являются
допустимыми.

 Помимо обычного наследования имен методов, первый специальный аргумент 
– это единственная необычная особенность методов. Первый аргумент 
в методах классов обычно называется self, в соответствии с общепринятыми
соглашениями (с технической точки зрения само имя не играет никакой 
роли, значение имеет позиция аргумента). Этот аргумент обеспечивает 
доступ к экземпляру, то есть к субъекту вызова, – поскольку из классов
может создаваться множество объектов экземпляров, этот аргумент 
необходим для доступа к данным конкретного экземпляра.

 Программисты, знакомые с языком C++, сочтут, что аргумент self в языке
Python напоминает указатель this в языке C++. Однако в языке Python имя
self всегда явно используется в программном коде: методы всегда должны
использовать имя self для получения или изменения атрибутов экземпляра,
обрабатываемого текущим вызовом метода. Такая явная природа аргумента
self предусмотрена намеренно – присутствие этого имени делает очевидным 
использование имен атрибутов экземпляра.


 Пример метода
 
 Чтобы пояснить эти концепции, обратимся к примеру. Предположим, 
что имеется следующее определение класса:
"""


class NextClass:              # Определение класса
    def printer(self, text):  # Определение метода
        self.message = text   # Изменение экземпляра
        print(self.message)   # Обращение к экземпляру


"""
 Имя printer ссылается на объект функции, а так как оно создается 
в области видимости инструкции class, оно становится атрибутом объекта 
класса и будет унаследовано всеми экземплярами, которые будут созданы
из класса. Обычно методы, такие как printer, предназначены для обработки 
экземпляров, поэтому мы вызываем их через экземпляры:
"""

x = NextClass()  # Создать экземпляр
x.printer('instance call')  # Вызвать его метод
print(x.message)  # Экземпляр изменился

"""
 Когда метод вызывается с использованием квалифицированного имени
экземпляра, как в данном случае, то сначала определяется местонахождение
метода printer, а затем его аргументу self автоматически присваивается 
объект экземпляра (x). В аргумент text записывается строка, переданная 
в вызов метода (‘instance call’). Обратите внимание, что Python
автоматически передает в первом аргументе self ссылку на сам экземпляр,
поэтому нам достаточно передать методу только один аргумент. Внутри 
метода printer имя self используется для доступа к данным конкретного 
экземпляра, потому что оно ссылается
на текущий обрабатываемый экземпляр.

 Методы могут вызываться любым из двух способов – через экземпляр 
или через сам класс. Например, метод printer может быть вызван 
с использованием имени класса, при этом ему явно требуется передать 
экземпляр в аргументе self:
"""

NextClass.printer(x, 'class call')  # Прямой вызов метода класса
print(x.message)  # Экземпляр снова изменился

"""
 Вызов метода, который производится через экземпляр и через имя класса,
оказывает одинаковое воздействие при условии, что при вызове через имя 
класса передается тот же самый экземпляр. По умолчанию, если попытаться
вызвать метод без указания экземпляра, будет выведено сообщение 
об ошибке:

>>> NextClass.printer(‘bad call’)
TypeError: unbound method printer() must be called with NextClass 
instance...
(TypeError: несвязанный метод printer() должен вызываться с экземпляром 
NextClass...)


 Вызов конструкторов супер-классов
 
 Обычно методы вызываются через экземпляры. Тем не менее вызовы методов
через имя класса могут играть особую роль. Одна из таких ролей связана 
с вызовом конструктора. Метод __init__ наследуется точно так же, 
как и любые другие атрибуты. Это означает, что во время создания 
экземпляра интерпретатор отыскивает только один метод __init__. 
Если в конструкторе подкласса необходимо гарантировать выполнение 
действий, предусматриваемых конструктором супер-класса, необходимо
явно вызвать метод __init__ через имя класса:


class Super:
    def __init__(self, x):
        ...программный код по умолчанию...
        
        
class Sub(Super):
    def __init__(self, x, y):
        Super.__init__(self, x)  # Вызов метода __init__ супер-класса
        ...адаптированный код...  # Выполнить дополнительные действия
        
        
I = Sub(1, 2)

 Это один из немногих случаев, когда вашему программному коду 
потребуется явно вызывать метод перегрузки оператора. Естественно,
вызывать конструктор супер-класса таким способом следует, только если
это действительно необходимо, – без этого вызова подкласс полностью 
переопределяет данный метод. Более реалистичный случай применения 
этого приема приводится в классе Manager, в предыдущей главе.


 Другие возможности методов
 
 Такой способ вызова методов через имя класса представляет собой основу
для расширения (без полной замены) поведения унаследованных методов.
В главе 31 мы познакомимся с еще одной возможностью, добавленной 
в Python 2.2, статическими методами, которые не предполагают наличие
объекта экземпляра в первом аргументе. Такие методы могут действовать 
как обычные функции, имена которых являются локальными по отношению 
к классам, где они были определены, и использоваться для манипулирования
данными класса. Родственные им методы класса принимают в первом 
аргументе сам класс, а не экземпляр, и могут использоваться
для манипулирования данными, принадлежащими конкретному классу. Однако 
это дополнительное расширение не является обязательным – 
обычно нам всегда бывает необходимо передавать экземпляр методам,
вызываемым либо через сам экземпляр, либо через имя класса.


 Наследование
 
 Основное назначение такого инструмента пространств имен, как инструкция
class, заключается в обеспечении поддержки наследования имен. В этом
разделе мы подробно остановимся на вопросах, связанных с механизмами
наследования атрибутов в языке Python.

 В языке Python наследование вступает в игру после того, как объект 
будет квалифицирован, и его действие заключается в операции поиска
в дереве определений атрибутов (в одном или более пространствах имен). 
Каждый раз, когда используется выражение вида object.attr (где object –
это объект экземпляра или класса), интерпретатор приступает к поиск
у первого вхождения атрибута attr в дереве пространств имен снизу вверх,
начиная с объекта object. Сюда относятся и ссылки на атрибуты аргумента
self внутри методов. Поскольку самые нижние определения в дереве
наследования переопределяют те, что находятся выше, механизм 
наследования составляет основу специализации программного кода.


 Создание дерева атрибутов
 
 На рис. приводятся способы, которыми создаются и заполняются именами 
деревья пространств имен. Вообще:

  Атрибуты экземпляров создаются посредством присваивания атрибутам
 аргумента self в методах.
 
  Атрибуты классов создаются инструкциями (присваивания), расположенными
 внутри инструкции class.
 
  Ссылки на супер-классы создаются путем перечисления классов в круглых
 скобках в заголовке инструкции class.
 
 Результатом является дерево пространств имен с атрибутами, 
которое ведет в направлении от экземпляров к классам, из которых 
они были созданы, и ко всем супер-классам, перечисленным в заголовке
инструкции class. Интерпретатор выполняет поиск в дереве в направлении 
снизу вверх, от экземпляров к супер-классам всякий раз,
когда используемое имя подразумевает атрибут объекта экземпляра.

 Это описание далеко не полное, потому что точно так же возможно
создавать атрибуты экземпляров и классов с помощью инструкций 
присваивания за пределами инструкций class – но этот прием используется
существенно реже и зачастую более подвержен ошибкам (изменения 
не изолированы от инструкций class). В языке Python все атрибуты всегда
доступны по умолчанию.

 
 Специализация унаследованных методов
 
 Только что описанная модель поиска в дереве наследования представляет 
собой прекрасный способ специализации программ. Поскольку механизм 
наследования сначала пытается отыскать имена в подклассах 
и только потом в их супер-классах, подклассы могут изменять поведение
по умолчанию, предусматриваемое атрибутами их супер-классов. Фактически
можно создавать целые системы как иерархии классов, возможности которых
расширяются за счет добавления новых подклассов, а не за счет изменения
существующего программного кода.

 Идея переопределения унаследованных имен приводит к множеству приемов
специализации. Например, подклассы могут полностью замещать 
унаследованные атрибуты, предоставлять атрибуты, которые ожидается 
отыскать в супер-классах, и расширять методы супер-класса за счет
их вызова из методов подкласса. Мы уже видели прием с замещением 
в действии. Ниже приводится пример, демонстрирующий, как выполняется
расширение:
"""


class Super:
    def method(self):
        print('in Super.method')


class Sub(Super):
    def method(self):  # Переопределить метод
        print('starting Sub.method')  # Дополнительное действие
        Super.method(self)  # Выполнить действие по умолчанию
        print('ending Sub.method')


"""
 Главное здесь – это прямые вызовы методов супер-класса. Класс Sub
замещает метод method класса Super своей собственной, специализированной
версией. Но внутри замещающего метода в классе Sub производится вызов
версии, экспортируемой классом Super, чтобы выполнить действия 
по умолчанию. Другими словами, метод Sub.method не замещает полностью 
метод Super.method, а просто расширяет его:
"""

x = Super()  # Создать экземпляр класса Super
x.method()   # Вызвать Super.method

x = Sub()  # Создать экземпляр класса Sub
x.method()  # Вызвать Sub.method, который вызовет Super.method

"""
 Приемы организации взаимодействия классов
 
 Расширение – это лишь один из способов организации взаимодействий 
с супер-классом. В файле ниже, specialize.py, определяется несколько
классов, которые иллюстрируют различные приемы использования классов:

 Super
 
  Определяет метод method и метод delegate, который предполагает наличие
 метода action в подклассе.
 
 Inheritor
 
  Не предоставляет никаких новых имен, поэтому он получает все, 
 что определено только в классе Super.
 
 Replacer
 
  Переопределяет метод method класса Super своей собственной версией.
  
 Extender
 
  Адаптирует метод method класса Super, переопределяя и вызывая его,
 чтобы выполнить действия, предусмотренные по умолчанию.
 
 Provider
 
  Реализует метод action, который ожидается методом delegate 
 класса Super.
  
 Рассмотрим каждый из этих классов, чтобы получить представление 
о способах, которыми они адаптируют свой общий супер-класс. Содержимое
самого файла приводится ниже:
"""


class Super:
    def method(self):
        print('in Super.method')  # Поведение по умолчанию

    def delegate(self):
        self.action()  # Ожидаемый метод


class Inheritor(Super):  # Наследует методы, как они есть
    pass


class Replacer(Super):  # Полностью замещает method
    def method(self):
        print('in Replacer.method')


class Extender(Super):  # Расширяет поведение метода method
    def method(self):
        print('starting Extender.method')
        Super.method(self)
        print('ending Extender.method')


class Provider(Super):  # Определяет необходимый метод
    def action(self):
        print('in Provider.action')


if __name__ == '__main__':
    for klass in (Inheritor, Replacer, Extender):
        print('\n' + klass.__name__ + '...')
        klass().method()

    print('\nProvider...')
    x = Provider()
    x.delegate()

"""
 Здесь следует отметить несколько моментов. Программный код тестирования
модуля в конце примера создает экземпляры трех разных классов
в цикле for. Поскольку классы – это объекты, можно поместить их в кортеж
и создавать экземпляры единообразным способом (подробнее об этой идее 
рассказывается ниже). Кроме всего прочего, классы, как и модули, имеют 
атрибут __name__ – он содержит строку с именем класса, указанным
в заголовке инструкции class. Ниже показано, что произойдет, 
если запустить файл:

% python specialize.py
Inheritor...
in Super.method
Replacer...
in Replacer.method
Extender...
starting Extender.method
in Super.method
ending Extender.method
Provider...
in Provider.action


 Абстрактные супер-классы
 
 Обратите внимание, как работает класс Provider в предыдущем примере. 
Когда через экземпляр класса Provider вызывается метод delegate,
инициируются две независимые процедуры поиска:

 1. При вызове x.delegate интерпретатор отыскивает метод delegate
в классе Super, начиная поиск от экземпляра класса Provider и двигаясь 
вверх по дереву наследования. Экземпляр x передается методу в виде 
аргумента self, как обычно.

 2. Внутри метода Super.delegate выражение self.action приводит
к запуску нового, независимого поиска в дереве наследования, начиная 
от экземпляра self и дальше вверх по дереву. Поскольку аргумент self 
ссылается на экземпляр класса Provider, метод action будет найден 
в подклассе Provider. Такой способ «восполнения пробелов» в реализации –
обычное дело для платформ ООП. По крайней мере, в терминах метода 
delegate такие супер-классы, как в этом примере, иногда называют
абстрактными супер-классами – классы, которые предполагают, что часть
их функциональности будет реализована их подклассами. Если ожидаемый
метод не определен в подклассе, интерпретатор возбудит исключение 
с сообщением о неопределенном имени, когда поиск в дереве наследования 
завершится неудачей.

 Разработчики классов иногда делают такие требования к подклассам более
очевидными с помощью инструкций assert или возбуждая встроенное
исключение NotImplementedError с помощью инструкции raise (более 
подробно об инструкциях, которые могут возбуждать исключения, 
мы поговорим в следующей части книги). Ниже приводится короткий пример 
приема, основанного на применении инструкции assert:


class Super:
    def delegate(self):
        self.action()
    def action(self):
        assert False, ‘action must be defined!’ 
        # При вызове этой версии
        
        
>>> X = Super()
>>> X.delegate()
AssertionError: action must be defined!

 Мы познакомимся с инструкцией assert в главах 32 и 33, а пока лишь 
замечу, что если выражение возвращает ложь, она возбуждает исключение 
с указанным сообщением об ошибке. В данном случае выражение всегда 
возвращает ложь, чтобы вызвать появление об ошибке, если метод не будет
переопределен и поиск по дереву наследования остановится на этой версии.
В некоторых классах, напротив, в таких методах-заглушках исключение 
NotImplementedError возбуждается напрямую.


class Super:
    def delegate(self):
        self.action()
    def action(self):
        raise NotImplementedError(‘action must be defined!’)
        
        
>>> X = Super()
>>> X.delegate()
NotImplementedError: action must be defined!

 При работе с экземплярами подклассов мы так же будем получать 
исключения, если эти подклассы не обеспечат собственную реализацию 
ожидаемого метода, замещающего метод в супер-классе:

>>> class Sub(Super): pass
...
>>> X = Sub()
>>> X.delegate()
NotImplementedError: action must be defined!
>>> class Sub(Super):
...     def action(self): print(‘spam’)
...
>>> X = Sub()
>>> X.delegate()
spam


 Абстрактные супер-классы в Python 2.6 и 3.0
 
 В версиях Python 2.6 и 3.0 абстрактные супер-классы
(они же «абстрактные базовые классы»), представленные
в предыдущем разделе, которые требуют, чтобы подклассы
переопределяли некоторые методы, могут быть реализованы
с применением специальной синтаксической конструкции определения класса.
Способ определения абстрактного супер-класса зависит от версии
интерпретатора. В Python 3.0 для этих целей используется именованный 
аргумент в заголовке инструкции class и специальный декоратор @abstract
методов. Обе конструкции мы будем подробно рассматривать далее, 
в этой книге:

from abc import ABCMeta, abstractmethod

class Super(metaclass=ABCMeta):
    @abstractmethod
    def method(self, ...):
        pass
        
 В Python 2.6 вместо именованного аргумента в заголовке инструкции class
используется атрибут класса:

class Super:
    __metaclass__ = ABCMeta
    @abstractmethod
    def method(self, ...):
        pass

 В любом случае результат получается одним и тем же – мы лишены 
возможности создавать экземпляры, если метод не будет определен ниже 
в дереве классов. Ниже приводится пример абстрактного супер-класса,
реализованного в версии 3.0, эквивалентный примеру в предыдущем разделе:
"""

from abc import ABCMeta, abstractmethod


class Super(metaclass=ABCMeta):
    def delegate(self):
        self.action()

    @abstractmethod
    def action(self):
        pass


class Sub(Super):
    def action(self): print('spam')


X = Sub()
X.delegate()

"""
 Реализованный таким способом класс с абстрактным методом не может 
использоваться для создания экземпляров (то есть нам не удастся создать 
экземпляр вызовом этого класса), если все абстрактные методы не будут 
реализованы в подклассах. Хотя при такой реализации объем программного
кода увеличивается, тем не менее она имеет свои преимущества – 
ошибки  из-за отсутствующих методов будут появляться при попытке создать
экземпляр класса, а не позднее, при попытке вызвать отсутствующий метод. 
Данная возможность может использоваться для построения ожидаемого 
интерфейса, полнота реализации которого будет автоматически проверяться
в клиентских классах.
"""

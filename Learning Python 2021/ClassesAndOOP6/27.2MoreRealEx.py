"""
 Шаг 5: адаптация конструкторов

 Наш программный код действует так, как он действует, но если вы
внимательнее изучите текущую версию, вы можете заметить кое-что
непонятное – кажется бессмысленным указывать значение ‘mgr’ (менеджер)
в аргументе job (должность) при создании объекта класса Manager:
эта должность уже подразумевается названием класса. Было бы лучше
заполнять этот атрибут автоматически, при создании экземпляра
класса Manager.

 Для этого мы можем проделать тот же трюк, что и в предыдущем разделе:
мы можем адаптировать логику работы конструктора в классе Manager так,
чтобы он автоматически подставлял название должности. С точки зрения
реализации, нам необходимо переопределить метод __init__
в классе Manager, чтобы он подставлял строку ‘mgr’ автоматически.
Как и при адаптации метода giveRaise, нам также необходимо вызывать
оригинальный метод __init__ из класса Person за счет обращения
к имени класса, чтобы инициализировать остальные атрибуты объекта.

 В новой версии сценария, которая приводится ниже, мы создали
новый конструктор для класса Manager и изменили вызов, создающий объект
tom, – теперь мы не передаем ему название должности ‘mgr’:
"""


# Добавлен адаптированный конструктор в подкласс
class Person:
    def __init__(self, name, job=None, pay=0):
        self.name = name
        self.job = job
        self.pay = pay

    def lastName(self):
        return self.name.split()[-1]

    def giveRaise(self, percent):
        self.pay = int(self.pay * (1 + percent))

    def __str__(self):
        return '[Person: % s, % s]' % (self.name, self.pay)


class Manager(Person):
    def __init__(self, name, pay):  # Переопределенный конструктор
        Person.__init__(self, name, 'mgr', pay)  # Вызов оригинального
        # конструктора со значением ‘mgr’ в аргументе job

    def giveRaise(self, percent, bonus=.10):
        Person.giveRaise(self, percent + bonus)


bob = Person('Bob Smith')
sue = Person('Sue Jones', job='dev', pay=100000)
tom = Manager('Tom Jones', 50000)  # Указывать должность не требуется:

if __name__ == '__main__':
    print(bob)
    print(sue)
    print(bob.lastName(), sue.lastName())
    sue.giveRaise(.10)
    print(sue)

    tom.giveRaise(.10)  # Подразумевается/устанавливается классом
    print(tom.lastName())
    print(tom)

"""
 Здесь мы снова использовали тот же прием расширения конструктора
__init__, который выше использовался для расширения метода giveRaise, – 
вызвали версию метода из супер-класса обращением к имени класса и явно
передали экземпляр self. Несмотря на странный вид имени конструктора, 
конечный эффект получается тот же самый. Так как нам необходимо 
задействовать логику конструктора класса Person (чтобы инициализировать 
атрибуты экземпляра), мы должны вызвать его именно так, как показано
в примере, в противном случае экземпляры класса Manager окажутся 
без атрибутов.

 Такая форма вызова конструктора супер-класса из конструктора подкласса
широко используется при программировании на языке Python. Механизм
наследования, реализованный в интерпретаторе, позволяет отыскать 
только один метод __init__ на этапе конструирования – самый нижний
в дереве классов. Если во время конструирования объекта требуется
вызвать метод __init__, расположенный выше (что обычно и делается), 
его необходимо вызывать вручную, обращением через имя супер-класса.
Положительная сторона такого подхода заключается в том, что вы можете 
явно передать конструктору супер-класса только необходимые аргументы
или вообще не вызывать его: возможность отказа от вызова конструктора 
супер-класса позволяет полностью заместить логику его работы,
а не дополнять ее.

 В процессе работы эта версия сценария выводит ту же информацию,
что и прежде, – мы не изменили логику его работы, мы просто 
реструктурировали программный код, чтобы избавиться от некоторой 
избыточности:

[Person: Bob Smith, 0]
[Person: Sue Jones, 100000]
Smith Jones
[Person: Sue Jones, 110000]
Jones
[Person: Tom Jones, 60000]


 ООП проще, чем может показаться
 
 В своем законченном виде, несмотря на незначительные размеры, 
наши классы задействовали практически все наиболее важные концепции 
механизма ООП в языке Python:

  Создание экземпляров – заполнение атрибутов экземпляров.
  
  Методы, реализующие поведение, – инкапсуляция логики в методах класса.
  
  Перегрузка операторов – реализация поддержки встроенных операций, 
 таких как вывод.
 
  Адаптация поведения – переопределение специализированных версий 
 методов в подклассах.
 
  Адаптация конструкторов – добавление логики инициализации, 
 в дополнение к логике супер-класса.
 
 Большая часть этих концепций основана на трех простых механизмах: 
поиске атрибутов в дереве наследования, специальном аргументе self 
методов и автоматическом выборе нужного метода перегрузки операторов.

 Попутно мы также упростили возможность изменения нашего программного
кода в будущем, использовав склонность классов к многократному 
использованию программного кода для снижения избыточности. Например,
мы оформили логику работы классов в виде методов и предусмотрели вызов 
методов супер-класса, чтобы избежать появления нескольких копий одного
и того же программного кода. Большинство этих действий естественным 
образом проистекает из мощных возможностей классов в структурировании 
программного кода.


 Другие способы комбинирования классов
 
 После всего вышесказанного я должен сообщить, что, несмотря на простоту
ООП в языке Python, объединение классов в крупных программах – это уже
отчасти искусство. В этой главе основное свое внимание мы 
сконцентрировали на механизме наследования, потому что он поддерживается
самим языком, но иногда программисты используют иные способы 
комбинирования классов. Например, очень часто используется прием 
вложения объектов друг в друга для создания составных объектов. 
Более детально мы исследуем этот прием в главе 30, которая посвящена
скорее вопросам проектирования, чем языку Python, – однако вкратце 
замечу, что мы могли бы использовать этот прием при создании нашего
класса Manager, вложив в него объект класса Person, а не наследуя 
этот класс.

 Следующая альтернативная реализация демонстрирует такую возможность,
используя метод __getattr__ перегрузки операторов, с которым мы 
познакомимся в главе 29, чтобы перехватывать попытки обращения
к несуществующим атрибутам и делегировать эти обращения вложенному
объекту, вызовом встроенной функции getattr. Здесь также имеется 
адаптированная версия метода giveRaise, которая изменяет значение 
аргумента, передаваемого методу вложенного объекта. В результате класс 
Manager превращается в контроллер, который вызывает методы вложенного
объекта, а не методы супер-класса:
"""


# Альтернативная версия класса Manager с вложенным объектом
class Manager:
    def __init__(self, name, pay):
        self.person = Person(name, 'mgr', pay)  # Вложенный объект
        #                                         Person

    def giveRaise(self, percent, bonus=.10):  # Перехватывает
        self.person.giveRaise(percent + bonus)  # и делегирует

    def __getattr__(self, attr):  # Делегирует обращения
        return getattr(self.person, attr)  # ко всем остальным атрибутам

    def __str__(self):
        return str(self.person)  # Требуется перегрузка (в 3.0)


"""
 В действительности, этот альтернативный вариант класса Manager 
представляет достаточно распространенный шаблон проектирования, 
известный как делегирование, – составная структура служит оберткой
вокруг вложенного объекта, управляет им и перенаправляет ему вызовы 
методов. Мы сумели реализовать этот шаблон в нашем примере, но для этого
потребовалось написать вдвое больше программного кода, 
и он не так хорошо удовлетворяет нашим потребностям, как механизм 
наследования, позволяющий выполнять непосредственную адаптацию. 
(Фактически ни один здравомыслящий программист не стал бы применять 
этот шаблон для реализации нашего примера, кроме тех, кто пишет 
учебники.) В этой реализации класс Manager в действительности 
не наследует класс Person, поэтому нам пришлось написать дополнительный 
программный код, который вручную вызывает необходимые методы вложенного
объекта – методы перегрузки операторов, такие как __str__, потребовалось
переопределить (по крайней мере, в Python 3.0, о чем дополнительно 
рассказывается во врезке «Перехват обращений к встроенным атрибутам 
в версии 3.0» ниже), а реализация дополнительных особенностей в классе 
Manager выглядит сложнее, потому что информация о состоянии находится 
уровнем ниже.

 И все же прием, основанный на использовании вложенных объектов, 
с успехом может использоваться на практике, особенно когда круг 
взаимодействий контейнера с вложенными объектами уже, чем предполагает
прием адаптации. Уровень контроллера, который представляет 
альтернативная реализация класса Manager, например, может пригодиться 
для отслеживания и проверки вызовов методов других объектов (мы будем 
использовать практически идентичный прием при изучении декораторов
классов, далее в этой книге). Кроме того, для объединения других 
объектов в виде множества можно было бы использовать гипотетический 
агрегатный класс Department, как показано ниже. Добавьте его реализацию
в конец файла person.py, чтобы получить возможность опробовать его
самостоятельно:
"""


# Объединение объектов в составной объект
class Department:
    def __init__(self, *args):
        self.members = list(args)

    def addMember(self, person):
        self.members.append(person)

    def giveRaises(self, percent):
        for person in self.members:
            person.giveRaise(percent)

    def showAll(self):
        for person in self.members:
            print(person)


development = Department(bob, sue)  # Встраивание объектов
#                                     в составной объект
development.addMember(tom)
development.giveRaises(.10)  # Вызов метода giveRaise вложенных объектов
development.showAll()  # Вызов метода __str__ вложенных объектов

"""
 Интересно отметить, что в этом примере используются оба приема, 
наследование и встраивание, – объекты класса Department являются
составными объектами, которые управляют другими встроенными объектами,
но сами встроенные объекты классов Person и Manager используют механизм
наследования для адаптации своего поведения. В качестве еще одного
примера можно привести графический интерфейс пользователя, в реализации
которого точно так же для адаптации поведения или внешнего вида кнопок 
и меток может использоваться механизм наследования, а для создания
пакетов встроенных виджетов, таких как формы ввода, калькуляторы 
и текстовые редакторы, – прием встраивания. Структура такого класса 
зависит от объектов, которые требуется смоделировать.

 Проблемы проектирования таких составных объектов рассматриваются 
в главе 30, поэтому мы пока отложим дальнейшие исследования. Замечу 
еще раз, что наши классы Person и Manager демонстрируют применение 
всех основных механизмов ООП в языке Python. После овладения основами 
ООП разработка обобщенных инструментов для применения их в своих 
сценариях часто является естественным следующим этапом – и темой 
следующего раздела.


 Шаг 6: использование инструментов интроспекции
 
 Давайте добавим последний штрих, прежде чем сохраним наши объекты
в базе данных. Наши классы имеют законченный вид и демонстрируют большую 
часть основ ООП. Однако остаются еще две проблемы, которые мы должны 
сгладить, прежде чем запустить эти классы в работу:

  Во-первых, если внимательно посмотреть на то, как сейчас наши объекты
 выводятся на экран, можно заметить, что объект tom, принадлежащий
 к классу Manager, помечается как объект класса Person. С технической 
 точки зрения это не является ошибкой, так как класс Manager является 
 адаптированной и специализированной версией класса Person. Однако 
 более правильным было бы отображать как можно более точное имя класса 
 объекта (то есть имя самого нижнего класса в иерархии).
 
  Во-вторых, что, пожалуй, более важно, в текущей версии отображается
 информация только о тех атрибутах, которые мы явно указали в методе
 __str__, чего может оказаться недостаточно в будущем. Например, сейчас
 у нас нет возможности убедиться, что атрибут job в объекте tom получает
 значение ‘mgr’ в конструкторе класса Manager, потому что метод __str__,
 который реализован в классе Person, не выводит его. Более того, если мы
 когда-нибудь расширим или как-то иначе изменим набор атрибутов, которым
 выполняется присваивание в методе __init__, мы должны будем также
 добавить вывод новых атрибутов в методе __str__, в противном случае
 результаты, возвращаемые этим методом, со временем перестанут 
 соответствовать действительности.

 Последний пункт означает, что мы снова добавляем себе лишнюю работу 
в будущем за счет добавления избыточного программного кода. Поскольку
любое несоответствие в методе __str__ будет отражаться на выводе 
программы, эта избыточность может оказаться более очевидной,
чем ее разновидности, которые мы устраняли ранее, – попытки избежать 
выполнения лишней работы в будущем вообще достойны поощрения.


 Специальные атрибуты классов
 
 Обе упомянутые проблемы можно решить с помощью инструментов
интроспекции, имеющихся в языке Python, – специальных атрибутов 
и функций, обеспечивающих доступ к внутренней реализации объектов. 
Это узкоспециализированные инструменты, и обычно они используются 
программистами, создающими инструменты для других программистов, 
и гораздо реже программистами, разрабатывающими приложения. Но даже 
учитывая это обстоятельство, знание основных приемов использования 
этих инструментов будет полезным, потому что они позволяют писать 
программный код, оперирующий классами обобщенными способами.
В нашем случае, например, мы могли бы использовать две особенности,
которые были представлены в конце предыдущей главы:

  Встроенный атрибут instance.__class__ в экземпляре ссылается на класс
 этого экземпляра. Классы, в свою очередь, имеют атрибут __name__, 
 подобно модулям, и последовательность __bases__, обеспечивающую доступ 
 к супер-классам. Мы можем использовать эти атрибуты при выводе имени 
 класса, к которому принадлежит экземпляр, вместо того, чтобы выводить 
 жестко заданное имя.
 
  Встроенный атрибут object.__dict__ содержит словарь с парами 
 ключ/значение, каждая из которых соответствует определенному атрибуту 
 в пространстве имен объекта (включая модули, классы и экземпляры). 
 Поскольку значением этого атрибута является словарь, мы можем получать 
 из него список ключей, значения атрибутов по ключам, выполнять итерации
 по ключам и так далее, и тем самым обеспечить обобщенный способ 
 обработки всех атрибутов. На основе этого словаря мы можем реализовать 
 вывод всех атрибутов, имеющихся в любом экземпляре, а не только тех, 
 которые явно будут указаны в методе вывода.
 
 Ниже приводится пример использования этих инструментов в интерактивном
сеансе Python. Обратите внимание, что мы импортируем класс Person
с помощью инструкции from, – имена классов располагаются в модулях 
и могут импортироваться как обычные функции и другие переменные:
"""

print(bob.__class__)  # Выведет класс объекта bob и его имя

print(bob.__class__.__name__)

print(list(bob.__dict__.keys()))  # Атрибуты – это действительно
#                                   ключи словаря
# Функция list используется для получения
# полного списка в версии 3.0

for key in bob.__dict__:
    print(key, '=>', bob.__dict__[key])  # Обращение по индексам

for key in bob.__dict__:
    print(key, '=>', getattr(bob, key))  # Аналогично выражению
    # obj.attr, где attr - переменная

"""
 Как уже отмечалось в предыдущей главе, некоторые атрибуты экземпляров
могут отсутствовать в словаре __dict__, если класс экземпляра определяет
атрибут __slots__, который является дополнительной и малопонятной
особенностью классов нового стиля (и всех классов в Python 3.0),
которая используется для организации хранения атрибутов в виде массива 
и которую мы будем обсуждать в главах 30 и 31. Поскольку 
в действительности слоты принадлежат классам, а не экземплярам, 
и они очень редко используются на практике, мы можем просто игнорировать
их в нашем примере и сосредоточиться на обычном атрибуте __dict__.


 Обобщенный инструмент отображения
 
 Мы можем задействовать эти инструменты в супер-классе для точного
отображения имен классов и вывода значений всех атрибутов экземпляров 
любых классов. Создайте новый файл в своем текстовом редакторе
и добавьте в него программный код, что приводится ниже, – это новый, 
независимый модуль с именем classtools.py, реализующий единственный
класс. В методе __str__ перегрузки операции вывода этого класса 
используются обобщенные инструменты интроспекции, поэтому он может 
работать с любыми экземплярами, независимо от того, какими атрибутами
они обладают. А так как это – класс, он автоматически превращается 
в обобщенный инструмент отображения: благодаря наследованию, он может
добавляться в любые классы, где требуется обеспечить вывод данной
информации. Как дополнительное преимущество, если нам когда-нибудь 
понадобится изменить формат вывода информации об экземплярах, 
достаточно будет изменить только этот класс, потому что все классы будут
наследовать метод __str__ этого класса и автоматически будут 
использовать новый формат вывода:
"""


# Файл classtools.py (новый)
# Различные утилиты и инструменты для работы с классами
class AttrDisplay:
    """
    Реализует наследуемый метод перегрузки операции вывода, отображающий
    имена классов экземпляров и все атрибуты в виде пар имя=значение,
    имеющиеся в экземплярах (исключая атрибуты, унаследованные
    от классов).
    Может добавляться в любые классы и способен работать
    с любыми экземплярами.
    """

    def gatherAttrs(self):
        attrs = []
        for key in sorted(self.__dict__):
            attrs.append('%s=%s' % (key, getattr(self, key)))
        return ', '.join(attrs)

    def __str__(self):
        return '[%s: %s]' % (self.__class__.__name__,
                             self.gatherAttrs())


if __name__ == '__main__':
    class TopTest(AttrDisplay):
        count = 0

        def __init__(self):
            self.attr1 = TopTest.count
            self.attr2 = TopTest.count + 1
            TopTest.count += 2


    class SubTest(TopTest):
        pass


    X, Y = TopTest(), SubTest()
    print(X)  # Выведет все атрибуты экземпляра
    print(Y)  # Выведет имя класса, самого близкого
    #           в дереве наследования

"""
 Обратите внимание на строки документирования – так как мы создаем 
многоцелевой инструмент, вполне естественно снабдить его описанием 
для потенциальных пользователей. Как мы видели в главе 15, строки
документирования могут помещаться в начало простых функций и модулей, 
однако точно так же они могут помещаться в начало классов и их методов –
эти строки автоматически извлекаются и отображаются функцией help
и инструментом PyDoc (мы еще вернемся к строкам документирования 
в главе 28).

 Если запустить этот модуль, как самостоятельный сценарий,
его программный код самопроверки создаст два экземпляра и выведет их –
реализованный здесь метод __str__ выведет имена классов экземпляров 
и все их атрибуты в виде пар имя=значение, отсортированные по именам 
атрибутов в алфавитном порядке:

C:\misc> classtools.py
[TopTest: attr1=0, attr2=1]
[SubTest: attr1=2, attr2=3]


 Атрибуты экземпляров и атрибуты классов

 Если внимательно изучить программный код самопроверки в модуле 
classtools, можно заметить, что реализованный нами класс отображает
только атрибуты экземпляров, присоединенные непосредственно к объекту,
расположенному в самом низу дерева наследования, – то есть те, 
что содержатся в атрибуте __dict__ объекта self. Как результат, 
мы не получаем информации об атрибутах, унаследованных экземплярами 
от классов, находящихся выше в дереве (таких как атрибут count
в этом примере). Унаследованные атрибуты класса присоединяются только
к объекту класса, и не повторяются в экземплярах.

 Если вам потребуется добавить вывод унаследованных атрибутов, вы можете
с помощью ссылки __class__ получить доступ к классу экземпляра и извлечь
из его словаря __dict__ атрибуты класса, а затем выполнить итерации 
через содержимое атрибута __bases__ класса, чтобы подняться до уровня 
супер-классов (настолько высоко, насколько это потребуется). Если вы
предпочитаете не усложнять программный код, вместо атрибута __dict__ 
можно вызвать встроенную функцию dir, передав ей экземпляр, и получить 
тот же результат, потому что функция dir включает в результат 
унаследованные имена и возвращает его в виде отсортированного списка:
"""

# В Python 3.0:
print(list(bob.__dict__.keys()))  # В 3.0 метод keys возвращает
#                                   представление, а не список

print(dir(bob))  # В 3.0 включаются методы типа класса

"""
 Выбор имен в инструментальных классах
 
 И последняя тонкость: поскольку наш класс AttrDisplay в модуле 
classtools является обобщенным инструментом, предназначенным служить 
супер-классом для любых других классов, мы должны помнить о возможности
непреднамеренных конфликтов имен с клиентскими классами. Предполагается,
что в клиентских подклассах будут использоваться оба метода, __str__ 
и gatherAttrs, но может оказаться так, что последний из них не будет 
соответствовать ожиданиям подклассов, – если в подклассе
по неосторожности будет переопределено имя gatherAttrs, это наверняка
нарушит работу нашего класса, потому что вместо нашей версии будет 
использоваться версия метода, реализованная в подклассе.

 Чтобы убедиться в этом, добавим реализацию метода gatherAttrs
в класс TopTest в программном коде самопроверки – если только новый
метод не будет идентичен оригинальной версии, наш инструментальный класс
не будет давать ожидаемых результатов:


class TopTest(AttrDisplay):
    ....
    def gatherAttrs(self):  # Replaces method in AttrDisplay!
        return ‘Spam’
        
        
 Это необязательно плохо – иногда бывает желательно создать другие 
методы, доступные в подклассах, либо для непосредственного 
использования, либо для адаптации. Однако если в действительности 
нам требуется предоставить только метод __str__, тогда такой подход
нельзя назвать идеальным.

 Чтобы минимизировать вероятность конфликта имен, как в данном случае,
программисты на языке Python часто добавляют символ подчеркивания
в начало имени метода, не предназначенного для использования 
за пределами класса: _gatherAttrs в нашем случае. Этот прием 
не избавляет нас полностью от ошибок (что, если в другом классе также
будет определен метод _gatherAttrs?), но обычно этого бывает достаточно,
а кроме того – это общепринятое соглашение об именовании внутренних 
методов классов в языке Python.

 Лучшее, но реже используемое решение состоит в том, чтобы добавить 
два символа подчеркивания в начало имени метода: __gatherAttrs.
Интерпретатор автоматически дополняет такие имена, включая в них имя 
вмещающего класса, что обеспечивает им истинную уникальность.
Эту особенность обычно называют псевдочастные атрибуты класса. Мы будем
рассматривать ее в главе 30. А пока оставим оба метода общедоступными.


 Окончательные версии наших классов
 
 Теперь, чтобы воспользоваться этим обобщенным инструментом в наших 
классах, достаточно будет импортировать его из модуля, добавить в список
наследуемых классов нашего базового класса и удалить из него реализацию 
метода __str__, которая была создана ранее. Новая реализация метода 
перегрузки операции вывода будет унаследована экземплярами классов
Person и Manager – класс Manager унаследует метод __str__ от класса
Person, который в свою очередь унаследует ее от класса AttrDisplay, 
реализованного в другом модуле. Ниже приводится окончательная версия
нашего модуля person.py со всеми изменениями:
"""


# Файл person.py (окончательная версия)
class Person(AttrDisplay):
    """
    Создает и обрабатывает записи с информацией о людях
    """

    def __init__(self, name, job=None, pay=0):
        self.name = name
        self.job = job
        self.pay = pay

    def lastName(self):  # Предполагается, что фамилия
        return self.name.split()[-1]  # указана последней

    def giveRaise(self, percent):  # Процент – величина в диапазоне 0..1
        self.pay = int(self.pay * (1 + percent))


class Manager(Person):
    """
    Версия класса Person, адаптированная в соответствии
    со специальными требованиями
    """

    def __init__(self, name, pay):
        Person.__init__(self, name, 'mgr', pay)

    def giveRaise(self, percent, bonus=.10):
        Person.giveRaise(self, percent + bonus)


if __name__ == '__main__':
    bob = Person('Bob Smith')
    sue = Person('Sue Jones', job='dev', pay=100000)
    print(bob)
    print(sue)
    print(bob.lastName(), sue.lastName())
    sue.giveRaise(.10)
    print(sue)
    tom = Manager('Tom Jones', 50000)
    tom.giveRaise(.10)
    print(tom.lastName())
    print(tom)

"""
 Так как это окончательная версия, мы добавили в нее несколько 
комментариев, описывающих наши классы, – строки документирования
с функциональным описанием и небольшие примечания, начинающиеся
с символа #, в соответствии общепринятыми соглашениями. Если теперь 
запустить этот сценарий, он выведет все атрибуты наших объектов,
а не только те, что ранее были явно указаны в оригинальной версии
метода __str__. Наша последняя проблема была разрешена: так как
реализация класса AttrDisplay извлекает имя класса непосредственно 
из экземпляра, для каждого объекта выводится имя ближайшего 
к нему класса – для объекта tom теперь выводится имя класса Manager,
а не Person, и мы, наконец-то, можем убедиться, что атрибут job 
был корректно инициализирован в конструкторе класса Manager:

C:\misc> person.py
[Person: job=None, name=Bob Smith, pay=0]
[Person: job=dev, name=Sue Jones, pay=100000]
Smith Jones
[Person: job=dev, name=Sue Jones, pay=110000]
Jones
[Manager: job=mgr, name=Tom Jones, pay=60000]

 На этот раз сценарий выводит больше полезной информации, чем прежде.
С точки зрения отдаленной перспективы наш класс, реализующий вывод 
атрибутов, можно рассматривать как обобщенный инструмент, который можно
использовать как супер-класс для любых других классов, обеспечивающий
вывод атрибутов. Все клиенты, наследующие его, автоматически будут
воспринимать все изменения, которые в дальнейшем будут производиться
в нашем инструменте. Далее в этой книге мы познакомимся с еще более 
мощными концепциями инструментальных классов, такими как декораторы
и метаклассы. Наряду с инструментами интроспекции, имеющимися 
в языке Python, они позволяют писать программный код, расширяющий классы
и управляющий ими структурированными и простыми в сопровождении 
способами.


 Шаг 7 (последний): сохранение объектов в базе данных
 
К настоящему моменту мы почти закончили нашу работу. Теперь у нас
имеется система из двух модулей, которая не только реализует 
поставленную задачу представления информации о людях, но и предоставляет 
обобщенный инструмент отображения атрибутов, который в будущем может 
использоваться нами и в других программах. Поместив функции и классы 
в модули, мы обеспечили возможность многократного их использования. 
А организовав программное обеспечение в виде классов, мы обеспечили 
возможность его расширения.

 Наши классы действуют так, как мы и задумывали, однако объекты, которые
создаются с их помощью, не являются настоящими записями в базе данных.
То есть по завершении программы все созданные экземпляры исчезнут – они
являются обычными объектами в памяти компьютера и не сохраняются 
на устройствах долговременного хранения, например в файлах, поэтому их 
не удастся восстановить при следующем запуске программы. Однако, 
как оказывается, совсем не сложно организовать сохранение объектов 
с помощью такой особенности Python, как хранилище объектов, позволяющей
восстанавливать объекты после того, как программа создаст их и завершит
работу. На заключительном шаге этого примера мы реализуем возможность 
сохранения объектов.


 Модули pickle, shelve и dbm
 
 Возможность сохранения объектов во всех версиях Python обеспечивают три
модуля в стандартной библиотеке:

 pickle
 
  Преобразует произвольные объекты на языке Python в строку байтов 
 и обратно.
 
 dbm (в Python 2.6 называется anydbm)
 
  Реализует сохранение строк в файлах, обеспечивающих возможность 
 обращения по ключу.
 
 shelve
 
  Использует первые два модуля, позволяя сохранять объекты 
 в файлах-хранилищах, обеспечивающих возможность обращения по ключу.

 Мы уже сталкивались с этими модулями в главе 9, когда изучали основы
работы с файлами. Они реализуют мощные возможности сохранения данных.
Мы не можем достаточно подробно останавливаться на особенностях этих
модулей в данной книге, однако они настолько просты в обращении, 
что краткого введения будет вполне достаточно, чтобы приступить 
к их использованию.

 Модуль pickle обеспечивает самые общие средства преобразования 
объектов: он способен превратить практически любой объект, находящийся
в памяти, в строку байтов, которая затем может использоваться 
для восстановления оригинального объекта. Модуль pickle может 
обрабатывать почти все объекты, создаваемые вами, – списки, словари,
вложенные комбинации из этих объектов, а также экземпляры классов. 
Последнее особенно важно для нас, потому что эта возможность позволяет 
сохранять данные (атрибуты) и поведение (методы) – фактически 
эта комбинация эквивалентна «записям» и «программам». Благодаря 
такой универсальности модуля pickle, он поможет нам избежать
необходимости писать дополнительный программный код, реализующий 
создание и анализ текстовых файлов, содержащих наши объекты. Сохраняя
объекты в файле в виде строк с помощью модуля pickle, вы фактически 
обеспечиваете долговременное хранение этих объектов: позднее достаточно
будет просто загрузить эти строки и восстановить из них оригинальные 
объекты.

 С помощью модуля pickle достаточно просто организовать сохранение 
объектов в простых файлах и загрузку их из файлов, однако модуль shelve 
обеспечивает дополнительные удобства, позволяя сохранять объекты, 
обработанные модулем pickle, по ключу. Модуль shelve преобразует объект 
в строку с помощью модуля pickle и сохраняет ее под указанным ключом
в файле dbm. Позднее, когда это необходимо, модуль shelve извлекает 
строку по ключу и воссоздает оригинальный объект в памяти, опять же
с помощью модуля pickle. На первый взгляд все это кажется немного 
сложным, однако в программе обращение к объектам в хранилище выглядит
как обращение к элементам словаря – вы обращаетесь к объекту по ключу,
сохраняете его, выполняя присваивание по ключу, и можете использовать 
инструменты словарей, такие как len, in и dict.keys, чтобы получить 
дополнительную информацию. Модуль shelve автоматически отображает
операции со словарем на объекты, хранящиеся в файле.

 Фактически единственное отличие между хранилищами объектов и обычными 
словарями состоит в том, что хранилища необходимо предварительно 
открывать, а затем закрывать их после внесения изменений. Таким образом,
хранилища можно рассматривать, как простейшие базы данных, позволяющие 
сохранять и извлекать объекты по ключу и тем самым обеспечивающие
сохранность объектов между запусками программы. Хранилища 
не поддерживают возможность выполнения запросов, например, на языке SQL, 
и испытывают недостаток дополнительных возможностей, которыми обладают
развитые базы данных (такие как обработка транзакций), однако объекты, 
находящиеся в хранилище, способны использовать всю широту возможностей
языка Python после того, как они будут извлечены обратно.


 Сохранение объектов в хранилище
 
 Напишем новый сценарий, который сохраняет экземпляры наших классов
в хранилище. В своем текстовом редакторе создайте новый файл makedb.py.
Так как это новый файл, в него необходимо импортировать наши классы, 
чтобы с их помощью создать несколько экземпляров для последующего
сохранения. Ранее для загрузки класса в интерактивную оболочку 
мы использовали инструкцию from, но в действительности существует 
два способа загрузки классов из модулей, так же как функций и других 
переменных (имена классов – это переменные, которые ничем не отличаются 
от любых других переменных и не являются чем-то особенным 
в этом смысле):

import person  # Загружает класс с помощью инструкции import
bob = person.Person(...)  # Обращение к классу через имя модуля

from person import Person  # Загружает класс с помощью инструкции from
bob = Person(...)  # Обращение по непосредственному имени класса

 Для загрузки классов в сценарий мы будем использовать инструкцию from,
просто потому, что в этом случае придется чуть меньше вводить 
с клавиатуры. Скопируйте следующий фрагмент, создающий экземпляры наших
классов, в новый сценарий, чтобы нам было что сохранять (это всего лишь
демонстрационный пример, поэтому мы не будем беспокоиться 
об избыточности программного кода самопроверки). Создав экземпляры,
мы практически без труда можем сохранить их в хранилище. Для этого 
достаточно просто импортировать модуль shelve, открыть новое хранилище,
указав имя внешнего файла, выполнить присваивание объектов по ключам 
и по окончании закрыть хранилище:
"""

# Файл makedb.py: сохраняет объекты Person в хранилище

import shelve

db = shelve.open('persondb')  # Имя файла хранилища

for obj in (bob, sue, tom):  # В качестве ключа использовать
    #                          атрибут name
    db[obj.name] = obj  # Сохранить объект в хранилище
db.close()  # Закрыть после внесения изменений

"""
 Обратите внимание, что при присваивании объектов в качестве ключей 
используются значения атрибутов name. Так сделано просто потому, 
что это удобно, – ключами в хранилище могут быть любые строки, которые 
можно было бы создать с применением уникальных характеристик, таких как 
идентификатор процесса и отметки времени (их можно получить с помощью
модулей os и time стандартной библиотеки). Единственное ограничение – 
ключи могут быть только строками и должны быть уникальными, потому что
под каждым ключом можно сохранить только один объект (впрочем, таким 
объектом может быть список или словарь, содержащий множество объектов). 
А вот значениями, которые сохраняются по ключу, могут быть объекты 
практически любого типа: это могут быть объекты встроенных типов, таких 
как строки, списки, словари и экземпляры пользовательских классов,
а также вложенные комбинации из них.

 Вот, собственно, и все – если при запуске сценарий ничего не выводит, 
это означает, что он, скорее всего, работает – мы не предусмотрели вывод 
какой-либо информации, просто создаем и сохраняем объекты:

C:\misc> makedb.py


 Исследование хранилища в интерактивном сеансе
 
 К настоящему моменту у нас имеется в текущем рабочем каталоге один
или более файлов, имена которых начинаются с «persondb». Реально 
создаваемые файлы могут отличаться в зависимости от платформы, 
и точно так же, как при использовании встроенной функции open, функция 
shelve.open() создает файлы в текущем рабочем каталоге, если указанное
имя файла не содержит полный путь. Но независимо от того,
где сохраняются эти файлы, они обеспечивают доступ по ключу 
к представлениям объектов, созданных с помощью модуля pickle. 
Не удаляйте эти файлы – они являются вашей базой данных, которую вам 
придется копировать или перемещать, когда вы будете создавать резервные
копии вашего хранилища или переносить его.

 При желании вы можете заглянуть внутрь файлов хранилищ с помощью 
программы Проводника Windows (Windows Explorer) или с помощью 
интерактивной оболочки Python, однако эти файлы имеют двоичный формат 
и их содержимое не имеет большого смысла вне контекста модуля shelve.
В Python 3.0, в случае отсутствия дополнительного программного 
обеспечения, наша база данных сохраняется в трех файлах (в 2.6 – 
только в одном, с именем persondb, потому что в этой версии присутствует
модуль расширения bsddb; в версии 3.0 модуль bsddb является сторонним 
дополнением, которое распространяется с открытыми исходными текстами):


>>> 
[‘person.py’, ‘person.pyc’, ‘persondb.bak’, ‘persondb.dat’, 
 ‘persondb.dir’]
‘Tom Jones’, (1024, 91)
...часть строк опущена...
>>> pri
"""

# Модуль, позволяющий получить список файлов в каталоге:
# проверка наличия файлов

import glob


print(glob.glob('person*'))

# Тип файла: текстовый – для строк, двоичный – для байтов
print(open('persondb.dir').read())

print(open('persondb.dat', 'rb').read())

"""
 Расшифровать такое содержимое вполне возможно, но оно может изменяться
в зависимости от платформы и уж определенно не может квалифицироваться
как дружественный интерфейс к базе данных! Чтобы проверить результаты
нашего труда, можно написать еще один сценарий или попробовать 
поработать с хранилищем в интерактивной оболочке. Поскольку 
сами хранилища являются объектами на языке Python, содержащими другие 
объекты на языке Python, мы можем работать с ними, используя привычный
синтаксис языка Python. Ниже приводится листинг интерактивного сеанса,
который фактически играет роль клиента базы данных:
"""

db = shelve.open('persondb')  # Открыть хранилище

print(len(db))  # В хранилище содержится три ‘записи’

print(list(db.keys()))  # keys – это оглавление
# Функция list используется, чтобы получить список в 3.0

bob = db['Bob Smith']  # Извлечь объект bob по ключу
print(bob)  # Вызовет __str__ из AttrDisplay

print(bob.lastName())  # Вызовет lastName из Person

for key in db:  # Итерации, извлечение, вывод
    print(key, '=>', db[key])

for key in sorted(db):
    print(key, '=>', db[key])  # Итерации через отсортированный
    #                            список ключей

"""
 Обратите внимание: от нас не требуется импортировать классы Person 
или Manager, чтобы загрузить и использовать сохраненные объекты. 
Например, мы можем вызвать метод lastName объекта bob и вывести 
его содержимое, которое будет отформатировано автоматически, 
даже при том что класс Person этого объекта находится вне области
видимости. Это обусловлено тем, что, когда модуль pickle преобразует 
экземпляр класса, он записывает атрибуты экземпляра self вместе 
с именем класса, из которого он был создан, и именем модуля, 
где находится определение этого класса. Когда позднее объект bob 
извлекается из хранилища, интерпретатор автоматически импортирует класс 
и связывает с ним объект bob.

 Благодаря такому поведению после загрузки экземпляры классов
автоматически обретают поведение своего класса. Мы должны импортировать 
наши классы, только если необходимо создавать новые экземпляры,
но не для работы с существующими. Такая особенность поведения влечет з
а собой следующие последствия:

  Недостаток заключается в том, что позднее, когда выполняется загрузка
 экземпляров, классы и их модули должны быть доступны 
 для импортирования. Если говорить более формально, классы сохраняемых 
 объектов должны быть определены на верхнем уровне модуля, который 
 находится в одном из каталогов в пути поиска sys.path (и не должны
 находиться в модуле __main__ сценария, если только они не используются
 только в пределах этого модуля). Из-за этих требований, предъявляемых 
 к внешним файлам модулей, в некоторых приложениях для сохранения 
 используются более простые объекты, такие как словари или списки, 
 особенно когда они передаются другим приложениям через Интернет.

  Преимущество заключается в том, что изменения в реализации класса 
 автоматически будут восприняты экземплярами после их загрузки – 
 часто нет никакой необходимости обновлять сохраненные объекты, 
 потому что обычно изменения касаются только реализации методов класса.

 Кроме того, модуль shelve имеет определенные ограничения (некоторые
из них упоминаются в конце этой главы, в списке баз данных, предлагаемых
к использованию). Тем не менее модули shelve и pickle являются отличными
инструментами, когда речь идет о реализации простого хранилища объектов.


 Обновление объектов в хранилище
 
 Теперь создадим еще один, последний сценарий, который обновляет
экземпляры (записи) при каждом запуске, чтобы мы могли убедиться,
что наши объекты действительно сохраняются между запусками программы
(то есть при каждом запуске программы доступны их текущие значения).
Следующий файл, updatedb.py, выводит содержимое базы данных
и увеличивает зарплату в одном из наших объектов при каждом запуске.
Если внимательно проследить за тем, что делает этот сценарий, можно 
заметить, что он «бесплатно» пользуется массой возможностей – 
при выводе наших объектов автоматически вызывается наша реализация
метода __str__ и повышение зарплаты выполняется вызовом нашего метода 
giveRaise. Все это возможно благодаря особенностям ООП и механизму
наследования объектов, даже если сами объекты находятся 
в файле хранилища:
"""

# Файл updatedb.py: обновляет объект класса Person в базе данных

db = shelve.open('persondb')  # Открыть хранилище в файле
#                               с указанным именем

sue = db['Sue Jones']  # Извлечь объект по ключу
sue.giveRaise(.10)  # Изменить объект в памяти вызовом метода
db['Sue Jones'] = sue  # Присвоить по ключу,
#                        чтобы обновить объект в хранилище

db.close()

"""
 Благодаря тому, что при запуске этот сценарий выводит содержимое 
базы данных, мы можем запустить его несколько раз и увидеть, 
как изменяются наши объекты. Ниже приводятся результаты нескольких 
запусков сценария, где можно наблюдать, как каждый раз повышается
зарплата sue (отличный сценарий для sue...):

c:\misc> updatedb.py
Bob Smith => [Person: job=None, name=Bob Smith, pay=0]
Sue Jones => [Person: job=dev, name=Sue Jones, pay=100000]
Tom Jones => [Manager: job=mgr, name=Tom Jones, pay=50000]

c:\misc> updatedb.py
Bob Smith => [Person: job=None, name=Bob Smith, pay=0]
Sue Jones => [Person: job=dev, name=Sue Jones, pay=110000]
Tom Jones => [Manager: job=mgr, name=Tom Jones, pay=50000]

 Все, что мы наблюдаем здесь, – это результат работы модулей shelve 
и pickle, входящих в состав Python, и поведения, которое мы сами 
реализовали в наших классах. Напомню также, что мы можем проверить 
результаты запуска сценария с помощью интерактивной оболочки (эквивалент 
клиента базы данных на основе модуля shelve):

c:\misc> python
>>> import shelve
>>> db = shelve.open(‘persondb’)  # Открыть базу данных
>>> rec = db[‘Sue Jones’]  # Извлечь объект по ключу
>>> print(rec)
[Person: job=dev, name=Sue Jones, pay=146410]
>>> rec.lastName()
‘Jones’
>>> rec.pay
146410


 Рекомендации на будущее
 
 Это заключительный раздел данной главы. К настоящему моменту
вы увидели все основные механизмы ООП языка Python в действии
и познакомились со способами, позволяющими избежать
избыточности программного кода и сопутствующих ей проблем
при сопровождении. Вы создали полноценные классы,
выполняющие настоящую работу. Дополнительно вы смогли превратить
экземпляры этих классов в настоящие записи в базе данных, сохранив их
в хранилище с помощью модуля shelve, и тем самым обеспечили возможность
долговременного хранения информации.

 Конечно, существует гораздо больше особенностей, чем мы исследовали 
здесь. Например, мы могли бы расширить наши классы, чтобы сделать их
еще более реалистичными, добавить в них новые черты поведения 
и так далее. Например, на практике в операцию увеличения зарплаты
следовало бы добавить проверку коэффициента повышения, 
чтобы гарантировать, что его значение находится в диапазоне от нуля
до единицы, – мы добавим ее ниже, в этой же книге, когда познакомимся
с декораторами. Кроме того, этот пример можно было бы преобразовать
в персональную базу данных с контактной информацией, изменив перечень 
атрибутов в объектах и методов, предназначенных для их обработки.
В общем, этот список предложений можно продолжить в соответствии
с богатством вашего воображения.

 Кроме того, мы могли расширить круг наших интересов и использовать
инструменты, поставляемые в составе Python или доступные в мире 
свободного программного обеспечения:

 Графический интерфейс пользователя
 
  В настоящий момент мы можем взаимодействовать с нашей базой данных
 только с помощью командного интерфейса интерактивной оболочки 
 и сценариев. Однако мы могли бы повысить удобство использования 
 базы данных объектов, добавив графический интерфейс пользователя, 
 позволяющий просматривать и изменять записи. Имеется возможность 
 создавать переносимые графические интерфейсы с помощью пакета tkinter 
 (Tkinter – в 2.6), входящего в состав стандартной библиотеки Python,
 или с помощью сторонних инструментов, таких как WxPython и PyQt. 
 Пакет tkinter распространяется в составе Python, позволяет быстро 
 создавать простые графические интерфейсы и идеально подходит 
 для изучения приемов разработки графического интерфейса. WxPython
 и PyQt являются более сложными в использовании, но зачастую позволяют 
 получать более высококачественные графические интерфейсы.

 Веб-сайты
 
  Хотя графические интерфейсы удобны в использовании и обладают высокой 
 скоростью работы, тем не менее они не могут состязаться
 с веб-интерфейсами в смысле доступности. Вместо или в дополнение 
 к графическому интерфейсу и интерактивной оболочке мы могли бы также
 реализовать веб-сайт, позволяющий просматривать и изменять записи.
 Веб-сайты можно строить на основе простых инструментов создания 
 CGI-сценариев, входящих в состав Python, или использовать полноценные 
 веб-фреймворки от сторонних производителей, такие как Django, 
 TurboGears, Pylons, web2Py, Zope или Google App Engine. 
 При использовании веб-интерфейса данные по-прежнему могут сохраняться 
 в файлах с помощью модулей shelve, pickle или других инструментов, 
 предназначенных для использования в программах на языке Python. 
 Сценарии, обрабатывающие эти файлы, вызываются сервером автоматически,
 в ответ на запросы, поступающие от веб-броузеров и других клиентов,
 и возвращают разметку HTML, обеспечивающую взаимодействие 
 с пользователем, либо непосредственно, либо с применением фреймворка.

 Веб-службы
  
  Веб-клиенты часто сами могут выполнять анализ информации, полученной 
 в ответе от веб-сайта (этот прием известен под красочным называнием
 «screen scraping»1). Однако мы могли бы пойти еще дальше и предоставить
 более прямой способ извлечения записей из базы данных на стороне 
 веб-сервера – посредством интерфейсов веб-служб, таких как SOAP 
 или XMLRPC, поддержка которых или включена в состав Python,
 или может быть добавлена за счет установки сторонних, свободно 
 распространяемых пакетов и модулей. Веб-службы возвращают данные 
 в более непосредственном виде, по сравнению со страницами HTML, 
 возвращаемыми веб-сервером.
 
 Базы данных
 
  Если база данных должна хранить большой объем данных или эти данные
 имеют большое значение, мы могли бы отказаться от использования модуля
 shelve и использовать более полноценный механизм хранения данных,
 такой как ZODB (свободно распространяемая, объектно-ориентированная
 база данных, ООДБ), или более традиционную реляционную базу данных,
 такую как MySQL, Oracle, PostgreSQL или SQLite. В состав Python уже 
 входит поддержка встраиваемой системы баз данных SQLite, однако в Сети
 вы найдете и другие свободно распространяемые альтернативы. Механизм
 ZODB, например, своими особенностями напоминает модуль shelve, однако
 в ZODB отсутствуют многие ограничения, присущие shelve; он поддерживает
 возможность работы с большими базами данных, параллельное изменение 
 данных, транзакции и автоматическую сквозную запись изменений,
 выполняемых в памяти. Базы данных SQL, такие как MySQL, обеспечивают 
 инструментальные средства по организации хранилищ данных уровня
 предприятия и могут напрямую использоваться из сценариев 
 на языке Python.

 Механизмы объектно-реляционных отображений (ORM)
 
  При переходе на использование системы управления реляционными базами 
 данных нам не придется отказываться от инструментов ООП, имеющихся 
 в языке Python. Механизмы объектно-реляционного отображения 
 (object-relational mapping, ORM), такие как SQLObject и SQLAlchemy, 
 могут автоматически отображать реляционные таблицы и записи в классы 
 и экземпляры на языке Python и обратно, благодаря чему мы можем 
 обрабатывать хранимые данные, используя привычный синтаксис классов
 языка Python. Эти механизмы обеспечивают альтернативу использованию 
 ООДБ, таких как shelve и ZODB, и позволяют объединить сильные стороны
 реляционных баз данных и модели классов в языке Python.
"""

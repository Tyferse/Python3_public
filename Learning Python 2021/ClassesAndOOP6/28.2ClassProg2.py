"""
 Пространства имен: окончание истории

 Теперь, когда мы уже исследовали объекты классов и экземпляров,
повествование о пространствах имен в языке Python можно считать
завершенным. Для справки я напомню здесь все правила, используемые
при разрешении имен. Первое, что вам нужно запомнить: квалифицированные
и неквалифицированные имена интерпретируются по-разному, и некоторые
области видимости служат для инициализации пространств имен объектов:

  Неквалифицированные имена (например, X) располагаются в областях
 видимости.

  Квалифицированные имена атрибутов (например, object.X) принадлежат
 пространствам имен объектов.

  Некоторые области видимости инициализируют пространства имен объектов
 (в модулях и классах).


 Простые имена: глобальные, пока не выполняется присваивание

 Поиск неквалифицированных простых имен выполняется в соответствии
с правилом лексической видимости LEGB, выведенном для функций
в главе 17:

 Присваивание (X = value)

  Операция присваивания делает имена локальными: создает или изменяет
 имя X в текущей локальной области видимости, если имя не объявлено
 глобальным.

 Ссылка (X)

  Пытается отыскать имя X в текущей локальной области видимости, затем
 в области видимости каждой из вмещающих функций, затем в текущей
 глобальной области видимости и, наконец, во встроенной
 области видимости.


 Имена атрибутов: пространства имен объектов

 Квалифицированные имена атрибутов ссылаются на атрибуты конкретных
объектов и к ним применяются правила, предназначенные для модулей
и классов. Для объектов классов и экземпляров эти правила дополняются
включением процедуры поиска в дереве наследования:

 Присваивание (object.X = value)

  Создает или изменяет атрибут с именем X в пространстве имен
 объекта object, и ничего больше. Восхождение по дереву наследования
 происходит только при попытке получить ссылку на атрибут,
 но не при выполнении операции присваивания.

 Ссылка (object.X)

  Для объектов, созданных на основе классов, поиск атрибута X
 производится сначала в объекте object, затем во всех классах,
 расположенных выше в дереве наследования. В случае объектов, которые
 создаются не из классов, таких как модули, атрибут X извлекается
 непосредственно из объекта object.


 «Дзен» пространств имен в Python:
классификация имен происходит при присваивании

 Из-за различий в процедурах поиска простых и составных имен
и нескольких уровней поиска в обеих процедурах иногда бывает трудно
сказать, где будет найдено имя. В языке Python место, где выполняется
присваивание, имеет крайне важное значение – оно полностью определяет
область видимости или объект, где будет размещаться имя.
Файл manynames.py, ниже, иллюстрирует, как эти принципы переводятся
в программный код, и обобщает идеи, касающиеся пространств имен,
с которыми мы встречались на протяжении книги:
"""

# manynames.py

X = 11  # Глобальное (в модуле) имя/атрибут (X, или manynames.X)


def f():
    print(X)  # Обращение к глобальному имени X (11)


def g():
    X = 22  # Локальная (в функции) переменная
    #         (X, скрывает имя X в модуле)
    print(X)


class C:
    X = 33  # Атрибут класса (C.X)

    def m(self):
        X = 44  # Локальная переменная в методе (X)
        self.X = 55  # Атрибут экземпляра (instance.X)


"""
 В этом файле пять раз выполняется присваивание одному 
и тому же имени X. Однако, так как присваивание выполняется в пяти 
разных местах, все пять имен X в этой программе представляют совершенно
разные переменные. Сверху вниз присваивание имени X приводит к созданию:
атрибута модуля (11), локальной переменной в функции (22),
атрибута класса (33), локальной переменной в методе (44) и атрибута 
экземпляра (55). Все пять переменных имеют одинаковые имена, однако 
они создаются в разных местах программного кода или в разных объектах,
что делает их уникальными переменными.

 Не следует торопиться тщательно изучать этот пример, 
потому что в нем собраны идеи, которые мы исследовали на протяжении 
последних нескольких частей этой книги. Когда до вас дойдет его смысл, 
вы достигнете своего рода нирваны пространств имен в языке Python.
Конечно, существует и другой путь к нирване – просто запустите программу
и посмотрите, что произойдет. Ниже приводится остаток этого файла, 
где создается экземпляр и выводятся значения всех имеющихся 
переменных X:
"""

# manynames.py, продолжение

if __name__ == '__main__':
    print(X)  # 11: модуль (за пределами файла manynames.X)
    f()  # 11: глобальная
    g()  # 22: локальная
    print(X)  # 11: переменная модуля не изменилась
    obj = C()  # Создать экземпляр
    print(obj.X)  # 33: переменная класса, унаследованная экземпляром
    obj.m()  # Присоединить атрибут X к экземпляру
    print(obj.X)  # 55: экземпляр
    print(C.X)  # 33: класс (она же obj.X, если в экземпляре нет X)
    # print(C.m.X) # ОШИБКА: видима только в методе
    # print(g.X) # ОШИБКА: видима только в функции

"""
 В комментариях отмечено, что будет выведено на экран после запуска
этого файла, – прочитайте их, чтобы увидеть, к какой переменной X 
выполняется обращение в том или ином случае. Обратите также внимание, 
что мы можем добраться до атрибута класса (C.X), но мы никогда не сможем 
получить доступ к локальным переменным в функциях или методах, находясь 
за пределами соответствующих инструкций def. Локальные переменные видимы
только программному коду внутри инструкции def и существуют в памяти 
только во время выполнения функции или метода.

 Некоторые из имен, определяемых этим файлом, видимы и за пределами 
файла, в других модулях, но не забывайте, чтобы получить доступ 
к именам в другом файле, мы всегда должны сначала выполнить операцию
импортирования – в конце концов, в этом заключается главная особенность
модулей.
"""

# otherfile.py

# import manynames

print(X)  # 11: глобальная, ставшая атрибутом в результате импорта
X = 66
print(X)  # 66: здешняя глобальная переменная

f()  # 11: X в manynames, не здешняя глобальная!
g()  # 22: локальная в функции, в другом файле

print(C.X)  # 33: атрибут класса в другом модуле
I = C()
print(I.X)  # 33: все еще атрибут класса
I.m()
print(I.X)  # 55: а теперь атрибут экземпляра!

"""
 Обратите внимание, что manynames.f() выводит значение переменной X 
из модуля manynames, а не переменной из текущего модуля – область
видимости всегда определяется местоположением инструкции присваивания 
в программном коде (то есть лексически) и не зависит от того, 
что импортируется и куда импортируется. Кроме того, обратите внимание,
что собственный атрибут X в экземпляре отсутствовал, пока не был вызван
метод I.m(), – атрибуты, как и любые другие переменные, появляются 
на свет во время операции присваивания, а не до нее. Обычно атрибуты 
экземпляра создаются за счет присваивания им начальных значений 
в конструкторе __init__, но это не единственная возможность.

 Наконец, как мы узнали в главе 17, с помощью инструкций global 
и (в Python 3.0) nonlocal функции могут изменять переменные, находящиеся 
за их пределами, – эти инструкции не только обеспечивают доступ
к переменным для записи, но и изменяют правила привязки инструкций 
присваивания к пространствам имен:
"""

X = 11  # Глобальная в модуле


def g1():
    print(X)  # Ссылка на глобальную переменную в модуле


def g2():
    global X
    X = 22  # Изменит глобальную переменную в модуле


def h1():
    X = 33  # Локальная в функции

    def nested():
        print(X)  # Ссылка на локальную переменную в объемлющей функции


def h2():
    X = 33  # Локальная в функции

    def nested():
        nonlocal X  # Инструкция из Python 3.0
        X = 44  # Изменит локальную переменную в объемлющей функции


"""
 Конечно, вы не должны использовать одно и то же имя для обозначения 
всех переменных в своем сценарии! Но этот пример демонстрирует, 
что если даже вы поступите так, пространства имен в языке Python 
предотвратят случайный конфликт имен, используемых в одном контексте, 
с именами, используемыми в другом контексте.


 Словари пространств имен
 
 В главе 22 мы узнали, что пространства имен модулей фактически
реализованы как словари и доступны в виде встроенного атрибута __dict__. 
То же относится к объектам классов и экземпляров: обращение 
к квалифицированному имени атрибута фактически является операцией 
доступа к элементу словаря, а механизм наследования атрибута работает 
лишь как поиск в связанных словарях. Фактически объекты экземпляра 
и класса – это в значительной степени просто словари со ссылками,
ведущими вглубь интерпретатора. Интерпретатор Python обеспечивает 
возможность доступа к этим словарям, а также к ссылкам между ними 
для использования в особых случаях (например, при создании 
инструментальных средств).

 Чтобы понять внутреннее устройство атрибутов, давайте с помощью 
интерактивной оболочки проследим, как растут словари пространств имен,
когда в игру вступают классы. Более простой вариант этого примера 
мы уже видели в главе 26, но теперь мы знаем гораздо больше о методах
и супер-классах, поэтому расширим его немного. Сначала определим
супер-класс и подкласс с методами, которые сохраняют данные
в своих экземплярах:
"""


class super:
    def hello(self):
        self.data1 = 'spam'


class sub(super):
    def hola(self):
        self.data2 = 'eggs'


"""
 Когда мы создаем экземпляр подкласса, он начинает свое существование 
с пустым словарем пространства имен, но имеет ссылку на класс, стоящий
выше в дереве наследования. Фактически дерево наследования доступно
в виде специальных атрибутов, которые вы можете проверить. Экземпляры 
обладают атрибутом __class__, который ссылается на класс, а классы имеют
атрибут __bases__, который является кортежем, содержащим ссылки 
на супер-классы выше в дереве наследования (я выполнял этот пример
в Python 3.0 – в версии 2.6 формат вывода и имена некоторых внутренних
атрибутов немного отличаются):
"""

X = sub()
print(X.__dict__)  # Словарь пространства имен экземпляра

print(X.__class__)  # Класс экземпляра

print(sub.__bases__)  # Супер-классы данного класса

print(super.__bases__)  # В Python 2.6 возвращает пустой кортеж ()

"""
 Так как в классах выполняется присваивание атрибутам аргумента self, 
тем самым они заполняют объекты экземпляров, то есть атрибуты включаются
в словари пространств имен экземпляров, а не классов. В пространство 
имен объекта экземпляра записываются данные, которые могут отличаться
для разных экземпляров, и аргумент self является точкой входа 
в это пространство имен:
"""

Y = sub()
X.hello()
print(X.__dict__)

X.hola()
print(X.__dict__)

print(sub.__dict__.keys())
print(super.__dict__.keys())

print(Y.__dict__)

"""
 Обратите внимание на имена в словарях классов, содержащие символы
подчеркивания, – эти имена определяются интерпретатором автоматически. 
Большинство из них обычно не используются в программах, но существуют
такие инструменты, которые используют некоторые из этих имен 
(например, __doc__ хранит строки документирования, обсуждавшиеся
в главе 15).

 Обратите также внимание, что второй экземпляр Y, созданный в начале 
сеанса, по-прежнему имеет пустой словарь пространства имен, 
несмотря на то, что словарь экземпляра X заполнялся инструкциями 
присваивания в методах. Напомню еще раз, что у каждого экземпляра 
имеется свой, независимый словарь, который изначально пуст и может быть
заполнен совершенно другими атрибутами, чем пространства имен других 
экземпляров того же самого класса.

 Так как атрибуты фактически являются ключами словаря, существует два
способа получать и изменять их значения – по квалифицированным именам
или индексированием по ключу:
"""

print(X.data1, X.__dict__['data1'])

X.data3 = 'toast'
print(X.__dict__)

X.__dict__['data3'] = 'ham'
print(X.data3)

"""
 Однако такая эквивалентность применяется только к атрибутам, фактически
присоединенным к экземпляру. Так как обращение по квалифицированному
имени также вызывает запуск процедуры поиска в дереве наследования, 
такой способ может обеспечить доступ к атрибутам, которые нельзя 
получить индексированием словаря. Например, унаследованный атрибут 
X.hello недоступен через выражение X.__dict__[‘hello’].

 Наконец, ниже показано, что дает применение функции dir, с которой
мы встречались в главах 4 и 15, к объектам классов и экземпляров. 
Эта функция применяется к объектам, имеющим атрибуты: dir(object)
напоминает вызов object.__dict__.keys(). Однако обратите внимание,
что функция dir сортирует свой список и включает в него некоторые 
системные атрибуты; начиная с версии Python 2.2, функция dir также
автоматически собирает унаследованные атрибуты, а в версии 3.0 она 
добавляет в перечень имена, унаследованные от класса object, который
является супер-классом для всех классов:
"""

# В Python 3.0:

print(dir(X))

print(dir(sub))

print(dir(super))

"""
 Поэкспериментируйте самостоятельно с этими специальными атрибутами,
чтобы получить представление о том, как в действительности ведется
работа с атрибутами. Даже если вы никогда не будете использовать их
в своих программах, понимание того, что пространства имен – 
это всего лишь обычные словари, поможет лишить покрова таинственности
само понятие пространств имен.


 Ссылки на пространства имен
 
 В предыдущем разделе были представлены специальные атрибуты экземпляра
и класса __class__ и __bases__, но не объяснялось, зачем они могут 
понадобиться. В двух словах, эти атрибуты позволяют осматривать иерархии 
наследования в вашем программном коде. Например, их можно использовать
для отображения дерева классов на экране, как в следующем примере:
"""

# classtree.py

"""
Выполняет обход дерева наследования снизу вверх, используя ссылки 
на пространства имен, и отображает супер-классы с отступами
"""


def classtree(cls, indent):
    print('.' * indent + cls.__name__)  # Вывести имя класса
    for supercls in cls.__bases__:  # Рекурсивный обход
        classtree(supercls, indent + 3)  # всех супер-классов
        # Каждый супер-класс может быть посещен
        # более одного раза


def instancetree(inst):
    print('Tree of', inst.__class__.__name__)  # Показать экземпляр
    classtree(inst.__class__, 3)  # Взойти к его классу


def selftest():
    class A:
        pass

    class B(A):
        pass

    class C(A):
        pass

    class D(B, C):
        pass

    class E:
        pass

    class F(D, E):
        pass

    instancetree(B())
    instancetree(F())


if __name__ == '__main__':
    selftest()

"""
 Функция classtree в этом сценарии является рекурсивной – она выводит 
имя класса, используя атрибут __name__, и затем начинает подъем 
к супер-классам, вызывая саму себя. Это позволяет функции выполнять обход
деревьев классов произвольной формы – в процессе рекурсии выполняется 
подъем по дереву и заканчивается по достижении корневых супер-классов,
у которых атрибут __bases__ пуст.

 Большую часть этого файла занимает программный код самотестирования –
если запустить файл как самостоятельный сценарий, он построит пустое 
дерево классов, создаст в нем два экземпляра и выведет структуры 
классов, соответствующие им:

C:\misk> c:\python26\python classtree.py
Tree of <__main__.B instance at 0x02557328>
...B
......A
Tree of <__main__.F instance at 0x02557328>
...F
......D
.........B
............A
.........C
............A
......E

 При работе под управлением Python 3.0 в дерево классов будет включен
супер-класс всех объектов object, который автоматически добавляется
в список супер-классов, когда он пуст, потому что все классы
в Python 3.0 относятся к классам «нового стиля»
(подробнее об этом рассказывается в главе 31):

C:\misc> c:\python30\python classtree.py
Tree of <__main__.B object at 0x02810650>
...B
......A
.........object
Tree of <__main__.F object at 0x02810650>
...F
......D
.........B
............A
...............object
.........C
............A
...............object
......E
.........object

 Отступы, отмеченные точками, обозначают высоту в дереве классов. 
Конечно, мы могли бы улучшить формат вывода и даже отобразить дерево
в графическом интерфейсе. Мы можем импортировать эти функции везде, 
где нам может потребоваться быстро отобразить дерево классов:

C:\misc> c:\python30\python
>>> class Emp: pass
...
>>> class Person(Emp): pass
...
>>> bob = Person()

>>> import classtree
>>> classtree.instancetree(bob)
Tree of <__main__.Person instance at 0x028203B0>
...Person
......Emp
.........object

 Независимо от того, будете вы создавать и использовать нечто подобное 
в своей практике или нет, этот пример демонстрирует один из многих
способов использования специальных атрибутов, которые создаются
внутренними механизмами интерпретатора. Еще один пример вы увидите
в разделе «Множественное наследование: классы-смеси», в главе 30, 
где мы с помощью этого же приема реализуем вывод атрибутов всех объектов 
в дереве классов. В последней части книги мы снова вернемся к этой теме,
когда будем рассматривать способы создания частных атрибутов, проверку 
аргументов и многое другое. Доступность внутренних особенностей 
реализации является мощным оружием в руках программиста, однако 
оно требуется далеко не всем.


 Еще раз о строках документирования
 
 Пример модуля в предыдущем разделе содержит строку документирования,
описывающую этот модуль, но точно так же они могут использоваться
для описания компонентов классов. Строки документирования, которые 
мы подробно рассматривали в главе 15, – это литералы строк, которые
присутствуют на верхнем уровне различных структур и автоматически 
сохраняются интерпретатором в атрибутах __doc__ соответствующих им 
объектов. Строки документирования могут присутствовать в модулях, 
в инструкциях def, а также в определениях классов и методов.

 Теперь, когда мы ближе познакомились с классами и методами,
можно изучить короткий, но емкий пример docstr.py – 
здесь демонстрируются места в программном коде, где могут появляться
строки документирования. Все они могут представлять собой блоки 
в тройных кавычках:

“I am: docstr.__doc__”


def func(args):
    “I am: docstr.func.__doc__”
    pass
    
    
class spam:
    “I am: spam.__doc__ or docstr.spam.__doc__”
    def method(self, arg):
        “I am: spam.method.__doc__ or self.method.__doc__”
        pass
        
        
 Основное преимущество строк документирования состоит в том, 
что их содержимое доступно во время выполнения. То есть, если текст 
был оформлен в виде строки документирования, можно будет обратиться 
к атрибуту __doc__ объекта, чтобы получить его описание:

>>> import docstr
>>> docstr.__doc__
‘I am: docstr.__doc__’
>>> docstr.func.__doc__
‘I am: docstr.func.__doc__’
>>> docstr.spam.__doc__
‘I am: spam.__doc__ or docstr.spam.__doc__’
>>> docstr.spam.method.__doc__
‘I am: spam.method.__doc__ or self.method.__doc__’

 В главе 15 также обсуждается PyDoc – инструмент, который позволяет 
формировать отчеты из всех этих строк. Ниже приводится пример
интерактивного сеанса в Python 2.6 (в версии Python 3.0 выводятся
дополнительные атрибуты, унаследованные от класса object, который 
в модели классов «нового стиля» является супер-классом всех классов.
Запустите его у себя в версии 3.0, чтобы увидеть дополнительные 
атрибуты, а дополнительную информацию об этих различиях вы найдете
в главе 31):

>>> help(docstr)
Help on module docstr:

NAME
    docstr - I am: docstr.__doc__
    
FILE
    c:\misc\docstr.py
    
CLASSES
    spam
    
    class spam
     | I am: spam.__doc__ or docstr.spam.__doc__
     |
     | Methods defined here:
     |
     | method(self, arg)
     | I am: spam.method.__doc__ or self.method.__doc__
     
FUNCTIONS
    func(args)
        I am: docstr.func.__doc__

 Строки документирования доступны во время выполнения, но синтаксически
они менее гибки, чем комментарии # (которые могут находиться в любом
месте программы). Обе формы – полезные инструменты, и любая документация
к программе – это хорошо (при условии, что она точная). Вообще говоря, 
строки документирования лучше использовать для функционального описания
(что делают объекты), а комментарии # – для небольших пояснений 
(описывающих, как действуют выражения).


 Классы и модули
 
 Мы завершаем эту главу кратким сравнением предметов обсуждения двух
последних частей книги: модулей и классов. Так как оба представляют 
собой пространства имен, различия между ними бывает трудно заметить
сразу.

 В двух словах:
 
 Модули
     Это пакеты данных и исполняемого кода.
     
     Создаются как файлы с программным кодом на языке Python 
     или как расширения на языке C.
     
     Задействуются операцией импортирования.
     
 Классы
 
     Реализуют новые объекты.
     
     Создаются с помощью инструкции class.
     
     Задействуются операцией вызова.
     
     Всегда располагаются внутри модуля.
     
 Кроме того, классы поддерживают дополнительные возможности, недоступные 
в модулях, такие как перегрузка операторов, создание множества 
экземпляров и наследование. Несмотря на то что и классы, 
и модули являются пространствами имен, к настоящему времени вы должны 
четко понимать, что между ними имеются существенные различия.
"""

"""
 Множественное наследование: примесные классы

 Многие объектно-ориентированные шаблоны проектирования основаны
на объединении различных наборов методов. В строке заголовка инструкции
class в круглых скобках может быть перечислено более одного супер-класса.
В этом случае в игру вступает механизм множественного наследования –
класс и его экземпляры наследуют имена из всех перечисленных
супер-классов.

 При поиске атрибутов интерпретатор Python выполняет
обход супер-классов, указанных в строке заголовка класса, слева направо,
пока не будет найдено первое совпадение. С технической точки зрения
из-за того, что любой супер-класс может иметь собственные супер-классы,
процедура поиска может оказаться достаточно сложной
для крупных деревьев классов:

  В случае классических классов (которые использовались по умолчанию
 в версиях, предшествовавших Python 3.0) поиск атрибутов сначала
 продолжается по направлению снизу вверх всеми возможными путями,
 вплоть до вершины дерева наследования, а затем слева направо.

  В случае классов нового стиля (для всех классов в 3.0) поиск атрибутов
 сначала выполняется по уровням дерева наследования, то есть в ширину –
 слева направо (смотрите обсуждение классов нового стиля
 в следующей главе). Однако, независимо от модели, когда класс наследует
 несколько супер-классов, эти супер-классы просматриваются
 слева направо – в том порядке, в каком они следуют
 в заголовке инструкции class.

 Вообще множественное наследование хорошо использовать для моделирования
объектов, принадлежащих более чем одной группе. Например, человек может
быть инженером, писателем, музыкантом и так далее и наследовать свойства
всех этих групп. В случае множественного наследования объекты
приобретают совокупность черт, присущих всем его супер-классам.

 Пожалуй, самый распространенный случай, где используется множественное
наследование, – это «смешивание» методов общего назначения из нескольких
супер-классов. Обычно такие супер-классы называются примесными классами –
они предоставляют методы, которые добавляются в прикладные классы
наследованием. В некотором смысле примесные классы напоминают модули:
они предоставляют пакеты методов для использования в клиентских
подклассах. Однако, в отличие от простых функций в модулях, методы
в примесных классах обладают доступом к экземпляру self, что позволяет
им использовать информацию, хранящуюся в экземпляре, и вызывать другие
его методы. В следующем разделе демонстрируется один распространенный
пример использования подобных инструментов.


 Создание примесных классов, реализующих вывод

 Как мы уже видели, способ вывода экземпляра класса, используемый
в Python по умолчанию, не отличается информативностью:

\>>> class Spam:
...     def __init__(self): # Нет метода __repr__ или __str__
...         self.data1 = “food”
...
\>>> X = Spam()
\>>> print(X)  # По умолчанию: класс, адрес
<__main__.Spam instance at 0x00864818>  # Вывод экземпляра в Python 2.6

 Как мы видели в предыдущей главе, когда рассматривали перегрузку
операторов, существует возможность с помощью метода __repr__ или __str__
реализовать свою собственную операцию вывода. Но вместо того,
чтобы воспроизводить метод __repr__ в каждом классе, который
предполагается выводить на экран, почему бы не написать его
всего один раз в классе инструментов общего назначения и не наследовать
его во всех ваших классах?

 Для этого и используются примесные классы. Определив методы вывода
в супер-классе один раз, мы сможем повторно использовать его везде,
где потребуется задействовать форматированный вывод. Мы уже видели
инструменты, выполняющие действия, которые нам необходимы:

  Класс AttrDisplay в главе 27 обеспечивает вывод атрибутов экземпляра
 с помощью обобщенной реализации метода __str__, но он
 не предусматривает возможности подъема по дереву классов
 и использовался только в ситуации с простым наследованием.

  Модуль classtree.py в главе 28 содержит определения функций,
 позволяющих выполнять обход деревьев классов и выводить
 их схематическое представление, но они не выводят атрибуты объектов
 и не объединены в класс, который можно было бы наследовать.

 Здесь мы повторно рассмотрим приемы, использовавшиеся в этих примерах,
и на их основе создадим три примесных класса, которые могли бы служить
универсальными инструментами для отображения списков атрибутов
экземпляра, унаследованных атрибутов и атрибутов всех объектов в дереве
классов.

 Кроме того, мы попробуем применить наши инструменты в режиме
множественного наследования и используем приемы программирования,
благодаря которым наши классы будут лучше подходить на роль
универсальных инструментов.


 Получение списка атрибутов экземпляра с помощью __dict__

 Начнем с самого простого – с получения списка атрибутов, присоединенных
к экземпляру. Ниже приводится определение примесного класса
ListInstance, находящееся в файле lister.py, реализующего метод __str__
для всех классов, которые будут включать его в свой список супер-классов
в заголовках инструкций class. Поскольку этот инструмент является
классом, реализованная в нем логика вывода может использоваться
экземплярами любых его подклассов:
"""


# Файл lister.py
class ListInstance:
    """
    Примесный класс, реализующий получение форматированной строки
    при вызове функций print() и str() с экземпляром в виде аргумента,
    через наследование метода __str__, реализованного здесь; отображает
    только атрибуты экземпляра; self – экземпляр самого нижнего класса
    в дереве наследования; во избежание конфликтов с именами атрибутов
    клиентских классов использует имена вида __X
    """

    def __str__(self):
        return '<Instance of %s, address %s:\n%s>' \
               % (self.__class__.__name__,  # Имя клиентского класса
                  id(self),                 # Адрес экземпляра
                  self.__attrnames())       # Список пар name=value

    def __attrnames(self):
        result = ''
        for attr in sorted(self.__dict__):  # Словарь атрибутов
            result += '\tname %s=%s\n' % (attr, self.__dict__[attr])
        return result


"""
 Для извлечения имени класса экземпляра и списка атрибутов в классе
ListInstance используются уже известные нам приемы:

  Каждый экземпляр имеет встроенный атрибут __class__, ссылающийся 
 на класс, из которого он был создан, а каждый класс имеет атрибут 
 __name__, ссылающийся на имя класса. Таким образом, выражение 
 self.__class__.__name__ извлекает имя класса экземпляра.

  Основная работа этого класса заключается в том, чтобы просмотреть
 словарь атрибутов экземпляра (который представлен атрибутом __dict__)
 и сконструировать строку, содержащую имена и значения всех атрибутов
 экземпляра. Чтобы обеспечить единообразное представление 
 во всех версиях Python, ключи словаря сортируются 
 в порядке возрастания.
 
 В этом отношении класс ListInstance напоминает класс AttrDisplay 
из главы 27 – фактически, он до определенной степени является
разновидностью реализации AttrDisplay. Однако в нашем классе
используются два новых приема:

  Он отображает адрес экземпляра в памяти, вызывая встроенную
 функцию id, которая возвращает адрес объекта (по определению – 
 уникальный идентификатор объекта, который может пригодиться
 при последующих доработках этого программного кода).

  Использует псевдочастные имена для своих методов: __attrnames. 
 Как мы узнали выше в этой главе, интерпретатор автоматически искажает
 любые такие имена, дополняя их именем вмещающего класса 
 (в данном случае имя __attrnames превращается в имя 
 _ListInstance__attrnames). Это правило также распространяется 
 на атрибуты класса и на атрибуты экземпляра, присоединяемые к объекту 
 self. Это полезное свойство для таких универсальных инструментов, 
 как этот класс, так как оно гарантирует отсутствие конфликтов с именами
 в клиентских подклассах.

 Класс ListInstance определяет метод __str__ перегрузки операторов,
поэтому при выводе экземпляров, наследующих этот класс, 
они автоматически будут выводить свои атрибуты, давая о себе больше
информации, чем просто свой адрес. Ниже демонстрируется пример 
использования этого класса в режиме простого наследования (этот пример
одинаково работает в Python 3.0 и 2.6):
"""


class Spam(ListInstance):  # Наследует метод __str__
    def __init__(self):
        self.data1 = 'food'


x = Spam()
print(x)  # print() и str() вызывают __str__

"""
 Вы можете также получить эти результаты в виде строки, без вывода 
на экран, с помощью функции str. При этом функция автоматического вывода
в интерактивной оболочке по-прежнему использует формат по умолчанию 
для представления экземпляра:

>>> str(x)
‘<Instance of Spam, address 40240880:\n\tname data1=food\n>’
>>> x # По умолчанию используется __repr__
<__main__.Spam object at 0x026606F0>

 Класс ListInstance пригодится в любых классах, которые вам придется
создавать, – даже в классах, уже имеющих один или более супер-классов.
Здесь в игру вступает механизм множественного наследования: добавляя 
ListInstance в список супер-классов в заголовке инструкции class
(то есть, «подмешав» его), вы получаете реализацию метода __str__ 
«в подарок», что не мешает наследовать существующие супер-классы.
Эта возможность демонстрируется в файле testmixin.py:
"""


# Файл testmixin.py

class Super:
    def __init__(self):  # Метод __init__ супер-класса
        self.data1 = 'spam'  # Создать атрибуты экземпляра

    def ham(self):
        pass


class Sub(Super, ListInstance):  # Подмешать методы ham и __str__
    def __init__(self):  # Инструментальные классы имеют доступ к self
        Super.__init__(self)
        self.data2 = 'eggs'  # Добавить атрибуты экземпляра
        self.data3 = 42

    def spam(self):  # Определить еще один метод
        pass


if __name__ == '__main__':
    X = Sub()
    print(X)  # Вызовет подмешанный метод __str__

"""
 Здесь класс Sub наследует имена из двух классов, Super и ListInstance, 
– этот объект состоит из своих собственных имен и из имен обоих 
супер-классов. Если создать и вывести экземпляр класса Sub,
автоматически будет получено адаптированное его представление,
воспроизведенное методом __str__ примесного класса ListInstance 
(данный сценарий выведет одинаковые результаты в обеих версиях Python,
3.0 и 2.6, за исключением адресов объектов):

C:\misc> C:\python30\python testmixin.py
<Instance of Sub, address 40962576:
name data1=spam
name data2=eggs
name data3=42
>

 Реализация класса ListInstance в состоянии работать с любыми классами, 
потому что аргумент self ссылается на экземпляр подкласса, который 
наследует ListInstance, каким бы этот подкласс ни был. 
В некотором смысле, примесные классы – это классы, эквивалентные 
модулям, потому что они упаковывают методы, которые будут полезны 
самым разным клиентам. Ниже демонстрируется работа класса ListInstance 
в режиме простого наследования с экземплярами различных классов, 
к которым присоединяются дополнительные атрибуты за пределами 
определения класса:

>>> import lister
>>> class C(lister.ListInstance): pass
...
>>> x = C()
>>> x.a = 1; x.b = 2; x.c = 3
>>> print(x)
<Instance of C, address 40961776:
name a=1
name b=2
name c=3
>

 Примесные классы имеют не только практическую ценность, они также 
позволяют оптимизировать сопровождение программного кода, подобно любым 
другим классам. Например, если позднее вы решите усовершенствовать класс 
ListInstance, чтобы его метод __str__ выводил также все атрибуты класса,
которые были унаследованы экземпляром, вы без опаски сможете 
сделать это – так как это наследуемый метод, изменение в реализации 
__str__ автоматически начнет действовать и во всех подклассах, которые
импортируют и подмешивают его. Так как, собственно, это «позднее» уже
наступило, перейдем к следующему разделу и посмотрим, как может 
выглядеть такое усовершенствование.


 Получение списка атрибутов экземпляра с помощью функции dir
 
 В настоящий момент наш класс ListInstance отображает только атрибуты 
экземпляра (то есть имена, присоединенные к самому объекту экземпляра).
Однако совсем несложно усовершенствовать реализацию класса так, 
чтобы отображались все атрибуты, доступные экземпляру, – 
как его собственные, так и унаследованные от его классов. Хитрость 
заключается в том, чтобы вместо сканирования словаря __dict__ экземпляра
использовать встроенную функцию dir, – словарь хранит только атрибуты 
экземпляра, а функция dir, начиная с версии Python 2.2, возвращает 
список всех унаследованных атрибутов.

 Ниже приводится усовершенствованная реализация, действующая 
по этой схеме, – я переименовал класс, чтобы упростить тестирование,
но если бы эта реализация заменила оригинальную версию, 
она автоматически начала бы действовать во всех существующих клиентах:
"""


# Файл lister.py, продолжение
class ListInherited:
    """
    Использует функцию dir() для получения списка атрибутов самого
    экземпляра и атрибутов, унаследованных экземпляром от его классов;
    в Python 3.0 выводится больше имен атрибутов, чем в 2.6, потому что
    классы нового стиля в конечном итоге наследуют супер-класс object;
    метод getattr() позволяет получить значения унаследованных
    атрибутов, отсутствующих в self.__dict__; реализует метод __str__,
    а не __repr__, потому что в противном случае данная реализация
    может попасть в бесконечный цикл при выводе связанных методов!
    """

    def __str__(self):
        return '<Instance of %s, address %s:\n%s>'\
               % (self.__class__.__name__,  # Имя класса экземпляра
                  id(self),  # Адрес экземпляра
                  self.__attrnames())  # Список пар name=value

    def __attrnames(self):
        result = ''
        for attr in dir(self):  # Передать экземпляр функции dir()
            if attr[:2] == '__' and attr[-2:] == '__':  # Пропустить
                result += '\tname %s=<>\n' % attr     # внутренние имена
            else:
                result += '\tname %s=%s\n' % (attr, getattr(self, attr))
        return result


"""
 Обратите внимание, что данная реализация пропускает имена вида __X__, –
в большинстве случаев эти имена предназначены для внутреннего 
использования и их обычно бывает нежелательно выводить в общем списке.
Кроме того, в данной версии потребовалось использовать встроенную
функцию getattr для извлечения значений атрибутов по именам в виде строк
и отказаться от использования словаря с атрибутами – некоторые имена, 
доступные экземпляру, не принадлежат самому экземпляру, 
а функция getattr поддерживает поиск имен в дереве наследования.

 Чтобы проверить новую версию, изменим файл testmixin.py так, 
чтобы задействовать новый класс:
"""


class Sub(Super, ListInherited):  # Подмешать __str__
    def __init__(self):  # Инструментальные классы имеют доступ к self
        Super.__init__(self)
        self.data2 = 'eggs'  # Добавить атрибуты экземпляра
        self.data3 = 42

    def spam(self):  # Определить еще один метод
        pass


"""
 Результат работы этой версии файла зависит от версии интерпретатора. 
В Python 2.6 будет получен следующий список – обратите внимание, 
как действует механизм искажения имен для имени метода __attrnames 
в классе ListInherited (я сократил полное отображаемое значение, 
чтобы уместить его по ширине страницы):

C:\misc> c:\python26\python testmixin.py
<Instance of Sub, address 40073136:
    name _ListInherited__attrnames=<bound method Sub.__attrnames 
    of <...>>
    name __doc__=<>
    name __init__=<>
    name __module__=<>
    name __str__=<>
    name data1=spam
    name data2=eggs
    name data3=42
    name ham=<bound method Sub.ham of <__main__.Sub instance at ...>>
    name spam=<bound method Sub.spam of <__main__.Sub instance at ...>>
>

 В Python 3.0 список содержит гораздо больше атрибутов, потому что 
все классы являются классами «нового стиля» и наследуют атрибуты
и методы от супер-класса object (подробнее о нем рассказывается
в главе 31). Так как из супер-класса по умолчанию наследуется достаточно
большое количество имен, я опустил многие из них – запустите этот пример
у себя, чтобы получить полный список:

C:\misc> c:\python30\python testmixin.py
<Instance of Sub, address 40831792:
    name _ListInherited__attrnames=<bound method Sub.__attrnames 
    of <...>>
    name __class__=<>
    name __delattr__=<>
    name __dict__=<>
    name __doc__=<>
    name __eq__=<>
    ...часть имен опущена...
    name __repr__=<>
    name __setattr__=<>
    name __sizeof__=<>
    name __str__=<>
    name __subclasshook__=<>
    name __weakref__=<>
    name data1=spam
    name data2=eggs
    name data3=42
    name ham=<bound method Sub.ham of <__main__.Sub object 
    at 0x026F0B30>>
    name spam=<bound method Sub.spam of <__main__.Sub object at ...>>
    
 Следует также заметить, что теперь, когда мы предусматриваем вывод 
унаследованных методов, мы должны поместить реализацию перегрузки вывода
в метод __str__, а не в __repr__. В методе __repr__ эта реализация будет 
попадать в бесконечный цикл – при попытке отобразить значение метода
вызывается метод __repr__ класса, которому принадлежит отображаемый 
метод, чтобы вывести информацию о классе. То есть, если метод __repr__ 
класса ListInherited попытается отобразить метод, тогда при выводе 
информации о классе, которому принадлежит отображаемый метод, 
снова будет вызван метод __repr__ класса ListInherited. Эту проблему 
сложно заметить, но она существует! Измените имя метода __str__ 
на __repr__, чтобы убедиться в этом. Если вам необходимо использовать 
метод __repr__ в подобной ситуации, вы можете избежать зацикливания, 
сравнивая тип атрибута со значением types.MethodType из стандартной 
библиотеки с помощью функции isinstance и пропуская элементы, 
для которых функция вернет значение True.


 Получение списка атрибутов с привязкой к объектам в дереве классов
 
 Теперь добавим последнее усовершенствование. В настоящий момент класс
ListInherited ничего не сообщает о том, из каких классов
были унаследованы те или иные имена. Однако, как мы видели в примере 
classtree.py в конце главы 28, реализовать обход дерева классов совсем 
не сложно. Следующий примесный класс использует тот же прием 
для отображения атрибутов, сгруппированных по классам, попутно отображая
атрибуты, присоединенные к каждому объекту. Это достигается за счет 
обхода дерева наследования, от атрибута __class__ экземпляра 
к его классу и затем рекурсивно от атрибута __bases__ класса ко всем 
супер-классам, сканируя словари __dicts__ в процессе обхода:
"""


# Файл lister.py, продолжение
class ListTree:
    """
    Примесный класс, в котором метод __str__ просматривает все дерево
    классов и составляет список атрибутов всех объектов, находящихся
    в дереве выше self; вызывается функциями print(), str() и возвращает
    сконструированную строку со списком; во избежание конфликтов
    с именами атрибутов клиентских классов использует имена вида __X;
    для рекурсивного обхода супер-классов
    использует выражение-генератор; чтобы сделать подстановку значений
    более очевидной, использует метод str.format()
    """
    def __str__(self):
        self.__visited = {}
        return '<Instance of {0}, address {1}:\n{2}{3}>'.format(
            self.__class__.__name__, id(self),
            self.__attrnames(self, 0),
            self.__listclass(self.__class__, 4))

    def __listclass(self, aClass, indent):
        dots = '.' * indent
        if aClass in self.__visited:
            return '\n{0}<Class {1}:, address {2}: (see above)>\n'\
                .format(dots, aClass.__name__, id(aClass))
        else:
            self.__visited[aClass] = True
            genabove = (self.__listclass(c, indent+4)
                        for c in aClass.__bases__)
            return '\n{0}<Class {1}, address {2}:\n{3}{4}{5}>\n'\
                .format(dots, aClass.__name__, id(aClass),
                        self.__attrnames(aClass, indent),
                        ''.join(genabove), dots)

    def __attrnames(self, obj, indent):
        spaces = ' ' * (indent + 4)
        result = ''
        for attr in sorted(obj.__dict__):
            if attr.startswith('__') and attr.endswith('__'):
                result += spaces + '{0}=<>\n'.format(attr)
            else:
                result += spaces + '{0}={1}\n'\
                    .format(attr, getattr(obj, attr))
                
        return result


"""
 Обратите внимание, как используется выражение-генератор для реализации
рекурсивного обхода супер-классов, – оно активируется
вложенным строковым методом join. Обратите также внимание,
что в этой версии вместо оператора % форматирования
используется метод format, доступный в Python 3.0 и 2.6, –
это позволило сделать подстановку более очевидной. Когда выполняется
подстановка множества значений, как в данном случае,
явная нумерация аргументов может упростить чтение такого программного
кода. Проще говоря, в этой версии мы заменили первую из следующих 
строк второй:

return ‘<Instance of %s, address %s:\n%s%s>’ % (...)  # Выражение
return ‘<Instance of {0}, address {1}:\n{2}{3}>’.format(...)  # Метод

 Теперь изменим файл testmixin.py, чтобы испытуемый класс наследовал 
новый класс ListTree:
"""


class Sub(Super, ListTree):  # Подмешать __str__
    def __init__(self):  # Инструментальные классы имеют доступ к self
        Super.__init__(self)
        self.data2 = 'eggs'  # Добавить атрибуты экземпляра
        self.data3 = 42

    def spam(self):  # Определить еще один метод
        pass


x = Sub()
print(x)

"""
 В Python 2.6 этот сценарий выведет следующее:
 
C:\misc> c:\python26\python testmixin.py
<Instance of Sub, address 40728496:
    _ListTree__visited={}
    data1=spam
    data2=eggs
    data3=42
....<Class Sub, address 40701168:
        __doc__=<>
        __init__=<>
        __module__=<>
        spam=<unbound method Sub.spam>
........<Class Super, address 40701120:
            __doc__=<>
            __init__=<>
            __module__=<>
            ham=<unbound method Super.ham>
........>
........<Class ListTree, address 40700688:
            _ListTree__attrnames=<unbound method ListTree.__attrnames>
            _ListTree__listclass=<unbound method ListTree.__listclass>
            __doc__=<>
            __module__=<>
            __str__=<>
........>
....>
>

 Обратите внимание, что теперь в версии 2.6 методы определяются 
как несвязанные (unbound). Это обусловлено тем, что информацию о них 
мы извлекаем теперь непосредственно из классов, а не из экземпляров.
Обратите также внимание на результат искажения имени таблицы __visited 
в словаре атрибутов экземпляра – только у последних неудачников 
такое имя могло бы совпасть с каким-то другим.

 Если запустить этот сценарий под управлением Python 3.0, мы снова
получим более длинный список атрибутов и супер-классов.

 Обратите внимание, что в версии 3.0 несвязанные методы идентифицируются 
как простые функции, о чем уже говорилось выше в этой главе (и снова,
чтобы сэкономить пространство, я удалил большую часть встроенных 
атрибутов класса object; запустите этот сценарий у себя, чтобы получить 
полный список):

C:\misc> c:\python30\python testmixin.py
<Instance of Sub, address 40635216:
    _ListTree__visited={}
    data1=spam
    data2=eggs
    data3=42
....<Class Sub, address 40914752:
        __doc__=<>
        __init__=<>
        __module__=<>
        spam=<function spam at 0x026D53D8>
........<Class Super, address 40829952:
            __dict__=<>
            __doc__=<>
            __init__=<>
            __module__=<>
            __weakref__=<>
            ham=<function ham at 0x026D5228>
............<Class object, address 505114624:
                __class__=<>
                __delattr__=<>
                __doc__=<>
                __eq__=<>
                ...часть строк опущена...
                __repr__=<>
                __setattr__=<>
                __sizeof__=<>
                __str__=<>
                __subclasshook__=<>
............>
........>
........<Class ListTree, address 40829496:
            _ListTree__attrnames=<function __attrnames at 0x026D5660>
            _ListTree__listclass=<function __listclass at 0x026D56A8>
            __dict__=<>
            __doc__=<>
            __module__=<>
            __str__=<>
            __weakref__=<>
............<Class object:, address 505114624: (see above)>
........>
....>
>

 В этой версии исключается возможность многократного перечисления одного
и того же объекта класса за счет использования таблицы посещенных 
классов (именно поэтому в вывод включены значения, возвращаемые функцией
id для объектов, – они могут служить ключами отображаемых элементов). 
Как и в реализации функции транзитивной перезагрузки модулей, 
приводившейся в главе 24, словарь помогает избежать повторений
и зацикливаний, благодаря тому, что объекты классов могут использоваться
в качестве ключей словаря, – то же самое можно было бы реализовать
на основе множества.

 Кроме того, в этой версии снова использован прием, реализующий пропуск
внутренних объектов с именами вида __X__. Если закомментировать 
проверку этих имен, они будут отображаться наряду с обычными атрибутами.
Ниже приводится выдержка из результатов, полученных в Python 2.6,
произведен- ных сценарием с закомментированной проверкой (полный список 
получился намного длиннее, а в версии 3.0 он еще больше,
что может служить одной из причин, почему такие имена 
лучше пропустить!):

C:\misc> c:\python26\python testmixin.py
...часть строк опущена...
........<Class ListTree, address 40700688:
            _ListTree__attrnames=<unbound method ListTree.__attrnames>
            _ListTree__listclass=<unbound method ListTree.__listclass>
            __doc__=
        Примесный класс, в котором метод __str__ просматривает все 
        дерево классов и составляет список атрибутов всех объектов, 
        находящихся в дереве выше self; вызывается функциями print(),
        str() и возвращает сконструированную строку со списком; 
        во избежание конфликтов с именами атрибутов клиентских классов
        использует имена вида __X; для рекурсивного обхода супер-классов
        использует выражение-генератор; чтобы сделать подстановку
        значений более очевидной, использует метод str.format()
            __module__=lister
            __str__=<unbound method ListTree.__str__>
........>

 Забавы ради попробуйте смешать этот класс с каким-нибудь 
более существенным классом, например с классом Button из модуля tkinter. 
Вообще, класс ListTree желательно указать первым в списке (крайним 
слева) супер-классов в заголовке инструкции class, чтобы его метод
__str__ имел преимущество, – класс Button имеет собственный 
метод __str__, а процедура поиска при множественном наследовании 
в первую очередь просматривает супер-класс, стоящий первым в списке.
У меня вывод сценария получился очень массивным (более 18000 символов),
поэтому если вам интересно увидеть полный список, запустите его у себя 
(не забудьте, что в Python 2.6 модуль tkinter называется Tkinter):
"""

from tkinter import Button  # Оба класса имеют метод __str__


class MyButton(ListTree, Button):
    pass  # ListTree - первый: будет использоваться его метод __str__


B = MyButton(text='spam')
open('savetree.txt', 'w').write(str(B))  # Сохранить в файл для
# последующего просмотра
print(B)

"""
 (вполне естественно было бы на следующем шаге реализовать вывод схемы 
дерева в графическом интерфейсе), но я оставлю эту работу вам в качестве 
самостоятельного упражнения. Кроме того, в упражнениях, 
в конце этой части книги, будет предложено усовершенствовать этот пример
так, чтобы он выводил имена супер-классов в круглых скобках в первых
строках с именами экземпляров и классов.

 ООП тесно связано с повторным использованием программного кода, 
и примесные классы в этом отношении представляют собой мощный 
инструмент. Как почти все в программировании, множественное наследование
может быть благом при грамотном применении; но при неаккуратном
и чрезмерном употреблении эта возможность может осложнить вам жизнь. 
Мы вернемся к этому вопросу как к одной из типичных проблем в конце 
следующей главы. В этой главе мы также познакомимся с возможностью 
(в классах нового стиля) изменять порядок поиска для одного специального
случая множественного наследования.


 Классы – это объекты: универсальные фабрики объектов

 Иногда бывает необходимо, чтобы объекты создавались в ответ 
на сложившиеся условия, которые невозможно предсказать на этапе
разработки программы. Фабричный шаблон проектирования позволяет 
реализовать такой подход. В значительной степени благодаря высокой 
гибкости языка Python фабрики могут принимать самые разнообразные формы,
многие из которых вовсе не выглядят чем-то особенным.

 Классы – это объекты, поэтому их легко можно передавать между 
компонентами программы, сохранять в структурах данных и так далее.
Можно также передавать классы функциям, которые создают объекты 
произвольных типов, – в кругах, связанных с ООП, такие функции иногда
называют фабриками. В языках со строгой типизацией, таких как C++,
реализация таких функций – достаточно сложная задача, но в языке Python
она становится почти тривиальной. Синтаксическая конструкция, с которой
мы познакомились в главе 18, может вызывать любые классы с любым числом 
аргументов конструкторов за один присест, генерируя экземпляр 
любого типа:

 Фактически эта синтаксическая конструкция может вызывать 
любой вызываемый объект, включая функции, классы и методы. Функция 
factory в этом примере также может вызывать любые вызываемые объекты,
а не только классы (несмотря на имя аргумента).
"""


def factory(aClass, *args):  # Кортеж с переменным числом аргументов
    return aClass(*args)  # Вызов aClass (или apply, только в 2.6)


class Spam:
    def doit(self, message):
        print(message)


class Person:
    def __init__(self, name, job):
        self.name = name
        self.job = job


object1 = factory(Spam)  # Создать объект Spam
object2 = factory(Person, 'Guido', 'guru')  # Создать объект Person

"""
 В этом фрагменте определена функция-генератор объектов с именем 
factory. Она ожидает получить объект класса (любого) вместе с одним
или более аргументами конструктора класса. Функция использует 
специальный синтаксис вызова с переменным числом аргументов, 
чтобы создать и вернуть экземпляр.

 Остальная часть примера просто определяет два класса и генерирует 
экземпляры этих классов, передавая классы функции factory. И это
единственная фабричная функция, которую вам придется написать 
на языке Python, – она работает с любыми классами и с любыми аргументами
конструктора.

 Следует заметить, что здесь возможно одно небольшое улучшение, которое
заключается в обеспечении поддержки именованных аргументов конструктора;
фабричная функция может собрать их в аргумент **args и передать в вызов
класса в виде третьего аргумента:

def factory(aClass, *args, **kwargs):  # +kwargs
    return aClass(*args, **kwargs)     # Вызвать aClass

 К настоящему времени вы должны знать, что в языке Python все сущее 
является «объектом», включая и сами классы, которые в других языках,
таких как С++, являются лишь объявлениями для компилятора. Однако,
как упоминалось в начале этой части книги, в языке Python
только объекты, порожденные из классов, являются субъектами ООП.


 Зачем нужны фабрики?
 
 Итак, чем же хороша функция factory (помимо иллюстрации того, 
что классы являются объектами)? К сожалению, довольно сложно 
продемонстрировать применение этого шаблона проектирования, потому что
для этого необходимо привести фрагмент программного кода больший, 
чем позволяет пространство книги. Тем не менее такая фабрика могла бы 
помочь изолировать программный код от динамически настраиваемой 
конструкции объекта.

 Вспомним пример функции processor, представленный в главе 25, 
и затем пример применения принципа композиции в этой главе. 
В обоих случаях принимаются объекты, выполняющие чтение и запись 
обрабатываемого потоки данных. В оригинальной версии этого примера 
мы вручную передавали экземпляры специализированных классов, таких как 
FileWriter и SocketReader, для адаптации под обрабатываемые 
потоки данных – позднее мы передавали жестко заданные объекты файла,
потока и преобразования. В других случаях внешние источники данных могут 
определяться настройками в конфигурационных файлах или в элементах
управления графического интерфейса.

 В таком динамическом мире не представляется возможным жестко задавать
в сценарии объекты, реализующие интерфейс к потоку данных,
но вполне возможно создавать их во время выполнения, в соответствии
с содержимым конфигурационных файлов.

 Например, в файле с настройками может определяться имя класса потока,
который должен быть импортирован из модуля, и дополнительные аргументы 
конструктора. В этой ситуации могла бы пригодиться фабричная функция
или эквивалентный ей фрагмент программного кода, потому что они могли
бы позволить нам получить и передать классы, не определяя их заранее 
в программе. В действительности возможно представить себе, что требуемые
классы даже не существовали в тот момент, когда мы писали свой 
программный код:

classname = ...определяется конфигурационным файлом...
classarg = ...определяется конфигурационным файлом...

import streamtypes  # Специализированный программный код
aclass = getattr(streamtypes, classname)  # Извлечь из модуля

reader = factory(aclass, classarg) # Получить экземпляр aclass(classarg)
processor(reader, ...)

 Здесь встроенная функция getattr снова используется для извлечения 
атрибута модуля, имя которого задано в виде строки (это все равно, 
что записать выражение obj.attr, где attr – это строка). Так как этот
фрагмент предполагает наличие у конструктора единственного аргумента, 
то, строго говоря, здесь не требуется ни функция factory, ни функция 
apply – мы могли бы просто создать экземпляр класса обращением 
aclass(classarg). Эти функции более полезны в случаях, когда количество
аргументов не известно заранее, то есть когда универсальная фабричная 
функция способна повысить гибкость реализации.


 Прочие темы, связанные с проектированием
 
 В этой главе мы поближе познакомились с наследованием, композицией,
делегированием, множественным наследованием, связанными методами 
и фабриками – типичными шаблонами проектирования, которые используются 
в комбинации с классами при создании программ на языке Python. 
В действительности мы лишь слегка соприкоснулись с областью шаблонов 
проектирования. В книге обсуждаются и другие темы, связанные 
с проектированием, например:

  Абстрактные супер-классы (глава 28)
  
  Декораторы (главы 31 и 38)
  
  Подклассы встроенных типов (глава31)
  
  Статические методы и методы классов (глава 31)
  
  Управляемые атрибуты (глава 37)
  
  Метаклассы (главы 31 и 39)
  

 За дополнительной информацией по этой теме обращайтесь к книгам, 
которые посвящены вопросам ООП и шаблонам проектирования. Шаблоны
проектирования занимают важное положение в ООП и зачастую их реализация 
в языке Python выглядит более естественной, чем в других языках
программирования. Тем не менее они не являются характерными только 
для языка Python.
"""

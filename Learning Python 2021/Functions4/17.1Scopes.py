"""
 Области видимости


 Области видимости в языке Python

 Теперь, когда вы готовы приступить к созданию своих собственных
функций, нам необходимо более формально определить, что означают имена
в языке Python. Всякий раз, когда в программе используется некоторое
имя, интерпретатор создает, изменяет или отыскивает это имя
в пространстве имен – в области, где находятся имена. Когда мы говорим
о поиске значения имени применительно к программному коду, под термином
область видимости подразумевается пространство имен: то есть место
в программном коде, где имени было присвоено значение, определяет
область видимости этого имени для программного кода.

 Практически все, что имеет отношение к именам, включая классификацию
областей видимости, в языке Python связано с операциями присваивания.
Как мы уже видели, имена появляются в тот момент, когда им впервые
присваиваются некоторые значения, и прежде чем имена смогут быть
использованы, им необходимо присвоить значения. Поскольку имена
не объявляются заранее, интерпретатор Python по местоположению операции
присваивания связывает имя с конкретным пространством имен. Другими
словами, место, где выполняется присваивание, определяет пространство
имен, в котором будет находиться имя, а следовательно,
и область его видимости.

 Помимо упаковки программного кода функции привносят в программы еще
один слой пространства имен – по умолчанию все имена, значения которым
присваиваются внутри функции, ассоциируются с пространством имен этой
функции и никак иначе. Это означает, что:

  Имена, определяемые внутри инструкции def, видны только программному
 коду внутри инструкции def. К этим именам нельзя обратиться
 за пределами функции.

  Имена, определяемые внутри инструкции def, не вступают в конфликт
 с именами, находящимися за пределами инструкции def, даже если и там
 и там присутствуют одинаковые имена. Имя X, которому присвоено значение
 за пределами данной инструкции def (например, в другой инструкции def
 или на верхнем уровне модуля), полностью отлично от имени X, которому
 присвоено значение внутри инструкции def.

 В любом случае область видимости переменной (где она может
использоваться) всегда определяется местом, где ей было присвоено
значение, и никакого отношения не имеет к месту, откуда была вызвана
функция. Как мы узнаем далее в этой главе, значения переменным могут
быть присвоены в трех разных местах, соответствующих трем разным
областям видимости:

  Если присваивание переменной выполняется внутри инструкции def,
 переменная является локальной для этой функции.

  Если присваивание производится в пределах объемлющей инструкции def,
 переменная является нелокальной для этой функции.

  Если присваивание производится за пределами всех инструкций def, она
 является глобальной для всего файла.

 Мы называем это лексической областью видимости, потому что области
видимости переменных целиком определяются местоположением этих
переменных в исходных текстах программы, а не местом, откуда вызываются
функции. Например, в следующем файле модуля инструкция присваивания
X = 99 создает глобальную переменную с именем X (она видима из любого
места в файле), а инструкция X = 88 создает локальную переменную X
(она видима только внутри инструкции def):

X = 99
def func():
    X = 88

 Даже при том, что обе переменные имеют имя X, области видимости делают
их различными. Таким образом, области видимости функций позволяют
избежать конфликтов имен в программах и превращают функции
в самостоятельные элементы программ.


 Правила видимости имен

 До того как мы начали писать функции, весь программный код размещался
на верхнем уровне модуля (он не был вложен в инструкции def), поэтому
все имена, которые мы использовали, либо находились на верхнем уровне
в модуле, либо относились к предопределенным именам языка Python
(например, open). Функции образуют вложенные пространства имен (области
видимости), которые ограничивают доступ к используемым в них именам,
благодаря чему имена внутри функций не вступают в конфликт с именами
за их пределами (внутри модуля или внутри других функций). Повторю
еще раз, функции образуют локальную область видимости, а модули –
глобальную. Эти две области взаимосвязаны между собой следующим образом:

  Объемлющий модуль – это глобальная область видимости. Каждый модуль –
 это глобальная область видимости, то есть пространство имен, в котором
 создаются переменные на верхнем уровне в файле модуля. Глобальные
 переменные для внешнего мира становятся атрибутами объекта модуля,
 но внутри модуля могут использоваться как простые переменные.

  Глобальная область видимости охватывает единственный файл. Не надо
 заблуждаться насчет слова «глобальный» – имена на верхнем уровне файла
 являются глобальными только для программного кода в этом файле.
 На самом деле в языке Python не существует такого понятия,
 как всеобъемлющая глобальная для всех файлов область видимости. Имена
 всегда относятся к какому-нибудь модулю и всегда необходимо явно
 импортировать модуль, чтобы иметь возможность использовать имена,
 определяемые в нем. Когда вы слышите слово «глобальный», подразумевайте
 «модуль».

  Каждый вызов функции создает новую локальную область видимости.
 Всякий раз, когда вызывается функция, создается новая локальная область
 видимости – то есть пространство имен, в котором находятся имена,
 определяемые внутри функции. Каждую инструкцию def (и выражение lambda)
 можно представить себе, как определение новой локальной области
 видимости. Но так как язык Python позволяет функциям вызывать
 самих себя в цикле (этот прием известен как рекурсия), локальная
 область видимости с технической точки зрения соответствует вызову
 функции – другими словами, каждый вызов создает новое локальное
 пространство имен. Рекурсию удобно использовать, когда выполняется
 обработка данных, структура которых заранее не известна.

  Операция присваивания создает локальные имена, если они не были
 объявлены глобальными или нелокальными. По умолчанию все имена, которым
 присваиваются значения внутри функции, помещаются в локальную область
 видимости (пространство имен, ассоциированное с вызовом функции). Если
 необходимо присвоить значение имени верхнего уровня в модуле, который
 вмещает функцию, это имя необходимо объявить внутри функции глобальным
 с помощью инструкции global. Если необходимо присвоить значение имени,
 которое находится в объемлющей инструкции def, в Python 3.0 это имя
 необходимо объявить внутри функции с помощью инструкции nonlocal.

  Все остальные имена являются локальными в области видимости объемлющей
 функции, глобальными или встроенными. Предполагается, что имена,
 которым не присваивались значения внутри определения функции, находятся
 в объемлющей локальной области видимости (внутри объемлющей инструкции
 def), глобальной (в пространстве имен модуля) или встроенной
 (предопределенные имена в модуле builtins).

 Здесь следует отметить несколько важных особенностей. Прежде всего,
имейте в виду, что программный код, который вводится в интерактивной
оболочке, подчиняется тем же самым правилам. Возможно, вы этого еще
не знаете, но программный код, который вводится в интерактивной
оболочке, в действительности находится на уровне модуля __main__ – этот
модуль действует точно так же, как любой другой модуль; единственное
отличие состоит лишь в том, что результаты вычислений выводятся
немедленно. Вследствие этого имена, создаваемые в интерактивной
оболочке, также находятся внутри модуля и следуют обычным правилам
видимости: они являются глобальными для интерактивного сеанса. Подробнее
о модулях будет рассказываться в следующей части книги.

 Кроме того, обратите внимание, что любые операции присваивания,
выполняемые внутри функции, классифицируют имена как локальные:
инструкция =, инструкция import, инструкция def, передача аргументов
и так далее. Если какая-либо из разновидностей операции присваивания
выполняется в пределах инструкции def, имя становится локальным
по отношению к этой функции. Следует также заметить, что операции
непосредственного изменения объектов не рассматривают имена
как локальные – это свойственно только операциям присваивания. Например,
если имени L присвоен список, определенный на верхнем уровне в модуле,
то такая инструкция, как L.append(X), внутри функции не будет
классифицировать имя L как локальное, тогда как инструкция L = X –
будет. В первом случае происходит изменение объекта списка, на который
указывает L, а не самого имени L, – список L будет найден в глобальной
области видимости, как обычно, и Python изменит этот список,
без необходимости объявления имени global (или nonlocal). Этот пример
должен помочь явственнее ощутить различия между именами и объектами:
операция, изменяющая объект, совсем не то, что операция присваивания
объекта имени.


 Разрешение имен: правило LEGB

 Если предыдущий раздел показался вам запутанным, спешу успокоить –
в действительности все сводится к трем простым правилам. Для инструкции
def:
  Поиск имен ведется самое большее в четырех областях видимости:
 локальной, затем в объемлющей функции (если таковая имеется), затем
 в глобальной и, наконец, во встроенной.

  По умолчанию операция присваивания создает локальные имена.

  Объявления global и nonlocal отображают имена на область видимости
 вмещающего модуля и функции соответственно.

 Другими словами, все имена, которым присваиваются значения внутри
инструкции def (или внутри выражения lambda, с которым мы познакомимся
позже), по умолчанию являются локальными; функции могут использовать
имена в лексически объемлющих функциях и в глобальной области видимости,
но чтобы иметь возможность изменять их, они должны быть объявлены
нелокальными и глобальными.

 Схема разрешения имен в языке Python иногда называется правилом LEGB,
название которого состоит из первых букв названий областей видимости:

  Когда внутри функции выполняется обращение к неизвестному имени,
 интерпретатор пытается отыскать его в четырех областях видимости –
 в локальной (local, L), затем в локальной области любой объемлющей
 инструкции def (enclosing, E) или в выражении lambda, затем
 в глобальной (global, G) и, наконец, во встроенной (built-in, B). Поиск
 завершается, как только будет найдено первое подходящее имя. Если
 требуемое имя не будет найдено, интерпретатор выведет сообщение
 об ошибке. Как уже говорилось главе 6, прежде чем имя можно будет
 использовать, ему должно быть присвоено значение.

  Когда внутри функции выполняется операция присваивания (а не обращение
 к имени внутри выражения), интерпретатор всегда создает или изменяет
 имя в локальной области видимости, если в этой функции оно не было
 объявлено глобальным или нелокальным.

  Когда выполняется присваивание имени за пределами функции (то есть
 на уровне модуля или в интерактивной оболочке), локальная область
 видимости совпадает с глобальной – с пространством имен модуля.

 На рис. 17.1 показаны четыре области видимости в языке Python.
Примечательно, что второй области видимости E – в области видимости
объемлющей инструкции def или выражения lambda, с технической точки
зрения может находиться несколько вложенных друг в друга областей.
Но они появляются, только когда имеются вложенные друг в друга функции,
и именно к ним относится объявление nonlocal.

 Кроме того, имейте в виду, что эти правила применяются только к простым
именам переменных (таким как spam). В пятой и шестой частях книги
мы увидим, что полные имена атрибутов (такие, как object.spam)
принадлежат определенным объектам и к ним применяются иные правила
поиска, отличные от правил поиска в областях видимости, которые
мы только что рассмотрели. При обращении к атрибутам (имя, следующее
за точкой) поиск производится в одном или более объектах, а не
в областях видимости, что связано с механизмом, который называется
«наследованием» (рассматривается в шестой части книги).


 Пример области видимости

 Рассмотрим более крупный пример, демонстрирующий суть областей
видимости. Предположим, что следующий фрагмент составляет содержимое
файла модуля:

# Глобальная область видимости
X = 99  # X и func определены в модуле: глобальная область
def func(Y):  # Y и Z определены в функции: локальная область
    # Локальная область видимости
    Z = X + Y  # X – глобальная переменная
    return Z
func(1)  # func в модуле: вернет число 100

 В этом примере функция и модуль используют в своей работе несколько
имен. Применяя правила области видимости языка Python, можно
классифицировать эти имена следующим образом:

 Глобальные имена: X и func

  X – это глобальное имя, так как оно объявлено на верхнем уровне
 модуля. К этому имени можно обращаться внутри функции, не объявляя его
 глобальным. func – это глобальное имя по тем же причинам. Инструкция
 def связывает объект функции с именем func на верхнем уровне модуля.

 Локальные имена: Y и Z

  Имена Y и Z являются локальными (и существуют только во время
 выполнения функции), потому что присваивание значений обоим именам
 осуществляется внутри определения функции: присваивание переменной Z
 производится с помощью инструкции =, а Y – потому что аргументы всегда
 передаются через операцию присваивания.

 Суть такого разделения имен заключается в том, что локальные переменные
играют роль временных имен, которые необходимы только на время
исполнения функции. Например, в предыдущем примере аргумент Y
и результат сложения Z существуют только внутри функции – эти имена
не пересекаются с вмещающим пространством имен модуля
(или с пространствами имен любых других функций).

 Разделение имен на глобальные и локальные также облегчает понимание
функций, так как большинство имен, используемых в функции, появляются
непосредственно в самой функции, а не в каком-то другом, произвольном
месте внутри модуля. Кроме того, можно быть уверенным, что локальные
имена не будут изменены любой другой удаленной функцией в программе,
а это в свою очередь упрощает отладку программ.


 Встроенная область видимости

 Встроенная область видимости, уже упоминавшаяся выше, немного проще,
чем можно было бы подумать. В действительности встроенная область
видимости – это всего лишь встроенный модуль с именем builtis,
но для того, чтобы использовать имя builtis, необходимо импортировать
модуль builtis, потому что это имя само по себе не является встроенным.

 Я вполне серьезен! Встроенная область видимости реализована как модуль
стандартной библиотеки с именем builtis, но само имя не находится
во встроенной области видимости, поэтому, чтобы исследовать его,
необходимо импортировать модуль. После этого можно будет воспользоваться
функцией dir, чтобы получить список предопределенных имен:

\>>> import builtins
\>>> dir(builtins)
[‘ArithmeticError’, ‘AssertionError’, ‘AttributeError’, ‘BaseException’,
 ‘BufferError’, ‘BytesWarning’, ‘DeprecationWarning’, ‘EOFError’,
 ‘Ellipsis’, ...множество других имен опущено...
 ‘print’, ‘property’, ‘quit’, ‘range’, ‘repr’, ‘reversed’, ‘round’,
 ‘set’, ‘setattr’, ‘slice’, ‘sorted’, ‘staticmethod’, ‘str’, ‘sum’,
 ‘super’, ‘tuple’, ‘type’, ‘vars’, ‘zip’]

 Имена в этом списке составляют встроенную область видимости языка
Python. Примерно первая половина списка – это встроенные исключения,
а вторая – встроенные функции. Согласно правилу LEGB интерпретатор
выполняет поиск имен в этом модуле в последнюю очередь. Все имена
из этого списка вы получаете в свое распоряжение по умолчанию,
то есть чтобы их использовать, не требуется импортировать какие-либо
модули. Благодаря этому существует два способа вызвать встроенную
функцию – используя правило LEGB или импортируя модуль builtins вручную:

\>>> zip  # Обычный способ
<class zip>
\>>> import builtins  # Более сложный способ
\>>> builtins.zip
<class zip>

 Второй способ иногда удобно использовать при выполнении сложных
действий. Внимательный читатель может заметить, что согласно правилу
LEGB поиск имени прекращается, когда будет найдено первое подходящее
имя, откуда следует, что имена в локальной области видимости могут
переопределять переменные с теми же самыми именами, как в глобальной,
так и во встроенной области видимости, а глобальные имена могут
переопределять имена во встроенной области видимости. Например, внутри
функции можно создать переменную с именем open:

def hider():
    open = ‘spam’ #  Локальная переменная, переопределяет встроенное имя
    ...
    open(‘data.txt’)  # В этой области видимости файл не будет открыт!

 Однако в результате этого встроенная функция с именем open, которая
располагается во встроенной (внешней) области видимости, окажется
скрытой. Обычно это считается ошибкой, и самое неприятное,
что интерпретатор Python не выведет сообщения с предупреждением
(иногда в программировании возникают ситуации, когда действительно
бывает необходимо подменить встроенные имена, переопределив их
в своем коде).

 Таким же способом функции могут переопределять имена глобальных
переменных, определяя локальные переменные с теми же именами:

X = 88  # Глобальная переменная X
def func():
    X = 99  # Локальная переменная X: переопределяет глобальную

func()
print(X)  # Выведет 88: значение не изменилось

 В этом примере операция присваивания создает локальную переменную X,
которая совершенно отлична от глобальной переменной X, определенной
в модуле, за пределами функции. Вследствие этого внутри функции нет
никакой возможности изменить переменную, расположенную за пределами
функции, если не добавить объявление global (или nonlocal) в инструкцию
def (как описано в следующем разделе).


 Как испортить себе жизнь в Python 2.6

 Вот вам еще один пример того, что допустимо в языке Python, но чего
не следует делать: в версии 2.6 имена True и False – это всего лишь
переменные во встроенной области видимости. Их вполне возможно
переопределить с помощью такой инструкции: True = False. При этом вы
не нарушите общую логическую целостность! Эта инструкция всего лишь
переопределит значение слова True в единственной области видимостиВо
всех остальных областях видимости по-прежнему будет использоваться
оригинал из встроенной области видимости.

 Что еще интереснее, можно выполнить даже такую инструкцию:
__builtin__.True = False, и тогда истина станет ложью для всей
программы! Подобная возможность в версии 3.0 была ликвидирована,
там слова True и False считаются зарезервированными, как и слово None.
Кстати, эта операция отправляет среду IDLE в странное состояние,
когда пользовательский процесс сбрасывается.

 Однако такой прием удобен для создателей инструментальных средств,
которые вынуждены переопределять встроенные имена, такие как open,
для нужд специализированных функций. Кроме того, следует отметить,
что инструменты сторонних производителей, такие как PyChecker, выводят
предупреждения о типичных ошибках программирования, включая случайное
переопределение встроенных имен (эта возможность, встроенная
в PyChecker, известна как «shadowing» (сокрытие)).


 Инструкция global

 Инструкция global и родственная ей инструкция nonlocal – единственные
инструкции в языке Python, отдаленно напоминающие инструкции объявления.
Однако они не объявляют тип или размер – они объявляют пространства
имен. Инструкция global сообщает интерпретатору, что функция будет
изменять одно или более глобальных имен, то есть имен, которые находятся
в области видимости (в пространстве имен) вмещающего модуля.

 Инструкция global уже упоминалась выше, а ниже приводится общая
информация о ней:

  Глобальные имена – это имена, которые определены на верхнем уровне
 вмещающего модуля.

  Глобальные имена должны объявляться, только если им будут
 присваиваться значения внутри функций.

  Обращаться к глобальным именам внутри функций можно и без объявления
 их глобальными.

 Другими словами, инструкция global позволяет изменять переменные,
находящиеся на верхнем уровне модуля, за пределами инструкции def.
Как вы узнаете ниже, инструкция nonlocal практически идентична, но она
применяется не к именам на верхнем уровне модуля, а к именам,
находящимся в локальных областях видимости объемлющих инструкций def.

 Инструкция global состоит из ключевого слова global и следующих за ним
одного или более имен, разделенных запятыми, которые будут отображены
на область видимости вмещающего модуля при обращении к ним или при
выполнении операции присваивания внутри тела функции. Например:

X = 88  # Глобальная переменная X
def func():
    global X
    X = 99  # Глобальная переменная X: за пределами инструкции def

func()
print(X)  # Выведет 99

 В этом примере было добавлено объявление global, поэтому имя X внутри
инструкции def теперь ссылается на переменную X за ее пределами.
На этот раз оба имени представляют одну и ту же переменную. Ниже
приводится более сложный пример использования инструкции global:

y, z = 1, 2  # Глобальные переменные в модуле
def all_global():
    global x  # Объявляется глобальной для присваивания
    x = y + z  # Объявлять y, z не требуется: применяется правило LEGB

 Здесь все три переменные x, y и z, используемые внутри функции
all_global, являются глобальными. Переменные y и z глобальными считаются
потому, что внутри функции им не присваиваются значения. Переменная x
считается глобальной потому, что она перечислена в инструкции global,
которая явно отображает ее на область видимости модуля. Без инструкции
global переменная x считалась бы локальной, так как ей присваивается
значение внутри функции. Обратите внимание: переменные y и z не были
объявлены как глобальные, однако, следуя правилу LEGB, интерпретатор
автоматически отыщет их в области видимости модуля. Кроме того, следует
отметить, что переменная x может не существовать в модуле на момент
вызова функции – в этом случае операция присваивания в функции создаст
переменную x в области видимости модуля.


 Минимизируйте количество глобальных переменных

 По умолчанию имена, значения которым присваиваются внутри функций,
являются локальными, поэтому, если необходимо изменять имена
за пределами функций, следует использовать инструкцию global.
Это сделано в соответствии с общей идеологией языка Python – чтобы
сделать что-то «неправильное», необходимо писать дополнительный
программный код. Иногда бывает удобно использовать глобальные
переменные, однако по умолчанию, если переменной присваивается значение
внутри инструкции def, она становится локальной, потому что это,
как правило, наилучшее решение. Изменение глобальных переменных может
привести к появлению проблем, хорошо известных в разработке программного
обеспечения: когда значения переменных зависят от порядка, в каком
вызываются функции, это может осложнить отладку программы. Рассмотрим
следующий пример модуля:

X = 99
def func1():
    global X
    X = 88

def func2():
    global X
    X = 77

 Теперь представим, что перед нами стоит задача модифицировать этот
модуль или использовать его в другой программе. Каким будет значение
переменной X? На самом деле этот вопрос не имеет смысла, если
не указывать момент времени – значение переменной X зависит
от выбранного момента времени, так как оно зависит от того, какая
функция вызывалась последней (этого нельзя сказать только по одному
файлу модуля).

 В результате, чтобы понять этот программный код, необходимо знать путь
потока выполнения всей программы. И если возникнет необходимость
изменить этот модуль или использовать его в другой программе, необходимо
будет удерживать в своей памяти всю программу. В этой ситуации
невозможно использовать одну функцию, не принимая во внимание другую.
От них зависит значение глобальной переменной. Это типичная проблема
глобальных переменных – они вообще делают программный код более сложным
для понимания и использования, в отличие от кода, состоящего только
из независимых функций, логика выполнения которых построена
на использовании локальных имен.

 С другой стороны, за исключением случаев использования классов
и принципов объектно-ориентированного программирования, глобальные
переменные являются едва ли не самым удобным способом хранения
информации о состоянии (информации, которую необходимо хранить между
вызовами функции) – локальные переменные исчезают, когда функция
возвращает управление, а глобальные – нет. Это можно реализовать
с помощью других приемов, таких как использование изменяемых аргументов
по умолчанию и области видимости объемлющих функций, но они слишком
сложны по сравнению с глобальными переменными.

 Некоторые программы определяют отдельный глобальный модуль для хранения
всех глобальных имен – если это предусмотрено заранее,
это не так вредно. Кроме того, программы на языке Python, использующие
многопоточную модель выполнения для параллельной обработки данных,
тесно связаны с глобальными переменными – они играют роль памяти,
совместно используемой функциями, исполняющимися в параллельных потоках,
и выступают в качестве средств связи.

 Многопоточный режим позволяет запускать функции, которые выполняются
параллельно с основной программой, и поддерживается модулями _thread,
threading и queue (thread, threading и Queue в Python 2.6), входящими
в состав стандартной библиотеки. Так как все потоки управления
выполняются в рамках одного и того же процесса, глобальная область
видимости зачастую может служить аналогом области памяти, совместно
используемой всеми потоками. Многопоточный режим обычно используется
в программах с графическим интерфейсом пользователя, для реализации
неблокирующих операций и более оптимального использования вычислительной
мощности процессора. Однако описание многопоточной модели выполнения
выходит далеко за рамки данной книги, поэтому за дополнительной
информацией обращайтесь к книгам, упомянутым в предисловии (таким как
«Программирование на Python»), и к руководству
по стандартной библиотеке.

 А пока, особенно если вы не имеете достаточного опыта программирования,
по мере возможности избегайте искушения использовать глобальные
переменные (старайтесь организовать обмен данными через параметры
и возвращаемые значения). Шесть месяцев спустя вы и ваши коллеги будете
рады, что поступали таким образом.


 Минимизируйте количество изменений в соседних файлах

 В этом разделе описывается еще одна проблема, связанная с областями
видимости: несмотря на то, что существует возможность непосредственно
изменять переменные в другом файле, этого следует избегать.

# first.py
X = 99 # Это программный код не знает о существовании second.py
# second.py
import first
print(first.X) # Нет ничего плохого в том, чтобы обратиться к имени
# в другом файле
first.X = 88 # Но изменение может привести к сложностям

 Первый модуль определяет переменную X, а второй – выводит ее и затем
изменяет значение в инструкции присваивания. Обратите внимание,
что для этого во втором модуле необходимо импортировать первый модуль.
Как вы уже знаете, каждый модуль представляет собой отдельное
пространство имен (где размещаются переменные), поэтому, чтобы увидеть
содержимое одного модуля во втором, его необходимо импортировать.
Это главная особенность модулей: разделение пространств имен файлов
позволяет избежать конфликтов имен. В терминах этой главы глобальная
область видимости модуля после импортирования превращается
в пространство имен атрибутов объекта модуля – импортирующий модуль
автоматически получает доступ ко всем глобальным переменным
импортируемого модуля, поэтому при импортировании глобальная область
видимости импортируемого модуля, по сути, трансформируется
в пространство имен атрибутов.

 После импортирования первого модуля второй модуль выводит значение его
переменной и затем присваивает ей новое значение. Нет ничего плохого
в том, чтобы в одном модуле сослаться на переменную в другом модуле
и вывести ее, – как правило, именно таким способом обеспечивается связь
между модулями в крупных программах. Проблема состоит в том,
что эта операция выполняется слишком неявно: для любого, кто занимается
сопровождением или использует первый модуль, будет сложно догадаться,
что какой-то другой модуль, далеко отстоящий в цепочке импорта, может
изменить значение переменной X. В конце концов, второй модуль может
находиться вообще в другом каталоге, из-за чего его сложно будет найти.

 Хотя возможность изменения переменных в другом модуле всегда
оддерживалась в языке Python, следует помнить, что эти изменения могут
повлечь за собой трудноуловимые ошибки. Эта возможность порождает
слишком тесную зависимость между двумя модулями – так как оба они
зависят от значения переменной X, будет трудно понять или повторно
использовать один модуль без другого. Такая неочевидная зависимость
между модулями в лучшем случае приводит к снижению гибкости программы,
а в худшем случае – к ошибкам. Лучшая рекомендация в подобной ситуации –
не использовать такую возможность; лучше организовать взаимодействие
между модулями через вызовы функций, передавая им аргументы и получая
возвращаемые значения. В данном конкретном случае было бы лучше добавить
функцию доступа, которая будет выполнять изменения:

# first.py
X = 99
def setX(new):
    global X
    X = new

# second.py
import first
first.setX(88)

 Для этого потребуется добавить дополнительный программный код,
но он имеет огромное значение в смысле обеспечения удобочитаемости
и удобства в сопровождении – когда тот, кто впервые будет знакомиться
с модулем, увидит функцию, он будет знать, что это – часть интерфейса
модуля, и поймет, что переменная X может изменяться. Другими словами,
эта функция устраняет элемент неожиданности, который вряд ли может
считаться положительной характеристикой программного продукта.
Мы не можем полностью избавиться от изменений в соседних файлах, однако
здравый смысл диктует необходимость минимизировать их число, если это
не является широко распространенным явлением в программе.


 Другие способы доступа к глобальным переменным

 Интересно, что благодаря трансформации глобальных переменных
в атрибуты объекта загруженного модуля существует возможность
имитировать инструкцию global, импортируя вмещающий модуль и выполняя
присваивание его атрибутам, как показано в следующем примере модуля.
Программный код в этом файле в одном случае импортирует вмещающий модуль
по имени, а в другом использует таблицу загруженных модулей sys.modules
(подробнее об этой таблице рассказывается в главе 21):

# thismod.py
var = 99  # Глобальная переменная == атрибут модуля

def local():
    var = 0  # Изменяется локальная переменная

def glob1():
    global var  # Глобальное объявление (обычное)
    var += 1  # Изменяется глобальная переменная

def glob2():
    var = 0  # Изменяется локальная переменная
    import thismod  # Импорт самого себя
    glob.var += 1  # Изменяется глобальная переменная

def glob3():
    var = 0  # Изменяется локальная переменная
    import sys  # Импорт системной таблицы
    glob = sys.modules[‘thismod’]  # Получить объект модуля
    # (или использовать __name__)
    glob.var += 1  # Изменяется глобальная переменная

def test():
    print(var)
    local(); glob1(); glob2(); glob3()
    print(var)

 После запуска будут добавлены 3 глобальные переменные (только первая
функция ничего не добавляет):

\>>> import thismod
\>>> thismod.test()
99
102
\>>> thismod.var
102

 Этот пример иллюстрирует эквивалентность глобальных имен и атрибутов
модуля, однако чтобы явно выразить свои намерения, нам потребовалось
написать немного больше, чем при использовании инструкции global.

 Как видите, инструкция global обеспечивает возможность изменения
переменных в модуле из функций. Существует также родственная ей
инструкция nonlocal, которая обеспечивает возможность изменения
переменных в объемлющих функциях, но чтобы понять, где может пригодиться
эта инструкция, нам сначала нужно исследовать возможность вложения
функций друг в друга.
"""

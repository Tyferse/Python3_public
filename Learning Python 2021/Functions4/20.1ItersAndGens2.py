"""
 Итераторы и генераторы


 Еще раз о генераторах списков: функциональные инструменты

 В предыдущей главе мы изучили такие инструменты функционального
программирования, как функции map и filter, выполняющие отображение
операций на последовательности и сбор результатов. Это стало настолько
распространенной задачей в программировании на языке Python, что в нем
появилась новая особенность – генераторы списков, которые упрощают
решение задач еще больше, чем только что рассмотренные функции.
Проще говоря, генераторы списков применяют к элементам итерируемых
объектов произвольные выражения – вместо применения функций. Кроме того,
они могут быть более универсальными инструментами.

 Мы уже встречались с генераторами списков в главе 14 при изучении
инструкций циклов. Но так как они относятся к средствам функционального
программирования, таким как функции map и filter, здесь мы вернемся
к этой теме еще раз. С технической точки зрения эта особенность
не привязана к функциям; как мы увидим, генераторы списков –
более универсальные инструменты, чем map и filter, но иногда их проще
понять, проводя аналогии с альтернативами, основанными на применении
функций.


 Генераторы списков и функция map

 Рассмотрим несколько примеров, демонстрирующих самые основы. Как было
показано в главе 7, встроенная функция ord в языке Python возвращает
целочисленный код ASCII единственного символа (обратной к ней является
встроенная функция chr – она возвращает символ, соответствующий
коду ASCII):

\>>> ord(‘s’)
115

 Теперь предположим, что нам необходимо получить коды ASCII всех
символов в строке. Пожалуй, самый простой подход заключается
в использовании цикла for, в котором полученные результаты добавляются
в список:

\>>> res = []
\>>> for x in ‘spam’:
...     res.append(ord(x))
...
\>>> res
[115, 112, 97, 109]

 Однако теперь, когда мы уже познакомились с функцией map, тех же
результатов мы можем достичь с помощью единственного вызова функции
без необходимости заботиться о создании и заполнении списка:

\>>> res = map(ord, ‘spam’)     # Применить функцию к последовательности
\>>> res
[115, 112, 97, 109]

 Но те же результаты можно получить с помощью генератора списка – если
map отображает функцию на последовательность, то генератор списков
отображает на последовательность выражение:

\>>> res = [ord(x) for x in ‘spam’]  # Применит выражение
\>>> res                             # к последовательности
[115, 112, 97, 109]

 Генераторы списков собирают результаты применения произвольного
выражения к элементам последовательности и возвращают их в виде нового
списка. Синтаксически генераторы списков заключаются в квадратные скобки
(чтобы показать, что они конструируют списки). В простейшем виде
генератор списков представляет собой выражение, оперирующее переменной,
за которым следует конструкция, напоминающая заголовок цикла for,
в котором используется та же переменная. Во время выполнения
интерпретатор Python собирает результаты выражения для каждой итерации
подразумеваемого списка.

 Предыдущий пример дает тот же результат, что цикл for и вызов функции
map выше. Однако генераторы списков более удобны, особенно, когда
требуется применить к последовательности произвольное выражение:

\>>> [x ** 2 for x in range(10)]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

 Здесь создается список квадратов чисел от 0 до 9 (здесь мы позволили
интерактивной оболочке автоматически вывести список – если вам
необходимо сохранить список, присвойте его переменной). Чтобы выполнить
аналогичные действия с помощью функции map, потребовалось бы написать
отдельную функцию, реализующую операцию возведения в квадрат.
Так как эта функция нам не потребуется в другом месте программы,
ее можно было бы (хотя это и необязательно) реализовать не с помощью
инструкции def, а в виде lambda-выражения:

\>>> map((lambda x: x ** 2), range(10))
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

 Этот вызов выполняет ту же работу, и он всего на несколько символов
длиннее эквивалентной реализации на базе генератора списка. Кроме того,
он ненамного сложнее (по крайней мере, для тех, кто разбирается
в lambda-выражениях). Однако в случае более сложных выражений генераторы
списков часто выглядят проще. В следующем разделе
будет показано – почему.


 Добавление проверок и вложенных циклов: функция filter

 Генераторы списков обладают даже еще большей гибкостью,
чем было показано до сих пор. Например, как мы узнали в главе 14,
после цикла for можно добавить оператор if для реализации логики выбора.
Генераторы списков с оператором if можно представить как аналог
встроенной функции filter, представленной в предыдущем разделе, – они
пропускают элементы, для которых условное выражение в операторе if
возвращает ложь.

 Ниже приводятся две версии реализации выбора четных чисел в диапазоне
от 0 до 4 – с помощью генератора списка и с помощью функции filter,
которая использует небольшое lambda-выражение для выполнения проверки.
Для сравнения здесь также показана реализация на основе цикла for:

\>>> [x for x in range(5) if x % 2 == 0]
[0, 2, 4]

\>>> list(filter((lambda x: x % 2 == 0), range(5)))
[0, 2, 4]

\>>> res = []
\>>> for x in range(5):
...     if x % 2 == 0:
...         res.append(x)
...
\>>> res
[0, 2, 4]

 Во всех этих версиях используется оператор деления по модулю
(остаток от деления) %, с помощью которого определяются четные числа:
если остаток от деления на два равен нулю, следовательно, число четное.
Вызов функции filter здесь также выглядит ненамного длиннее,
чем генератор списка. Однако генераторы списков дают возможность
объединять оператор if и произвольные выражения, позволяя добиться
эффекта действия функций filter и map в единственном выражении:

\>>> [x ** 2 for x in range(10) if x % 2 == 0]
[0, 4, 16, 36, 64]

 На этот раз создается список квадратов четных чисел в диапазоне
от 0 до 9: цикл for пропускает числа, для которых условное выражение,
присоединенное справа, возвращает ложь, а выражение слева вычисляет
квадраты. Эквивалентный вызов функции map потребовал бы от нас больше
работы – нам пришлось бы объединить выбор элементов с помощью функции
filter и обход списка с помощью map, что в результате дает более
сложное выражение:

\>>> list(map((lambda x: x**2),
              filter((lambda x: x % 2 == 0), range(10))))
[0, 4, 16, 36, 64]

 В действительности, генераторы списков обладают еще большей гибкостью.
Они дают возможность запрограммировать любое число вложенных циклов
for, каждый из которых может сопровождаться собственным оператором if
с условным выражением. В общем виде генераторы списков выглядят
следующим образом:

[expression for target1 in sequence1 [if condition]
            for target2 in sequence2 [if condition] ...
            for targetN in sequenceN [if condition]]

 Вложенные операторы for в генераторах списков действуют точно так же,
как вложенные инструкции for. Например, следующий фрагмент:

\>>> res = [x + y for x in [0, 1, 2] for y in [100, 200, 300]]
\>>> res
[100, 200, 300, 101, 201, 301, 102, 202, 302]

 дает тот же результат, что и более объемный эквивалент:

\>>> res = []
\>>> for x in [0, 1, 2]:
...     for y in [100, 200, 300]:
...         res.append(x + y)
...
\>>> res
[100, 200, 300, 101, 201, 301, 102, 202, 302]

 Генераторы списков конструируют списки, однако итерации могут
выполняться по любым последовательностям и итерируемым объектам.
Следующий, немного похожий, фрагмент выполняет обход уже не списков
чисел, а строк, и возвращает результаты конкатенации:

\>>> [x + y for x in ‘spam’ for y in ‘SPAM’]
[‘sS’, ‘sP’, ‘sA’, ‘sM’, ‘pS’, ‘pP’, ‘pA’, ‘pM’,
‘aS’, ‘aP’, ‘aA’, ‘aM’, ‘mS’, ‘mP’, ‘mA’, ‘mM’]

 В заключение приведу более сложный генератор списка, который
иллюстрирует действие оператора if, присоединенного к вложенному
оператору for:

\>>> [(x, y) for x in range(5) if x % 2 == 0
             for y in range(5) if y % 2 == 1]
[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]

 Это выражение возвращает возможные комбинации четных и нечетных чисел
в диапазоне от 0 до 4. Условные выражения отфильтровывают элементы
в каждой из последовательностей. Ниже приводится эквивалентная
реализация на базе инструкций:

\>>> for x in range(5):
...     if x % 2 == 0:
...         for y in range(5):
...             if y % 2 == 1:
...                 res.append((x, y))
...
\>>> res
[(0, 1), (0, 3), (2, 1), (2, 3), (4, 1), (4, 3)]

 Не забывайте, что в случае, когда генератор списков становится слишком
сложным для понимания, вы всегда можете развернуть вложенные операторы
for и if (добавляя отступы), чтобы получить эквивалентные инструкции.
Программный код при этом получится более длинным, но более понятным.


 Генераторы списков и матрицы

 Конечно, генераторы списков не всегда выглядят настолько искусственно.
Рассмотрим еще одно, более сложное применение генераторов списков,
в качестве упражнения для ума. Основной способ реализации матриц
(они же – многомерные массивы) в языке Python заключается
в использовании вложенных списков. В следующем примере определяются
две матрицы 3x3 в виде вложенных списков:

\>>> M = [[1, 2, 3],
...       [4, 5, 6],
...       [7, 8, 9]]

\>>> N = [[2, 2, 2],
...       [3, 3, 3],
...       [4, 4, 4]]

 При такой организации всегда можно использовать обычную операцию
индексирования для обращения к строкам и элементам внутри строк:

\>>> M[1]
[4, 5, 6]
\>>> M[1][2]
6

 Генераторы списков являются мощным средством обработки таких структур
данных, потому что они позволяют автоматически сканировать строки
и столбцы матриц. Например, несмотря на то, что при такой организации
матрицы хранятся в виде списка строк, мы легко можем извлечь второй
столбец, просто обходя строки матрицы и выбирая элементы из требуемого
столбца или выполняя обход требуемых позиций в строках:

\>>> [row[1] for row in M]
[2, 5, 8]
\>>> [M[row][1] for row in (0, 1, 2)]
[2, 5, 8]

 Пользуясь позициями, мы так же легко можем извлечь элементы, лежащие
на диагонали. В следующем примере используется функция range – она
создает список смещений, который затем используется для индексирования
строк и столбцов одним и тем же значением. В результате сначала
выбирается M[0][0], затем M[1][1] и так далее (здесь предполагается,
что матрица имеет одинаковое число строк и столбцов):

\>>> [M[i][i] for i in range(len(M))]
[1, 5, 9]

 Наконец, проявив немного изобретательности, генераторы списков можно
использовать для объединения нескольких матриц. Первый пример ниже
создает простой список, содержащий результаты умножения соответствующих
элементов двух матриц, а второй создает структуру вложенных списков,
с теми же самыми значениями:

\>>> [M[row][col] * N[row][col] for row in range(3)
                                for col in range(3)]
[2, 4, 6, 12, 15, 18, 28, 32, 36]

\>>> [[M[row][col] * N[row][col] for col in range(3)]
                                  for row in range(3)]
[[2, 4, 6], [12, 15, 18], [28, 32, 36]]

 В последнем выражении итерации по строкам выполняются во внешнем цикле:
для каждой строки запускается итерация по столбцам, которая создает
одну строку в матрице с результатами. Это выражение эквивалентно
следующему фрагменту:

\>>> res = []
\>>> for row in range(3):
...     tmp = []
...     for col in range(3):
...         tmp.append(M[row][col] * N[row][col])
...     res.append(tmp)
...
\>>> res
[[2, 4, 6], [12, 15, 18], [28, 32, 36]]

 В отличие от этого фрагмента, версия на базе генератора списков
умещается в единственную строку и, вероятно, работает значительно
быстрее в случае больших матриц, но, правда, может и взорвать ваш мозг!
На этом перейдем к следующему разделу.


 Понимание генераторов списков

 При такой степени гибкости генераторы списков очень быстро могут стать
непостижимыми, особенно при наличии вложенных конструкций. Поэтому
начинающим осваивать язык Python я рекомендую в большинстве случаев
использовать простые циклы for и функцию map, а генераторы – в отдельных
случаях (если они получаются не слишком сложными). Здесь также действует
правило «чем проще, тем лучше»: лаконичность программного кода – намного
менее важная цель, чем его удобочитаемость.

 Однако в настоящее время усложнение программного кода обеспечивает
более высокую его производительность: проведенные тесты свидетельствуют,
что функция map работает практически в два раза быстрее,
чем эквивалентные циклы for, а генераторы списков обычно немного
быстрее, чем функция map. Это различие в скорости выполнения обусловлено
тем фактом, что функция map и генераторы списков реализованы на языке C,
что обеспечивает более высокую скорость, чем выполнение циклов for
внутри виртуальной машины Python (PVM).

 Применение циклов for делает логику программы более явной, поэтому
я рекомендую использовать их для обеспечения большей простоты. Однако
функция map и генераторы списков стоят того, чтобы знать и применять их
для реализации простых итераций, а также в случаях, когда скорость
работы приложения имеет критически важное значение. Кроме того,
функция map и генераторы списков являются выражениями и синтаксически
могут находиться там, где недопустимо использовать инструкцию for,
например в теле lambda-выражений, в литералах списков и словарей
и во многих других случаях. То есть вы должны стараться писать простые
функции map и генераторы списков, а в более сложных случаях использовать
полные инструкции.


 Придется держать в уме: генераторы списков и map

 Ниже приводится более реалистичный пример использования генераторов
списков и функции map (мы решали эту задачу с помощью генераторов
списков в главе 14, а здесь мы снова вернемся к ней, чтобы
продемонстрировать альтернативную реализацию на базе функции map).
Вспомните, что метод файлов readlines возвращает строки с символом
конца строки (\n) в конце:

\>>> open(‘myfile’).readlines()
[‘aaa\n’, ‘bbb\n’, ‘ccc\n’]

 Если требуется удалить символы конца строки, их можно отсечь сразу
во всех строках за одно действие с помощью генератора списков
или функции map (в Python 3.0 функция map возвращает итерируемый объект,
поэтому нам пришлось использовать функцию list, чтобы получить
весь список с результатами в интерактивном сеансе):

\>>> [line.rstrip() for line in open(‘myfile’).readlines()]
[‘aaa’, ‘bbb’, ‘ccc’]
\>>> [line.rstrip() for line in open(‘myfile’)]
[‘aaa’, ‘bbb’, ‘ccc’]
\>>> list(map((lambda line: line.rstrip()), open(‘myfile’)))
[‘aaa’, ‘bbb’, ‘ccc’]

 В последних двух случаях используются файловые итераторы (по сути
это означает, что вам не требуется вызывать метод, который будет читать
строки из файла). Вызов функции map выглядит немного длиннее,
чем генератор списков, но ни в одном из этих двух случаев не требуется
явно управлять конструированием списка результатов.

 Кроме того, генераторы списков могут играть роль операции извлечения
столбца. Стандартный прикладной интерфейс доступа к базам данных
в языке Python возвращает результаты запроса в виде списка кортежей,
как показано ниже. Список – это таблица, кортежи – это строки,
а элементы кортежей – это значения столбцов:

listoftuple = [(‘bob’, 35, ‘mgr’), (‘mel’, 40, ‘dev’)]

 Выбрать все значения из определенного столбца можно и вручную,
с помощью цикла for, но функция map и генераторы списков сделают это
быстрее и за один шаг:

\>>> [age for (name, age, job) in listoftuple]
[35, 40]
\>>> list(map((lambda (name, age, job): age), listoftuple))
[35, 40]

 В первом случае используется операция присваивания кортежа – чтобы
извлечь значения в список, а во втором – операция доступа к элементу
последовательности по его индексу. В Python 2.6 (но не в 3.0; смотрите
примечание к операции распаковывания аргументов в главе 18)
для распаковывания кортежей может также использоваться функция map:

# Только в версии 2.6
\>>> list(map((lambda (name, age, job): age), listoftuple))
[35, 40]

 За дополнительной информацией о прикладных интерфейсах языка Python
обращайтесь к другим книгам и источникам информации. Помимо обычных
отличий между функцией и выражением, главное отличие между функцией map
и генератором списков в Python 3.0 состоит в том, что функция map
возвращает итератор, воспроизводящий результаты по требованию;
чтобы добиться такой же экономии памяти, генераторы списков должны
оформляться в виде выражений-генераторов (одна из тем этой главы).


 Еще раз об итераторах: генераторы

 На сегодняшний день язык Python более широко поддерживает отложенные
операции, чем в прошлом, – он предоставляет инструменты, позволяющие
реализовать воспроизведение результатов по требованию, а не всех сразу.
В частности, существуют две языковые конструкции, откладывающие создание
результатов, когда это возможно:

  Функции-генераторы – выглядят как обычные инструкции def,
 но для возврата результатов по одному значению за раз используют
 инструкцию yield, которая приостанавливает выполнение функции.

  Выражения-генераторы – напоминают генераторы списков,
 о которых рассказывалось в предыдущем разделе, но они не конструируют
 список с результатами, а возвращают объект, который будет
 воспроизводить результаты по требованию.

 Поскольку ни одна из этих конструкций не создает сразу весь список
с результатами, они позволяют экономить память и производить
дополнительные вычисления между операциями получения результатов.
Как мы увидим далее, обе конструкции поддерживают такую возможность
возврата результатов по требованию за счет реализации протокола
итераций, который мы изучили в главе 14.


 Функции-генераторы: инструкция yield вместо return

 В этой части книги мы уже познакомились с обычными функциями, которые
получают входные параметры и возвращают единственный результат. Однако
точно так же возможно написать функцию, которая может возвращать
значение, а позднее продолжить свою работу с того места, где она была
приостановлена. Такие функции известны как функции-генераторы,
потому что они генерируют последовательность значений
с течением времени.

 Функции-генераторы во многом похожи на обычные функции
и в действительности создаются с помощью инструкции def. Единственное
отличие состоит в том, что они автоматически поддерживают протокол
итераций и могут использоваться в контексте итераций. Мы рассмотрели
итераторы в главе 14, а здесь взглянем на них еще раз, чтобы увидеть,
какое отношение они имеют к генераторам.


 Замораживание состояния

 В отличие от обычных функций, которые возвращают значение и завершают
работу, функции-генераторы автоматически приостанавливают и возобновляют
свое выполнение, при этом сохраняя информацию, необходимую
для генерации значений. Вследствие этого они часто представляют собой
удобную альтернативу вычислению всей серии значений заранее,
с ручным сохранением и восстановлением состояния в классах.
Функции-генераторы при приостановке автоматически сохраняют информацию
о своем состоянии, под которым понимается вся локальная область
видимости, со всеми локальными переменными, которая становится доступной
сразу же, как только функция возобновляет работу.

 Главное отличие функций-генераторов от обычных функций состоит в том,
что функция-генератор поставляет значение, а не возвращает его –
инструкция yield приостанавливает работу функции и передает значение
вызывающей программе, при этом сохраняется информация о состоянии,
необходимая, чтобы возобновить работу с того места, где она
была приостановлена. Когда функция-генератор возобновляет работу,
ее выполнение продолжается с первой инструкции, следующей за инструкцией
yield. Это позволяет функциям воспроизводить последовательности значений
в течение долгого времени, вместо того чтобы создавать
всю последовательность сразу и возвращать ее в виде некоторой
конструкции, такой как список.


 Интеграция с протоколом итераций

 Чтобы по-настоящему понять функции-генераторы, вы должны знать,
что они тесно связаны с понятием протокола итераций в языке Python.
Как мы уже знаем, итерируемые объекты определяют метод __next__,
который либо возвращает следующий элемент в итерации, либо возбуждает
особое исключение StopIteration по окончании итераций. Доступ
к итератору объекта можно получить с помощью встроенной функции iter.

 Циклы for и другие итерационные механизмы в языке Python используют
такой итерационный протокол, если он поддерживается, для обхода
последовательностей или значений генераторов. Если протокол
не поддерживается, инструкция for терпит неудачу и возвращается
к операции индексирования последовательности.

 Чтобы обеспечить поддержку этого протокола, функции, содержащие
инструкцию yield, компилируются именно как генераторы. При вызове такой
функции она возвращает объект генератора, поддерживающий интерфейс
итераций с помощью автоматически созданного метода __next__,
позволяющего продолжить выполнение. Функции-генераторы точно так же
могут включать инструкцию return, которая не только служит окончанием
блока def, но и завершает генерацию значений, возбуждая исключение
StopIteration после выполнения обычного выхода из функции.
С точки зрения вызывающей программы, метод __next__ генератора
возобновляет выполнение функции, работа которой продолжается, пока она
не встретит следующую инструкцию yield или пока не возбудит исключение
StopIteration.

 Таким образом, функции-генераторы оформляются как обычные инструкции
def, но содержащие инструкции yield, за счет чего они автоматически
получают поддержку протокола итераций и могут использоваться в любых
разновидностях итераций для воспроизведения результатов по требованию.


 Пример функции-генератора

 Чтобы проиллюстрировать основные моменты, рассмотрим следующий
фрагмент, где определяется функция-генератор, которая может
использоваться для генерации серии квадратов чисел:

\>>> def gensquares(N):
...     for i in range(N):
...         yield i ** 2       # Позднее продолжить работу с этого места
...

 Эта функция поставляет значение и тем самым возвращает управление
вызывающей программе на каждой итерации цикла – когда она возобновляет
работу, восстанавливается ее предыдущее состояние и управление
передается непосредственно в точку, находящуюся сразу же за инструкцией
yield. Например, при использовании в заголовке цикла for управление
возвращается функции на каждой итерации в точку, находящуюся сразу же
за инструкцией yield:

\>>> for i in gensquares(5):     # Возобновить работу функции
...      print(i, end = ‘ : ‘)   # Вывести последнее полученное значение
...
0 : 1 : 4 : 9 : 16 :
\>>>

 Чтобы завершить генерацию значений, функция может либо воспользоваться
инструкцией return без значения, либо просто позволить потоку управления
достичь конца функции.

 Если вам интересно узнать, что происходит внутри цикла for, вызовите
функцию-генератор напрямую:

\>>> x = gensquares(4)
\>>> x
<generator object at 0x0086C378>

 Здесь функция вернула объект-генератор, который поддерживает протокол
итераций, с которым мы познакомились в главе 14, – то есть имеет метод
__next__, который запускает функцию или возобновляет ее работу с места,
откуда было поставлено последнее значение, а также возбуждает исключение
StopIteration по достижении конца последовательности значений.
Для удобства в языке Python была создана встроенная функция next,
вызов next(X) которой производит вызов метода X.__next__() объекта:

\>>> next(x)        # То же, что и x.__next__() в версии 3.0
0
\>>> next(x)        # В версии 2.6 используйте вызов x.next() или next()
1
\>>> next(x)
4
\>>> next(x)
9
\>>> next(x)
Traceback (most recent call last):
...остальной текст опущен...
StopIteration

 Как мы узнали в главе 14, циклы for (и другие итерационные контексты)
работают с генераторами точно так же – вызывают метод __next__ в цикле,
пока не будет получено исключение. Если итерируемый объект
не поддерживает этот протокол, вместо него цикл for использует протокол
доступа к элементам по индексам.

 Обратите внимание, что в этом примере мы могли бы просто сразу создать
список всех значений:

\>>> def buildsquares(n):
...     res = []
...     for i in range(n): res.append(i**2)
...     return res
...
\>>> for x in buildsquares(5): print(x, end=’ : ‘)
...
0 : 1 : 4 : 9 : 16 :

 В такой ситуации мы могли бы использовать любой из приемов: цикл for,
функцию map или генератор списков:

\>>> for x in [n**2 for n in range(5)]:
...     print(x, end=’ : ‘)
...
0 : 1 : 4 : 9 : 16 :

\>>> for x in map((lambda x:x**2), range(5)):
...     print(x, end=’ : ‘)
...
0 : 1 : 4 : 9 : 16 :

 Однако генераторы предлагают лучшее решение с точки зрения
использования памяти и производительности. Они дают возможность избежать
необходимости выполнять всю работу сразу, что особенно удобно,
когда список результатов имеет значительный объем или когда вычисление
каждого значения занимает продолжительное время. Генераторы распределяют
время, необходимое на создание всей последовательности значений,
по отдельным итерациям цикла. Кроме того, в более сложных случаях
использования они обеспечивают простую альтернативу сохранению состояния
вручную между вызовами в объектах классов – в случае с генераторами
переменные функций сохраняются и восстанавливаются автоматически.
Подробнее об итераторах на базе классов рассказывается
в шестой части книги.


 Расширенный протокол функций-генераторов: send и next

 В версии Python 2.5 в протокол функций-генераторов был добавлен
метод send. Метод send не только выполняет переход к следующему элементу
в последовательности результатов, как это делает метод next, но еще и
обеспечивает для вызывающей программы способ взаимодействия
с генератором, влияя на его работу.

 С технической точки зрения yield в настоящее время является
не инструкцией, а выражением, которое возвращает элемент, передаваемый
методу send (несмотря на то, что его можно использовать любым
из двух способов – как yield X или как A = (yield X)). Когда выражение
yield помещается справа от оператора присваивания, оно должно
заключаться в круглые скобки, за исключением случая, когда оно
не является составной частью более крупного выражения. Например,
правильно будет написать X = yield Y, а также X = (yield Y) + 42.
При использовании расширенного протокола значения передаются генератору
G вызовом метода G.send(value). После этого программный код генератора
возобновляет работу, и выражение yield возвращает значение, полученное
от метода send. Когда вызывается обычный метод G.__next__()
(или выполняется эквивалентный вызов next(G)), выражение yield
возвращает None. Например:

\>>> def gen():
... for i in range(10):
... X = yield i
... print(X)
...
\>>> G = gen()
\>>> next(G)             # Чтобы запустить генератор, необходимо сначала
0                        # вызвать next()
\>>> G.send(77)          # Переход к следующему значению
77                       # и передача значения выражению yield
1
\>>> G.send(88)
88
2
\>>> next(G)             # next() и X.__next__() передают значение None
None
3

 Метод send может использоваться, например, чтобы реализовать генератор,
который можно будет завершать из вызывающей программы
или переустанавливать в нем текущую позицию в последовательности
результатов. Кроме того, генераторы в версии 2.5 поддерживают метод
throw(type) для возбуждения исключения внутри генератора в последнем
выражении yield и метод close, который возбуждает специальное исключение
GeneratorExit внутри генератора, чтобы вынудить его завершить итерации.
Мы не будем углубляться здесь в эти расширенные возможности –
за дополнительной информацией обращайтесь к стандартным руководствам
по языку Python.

 Обратите внимание, что в Python 3.0 имеется удобная встроенная функция
next(X), выполняющая вызов метода X.__next__() объекта, тогда как другие
методы генератора, такие как send, должны вызываться непосредственно,
как методы объекта генератора (например, G.send(X)).
Это объясняется тем, что все дополнительные методы реализованы только
во встроенных объектах генераторов, тогда как метод __next__ имеется
у всех итерируемых объектов (как встроенных типов,
так и пользовательских классов).
"""

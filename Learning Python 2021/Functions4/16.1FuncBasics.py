"""
 Основы функций

 Если говорить просто, то функция – это средство, позволяющее
группировать наборы инструкций так, что в программе они могут
запускаться неоднократно. Функции могут вычислять некоторый результат
и позволять указывать входные параметры, отличающиеся по своим значениям
от вызова к вызову. Возможность оформления операций в виде функций –
это очень удобный инструмент, который мы можем использовать в самых
разных ситуациях.

 С принципиальной точки зрения функции устраняют необходимость вставлять
в программу избыточные копии блоков одного и того же программного кода,
так как они могут быть заменены единственной функцией. Благодаря
функциям можно существенно уменьшить трудозатраты на программирование:
если операцию необходимо будет видоизменить, достаточно будет внести
изменения всего в одном месте, а не во многих.

 Функции – это самые основные программные структуры в языке Python,
обеспечивающие многократное использование программного кода
и уменьшающие его избыточность. Как будет показано далее, функции –
это еще и средство проектирования, которое позволяет разбить сложную
систему на достаточно простые и легко управляемые части. В табл.
приводятся основные инструменты, имеющие отношение к функциям, которые
мы будем изучать в этой части книги.

  Инструкция    Примеры
  Вызов         myfunc(‘spam’, ‘eggs’, meat=ham)

  def, return   def adder(a, b=1, *c):
                    return a+b+c[0]

  global        def changer():
                    global x; x = ‘new’

  nonlocal      def changer():
                    nonlocal x; x = ‘new’

  yield         def squares(x):
                    for i in range(x): yield i ** 2

  lambda        funcs = [lambda x: x**2, lambda x: x*3]


 Зачем нужны функции?

 Прежде чем перейти к обсуждению деталей, мы нарисуем себе четкую
картину, что из себя представляют функции. Функции – это практически
универсальное средство структурирования программы. Возможно, раньше вам
уже приходилось сталкиваться с ними в других языках программирования,
где они могли называться подпрограммами или процедурами. В процессе
разработки функции играют две основные роли:

  Максимизировать многократное использование программного кода
 и минимизировать его избыточность

  Как и в большинстве других языков программирования, функции в языке
 Python представляют собой простейший способ упаковки логики выполнения,
 которая может использоваться в разных местах программы и более чем
 один раз. До сих пор весь программный код, который нам приходилось
 писать, выполнялся немедленно. Функции позволяют группировать
 и обобщать программный код, который может позднее использоваться
 произвольное число раз. Так как функции позволяют поместить реализацию
 операции в одно место и использовать ее в разных местах, они являются
 самым основным инструментом структуризации: они дают возможность
 уменьшить избыточность программного кода и тем самым уменьшить
 трудозатраты на его сопровождение.

  Процедурная декомпозиция

  Функции также обеспечивают возможность разбить сложную систему
 на части, каждая из которых играет вполне определенную роль. Например,
 чтобы испечь пиццу, сначала нужно замесить тесто, раскатать его,
 добавить начинку, испечь и так далее. Если бы мы писали программу
 для машины по выпечке пиццы, мы могли бы общую задачу «испечь пиццу»
 разбить на мелкие части – по одной функции для каждого из этапов.
 Гораздо проще создать решение маленьких задач по отдельности,
 чем реализовать весь процесс целиком. Вообще функции описывают
 «как делать», а не «зачем делать». В шестой части книги мы увидим,
 почему это различие имеет такое большое значение.

 В этой части книги мы исследуем понятия языка Python, используемые при
создании функций: основы функций, правила области видимости и передача
аргументов, а также ряд сопутствующих концепций, таких как генераторы
и функциональные инструменты. Мы также еще раз вернемся к понятию
полиморфизма, введенному ранее в этой книге, поскольку на данном уровне
его важность становится еще более очевидной. Как вы увидите, функции
привносят не так много новых синтаксических конструкций, но они ведут
нас к более существенным идеям программирования.


 Создание функций

 Несмотря на то, что функции еще не были представлены формально,
тем не менее мы уже использовали некоторые из них в предыдущих главах.
Например, для создания объекта файла мы вызывали функцию open;
точно так же мы использовали встроенную функцию len, когда нам
необходимо было узнать число элементов в объекте коллекции.

 В этой главе мы узнаем, как создаются новые функции в языке Python.
Функции, которые мы пишем сами, ведут себя точно так же,
как и встроенные функции, которые нам уже приходилось встречать:
они могут вызываться в выражениях, получать значения и возвращать
результаты. Но для того, чтобы создавать новые функции,
необходимо ввести дополнительные понятия. Кроме того, в языке Python
функции ведут себя иначе, чем в компилирующих языках программирования,
таких как C. Ниже приводится краткое введение в основные концепции,
составляющие основу функций в языке Python, каждую из которых
мы будем изучать в этой части книги:

  def – это исполняемый программный код. Функции в языке Python
 создаются с помощью новой инструкции def. В отличие от функций
 в компилирующих языках программирования, таких как C, def относится
 к классу исполняемых инструкций – функция не существует, пока
 интерпретатор не доберется до инструкции def и не выполнит ее.
 Фактически вполне допустимо (а иногда даже полезно) вкладывать
 инструкции def внутрь инструкций if, циклов while и даже в другие
 инструкции def. В случае наиболее типичного использования инструкции
 def вставляются в файлы модулей и генерируют функции при выполнении
 во время первой операции импортирования.

  def создает объект и присваивает ему имя. Когда интерпретатор Python
 встречает и выполняет инструкцию def, он создает новый объект-функцию
 и связывает его с именем функции. Как и в любой другой операции
 присваивания, имя становится ссылкой на объект-функцию. В имени функции
 нет ничего необычного – как будет показано далее, объект-функция может
 быть связан с несколькими именами, может сохраняться в списке
 и так далее. Кроме того, к функциям можно прикреплять различные
 атрибуты, определяемые пользователем, для сохранения каких-либо данных.

  Выражение lambda создает объект и возвращает его в виде результата.
 Функции могут также создаваться с помощью выражения lambda.
 Это позволяет создавать встроенные определения функций там, где
 синтаксис языка не позволяет использовать инструкцию def
 (это достаточно сложная концепция, рассмотрение которой мы отложим
 до главы 19).

  return передает объект результата вызывающей программе. Когда функция
 вызывается, вызывающая программа приостанавливает свою работу, пока
 функция не завершит работу и не вернет управление. Функции, вычисляющие
 какое-либо значение, возвращают его с помощью инструкции return –
 возвращаемое значение становится результатом обращения к функции.

  yield передает объект результата вызывающей программе и запоминает,
 где был произведен возврат. Функции, известные как генераторы, для
 передачи возвращаемого значения могут также использовать инструкцию
 yield и сохранять свое состояние так, чтобы работа функции могла быть
 возобновлена позднее, – это еще одна из сложных тем, которые будут
 рассматриваться позже в этой части книги.

  Аргументы передаются посредством присваивания (в виде ссылок
 на объекты). В языке Python аргументы передаются функциям посредством
 выполнения операции присваивания (что, как мы уже знаем, означает –
 в виде ссылок на объекты). Как будет показано далее, модель, принятая
 в языке Python, в действительности не эквивалентна правилам передачи
 аргументов по ссылке в языке C или C++ – и вызывающая программа,
 и функция совместно используют ссылку на объект, но здесь нет никакого
 совмещения имен. Изменение имени аргумента также не изменяет имени
 в вызывающей программе, но модификация изменяемых объектов внутри
 функции может приводить к изменению объектов в вызывающей программе.

  global объявляет переменные, глобальные для модуля, без присваивания
 им значений. По умолчанию все имена, присваивание которым производится
 внутри функций, являются локальными для этих функций и существуют
 только во время выполнения функций. Чтобы присвоить значение имени
 в объемлющем модуле, функция должна объявить его с помощью инструкции
 global. Говоря в более широком смысле, поиск имен всегда производится
 в некоторой области видимости – там, где хранятся переменные, –
 а операция присваивания связывает имена с областями видимости.

  nonlocal объявляет переменные, находящиеся в области видимости
 объемлющей функции, без присваивания им значений. В Python 3 появилась
 новая инструкция nonlocal, позволяющая функциям присваивать значения
 переменным, находящимся в области видимости синтаксически объемлющей
 функции. Это позволяет использовать объемлющие функции, как место
 хранения информации о состоянии – информация восстанавливается в момент
 вызова функции, при этом отпадает необходимость использовать глобальные
 переменные.

  Аргументы получают свои значения (ссылки на объекты) в результате
 выполнения операции присваивания. При передаче аргументов функциям
 в языке Python выполняется операция присваивания значений (то есть,
 как мы уже знаем, ссылок на объекты). Как вы увидите далее, в языке
 Python передача объектов в функции производится по ссылкам, но это
 не означает, что создаются псевдонимы имен. Изменение имени аргумента
 внутри функции не влечет за собой изменения соответствующего имени
 в вызывающей программе, но изменения в изменяемых объектах, переданных
 функции, отразятся на объектах, переданных вызывающей программой.

  Аргументы, возвращаемые значения и переменные не объявляются.
 Как и повсюду в языке Python, на функции также не накладывается никаких
 ограничений по типу. Фактически никакие элементы функций не требуют
 предварительного объявления: вы можете передавать функции аргументы
 любых типов, возвращать из функции объекты любого типа и так далее.
 Как следствие этого одна и та же функция может применяться к объектам
 различных типов – допустимыми считаются любые объекты, поддерживающие
 совместимые интерфейсы (методы и выражения), независимо
 от конкретного типа.


 Инструкция def

 Инструкция def создает объект функции и связывает его с именем. В общем
виде инструкция имеет следующий формат:

def <name>(arg1, arg2,... argN):
    <statements>

 Как и все составные инструкции в языке Python, инструкция def состоит
из строки заголовка и следующего за ней блока инструкций, обычно
с отступами (или простая инструкция вслед за двоеточием).
Блок инструкций образует тело функции, то есть программный код, который
выполняется интерпретатором всякий раз, когда производится вызов
функции.

 В строке заголовка инструкции def определяются имя функции, с которым
будет связан объект функции, и список из нуля или более аргументов
(иногда их называют параметрами) в круглых скобках. Имена аргументов
в строке заголовка будут связаны с объектами, передаваемыми в функцию,
в точке вызова. Тело функции часто содержит инструкцию return:

def <name>(arg1, arg2,... argN):
    ...
    return <value>

 Инструкция return может располагаться в любом месте в теле функции –
она завершает работу функции и передает результат вызывающей программе.
Инструкция return содержит объектное выражение, которое дает результат
функции. Инструкция return является необязательной – если она
отсутствует, работа функции завершается, когда поток управления
достигает конца тела функции. С технической точки зрения, функция
без инструкции return автоматически возвращает объект None, однако
это значение обычно просто игнорируется. Функции могут также содержать
инструкции yield, которые используются для воспроизведения серии
значений с течением времени, однако обсуждение этой инструкции
мы отложим до главы 20, где обсуждаются расширенные темы,
касающиеся функций.


 Инструкции def исполняются во время выполнения

 Инструкция def в языке Python – это настоящая исполняемая инструкция:
когда она исполняется, она создает новый объект функции и присваивает
этот объект имени. (Не забывайте, все, что имеется в языке Python,
относится ко времени выполнения, здесь нет понятия времени компиляции.)
Будучи инструкцией, def может появляться везде, где могут появляться
инструкции, – даже внутри других инструкций. Например, даже при том,
что инструкции def обычно исполняются, когда производится импорт
вмещающего их модуля, допускается вкладывать определения функций внутрь
инструкций if, что позволяет производить выбор между альтернативами:

if test:
    def func():  # Определяет функцию таким способом
        ...
else:
    def func():  # Или таким способом
        ...
...
func()  # Вызов выбранной версии

 Чтобы понять этот фрагмент программного кода, обратите внимание, что
инструкция def напоминает инструкцию присваивания =: она просто
выполняет присваивание во время выполнения. В отличие от компилирующих
языков, таких как C, функции в языке Python не должны быть полностью
определены к моменту запуска программы. Другими словами, инструкции def
не интерпретируются, пока они не будут достигнуты и выполнены потоком
выполнения, а программный код внутри инструкции def не выполняется,
пока функция не будет вызвана позднее.

 Так как определение функции происходит во время выполнения, в именах
функций нет ничего особенного. Важен только объект,
на который ссылается имя:

othername = func  # Связывание объекта функции с именем
othername() #  Вызов функции

 В этом фрагменте функция была связана с другим именем и вызвана уже
с использованием нового имени. Как и все остальное в языке Python,
функции – это обычные объекты; они явно записываются в память во время
выполнения программы. Кроме поддержки возможности вызова, функции
позволяют присоединять любые атрибуты, в которых можно сохранять
информацию для последующего использования:

def func(): ...    # Создает объект функции
func()             # Вызывает объект
func.attr = value  # Присоединяет атрибут к объекту


 Первый пример: определения и вызовы

 Кроме таких концепций времени выполнения (которые кажутся наиболее
уникальными для программистов, имеющих опыт работы с традиционными
компилирующими языками программирования) в использовании функций нет
ничего сложного. Давайте напишем первый пример, в котором
продемонстрируем основные моменты. Как видите, функции имеют
две стороны: определение (инструкция def, которая создает функцию)
и вызов (выражение, которое предписывает интерпретатору выполнить
тело функции).


 Определение

 Ниже приводится фрагмент сеанса работы в интерактивной оболочке,
в котором определяется функция с именем times. Эта функция возвращает
результат обработки двух аргументов:

\>>> def times(x, y):  # Создать функцию и связать ее с именем
...     return x * y   # Тело, выполняемое при вызове функции
...

 Когда интерпретатор достигнет инструкции def и выполнит ее, он создаст
новый объект функции, в который упакует программный код функции и свяжет
объект с именем times. Как правило, такие инструкции размещаются
в файлах модулей и выполняются во время импортирования, однако такую
небольшую функцию можно определить и в интерактивной оболочке.


 Вызов

 После выполнения инструкции def появляется возможность вызвать функцию
в программе, добавив круглые скобки после ее имени. В круглых скобках
можно указать один или более аргументов, значения которых будут
присвоены именам, указанным в заголовке функции:

\>>> times(2, 4)  # Аргументы в круглых скобках
8

 Данное выражение передает функции times два аргумента. Как уже
упоминалось ранее, передача аргументов осуществляется за счет выполнения
операции присваивания, таким образом, имени x в заголовке функции
присваивается значение 2, а имени y – значение 4, после чего запускается
тело функции. В данном случае тело функции составляет единственная
инструкция return, которая отправляет обратно результат выражения.
В данном примере возвращаемый объект был выведен интерактивной оболочкой
автоматически (как и в большинстве языков, 2 * 4 в языке Python
равно 8), однако если бы результат потребовался позднее, мы могли бы
присвоить его переменной. Например:

\>>> x = times(3.14, 4)  # Сохранить объект результата
\>>> x
12.56

 Теперь посмотрим, что произойдет, если функции передать объекты
совершенно разных типов:

\>>> times(‘Ni’, 4)  # Функции не имеют типа
‘NiNiNiNi’

 На этот раз функция выполнила нечто совершенно иное (здесь вполне
уместна была бы ссылка на Монти Пайтона (Monty Python)). На этот раз
вместо двух чисел в аргументах x и y функции были переданы строка
и целое число. Вспомните, что оператор * может работать как с числами,
так и с последовательностями; поскольку в языке Python не требуется
объявлять типы переменных, аргументов или возвращаемых значений,
мы можем использовать функцию times для умножения чисел и повторения
последовательностей.

 Другими словами, смысл функции times и тип возвращаемого значения
определяется аргументами, которые ей передаются. Это основная идея языка
Python (и, возможно, ключ к использованию языка), которую мы рассмотрим
в следующем разделе.


 Полиморфизм в языке Python

 Как мы только что видели, смысл выражения x * y в нашей простой функции
times полностью зависит от типов объектов x и y – одна и та же функция
может выполнять умножение в одном случае и повторение в другом. В языке
Python именно объекты определяют синтаксический смысл операции.
В действительности оператор * – это всего лишь указание для
обрабатываемых объектов. Такого рода зависимость от типов известна как
полиморфизм – термин, впервые встретившийся нам в главе 4, который
означает, что смысл операции зависит от типов обрабатываемых объектов.
Поскольку Python – это язык с динамической типизацией, полиморфизм
в нем проявляется повсюду. Фактически все операции в языке Python
являются полиморфическими: вывод, извлечение элемента, оператор *
и многие другие.

 Такое поведение заложено в язык изначально и объясняет в большой
степени его краткость и гибкость. Например, единственная функция может
автоматически применяться к целой категории типов объектов. Пока объекты
поддерживают ожидаемый интерфейс (или протокол), функция сможет
обрабатывать их. То есть, если объект, передаваемый функции,
поддерживает ожидаемые методы и операторы выражений, он будет совместим
с логикой функции. Даже в случае с нашей простой функцией times
это означает, что любые два объекта, поддерживающие оператор *, смогут
обрабатываться функцией, и неважно, что они из себя представляют
и когда были созданы. Эта функция будет работать с числами (выполняя
операцию умножения) или со строкой и числом (выполняя операцию
повторения) и с любыми другими комбинациями объектов, поддерживающими
ожидаемый интерфейс, – даже с объектами, порожденными на базе классов,
которые мы еще пока не создали.

 Кроме того, если функции будут переданы объекты, которые
не поддерживают ожидаемый интерфейс, интерпретатор обнаружит ошибку
при выполнении выражения * и автоматически возбудит исключение.
Поэтому для нас совершенно бессмысленно предусматривать проверку
на наличие ошибок в программном коде. Фактически добавив такую проверку,
мы ограничим область применения нашей функции, так как она сможет
работать только с теми типами объектов, которые мы предусмотрели.

 Это важнейшее отличие философии языка Python от языков программирования
со статической типизацией, таких как C++ и Java: программный код
на языке Python не делает предположений о конкретных типах данных.
В противном случае он сможет работать только с теми типами данных,
которые ожидались на момент его написания, и он не будет поддерживать
объекты других совместимых типов, которые могут быть созданы в будущем.
Проверку типа объекта можно выполнить с помощью таких средств,
как встроенная функция type, но в этом случае программный код потеряет
свою гибкость. Вообще говоря, при программировании на языке Python
во внимание принимаются интерфейсы объектов, а не типы данных.

 Конечно, такая модель полиморфизма предполагает необходимость
тестирования программного кода на наличие ошибок, так как из-за
отсутствия объявлений типов нет возможности с помощью компилятора
выявить некоторые виды ошибок на ранней стадии. Однако в обмен на
незначительное увеличение объема отладки мы получаем существенное
уменьшение объема программного кода, который требуется написать,
и существенное увеличение его гибкости. На практике это означает
чистую победу.


 Второй пример: пересечение последовательностей

 Рассмотрим второй пример функции, которая делает немного больше,
чем простое умножение аргументов, и продолжает иллюстрацию основ
функций. В главе 13 мы написали цикл for, который выбирал элементы,
общие для двух строк. Там было замечено, что полезность этого
программного кода не так велика, как могла бы быть, потому что он может
работать только с определенными переменными и не может быть использован
повторно. Безусловно, можно было бы просто скопировать этот блок кода
и вставлять его везде, где потребуется, но такое решение нельзя признать
ни удачным, ни универсальным – нам по-прежнему придется редактировать
каждую копию, изменяя имена последовательностей; изменение алгоритма
также влечет за собой необходимость вносить изменения в каждую копию.


 Определение

 К настоящему моменту вы уже наверняка поняли, что решение этой дилеммы
заключается в том, чтобы оформить этот цикл for в виде функции. Такой
подход несет нам следующие преимущества:

  Оформив программный код в виде функции, появляется возможность
 использовать его столько раз, сколько потребуется.

  Так как вызывающая программа может передавать функции произвольные
 аргументы, функция сможет использоваться с любыми двумя
 последовательностями (или итерируемыми объектами) для получения
 их пересечения.

  Когда логика работы оформлена в виде функции, достаточно изменить
 программный код всего в одном месте, чтобы изменить способ получения
 пересечения.

  Поместив функцию в файл модуля, ее можно будет импортировать
 и использовать в любой программе на вашем компьютере.

 В результате программный код, обернутый в функцию, превращается
в универсальную утилиту нахождения пересечения:

def intersect(seq1, seq2):
    res = [] # Изначально пустой результат
    for x in seq1: # Обход последовательности seq1
        if x in seq2: # Общий элемент?
            res.append(x) # Добавить в конец
    return res

 В том, чтобы преобразовать фрагмент кода из главы 13 в функцию,
нет ничего сложного, – мы просто вложили оригинальную реализацию
в инструкцию def и присвоили имена объектам, с которыми она работает.
Поскольку эта функция возвращает результат, мы также добавили
инструкцию return, которая возвращает полученный объект результата
вызывающей программе.


 Вызов

 Прежде чем функцию можно будет вызвать, ее необходимо создать.
Для этого нужно выполнить инструкцию def, либо введя ее в интерактивной
оболочке, либо поместив ее в файл модуля и выполнив операцию импорта.
Как только инструкция def будет выполнена, можно будет вызывать функцию
и передать ей два объекта последовательностей в круглых скобках:

\>>> s1 = “SPAM”
\>>> s2 = “SCAM”
\>>> intersect(s1, s2)  # Строки
[‘S’, ‘A’, ‘M’]

 В данном примере мы передали функции две строки и получили список общих
символов. Алгоритм работы функции можно выразить простой фразой:
«Для всех элементов первого аргумента, если этот элемент присутствует
и во втором аргументе, добавить его в конец результата». Этот алгоритм
на языке Python описывается немного короче, чем на естественном языке,
но работает он точно так же.

 Справедливости ради следует признать, что наша функция поиска
пересечения работает слишком медленно (она выполняет вложенный цикл);
она находит пересечение, которое не является пересечением
в математическом смысле (в результате могут иметься повторяющиеся
значения); и к тому же она вообще не нужна (как мы увидим дальше,
операция пересечения в языке Python поддерживается множествами).
В действительности эту функцию можно заменить единственным выражением
генератора списков, демонстрирующим классический пример цикла
выборки данных:

\>>> [x for x in s1 if x in s2]
[‘S’, ‘A’, ‘M’]

 Однако она прекрасно подходит на роль простого примера,
демонстрирующего основы применения функций, – один фрагмент программного
кода может применяться к целому диапазону типов объектов,
о чем подробнее рассказывается в следующем разделе.


 Еще о полиморфизме

 Как и любая другая функция в языке Python, функция intersect также я
вляется полиморфной. То есть она может обрабатывать объекты произвольных
типов, при условии, что они поддерживают ожидаемый интерфейс:

\>>> x = intersect([1, 2, 3], (1, 4))  # Смешивание типов
\>>> x  # Объект с результатом
[1]

 На этот раз функции были переданы объекты разных типов – список и
кортеж, – и это не помешало ей отыскать общие элементы. Благодаря
отсутствию необходимости предварительного объявления типов аргументов
функция intersect благополучно будет выполнять итерации по объектам
последовательностей любых типов, если они будут поддерживать ожидаемые
интерфейсы. Для функции intersect это означает, что первый объект должен
обладать поддержкой циклов for, а второй – поддержкой оператора in,
выполняющего проверку на вхождение. Любые два объекта, отвечающие этим
условиям, будут обработаны независимо от их типов, включая как сами
последовательности, такие как строки и списки, так и любые итерируемые
объекты, с которыми мы встречались в главе 14, включая файлы, словари
и даже объекты, созданные на основе классов и использующие перегрузку
операторов (эту тему мы будем рассматривать в шестой части книги).

 Эта функция будет работать, если содержимое файлов передается ей
в виде результатов вызова метода file.readlines(). Она может н
е работать непосредственно с открытыми файлами, в зависимости
от особенностей реализации поддержки оператора in в объектах файлов.
Вообще, после достижения конца файла необходимо переустановить текущую
позицию в начало этого файла (например, с помощью вызова метода
file.seek(0)). Как мы увидим в главе 29, когда будем изучать возможность
перегрузки операторов, классы реализуют поддержку оператора in либо
с помощью метода __contains__, либо за счет реализации общей поддержки
протокола итераций с помощью метода __iter__ или более старого метода
__getitem__. С помощью этих методов мы можем определить, что означает
понятие итерации для наших данных.

 И снова, если функции передать объекты, которые не поддерживают эти
интерфейсы (например, числа), интерпретатор автоматически обнаружит
несоответствие и возбудит исключение, то есть именно то, что нам
требуется, и это лучше, чем добавление явной проверки типов аргументов.
Отказываясь от реализации проверки типов и позволяя интерпретатору
самому обнаруживать несоответствия, мы тем самым уменьшаем объем
программного кода и повышаем его гибкость.


 Локальные переменные

 Пожалуй, самое интересное в этом примере заключено в переменных.
Переменная res внутри функции intersect – это то, что в языке Python
называется локальной переменной, – имя, которое доступно только
программному коду внутри инструкции def и существует только во время
выполнения функции. Фактически любые имена, которым тем или иным
способом были присвоены некоторые значения внутри функции, по умолчанию
классифицируются как локальные переменные. Почти все имена в функции
intersect являются локальными переменными:

  Переменная res явно участвует в операции присваивания, поэтому она –
 локальная переменная.

  Аргументы передаются через операцию присваивания, поэтому seq1 и seq2
 тоже локальные переменные.

  Цикл for присваивает элементы переменной, поэтому имя x также является
 локальным.

 Все эти локальные переменные появляются только в момент вызова функции
и исчезают, когда функция возвращает управление – инструкция return,
стоящая в конце функции intersect, возвращает объект результата,
а имя res исчезает. Однако, чтобы полностью исследовать понятие
локальности, нам необходимо перейти к главе 17.
"""

"""
 Краткая сводка по синтаксису генераторов в 3.0

 В этой главе наше внимание было сосредоточено на генераторах списков и
на объектах-генераторах, но не следует забывать о существовании еще двух
форм генераторов: генераторов множеств и словарей, появившихся
в Python 3.0. Мы встречались с ними в главах 5 и 8, а теперь, с учетом
накопленных представлений о генераторах, мы в состоянии полностью
охватить эти разновидности генераторов:

  В случае с множествами литеральная форма {1, 3, 2} эквивалентна вызову
 set([1, 3, 2]), а новый синтаксис генераторов множеств
 {f(x) for x in S if P(x)} напоминает синтаксис выражений-генераторов
 set(f(x) for x in S if P(x)), где f(x) – произвольное выражение.

  В случае со словарями новая конструкция генераторов словарей
 {key: val for (key, val) in zip(keys, vals)} действует точно так же,
 как dict(zip(keys, vals)), and {x: f(x) for x in items}, и напоминает
 выражение-генератор dict((x, f(x)) for x in items).

 Ниже приводится краткая сводка по всем альтернативным генераторам
в версии 3.0. Последние две конструкции являются новыми и недоступны
в версии 2.6:

\>>> [x * x for x in range(10)]        # Генератор списков: конструирует
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]   # список подобно вызову
                                       # list(generator expr)

\>>> (x * x for x in range(10))   # Выражение-генератор: воспроизводит
<generator object at 0x009E7328>  # элементы. Скобки часто необязательны

\>>> {x * x for x in range(10)}      # Генератор множеств, новинка в 3.0
{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}  # {x, y} – литерал множества в 3.0

\>>> {x: x * x for x in range(10)}   # Генератор словарей, новинка в 3.0
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}


 Понимание генераторов множеств и словарей

 В некотором смысле, конструкции генераторов множеств и словарей
являются всего лишь синтаксическим подсластителем
для выражений-генераторов, которые передаются конструкторам этих типов
данных. Поскольку обе конструкции способны принимать любые итерируемые
объекты, следующие генераторы являются вполне допустимыми:

\>>> {x * x for x in range(10)}      # Генератор
{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}
\>>> set(x * x for x in range(10))   # Генератор и конструктор типа
{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}
\>>> {x: x * x for x in range(10)}
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
\>>> dict((x, x * x) for x in range(10))
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}

 Как и в случае с генераторами списков, мы всегда можем конструировать
объекты результата вручную. Ниже приводятся реализации, эквивалентные
двум последним генераторам:

\>>> res = set()
\>>> for x in range(10):  # Эквивалент генератора множеств
...     res.add(x * x)
...
\>>> res
{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}

\>>> res = {}
\>>> for x in range(10):  # Эквивалент генератора словарей
...     res[x] = x * x
...
\>>> res
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}

 Обратите внимание, что хотя обе формы принимают итераторы, но они
не воспроизводят результаты по требованию – обе формы конструируют
результат целиком. Если вам потребуется воспроизводить ключи и значения
по запросу, используйте выражение-генератор:

\>>> G = ((x, x * x) for x in range(10))
\>>> next(G)
(0, 0)
\>>> next(G)
(1, 1)


 Расширенный синтаксис генераторов множеств и словарей

 Как и генераторы списков, генераторы множеств и словарей поддерживают
вложенные условные инструкции if, позволяющие отфильтровывать элементы
из результата, – следующие конструкции воспроизводят квадраты четных
чисел (то есть чисел, которые делятся на 2 без остатка)
в заданном диапазоне:

\>>> [x * x for x in range(10) if x % 2 == 0]  # Списки упорядочены
[0, 4, 16, 36, 64]
\>>> {x * x for x in range(10) if x % 2 == 0}  # А множества - нет
{0, 16, 4, 64, 36}
\>>> {x: x * x for x in range(10) if x % 2 == 0}  # Как и ключи словаря
{0: 0, 8: 64, 2: 4, 4: 16, 6: 36}

 Вложенные циклы for также являются допустимыми, хотя неупорядоченная
природа обоих типов, не допускающая появления дубликатов, может
несколько осложнять интерпретацию результатов:

\>>> [x + y for x in [1, 2, 3] for y in [4, 5, 6]]  # Списки сохраняют
[5, 6, 7, 6, 7, 8, 7, 8, 9]                         # дубликаты
\>>> {x + y for x in [1, 2, 3] for y in [4, 5, 6]}  # А множества - нет
{8, 9, 5, 6, 7}
\>>> {x: y for x in [1, 2, 3] for y in [4, 5, 6]}  # Как и ключи
{1: 6, 2: 6, 3: 6}                                 # словарей

 Подобно генераторам списков, генераторы множеств и словарей способны
выполнять итерации по итераторам любых типов – спискам, строкам, файлам,
диапазонам целых чисел и любым другим объектам, поддерживающим протокол
итераций:

\>>> {x + y for x in ‘ab’ for y in ‘cd’}
{‘bd’, ‘ac’, ‘ad’, ‘bc’}
\>>> {x + y: (ord(x), ord(y)) for x in ‘ab’ for y in ‘cd’}
{‘bd’: (98, 100), ‘ac’: (97, 99), ‘ad’: (97, 100), ‘bc’: (98, 99)}

\>>> {k * 2 for k in [‘spam’, ‘ham’, ‘sausage’] if k[0] == ‘s’}
{‘sausagesausage’, ‘spamspam’}
\>>> {k.upper(): k * 2 for k in [‘spam’, ‘ham’, ‘sausage’]
                                            if k[0] == ‘s’}
{‘SAUSAGE’: ‘sausagesausage’, ‘SPAM’: ‘spamspam’}

 Поэкспериментируйте с этими инструментами самостоятельно, чтобы полнее
усвоить принцип их действия. Они могут обладать или не обладать более
высокой производительностью по сравнению с генераторами или циклами for,
но для такой оценки мы должны иметь возможность явно оценить
их производительность, что естественным образом ведет нас к следующему
разделу.


 Хронометраж итерационных альтернатив

 В этой книге нам встретилось несколько итерационных альтернатив. Чтобы
подвести итог, коротко проанализируем ситуацию, соединив все,
что мы узнали об итерациях и функциях.

 Несколько раз я упоминал, что генераторы списков обладают более высокой
скоростью выполнения, чем циклы for, а скорость работы функции map может
быть выше или ниже, в зависимости от конкретной решаемой задачи.
Выражения-генераторы, рассматривавшиеся в предыдущих разделах, обычно
немного медленнее, чем генераторы списков, но при этом они минимизируют
требования к объему используемой памяти.

 Все это справедливо на сегодняшний день, но относительная
производительность может измениться со временем, так как интерпретатор
Python постоянно оптимизируется. Если вам захочется проверить это самим,
попробуйте запустить следующий сценарий на своем компьютере,
со своей версией интерпретатора.


 Модуль time

 К счастью, Python существенно упрощает хронометраж выполнения
программного кода. Чтобы увидеть, как различные варианты выполнения
итераций выстраиваются по производительности, рассмотрим простую,
но достаточно универсальную утилиту timer, которую мы сохраним
в файле модуля, чтобы потом ее можно было использовать в различных
программах:
"""

import time
reps = 1000
repslist = range(reps)


def timer(func, *pargs, **kargs):
    start = time.time()
    for _ in repslist:
        ret = func(*pargs, **kargs)
        
    elapsed = time.time() - start
    return elapsed, ret


"""
 Функционально эта утилита способна вызывать любую функцию с любым
количеством позиционных и именованных аргументов. Она фиксирует 
начальное время, вызывает функцию фиксированное число раз и вычитает
время начала из времени конца. Важно отметить следующие обстоятельства:

  Модуль time из стандартной библиотеки языка Python позволяет получить
 текущее время с точностью, зависящей от платформы. В Windows, 
 как утверждается, этот модуль позволяет получить время с точностью 
 до микросекунды и, следовательно, обеспечивает высокую точность.
 
  Вызов функции range был вынесен за пределы цикла измерения времени,
 благодаря чему время конструирования диапазона не накладывается 
 на получаемые результаты в Python 2.6. В Python 3.0 функция range 
 возвращает итератор, поэтому в версии 3.0 данный шаг можно считать 
 излишним (хотя он и не мешает).
 
  Счетчик reps оформлен как глобальная переменная, благодаря чему она
 может изменяться импортирующим модулем при необходимости: 
 mytimer.reps = N.
 
 По окончании измерений утилита возвращает общее время выполнения всех
вызовов функции внутри кортежа, наряду с последним значением, полученным
от исследуемой функции, чтобы вызывающая программа могла проверить 
результат ее деятельности.

 Глядя вперед, можно отметить, что так как эта функция находится
в отдельном файле модуля, она может рассматриваться как удобный
инструмент общего пользования, доступный для импортирования любой 
программой. Подробнее с модулями и с операцией импортирования
вы познакомитесь в следующей части книги, но вы знаете уже достаточно,
чтобы понять этот программный код, – просто импортируйте модуль 
и вызовите функцию.


 Сценарий хронометража
 
 Теперь можно приступать к измерению производительности инструментов 
итераций. Запустите следующий сценарий – он использует модуль mytimer,
который мы только что написали, для измерения относительной скорости
выполнения различных приемов конструирования списков, изученных нами:
"""

import sys

reps = 5000
repslist = range(reps)  # Вызов функции range вынесен
#                         за пределы цикла в 2.6


def forLoop():
    res = []
    for x in repslist:
        res.append(abs(x))
        
    return res


def listComp():
    return [abs(x) for x in repslist]


def mapCall():
    return list(map(abs, repslist))  # Вызов list необходим только в 3.0


def genExpr():
    return list(abs(x) for x in repslist)  # Функция list вынуждает
#                                           вернуть сразу все результаты


def genFunc():
    def gen():
        for x in repslist:
            yield abs(x)
            
    return list(gen())


print(sys.version)
for test in (forLoop, listComp, mapCall, genExpr, genFunc):
    elapsed, result = timer(test)
    print('-' * 33)
    print(' %-9s: %.5f = > [%s... %s]' %
          (test.__name__, elapsed, result[0], result[-1]))

"""
 Этот сценарий тестирует все пять альтернативных способов создания 
списков и, как видно из листинга, выполняет по 10 миллионов итераций 
каждым из способов, то есть каждый из тестов создает список из 10 000
элементов 1 000 раз.

 Обратите внимание, как выражения и функции передаются встроенной 
функции list, чтобы вынудить их выдать все значения, – если бы этого 
не было сделано, мы бы просто создали генератор, который не выполняет 
никакой работы. В Python 3.0 (только) мы также должны передать функции 
list результат вызова функции map, поскольку в этой версии 
она возвращает итератор. Кроме того, заметьте, как программный код 
в самом конце сценария выполняет обход кортежа из четырех функций 
и выводит значение атрибута __name__ для каждой из них: это встроенный
атрибут, который возвращает имя функции.


 Результаты хронометража
Когда я запустил сценарий из предыдущего раздела в Windows Vista
на своем ноутбуке, где установлен Python 3.0, я обнаружил,
что функция map оказалась немного быстрее, чем генератор списков;
оба они оказались существенно быстрее эквивалентной инструкции
цикла for, а функция-генератор и выражение-генератор заняли
промежуточное положение:

C:\misc> c:\python30\python timeseqs.py
3.0.1 (r301:69561, Feb 13 2009, 20:04:18) [MSC v.1500 32 bit (Intel)]
---------------------------------
forLoop : 2.64441 => [0...9999]
---------------------------------
listComp : 1.60110 => [0...9999]
---------------------------------
mapCall : 1.41977 => [0...9999]
---------------------------------
genExpr : 2.21758 => [0...9999]
---------------------------------
genFunc : 2.18696 => [0...9999]

 Если внимательно изучить программный код и полученные результаты,
можно заметить, что выражения-генераторы выполняются медленнее, чем
генераторы списков. Несмотря на то что обертывание выражения-генератора
в вызов функции list превращает его в функциональный эквивалент 
генератора списка в квадратных скобках, тем не менее результаты
показывают, что внутренние реализации этих двух видов выражений 
отличаются (даже если учесть время, затрачиваемое на вызов функции list
в тесте производительности выражения-генератора):

return [abs(x) for x in range(size)]    # 1.6 секунды
return list(abs(x) for x in range(size)) 
# 2.2 секунды: качественно отличаются

 Интересно отметить, что когда я запускал этот сценарий в Windows XP, 
где установлен Python 2.5, при подготовке предыдущего издания книги, 
были получены похожие результаты – генератор списков оказался почти 
в два раза быстрее эквивалентного цикла for, а функция map оказалась 
немного быстрее генератора списков при отображении встроенной функции 
abs (возвращает абсолютное значение). Тогда я не тестировал 
функцию-генератор и формат вывода результатов был не такой симпатичный:

2.5 (r25:51908, Sep 19 2006, 09:52:17) [MSC v.1310 32 bit (Intel)]
forStatement => 6.10899996758
listComprehension => 3.51499986649
mapFunction => 2.73399996758
generatorExpression => 4.11600017548

 То обстоятельство, что по результатам хронометража тесты 
под управлением Python 2.5 выполняются более чем в два раза медленнее,
обусловлено тем, что более свежие тесты я выполнял на более быстром
ноутбуке, а вовсе не улучшениями производительности в Python 3.0. 
В действительности, производительность тестов в версии 2.6 на том же
самом компьютере оказывается чуть выше, чем в версии 3.0, если из теста 
функции map убрать вызов функции list, чтобы избежать двойного создания
списка с результатами (попробуйте сами выполнить тестирование, 
чтобы проверить правоту моих слов).

 Но вот как изменилось положение дел, когда сценарий был изменен так,
чтобы он выполнял настоящую операцию, такую как сложение, вместо вызова
тривиальной встроенной функции abs (опущенные части сценария остались 
без изменений):
"""


def forLoop():
    res = []
    for x in repslist:
        res.append(x + 10)
    return res


def listComp():
    return [x + 10 for x in repslist]


def mapCall():
    return list(map((lambda x: x + 10), repslist))  # Вызов list
#                                                 необходим только в 3.0


def genExpr():
    return list(x + 10 for x in repslist)  # Вызов list необходим
    #                                        в 2.6 + 3.0


def genFunc():
    def gen():
        for x in repslist:
            yield x + 10
    return list(gen())


print(sys.version)
for test in (forLoop, listComp, mapCall, genExpr, genFunc):
    elapsed, result = timer(test)
    print('-' * 33)
    print(' %-9s: %.5f = > [%s... %s]' %
          (test.__name__, elapsed, result[0], result[-1]))

"""
 Теперь присутствие вызова пользовательской функции сделало вызов map
более медленным, чем цикл for, несмотря на то, что инструкция цикла 
содержит больше программного кода. В Python 3.0:

C:\misc> c:\python30\python timeseqs.py
3.0.1 (r301:69561, Feb 13 2009, 20:04:18) [MSC v.1500 32 bit (Intel)]
---------------------------------
forLoop : 2.60754 => [10...10009]
---------------------------------
listComp : 1.57585 => [10...10009]
---------------------------------
mapCall : 3.10276 => [10...10009]
---------------------------------
genExpr : 1.96482 => [10...10009]
---------------------------------
genFunc : 1.95340 => [10...10009]

 Результаты, полученные в Python 2.5 на более медленном компьютере
при подготовке предыдущего издания, демонстрируют ту же тенденцию,
хотя производительность и оказывается в два раза ниже, что обусловлено
различиями в быстродействии компьютеров, на которых выполнялось 
тестирование:

2.5 (r25:51908, Sep 19 2006, 09:52:17) [MSC v.1310 32 bit (Intel)]
forStatement => 5.25699996948
listComprehension => 2.68400001526
mapFunction => 5.96900010109
generatorExpression => 3.37400007248

 Так как внутренние механизмы интерпретатора сильно оптимизированы,
анализ производительности, как в данном случае, становится очень 
непростым делом. В действительности невозможно заранее утверждать, 
какой метод лучше, – лучшее, что можно сделать, это провести хронометраж
своего программного кода, на своем компьютере, со своей версией Python.
В этом случае все, что можно сказать наверняка, – это то, 
что в данной версии Python использование пользовательской функции 
в вызове map может привести к снижению производительности
по крайней мере в 2 раза, и что в этом испытании генератор списков
оказался самым быстрым.

 Однако, как уже говорилось ранее, производительность не должна быть 
главной целью при создании программ на языке Python. Первый шаг на пути
к оптимизации программ на языке Python – это отказаться от всякой 
оптимизации! Основное внимание должно уделяться удобочитаемости 
и простоте программного кода, и только потом код можно будет 
оптимизировать, если это действительно необходимо. Вполне возможно, 
что все пять вариантов обладают достаточной скоростью обработки
имеющихся наборов данных, – в этом случае основной целью должна быть 
ясность программного кода.


 Альтернативные реализации модуля хронометража
 
 Модуль хронометража из предыдущего раздела вполне работоспособен, 
но в некоторых отношениях он слишком примитивен:

  В нем всегда используется функция time.clock. В операционной системе
 Windows она является лучшим выбором, однако на некоторых платформах
 в системе UNIX более высокую точность можно получить с помощью функции 
 time.time.
 
  Для изменения количества повторений требуется изменять глобальную
 переменную модуля – не самое идеальное решение, если функция timer 
 импортируется и одновременно используется в нескольких модулях.
 
  Функция timer выполняет тестовую функцию большое число раз. Чтобы
 учесть случайные флуктуации, вызванные различными уровнями нагрузки 
 на систему, можно было бы отбирать наилучшие результаты из серии
 тестов вместо того, чтобы рассчитывать общее время выполнения.
 
 Ниже приводится более сложная, альтернативная реализация модуля 
mytimer, в которой учтены все три пожелания: производится выбор функции
определения времени в зависимости от платформы, счетчик повторений
передается функции timer в виде именованного аргумента _reps 
и дополнительно предоставляется функция хронометража, возвращающая 
лучший результат из серии по N испытаниям:
"""

"""
timer(spam, 1, 2, a=3, b=4, _reps=1000) вызывает и измеряет время работы 
функции spam(1, 2, a=3) _reps раз, и возвращает общее время, затраченное
на все вызовы, с результатом вызова испытуемой функции;

best(spam, 1, 2, a=3, b=4, _reps=50) многократно вызывает функцию 
timer, чтобы исключить влияние флуктуаций в нагрузке на систему, 
и возвращает  лучший результат из серии по _reps испытаниям
"""

timefunc = time.time


def trace(*args): pass                      # Заглушка: вывод аргументов


def timer(func, *pargs, **kargs):
    _reps = kargs.pop('_reps', 1000)         # Полученное число повторов
    #                                          или значение по умолчанию

    trace(func, pargs, kargs, _reps)
    repslist = range(_reps)             # Вызов range вынесен за пределы
    #                                     цикла for для версии 2.6

    start = timefunc()
    for _ in repslist:
        ret = func(*pargs, **kargs)
        
    elapsed = timefunc() - start
    return elapsed, ret


def best(func, *pargs, **kargs):
    _reps = kargs.pop('_reps', 50)
    best = 2 ** 32
    for i in range(_reps):
        time1, ret = timer(func, *pargs, _reps=1, **kargs)
        if time1 < best:
            best = time1
        
    return best, ret


"""
 Строка документирования в самом начале модуля описывает порядок его 
использования. Здесь используется метод pop словарей, чтобы удалить 
аргумент _reps из списка аргументов, предназначенных для испытуемой
функции, и подставить значение по умолчанию в случае необходимости.
Кроме того, модуль позволяет выводить значения аргументов на этапе 
отладки, для чего достаточно заменить вызов функции trace вызовом 
функции print. Чтобы проверить работу нового модуля в Python� 3.0 
или 2.6, измените тестовый сценарий, как показано ниже (опущенный 
программный код в функциях остался таким же, как в предыдущей версии, 
где в каждом испытании используется операция x + 1):
"""

reps = 10000
repslist = range(reps)

print(sys.version)
for tester in (timer, best):
    print('<%s>' % tester.__name__)
    for test in (forLoop, listComp, mapCall, genExpr, genFunc):
        elapsed, result = tester(test)
        print('-' * 35)
        print('%-9s: %.5f => [%s...%s]' %
              (test.__name__, elapsed, result[0], result[-1]))

"""
 При запуске сценария в Python 3.0 результаты хронометража остались 
практически такими же. И относительно такими же – при выявлении 
наилучших показателей. Многократный запуск тестирования, похоже, 
позволяет отфильтровывать флуктуации, вызванные изменением нагрузки
на систему, так же хорошо, как и прием выбора лучшего значения из серии,
однако последний лучше подходит для тестирования функций 
с продолжительным временем работы. На моем компьютере были получены
следующие результаты:

C:\misc> c:\python30\python timeseqs.py
3.0.1 (r301:69561, Feb 13 2009, 20:04:18) [MSC v.1500 32 bit (Intel)]
<timer>
-----------------------------------
forLoop : 2.35371 => [10...10009]
-----------------------------------
listComp : 1.29640 => [10...10009]
-----------------------------------
mapCall : 3.16556 => [10...10009]
-----------------------------------
genExpr : 1.97440 => [10...10009]
-----------------------------------
genFunc : 1.95072 => [10...10009]
<best>
-----------------------------------
forLoop : 0.00193 => [10...10009]
-----------------------------------
listComp : 0.00124 => [10...10009]
-----------------------------------
mapCall : 0.00268 => [10...10009]
-----------------------------------
genExpr : 0.00164 => [10...10009]
-----------------------------------
genFunc : 0.00165 => [10...10009]

 Значения времени, которые вернула функция best, оказались очень 
маленькими, но они могут существенно возрасти при тестировании 
программы, которая выполняет множество итераций по большим массивам
данных. В большинстве случаев, по крайней мере в смысле относительной 
производительности, генераторы списков показывают наилучшую 
производительность – функция map оказывается чуть быстрее лишь 
при использовании встроенных функций.


 Использование аргументов, которые могут передаваться только по именам
 
 Чтобы упростить реализацию модуля mytimer, мы можем также использовать
аргументы, которые могут передаваться только по именам, появившиеся
в Python 3.0. Как мы узнали в главе 19, аргументы, которые могут 
передаваться только по именам, идеально подходят для передачи параметров 
настройки, таких как аргумент _reps. Они должны указываться в заголовках
функций после формы представления аргументов * и перед формой **, 
а в вызовах функций они должны передаваться в виде именованных
аргументов и указываться перед формой **, если она используется. 
Ниже приводится альтернативная версия предыдущего модуля, 
где используются аргументы, которые могут передаваться только по именам.
Реализация модуля стала выглядеть проще, но теперь он может работать 
только под управлением Python 3.X:

“””
Вместо формы ** и метода pop словарей используются аргументы,
которые могут передаваться только по именам, появившиеся в версии 3.0.
В версии 3.0 нет необходимости выносить вызов range() за пределы цикла, 
так как эта функция возвращает генератор, а не список
“””
"""

trace = lambda *args: None  # or print
timefunc = time.time


def timer(func, *pargs, _reps=1000, **kargs):
    trace(func, pargs, kargs, _reps)
    start = timefunc()
    for _ in range(_reps):
        ret = func(*pargs, **kargs)
        
    elapsed = timefunc() - start
    return elapsed, ret


def best(func, *pargs, _reps=50, **kargs):
    best = 2 ** 32
    for i in range(_reps):
        time1, ret = timer(func, *pargs, _reps=1, **kargs)
        if time1 < best:
            best = time1
            
    return best, ret


"""
 Эта версия модуля используется точно так же и возвращает результаты, 
идентичные предыдущей версии, не считая незначительных расхождений,
характерных для разных испытательных серий:

C:\misc> c:\python30\python timeseqs.py
...результаты те же, что и прежде...

 Для разнообразия мы можем также опробовать данную версию модуля 
в интерактивном сеансе. Это универсальный инструмент – он никак 
не зависит от сценария хронометража:
"""


def power(X, Y): return X ** Y  # Испытуемая функция


print(timer(power, 2, 32))  # Общее время, последний результат

print(timer(power, 2, 32, _reps=1000000))  # Переопределить количество
#                                            повторов

print(timer(power, 2, 100000)[0])  # 2 ** 100000: общее время
#                                    для 1000 повторов

print(best(power, 2, 32))  # Лучшее время, последний результат

print(best(power, 2, 100000)[0])  # 2 ** 100000: лучшее время

print(best(power, 2, 100000, _reps=500)[0])  # Переопределить количество
#                                             повторов

"""
 Для таких тривиальных функций, как та, что использовалась 
в этом интерактивном сеансе, затраты времени на выполнение программного
кода хронометража, вероятно, сопоставимы с затратами на выполнение самой 
испытуемой функции, поэтому не следует рассматривать результаты,
как некоторый абсолютный показатель (здесь мы измеряли не только 
производительность операции X ** Y). Результаты хронометража смогут
помочь вам судить об относительной производительности альтернативных
решений и могут оказаться более осмысленными при тестировании длительных
операций, таких как показано ниже, – операция возведения числа 2 
в степень 1000000 выполняется на порядок (в 10 раз) дольше, 
чем предыдущая операция 2**100000:

>>> timer(power, 2, 1000000, _reps=1)[0]  # 2 ** 1000000: общее время
0.088112804839710179
>>> timer(power, 2, 1000000, _reps=10)[0]
0.40922470593329763
>>> best(power, 2, 1000000, _reps=1)[0]  # 2 ** 1000000: лучшее время
0.086550036387279761
>>> best(power, 2, 1000000, _reps=10)[0]  # Иногда 10 ничуть не хуже 50
0.029616752967200455
>>> best(power, 2, 1000000, _reps=50)[0]  # Лучшее разрешение
0.029486918030102061

 Напомню еще раз: хотя здесь получаются достаточно маленькие времена, 
они могут увеличиваться существенно в программах, часто вычисляющих 
степень числа.


 Типичные ошибки при работе с функциями
 
 Теперь, когда мы закончили изучение функций, рассмотрим некоторые
наиболее распространенные ошибки. При работе с функциями вас поджидают
подводные камни, о которых вы можете не догадываться. Они не всегда
видны, некоторые из них исчезли в последних версиях, но большая часть 
оставшихся продолжает ставить в тупик начинающих программистов.


 Локальные имена определяются статически
 
 Как известно, имена, которым выполняется присваивание внутри функции,
по умолчанию рассматриваются как локальные – они располагаются в области
видимости функции и существуют только во время работы функции. Но я еще
не говорил, что локальные переменные определяются статически, во время
компиляции программного кода в инструкции def, а не в соответствии 
с операциями присваивания, производимыми во время выполнения. 
Эта особенность становится причиной появления самых причудливых 
сообщений в группе новостей, получаемых от начинающих программистов.

 Обычно, если внутри функции имени не присваивается какое-либо значение,
поиск его будет производиться в области видимости объемлющего модуля:

>>> X = 99
>>> def selector(): # Переменная X используется, но ей ничего 
...     print(X)  # Переменная X будет найдена          не присваивается
...               # в глобальной области вид-ти
>>> selector()
99

 В этом фрагменте переменная X внутри функции определяется 
как переменная X модуля. Но посмотрите, что произойдет, если добавить
инструкцию присваивания переменной X после ее использования:

>>> def selector():
...     print(X)  # Переменная еще не существует!
...     X = 88  # X классифицируется как локальная переменная
...     # То же самое происходит при “import X”, “def X”...
>>> selector()
Traceback (most recent call last):
...текст сообщения об ошибке опущен...
UnboundLocalError: local variable ‘X’ referenced before assignment

 Было получено сообщение о том, что переменная не определена, 
но причина его появления не очевидна. Этот программный код компилируется
интерпретатором во время ввода в интерактивной оболочке или во время
импорта модуля. Во время компиляции Python обнаруживает операцию 
присваивания переменной X и делает вывод, что X – это локальное имя 
везде в теле функции. Но во время выполнения функции, из-за того,
что к моменту вызова инструкции print операция присваивания еще 
не производилась, интерпретатор сообщает о том, что имя не определено.
Согласно этому правилу использования имен, он говорит, что обращение
к локальной переменной X произведено до того, как ей было присвоено 
значение. Фактически любая операция присваивания внутри функции создает
локальное имя. Операция импортирования, =, вложенные инструкции def,
вложенные определения классов и так далее – все трактуются именно 
таким образом.

 Проблема возникает из-за того, что операция присваивания делает имена 
локальными для всей функции, а не только для той ее части, которая 
следует за инструкцией присваивания. На самом деле предыдущий пример 
далеко неоднозначен: что имелось в виду – требовалось вывести глобальную 
переменную X и затем создать локальную переменную или это просто ошибка 
программиста? Так как Python интерпретирует имя X как локальное во всей
функции, то это ошибка – если вы действительно хотите вывести значение
глобальной переменной X, объявите ее глобальной с помощью инструкции
global:

>>> def selector():
...     global X # Принудительное объявление X глобальным (везде)
...     print(X)
...     X = 88
...
>>> selector()
99

 При этом следует помнить, что в этом случае операция присваивания
изменит глобальную переменную X, а не локальную. Внутри функции можно
использовать как локальную, так и глобальную версии одного и того же
имени. Если вы действительно предполагаете вывести значение глобальной
переменной, а затем присвоить значение локальной версии того же самого 
имени, импортируйте вмещающий модуль и обращайтесь к глобальной 
переменной как к атрибуту модуля:

>>> X = 99
>>> def selector():
...     import __main__  # Импортировать вмещающий модуль
...     print(__main__.X)  # Квалифицированное обращение к глобальной
                             версии имени
...     X = 88  # Неквалифицированное локальное имя X
...     print(X)  # Вывести локальную версию имени
...
>>> selector()
99
88

 Обращение по квалифицированному имени (часть .X) приводит к извлечению
значения из пространства имен объекта. Пространством имен интерактивной
оболочки является модуль с именем __main__, поэтому при обращении
по имени __main__.X извлекается глобальная версия X. Если что-то вам 
показалось непонятным, прочитайте главу 17.

 Положение дел с локальными переменными в последних версиях Python 
несколько улучшилось, потому что в данном случае выводится более 
определенное сообщение об ошибке «обращение к локальной переменной
до присваивания», которое показано в листинге примера (теперь 
оно используется вместо более расплывчатого сообщения об ошибке, 
связанной с именем), впрочем, этот вид ошибки все еще встречается.


 Значения по умолчанию и изменяемые объекты
 
 Значения по умолчанию для аргументов функции вычисляются и запоминаются
в момент выполнения инструкции def, а не при вызове функции. Внутренняя
реализация Python сохраняет по одному объекту для каждого аргумента
со значением по умолчанию, присоединенного к функции.

 Вычисление значений по умолчанию в момент определения функции – 
это чаще именно то, что вам требуется; это позволяет, в случае 
необходимости, сохранять значения из объемлющей области видимости. 
Но так как значения по умолчанию сохраняются между вызовами функции, 
следует быть внимательным при воздействии на изменяемые значения 
по умолчанию. Например, следующая функция использует пустой список 
в качестве значения по умолчанию своего аргумента, а затем изменяет его 
при каждом вызове:

>>> def saver(x=[]):  # Объект списка сохраняется
...     x.append(1)  # При каждом вызове изменяется один 
...     print(x)     # и тот же объект!
...
>>> saver([2])  # Значение по умолчанию не используется
[2, 1]
>>> saver()  # Используется значение по умолчанию
[1]
>>> saver()  # Список растет при каждом вызове!
[1, 1]
>>> saver()
[1, 1, 1]

 Некоторые воспринимают такое поведение как достоинство – изменяемые 
аргументы по умолчанию сохраняют свое состояние между вызовами функции,
поэтому они могут играть роль, подобную роли статических локальных 
переменных в языке C. В некотором смысле они ведут себя как глобальные 
переменные за исключением того, что их имена являются локальными 
по отношению к функциям, вследствие чего исключается конфликт имен 
с переменными, определенными в другом месте.

 Для большинства же это выглядит как недостаток, особенно для тех,
кто впервые сталкивается с этой особенностью. В языке Python существует 
лучший способ сохранения состояния между вызовами функций (например, 
за счет использования классов, которые будут рассматриваться в шестой 
части книги). Кроме того, такое поведение аргументов по умолчанию сложно 
запомнить (и вообще понять). Они могут изменяться с течением времени.
В предыдущем примере для значения по умолчанию существует единственный 
объект списка – тот, что был создан в момент выполнения инструкции def. 
При каждом обращении к функции не будет создаваться новый список,
поэтому он будет расти с каждым новым вызовом – он не опустошается
при каждом вызове.

 Если такое поведение является неприемлемым, можно просто создавать 
копию аргумента по умолчанию в начале тела функции или переместить 
выражение, возвращающее значение по умолчанию, в тело функции. Поскольку
в этом случае значение по умолчанию будет находиться в программном коде,
который выполняется при каждом вызове функции, вы всякий раз будете 
получать новый объект:

>>> def saver(x=None):
...     if x is None:  # Аргумент отсутствует?
...         x = []  # Создать новый список
...     x.append(1)  # Изменить объект списка
...     print(x)
...
>>> saver([2])
[2, 1]
>>> saver()  # Список больше не растет
[1]
>>> saver()
[1]

 Между прочим, инструкцию if в этом примере в большинстве случаев можно
было бы заменить выражением x = x or [], где используется тот факт,
что оператор or в языке Python возвращает один из двух объектов: если 
аргумент отсутствует, имя x получит значение по умолчанию None, 
и тогда оператор or вернет новый пустой список справа от него.

 Однако это не совсем одно и то же. Если функции будет передан пустой 
список, оператор вернет вновь созданный список вместо полученного 
в аргументе, как это делает инструкция if. (Выражение примет вид
[] or [], которое возвращает новый пустой список справа, – вернитесь 
к разделу «Проверка истинности» в главе 12, если вам не понятно, почему
так происходит.) В разных программах могут предъявляться разные 
требования к такому поведению.

 На сегодняшний день имеется еще один, менее запутанный, способ 
получения изменяемых значений по умолчанию, который заключается 
в использовании атрибутов функций, о которых рассказывается в главе 19:

>>> def saver():
...     saver.x.append(1)
...     print(saver.x)
...
>>> saver.x = []
>>> saver()
[1]
>>> saver()
[1, 1]
>>> saver()
[1, 1, 1]

 Имя функции является глобальным для самой функции, но объявлять 
его глобальным внутри функции не требуется, так как мы фактически 
не изменяем его внутри функции. Такой прием использования атрибутов,
присоединенных к объекту функции, оказывается более явным (и, вероятно,
менее таинственным).


 Функции, не возвращающие результат
 
 В языке Python функции могут не иметь инструкцию return (или yield).
Когда функция не возвращает управление явно, выход из нее происходит,
когда поток управления достигает конца тела функции. С технической точки
зрения все функции возвращают некоторое значение – в отсутствие 
инструкции return функция автоматически возвращает объект None:

>>> def proc(x):
...     print(x)  # Нет возвращаемого значения, возвращается None
...
>>> x = proc(‘testing 123...’)
testing 123...
>>> print(x)
None

 Такие функции, как эта, не имеющие инструкции return, представляют
собой эквивалент того, что в других языках программирования называется 
«процедурами». Как правило, они вызываются как инструкции, 
а возвращаемое значение None игнорируется, поскольку они выполняют 
свою работу, не вычисляя результат.

 Об этом следует помнить, потому что интерпретатор ничего не сообщит 
вам, если вы попытаетесь присвоить результат функции, которая ничего 
не возвращает. Например, присваивание результата метода списков append 
не вызывает появление ошибки, но при этом вы получите объект None, 
а не обновленный список:

>>> list = [1, 2, 3]
>>> list = list.append(4)  # метод append – это “процедура”
>>> print(list)  # метод append изменяет сам список
None

 Как упоминалось в разделе «Типичные ошибки программирования»
в главе 15, действие таких функций проявляется как побочный эффект, 
и они обычно вызываются как инструкции, а не как выражения.


 Переменные цикла в объемлющей области видимости
 
 Эта ошибка была описана в главе 17, когда мы рассматривали области 
видимости объемлющих функций, однако напомню еще раз: будьте внимательны 
при использовании переменных в области видимости объемлющей функции, 
которые изменяются объемлющим циклом, – все ссылки на эту переменную 
будут запоминать значение, которое будет иметь переменная в последней
итерации цикла. Чтобы сохранить значения переменной цикла в каждой 
итерации, используйте аргументы со значениями по умолчанию
(дополнительные сведения по этой теме вы найдете в главе 17).
"""

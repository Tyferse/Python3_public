"""
 Примеры использования именованных аргументов и значений по умолчанию

 Предыдущие пояснения в программном коде выглядят гораздо проще. Если
не используются какие-то специальные формы сопоставления, по умолчанию
сопоставление значений и имен аргументов производится по позиции, слева
направо, как и в большинстве других языков. Например, если определена
функция, которая требует передачи трех аргументов, она должна вызываться
с тремя аргументами:

\>>> def f(a, b, c): print(a, b, c)
...

 Здесь значения передаются по позиции – имени a соответствует
значение 1, имени b соответствует значение 2 и так далее (этот пример
будет работать в обеих версиях Python, 3.0 и 2.6, только в Python 2.6
в выводе появятся лишние круглые скобки, так как в этой версии вызов
функции print интерпретируется как вывод кортежа):

\>>> f(1, 2, 3)
1 2 3

 Именованные аргументы

 В языке Python существует возможность явно определить соответствия
между значениями и именами аргументов при вызове функции. Именованные
аргументы позволяют определять соответствие по именам, а не по позициям:

\>>> f(c=3, b=2, a=1)
1 2 3

 В этом вызове c=3, например, означает, что значение 3 передается
функции в аргументе с именем c. Говоря более формальным языком,
интерпретатор сопоставляет имя с в вызове функции с именем аргумента с
в заголовке определения функции и затем передает значение 3 в этот
аргумент. Результат этого вызова ничем не будет отличаться
от предыдущего. Обратите внимание, что при использовании именованных
аргументов порядок их следования не имеет никакого значения, потому что
сопоставление производится по именам, а не по позициям. Существует даже
возможность объединять передачу аргументов по позициям и по именам
в одном вызове. В этом случае сначала будут сопоставлены все позиционные
аргументы, слева направо, а потом будет выполнено сопоставление
именованных аргументов:

\>>> f(1, c=3, b=2)
1 2 3

 Большинство из тех, кто впервые сталкивается с такой возможностью,
задаются вопросом: где такая возможность может пригодиться? Именованные
аргументы в языке Python обычно играют две роли. Во-первых, они делают
вызовы функций более описательными (представьте, что вы используете
имена аргументов более осмысленные, чем простые a, b и c). Например,
такой вызов:

func(name=’Bob’, age=40, job=’dev’)

 несет больше смысла, чем вызов с тремя простыми значениями,
разделенными запятыми, – имена аргументов играют роль меток для данных,
участвующих в вызове. Во-вторых, именованные аргументы используются
вместе со значениями по умолчанию, о которых мы поговорим далее.


 Значения по умолчанию

 О значениях по умолчанию мы немного говорили ранее, когда обсуждали
области видимости вложенных функций. Если коротко, значения по умолчанию
позволяют сделать отдельные аргументы функции необязательными, если
значение не передается при вызове, аргумент получит значение
по умолчанию перед тем как будет запущено тело функции. Например, ниже
приводится функция, в которой один аргумент является обязательным,
а два имеют значения по умолчанию:

\>>> def f(a, b=2, c=3): print a, b, c
...

 При вызове такой функции мы обязаны передать значение для аргумента a,
по позиции или по имени, а значения для аргументов b и с можно опустить.
Если значения аргументов b и c будут опущены, они примут значения
по умолчанию 2 и 3 соответственно:

\>>> f(1)
1 2 3
\>>> f(a=1)
1 2 3

 Если функции передать только два значения, аргумент с примет значение
по умолчанию, а если три – ни одно из значений по умолчанию не будет
использовано:

\>>> f(1, 4)
1 4 3
\>>> f(1, 4, 5)
1 4 5

 Наконец, ниже приводится пример взаимодействия режимов передачи
значений по именам и по умолчанию. Поскольку именованные аргументы могут
нарушать обычный порядок следования аргументов слева направо, они,
по сути, позволяют «перепрыгивать» через аргументы со значениями
по умолчанию:

\>>> f(1, c=6)
1 2 6

 Здесь значение 1 будет сопоставлено с аргументом по позиции, аргумент c
получит значение 6, а аргумент b, в середине, – значение по умолчанию 2.
Не путайте синтаксические конструкции name=value в заголовке функции
и в вызове функции – в вызове она означает использование
режима сопоставления значения с именованным аргументом, а в заголовке
определяет значение по умолчанию для необязательного аргумента.
В обоих случаях это не инструкция присваивания –
это особая синтаксическая конструкция для этих двух случаев,
которая модифицирует механику сопоставления значений
с именами аргументов, используемую по умолчанию.


 Комбинирование именованных аргументов и значений по умолчанию

 Ниже приводится немного больший по объему пример, демонстрирующий
использование именованных аргументов и аргументов со значениями
по умолчанию. В этом примере вызывающая программа всегда должна
передавать функции как минимум два аргумента (spam и eggs), два других
аргумента являются необязательными. В случае их отсутствия интерпретатор
присвоит именам toast и ham значения по умолчанию, указанные
в заголовке:

def func(spam, eggs, toast=0, ham=0):  # Первые 2 являются обязательными
    print(spam, eggs, toast, ham)

func(1, 2)                                       # Выведет: (1, 2, 0, 0)
func(1, ham=1, eggs=0)                           # Выведет: (1, 0, 0, 1)
func(spam=1, eggs=0)                             # Выведет: (1, 0, 0, 0)
func(toast=1, eggs=2, spam=3)                    # Выведет: (3, 2, 1, 0)
func(1, 2, 3, 4)                                 # Выведет: (1, 2, 3, 4)

 Обратите внимание еще раз: когда в вызовах используются именованные
аргументы, порядок их следования не имеет значения, потому что
сопоставление выполняется по именам, а не по позициям. Вызывающая
программа обязана передать значения для аргументов spam и eggs,
а сопоставление может выполняться как по позиции, так и по именам.
Обратите также внимание на то, что форма name=value имеет разный смысл
в вызове функции и в инструкции def (именованный аргумент – в вызове
и значение по умолчанию – в заголовке).


 Примеры произвольного числа аргументов

 Последние два расширения * и ** механизма сопоставления аргументов
и их значений предназначены для поддержки возможности передачи
произвольного числа аргументов функциям. Оба варианта могут появляться
как в определениях функций, так и в их вызовах, и в обоих случаях они
имеют сходные назначения.


 Сбор аргументов в коллекцию

 В первом случае, в определении функции, выполняется сборка лишних
позиционных аргументов в кортеж:

\>>> def f(*args): print(args)
...

 При вызове этой функции интерпретатор Python соберет все позиционные
аргументы в новый кортеж и присвоит этот кортеж переменной args.
Это будет обычный объект кортежа, поэтому из него можно извлекать
элементы по индексам, выполнять обход в цикле for и так далее:

\>>> f()
()
\>>> f(1)
(1,)
\>>> f(1,2,3,4)
(1, 2, 3, 4)

 Комбинация ** дает похожий результат, но применяется при передаче
именованных аргументов – в этом случае аргументы будут собраны в новый
словарь, который можно обрабатывать обычными инструментами,
предназначенными для работы со словарями. В определенном смысле форма **
позволяет преобразовать аргументы, передаваемые по именам, в словари,
которые можно будет обойти с помощью метода keys, итераторов словарей
и так далее:

\>>> def f(**args): print(args)
...
\>>> f()
{}
\>>> f(a=1, b=2)
{‘a’: 1, ‘b’: 2}

 Наконец, в заголовках функций можно комбинировать обычные аргументы,
* и ** для реализации чрезвычайно гибких сигнатур вызова. Например,
в следующем фрагменте число 1 передается как позиционный аргумент,
2 и 3 объединяются в кортеж pargs с позиционными аргументами, а x и y
помещаются в словарь kargs с именованными аргументами:

\>>> def f(a, *pargs, **kargs): print(a, pargs, kargs)
...
\>>> f(1, 2, 3, x=1, y=2)
1 (2, 3) {‘y’: 2, ‘x’: 1}

 Фактически все эти формы передачи аргументов можно объединять в еще
более сложные комбинации, которые на первый взгляд могут показаться
неоднозначными, – к этой идее мы еще вернемся ниже, в этой главе.
А сейчас посмотрим, как используются формы * и ** в вызовах функций.


 Извлечение аргументов из коллекции

 В последних версиях Python форму * можно также использовать в вызовах
функций. В этом случае данная форма передачи аргументов имеет
противоположный смысл по сравнению с применением этой формы
в определениях функций – она распаковывает, а не создает коллекцию
аргументов. Например, можно передать в функцию четыре аргумента в виде
кортежа и позволить интерпретатору распаковать их в отдельные аргументы:

\>>> def func(a, b, c, d): print(a, b, c, d)
...
\>>> args = (1, 2)
\>>> args += (3, 4)
\>>> func(*args)
1 2 3 4

 Точно так же форма ** в вызовах функций распаковывает словари пар
ключ/значение в отдельные аргументы, которые передаются по ключу:

\>>> args = {‘a’: 1, ‘b’: 2, ‘c’: 3}
\>>> args[‘d’] = 4
\>>> func(**args)
1 2 3 4

 Здесь также можно очень гибко комбинировать в одном вызове обычные
позиционные и именованные аргументы:

\>>> func(*(1, 2), **{‘d’: 4, ‘c’: 4})
1 2 4 4
\>>> func(1, *(2, 3), **{‘d’: 4})
1 2 3 4
\>>> func(1, c=3, *(2,), **{‘d’: 4})
1 2 3 4
\>>> func(1, *(2, 3), d=4)
1 2 3 4
\>>> f(1, *(2,), c=3, **{‘d’:4})
1 2 3 4

 Такого рода программный код удобно использовать, когда заранее
невозможно предсказать число аргументов, которые могут быть переданы
функции вы можете собирать коллекцию аргументов во время исполнения
и вызывать функцию таким способом. Не путайте синтаксические конструкции
*/** в заголовках функций и в их вызовах – в заголовке они означают сбор
всех лишних аргументов в коллекцию, а в вызове выполняют распаковку
коллекций в отдельные аргументы.

 Как мы видели в главе 14, форма *pargs в вызовах функций является одной
из разновидностей итерационного контекста, поэтому с технической точки
зрения в таком виде допускается передавать не только кортежи
или последовательности других типов, но и любые итерируемые объекты,
как показано в этих примерах. Например, после символа * можно передать
объект файла, и он будет распакован в отдельные аргументы (например,
func(*open(‘fname’))).

 Это обобщение поддерживается в обеих версиях Python, 3.0 и 2.6, но она
действует исключительно в вызовах функций – в форме *pargs в вызовах
функций можно передавать любые итерируемые объекты – та же самая форма
в заголовке инструкции def всегда объединяет лишние позиционные
аргументы в кортеж. Такое поведение формы со звездочкой напоминает
синтаксис расширенной операции * распаковывания последовательностей
в Python 3, с которой мы встречались в главе 11 (например, x, *y = z),
только эта конструкция всегда создает списки, а не кортежи.


 Обобщенные способы вызова функций

 Примеры в предыдущем разделе могут показаться чересчур простыми,
но они демонстрируют способы использования функций, которые на практике
применяются гораздо чаще, чем можно было бы подумать. В программе может
потребоваться вызывать произвольные функции единообразным способом,
не имея представления об их именах и аргументах. В действительности
истинное преимущество специального синтаксиса передачи переменного числа
аргументов («varargs») состоит в том, что он не требует от вас заранее
знать количество обязательных аргументов в функции. Например,
в программе можно использовать условную инструкцию if для выбора
из множества функций и списков аргументов и вызывать любую из них
единообразным способом:

if <test>:
    action, args = func1, (1,)        # Вызвать func1 с 1 аргументом
else:
    action, args = func2, (1, 2, 3)  # Вызвать func2 с 3 аргументами
...
action(*args)             # Фактический вызов универсальным способом

 В более общем случае синтаксис передачи произвольного числа аргументов
удобно использовать всегда, когда перечень аргументов не известен
заранее. Например, если пользователь выбирает функцию с помощью
пользовательского интерфейса, для вас может оказаться невозможным
записать явный вызов функции в программном коде. Чтобы решить
эту проблему, можно просто построить список аргументов с применением
операций над последовательностями и вызвать требуемую функцию,
воспользовавшись синтаксисом передачи произвольного числа аргументов:

\>>> args = (2,3)
\>>> args += (4,)
\>>> args
(2, 3, 4)
\>>> func(*args)

 Так как список аргументов передается функции в виде кортежа, программа
может создать его во время выполнения. Этот прием удобно использовать
в функциях, которые тестируют или измеряют производительность других
функций. Например, в следующем фрагменте мы реализовали поддержку вызова
произвольных функций с любым количеством любых аргументов, передавая
все аргументы, которые были получены:

def tracer(func, *pargs, **kargs):    # Принимает произвольные аргументы
    print(‘calling:’, func.__name__)
    return func(*pargs, **kargs)     # Передает все полученные аргументы

def func(a, b, c, d):
    return a + b + c + d

print(tracer(func, 1, 2, c=3, d=4))

 При вызове функции tracer все аргументы будут собраны в коллекции
и переданы требуемой функции с использованием синтаксиса передачи
произвольного количества аргументов:

calling: func
10


 Python 3.0: аргументы, которые могут передаваться только по именам

 В версии Python 3.0 были обобщены правила, определяющие порядок
следования разных видов аргументов в заголовках функций, что позволяет
нам определять аргументы, которые могут передаваться только в форме
именованных аргументов и никогда не будут заполняться значениями
позиционных аргументов. Эту особенность удобно использовать, когда
необходимо, чтобы функция могла принимать произвольное количество
аргументов, а также ряд дополнительных параметров настройки.

 Синтаксически аргументы, которые могут передаваться только в виде
именованных аргументов, оформляются в виде обычных именованных
аргументов, следующих за формой *args в списке аргументов. Все такие
аргументы могут передаваться в вызовы функций только по именам.
Например, в следующем фрагменте аргумент a может передаваться
как именованный или как позиционный аргумент, в b собираются все
дополнительные позиционные аргументы и аргумент c может передаваться
только как именованный аргумент:

\>>> def kwonly(a, *b, c):
...     print(a, b, c)
...
\>>> kwonly(1, 2, c=3)
1 (2,) 3
\>>> kwonly(a=1, c=3)
1 () 3
\>>> kwonly(1, 2, 3)
TypeError: kwonly() needs keyword-only argument c

 Чтобы показать, что функция не принимает списки аргументов произвольной
длины, можно использовать одиночный символ *, при этом она ожидает,
что все следующие за звездочкой аргументы будут передаваться по именам.
Следующей функции аргумент a можно передать как позиционный
или как именованный, но аргументы b и c могут передаваться только
как именованные аргументы; при этом функция не может принимать списки
аргументов произвольной длины:

\>>> def kwonly(a, *, b, c):
...     print(a, b, c)
...
\>>> kwonly(1, c=3, b=2)
1 2 3
\>>> kwonly(c=3, b=2, a=1)
1 2 3
\>>> kwonly(1, 2, 3)
TypeError: kwonly() takes exactly 1 positional argument (3 given)
\>>> kwonly(1)
TypeError: kwonly() needs keyword-only argument b

 Вы по-прежнему можете использовать значения по умолчанию
для аргументов, которые могут передаваться только в виде именованных,
несмотря на то, что в заголовке функции они располагаются
после символа *. Следующей функции аргумент a можно передать
как именованный или как позиционный, а аргументы b и c являются
необязательными, но передаваться должны только в виде именованных
аргументов:

\>>> def kwonly(a, *, b=’spam’, c=’ham’):
...     print(a, b, c)
...
\>>> kwonly(1)
1 spam ham
\>>> kwonly(1, c=3)
1 spam 3
\>>> kwonly(a=1)
1 spam ham
\>>> kwonly(c=3, b=2, a=1)
1 2 3
\>>> kwonly(1, 2)
TypeError: kwonly() takes exactly 1 positional argument (2 given)

 Аргументы со значениями по умолчанию, которые могут передаваться только
по именам, в действительности являются необязательными,
а те же самые аргументы без значений по умолчанию превращаются
в обязательные именованные аргументы:

\>>> def kwonly(a, *, b, c=’spam’):
...     print(a, b, c)
...
\>>> kwonly(1, b=’eggs’)
1 eggs spam
\>>> kwonly(1, c=’eggs’)
TypeError: kwonly() needs keyword-only argument b
\>>> kwonly(1, 2)
TypeError: kwonly() takes exactly 1 positional argument (2 given)

\>>> def kwonly(a, *, b=1, c, d=2):
...     print(a, b, c, d)
...
\>>> kwonly(3, c=4)
3 1 4 2
\>>> kwonly(3, c=4, b=5)
3 5 4 2
\>>> kwonly(3)
TypeError: kwonly() needs keyword-only argument c
\>>> kwonly(1, 2, 3)
TypeError: kwonly() takes exactly 1 positional argument (3 given)


 Правила, определяющие порядок следования

 Наконец, важно отметить, что аргументы, которые могут передаваться
только по именам, должны указываться после одиночного символа звездочки,
но не двойного; эти аргументы не могут располагаться после формы **args
представления списка именованных аргументов произвольной длины,
и пара символов ** без следующего за ними имени аргумента также не может
появляться в списке аргументов. В обоих случаях будет выведено сообщение
о синтаксической ошибке:

\>>> def kwonly(a, **pargs, b, c):
SyntaxError: invalid syntax
\>>> def kwonly(a, **, b, c):
SyntaxError: invalid syntax

 Это означает, что аргументы, которые могут передаваться только
по именам, в заголовке функции должны предшествовать форме **args
представления списка именованных аргументов произвольной длины
и следовать за формой *args представления списка позиционных аргументов
произвольной длины, когда присутствуют обе формы. Всякий раз, когда
именованный аргумент появляется перед формой *args, он интерпретируется
как позиционный аргумент со значением по умолчанию, но не как аргумент,
который может передаваться только по имени:

\>>> def f(a, *b, **d, c=6): print(a, b, c, d)  # Только именованные
SyntaxError: invalid syntax # должны предшествовать **!        аргументы
\>>> def f(a, *b, c=6, **d): print(a, b, c, d)  # Коллекции аргументов
...                                             # в заголовке
\>>> f(1, 2, 3, x=4, y=5)  # Используется значение по умолчанию
1 (2, 3) 6 {‘y’: 5, ‘x’: 4}
\>>> f(1, 2, 3, x=4, y=5, c=7)  # Переопределение значения по умолчанию
1 (2, 3) 7 {‘y’: 5, ‘x’: 4}
\>>> f(1, 2, 3, c=7, x=4, y=5)  # Среди именованных аргументов
1 (2, 3) 7 {‘y’: 5, ‘x’: 4}
\>>> def f(a, c=6, *b, **d): print(a, b, c, d)  # c не является только
...                                           # именованным аргументом!
\>>> f(1, 2, 3, x=4)
1 (3,) 2 {‘x’: 4}

 В вызовах функций используются похожие правила, определяющие порядок
следования аргументов: когда функции передаются аргументы, которые могут
быть только именованными, они должны располагаться перед формой **args.
При этом аргументы, которые могут передаваться только по именам, могут
располагаться как перед формой *args, так и после нее, а также могут
включаться в словарь **args:

\>>> def f(a, *b, c=6, **d): print(a, b, c, d)  # Только именованные
...                                             # аргументы между * и **
\>>> f(1, *(2, 3), **dict(x=4, y=5))  # Распаковывание аргументов
1 (2, 3) 6 {‘y’: 5, ‘x’: 4}           # при вызове
\>>> f(1, *(2, 3), **dict(x=4, y=5), c=7)  # Именованные аргументы
SyntaxError: invalid syntax # после **args!

\>>> f(1, *(2, 3), c=7, **dict(x=4, y=5))  # Переопределение значений
1 (2, 3) 7 {‘y’: 5, ‘x’: 4}                # по умолчанию

\>>> f(1, c=7, *(2, 3), **dict(x=4, y=5))  # Перед * или после нее
1 (2, 3) 7 {‘y’: 5, ‘x’: 4}

\>>> f(1, *(2, 3), **dict(x=4, y=5, c=7))  # Только именованные
1 (2, 3) 7 {‘y’: 5, ‘x’: 4}                # аргументы внутри **

 Изучите эти случаи самостоятельно и попробуйте сопоставить их
с описанными выше правилами, определяющими порядок следования
аргументов. Может показаться, что эти, достаточно искусственные, примеры
представляют наихудшие случаи, но они вполне могут возникнуть
на практике, особенно у тех, кто разрабатывает библиотеки и инструменты
на языке Python для других программистов.


 Когда используются аргументы,
которые могут передаваться только по именам?

 Итак, когда же бывает желательно использовать аргументы, которые могут
передаваться только по именам? Если говорить кратко, они упрощают
создание функций, которые принимают произвольное количество позиционных
аргументов и параметры настройки, передаваемые в виде именованных
аргументов. Аргументы, которые передаются только по именам,
можно и не использовать, но без их использования может потребоваться
выполнить лишнюю работу, чтобы определить значения по умолчанию
для таких параметров и проверять, что не было передано лишних
именованных аргументов. Представьте функцию, которая обрабатывает
множество передаваемых ей объектов и дополнительно принимает
флаг трассировки:

process(X, Y, Z)              # Используется значение флага по умолчанию
process(X, Y, notify=True)    # значение флага определяется явно

 Без использования аргумента, который может передаваться только
по имени, нам пришлось бы использовать обе формы, *args и **args,
и вручную проверять именованные аргументы, а благодаря аргументу,
который может передаваться только по имени, программный код получится
компактнее. Следующее определение функции гарантирует, что ни один
из позиционных аргументов не будет по ошибке сопоставлен с аргументом
notify, и требует, чтобы этот параметр передавался по имени:

def process(*args, notify=False): ...


 Функция поиска минимума

 Пришло время заняться чем-нибудь более практичным. Чтобы придать
обсуждению больше конкретики, выполним упражнение, которое демонстрирует
практическое применение механизмов сопоставления аргументов.

 Предположим, что вам необходимо написать функцию, которая способна
находить минимальное значение из произвольного множества аргументов
с произвольными типами данных. То есть функция должна принимать ноль
или более аргументов – столько, сколько вы пожелаете передать.
Более того, функция должна работать со всеми типами объектов, имеющимися
в языке Python: числами, строками, списками, списками словарей, файлами
и даже None.

 Первое требование представляет собой обычный пример того, как можно
найти применение форме *, – мы можем собирать аргументы в кортеж
и выполнять их обход с помощью простого цикла for. Второе требование
тоже не представляет никакой сложности: все типы объектов поддерживают
операцию сравнения, поэтому нам не требуется учитывать типы объектов
в функции (полиморфизм в действии) – мы можем просто слепо сравнивать
объекты и позволить интерпретатору самостоятельно выбрать корректную
операцию сравнения.


 Основное задание

 Ниже представлены три способа реализации этой функции, из которых
по крайней мере один был предложен студентом:

  Первая версия функции извлекает первый аргумент (args – это кортеж)
 и обходит остальную часть коллекции, отсекая первый элемент
 (нет никакого смысла сравнивать объект сам с собой, особенно если это
 довольно крупная структура данных).

  Вторая версия позволяет интерпретатору самому выбрать первый аргумент
 и остаток, благодаря чему отпадает необходимость извлекать первый
 аргумент и получать срез.

  Третья версия преобразует кортеж в список с помощью встроенной функции
 list и использует метод списка sort.

 Метод sort написан на языке C, поэтому иногда он может обеспечивать
более высокую производительность по сравнению с другими версиями
функции, но линейный характер сканирования в первых двух версиях
в большинстве случаев обеспечивает им более высокую скорость. Файл
mins.py содержит реализацию всех трех решений:
"""


def min1(*args):
    res = args[0]
    for arg in args[1:]:
        if arg < res:
            res = arg
    return res


def min2(first, *rest):
    for arg in rest:
        if arg < first:
            first = arg
    return first


def min3(*args):
    tmp = list(args)  # Или, в Python 2.4+: return sorted(args)[0]
    tmp.sort()
    return tmp[0]


print(min1(3, 4, 1, 2))
print(min2("bb", "aa"))
print(min3([2, 2], [1, 1], [3, 3]))

"""
 Все три решения дают одинаковые результаты. Попробуйте несколько раз
вызвать функции в интерактивной оболочке, чтобы поэкспериментировать
с ними самостоятельно:

% python mins.py
1
aa
[1, 1]

 Обратите внимание, что ни один из этих трех вариантов не выполняет 
проверку ситуации, когда функции не передается ни одного аргумента. 
Такую проверку можно было бы предусмотреть, но в этом нет никакой 
необходимости – во всех трех решениях интерпретатор автоматически
возбудит исключение, если та или иная функция не получит ни одного 
аргумента. В первом случае исключение будет возбуждено при попытке 
получить нулевой элемент; во втором – когда обнаружится несоответствие
списка аргументов; и в третьем – когда функция попытается вернуть 
нулевой элемент.

 Это именно то, что нам нужно, потому что эти функции поддерживают поиск
среди данных любого типа и не существует какого-то особого значения, 
которое можно было бы вернуть в качестве признака ошибки. 
Из этого правила есть свои исключения (например, когда приходится
выполнить дорогостоящие действия, прежде чем появится ошибка), 
но вообще лучше исходить из предположения, что аргументы не будут 
вызывать ошибок в работе программного кода функции, и позволить 
интерпретатору возбуждать исключения, когда этого не происходит.


 Дополнительные баллы
 
 Студенты и читатели могут получить дополнительные баллы, если изменят
эти функции так, что они будут отыскивать не минимальное, а максимальное
значение. Сделать это достаточно просто: в первых двух версиях 
достаточно заменить < на >, а третья версия должна возвращать 
не элемент tmp[0], а элемент tmp[-1]. Дополнительные баллы будут 
начислены тем, кто догадается изменить имя функции на «max» 
(хотя это совершенно необязательно).

 Кроме того, вполне возможно обобщить функцию так, что она будет 
отыскивать либо минимальное, либо максимальное значение, определяя 
отношения элементов за счет интерпретации строки выражения с помощью 
таких средств, как встроенная функция eval (подробности в руководстве 
к библиотеке), или передавая произвольную функцию сравнения. 
В файле minmax.py содержится реализация последнего варианта:
"""


def minmax(test, *args):
    res = args[0]
    for arg in args[1:]:
        if test(arg, res):
            res = arg
    return res


def lessthan(x, y): return x < y  # См. также: lambda


def grtrthan(x, y): return x > y


print(minmax(lessthan, 4, 2, 1, 5, 6, 3))  # Тестирование
print(minmax(grtrthan, 4, 2, 1, 5, 6, 3))

"""
% python minmax.py
1
6

 Функции – это одна из разновидностей объектов, которые могут 
передаваться в функции, как в этом случае. Например, чтобы заставить
функцию отыскивать максимальное (или любое другое) значение, мы могли бы 
просто передать ей нужную функцию test. На первый взгляд может 
показаться, что мы делаем лишнюю работу, однако главное преимущество
такого обобщения функций (вместо того, чтобы содержать две версии, 
отличающиеся единственным символом) заключается в том, что в будущем
нам может потребоваться изменить одну функцию, а не две.


 Универсальные функции для работы с множествами
 
 Теперь рассмотрим более полезный пример использования специальных 
режимов сопоставления аргументов. В конце главы 16 мы написали функцию,
которая возвращает пересечение двух последовательностей (она отбирает 
элементы, общие для обеих последовательностей). Ниже приводится версия
функции, которая возвращает пересечение произвольного числа 
последовательностей (одной или более), где используется механизм 
передачи произвольного числа аргументов в форме *args для сбора всех 
передаваемых аргументов в виде коллекции. Все аргументы передаются 
в тело функции в составе кортежа, поэтому для их обработки можно 
использовать простой цикл for. Ради интереса мы напишем функцию union,
возвращающую объединение, которая также принимает произвольное число
аргументов и собирает вместе все элементы, имеющиеся в любом 
из операндов:
"""


def intersect(*args):
    res = []
    for x in args[0]:  # Сканировать первую последовательность
        for other in args[1:]:  # Во всех остальных аргументах
            if x not in other:  # Общий элемент?
                break  # Нет: прервать цикл
            else:
                res.append(x)  # Да: добавить элемент в конец
    return res


def union(*args):
    res = []
    for seq in args:  # Для всех аргументов
        for x in seq:  # Для всех элементов
            if x not in res:
                res.append(x)  # Добавить новый элемент в результат
    return res


"""
 Поскольку эти функции могут использоваться многократно (и они слишком
большие, чтобы вводить их в интерактивной оболочке), мы сохраним их
в модуле с именем inter2.py (если вы забыли, как выполняется
импортирование модулей, прочитайте введение в главе 3 или подождите 
до пятой части книги). В обе функции аргументы передаются в виде 
кортежа args. Как и оригинальная версия intersect, обе они работают 
с любыми типами последовательностей. Ниже приводится пример обработки 
строк, последовательностей разных типов и случай обработки более чем 
двух последовательностей:

% python
>>> from inter2 import intersect, union
"""

s1, s2, s3 = "SPAM", "SCAM", "SLAM"
print(intersect(s1, s2), union(s1, s2))  # Два операнда

print(intersect([1, 2, 3], (1, 4)))  # Смешивание типов

print(intersect(s1, s2, s3))  # Три операнда

print(union(s1, s2, s3))

"""
 Имитация функции print в Python 3.0

 В заключение рассмотрим еще один, последний, пример использования 
специальных режимов сопоставления аргументов. Программный код, который
приводится здесь, предназначен для использования с интерпретатором 
версии Python 2.6 и ниже (он будет работать и в версии 3.0, но в этом 
нет никакого смысла): в нем используются обе формы представления 
аргументов (*args - кортеж позиционных аргументов и **args – словарь
именованных аргументов) для имитации интерфейса функции print 
в Python 3.

 Как мы узнали в главе 11, в действительности в этом нет никакой 
необходимости, потому что программисты, использующие версию 2.6, 
всегда могут включить поддержку функции print, появившейся в версии 3.0, 
выполнив инструкцию импортирования:

from __future__ import print_function

 Однако для демонстрации работы механизма сопоставления аргументов 
я поместил реализацию функции print30 в следующий ниже файл print30.py.
Эта функция выполняет ту же самую работу, имеет небольшой объем и может 
использоваться многократно:
"""

"""
Имитация большинства особенностей функции print в версии 3.0
для использования с интерпретатором версии 2.X
Сигнатура вызова: print30(*args, sep=’ ‘, end=’\n’, file=None)
"""

import sys


def print30(*args, **kargs):
    sep = kargs.get('sep', ' ')  # Именованные аргументы
    end = kargs.get('end', '\n')  # со значениями по умолчанию
    file = kargs.get('file', sys.stdout)
    output = ''
    first = True
    for arg in args:
        output += ('' if first else sep) + str(arg)
        first = False
    file.write(output + end)


"""
 Чтобы опробовать функцию, импортируйте ее в другом модуле 
или в интерактивном сеансе и попытайтесь использовать ее как функцию
print в версии 3.0. Ниже приводится испытательный сценарий
testprint30.py (обратите внимание, что функции присвоено имя «print30»,
потому что «print» является зарезервированным словом в версии 2.6):

from print30 import print30
"""

print30(1, 2, 3)
print30(1, 2, 3, sep=' ')  # Подавить вывод разделителя
print30(1, 2, 3, sep='...')
print30(1, [2], (3,), sep='...')  # Вывод объектов различных типов
print30(4, 5, 6, sep='', end=' ')  # Подавить вывод символа новой строки
print30(7, 8, 9)
print30()  # Добавить новую строку

print30(1, 2, 3, sep='??', end='.\n', file=sys.stderr)
#                                                   Перенаправить в файл

"""
 Если запустить этот сценарий под управлением Python 2.6, мы получим 
те же результаты, что и при использовании функции print в версии 3.0:

C:\misc> c:\python26\python testprint30.py
1 2 3
123
1...2...3
1...[2]...(3,)
4567 8 9
1??2??3.

 Хотя эта функция и не имеет практической ценности при работе 
с Python 3.0, тем не менее в этой версии она даст те же самые 
результаты. Как обычно, универсальная архитектура языка Python позволяет
нам создавать модели и исследовать концепции самого языка Python. 
В данном случае реализация механизма сопоставления аргументов на языке 
Python оказалась настолько же гибкой, как и внутренняя реализация.


 Использование аргументов, которые могут передаваться только по имени
 
 Интересно отметить, что этот пример можно было бы реализовать в версии
Python 3.0 с применением аргументов, которые могут передаваться только 
по имени, о которых рассказывалось выше в этой главе, – 
для автоматической проверки дополнительных параметров настройки:

# Использование аргументов, которые могут передаваться только по имени
def print30(*args, sep=’ ‘, end=’\n’, file=sys.stdout):
    output = ‘’
    first = True
    for arg in args:
        output += (‘’ if first else sep) + str(arg)
        first = False
    file.write(output + end)
    
 Эта версия действует точно так же, как и предыдущая, и может служить 
отличным примером того, насколько удобными могут быть аргументы, которые
могут передаваться только по имени. В оригинальной версии функции 
предполагается, что все позиционные аргументы являются объектами, 
которые требуется вывести, а все именованные аргументы являются 
дополнительными параметрами настройки. Это почти то, что нужно,
но прежняя версия будет молча игнорировать все лишние именованные 
аргументы, тогда как новая версия, например, вызовет исключение:

>>> print30(99, name=’bob’)
TypeError: print30() got an unexpected keyword argument ‘name’

 Чтобы выявить лишние именованные аргументы вручную, мы могли бы 
извлекать допустимые параметры с помощью метода dict.pop() 
и по окончании проверять размер словаря. Ниже приводится измененная
версия функции для Python 2.X, аналогичная по своей функциональности 
функции, где используются аргументы, которые могут передаваться только 
по имени:
"""


# Удаляет допустимые именованные аргументы со значениями по умолчанию
def print31(*args, **kargs):
    sep = kargs.pop('sep', ' ')
    end = kargs.pop('end', '\n')
    file = kargs.pop('file', sys.stdout)
    if kargs:
        raise TypeError('extra keywords: % s' % kargs)
    output = ''
    first = True
    for arg in args:
        output += ('' if first else sep) + str(arg)
        first = False
    file.write(output + end)


"""
 Эта версия действует точно так же, но на этот раз она обнаруживает 
недопустимые именованные аргументы:
"""

print31(99, name='bob')

"""
 Эта версия функции работает под управлением Python 2.6, но она 
на четыре строки длиннее, чем версия, где применяются аргументы,
которые могут передаваться только по именам. К сожалению, от лишнего
программного кода избавиться не удастся – версия с аргументами, которые 
могут передаваться только по именам, может работать только 
под управлением Python 3.0, что отменяет причины, побудившие меня 
написать этот пример (имитация функции из версии 3.0, которая способна
работать только в версии 3.0, не имеет никакой практической ценности!).
Однако в программах, предназначенных для работы под управлением 
интерпретатора версии 3.0, аргументы, которые могут передаваться только 
по именам, могут упростить реализацию функций, принимающих аргументы 
и дополнительные параметры настройки.


 Придется держать в уме: именованные аргументы

 Как вы уже наверняка поняли, специальные режимы сопоставления
аргументов могут быть весьма сложными. Однако они не являются
обязательными – вы можете использовать самый простой режим сопоставления 
позиционных аргументов, и это будет, пожалуй, самое лучшее решение,
пока вы только учитесь. Однако эти режимы используются в некоторых
инструментах Python, поэтому так важно иметь некоторое представление 
об этих режимах.

 Именованные аргументы играют важную роль в модуле tkinter, который 
фактически стал стандартным средством для разработки графического 
интерфейса в языке Python (в Python 2.6 этот модуль называется Tkinter). 
Мы познакомимся с tkinter далее в этой книге, но в качестве 
предварительного знакомства замечу, что при использовании этой 
библиотеки для установки значений параметров компонентов графического 
интерфейса используются именованные аргументы. Например, 
следующий вызов:

from tkinter import *
widget = Button(text=”Press me”, command=someFunction)

 создает новую кнопку и определяет текст на кнопке и функцию обратного 
вызова с помощью ключевых аргументов text и command. Так как графические
компоненты могут иметь большое число параметров, именованные аргументы 
позволяют указывать только необходимые параметры. В противном случае 
пришлось бы перечислять все возможные параметры в соответствии 
с их позициями или надеяться, что аргументы со значениями по умолчанию 
будут правильно интерпретироваться во всех возможных ситуациях.

 Многие встроенные функции в языке Python ожидают, что мы будем 
использовать именованные аргументы для определения режимов работы,
которые могут иметь, а могут и не иметь значения по умолчанию. Как
мы узнали в главе 8, например, встроенная функция sorted:

sorted(iterable, key=None, reverse=False)

 ожидает, что ей будет передан итерируемый объект для сортировки, 
но при этом позволяет передавать ей дополнительные именованные
аргументы, определяющие ключ словаря, по которому будет выполняться
сортировка, и признак сортировки в обратном порядке, которые
по умолчанию имеют значения None и False соответственно. Обычно мы
не используем эти параметры, поэтому они могут быть опущены, чтобы 
задействовать значения по умолчанию.
"""

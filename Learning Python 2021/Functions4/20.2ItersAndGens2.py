"""
 Выражения-генераторы: итераторы и генераторы списков

 Во всех последних версиях Python понятия итератора и генератора списков
были объединены в новую языковую конструкцию – выражения-генераторы.
Синтаксически выражения напоминают обычные генераторы списков, но они
заключаются не в квадратные, а в круглые скобки:

\>>> [x ** 2 for x in range(4)]      # Генератор списков: создает список
[0, 1, 4, 9]
\>>> (x ** 2 for x in range(4))      # Выражение-генератор: создает
<generator object at 0x011DC648>     # итерируемый объект

 Фактически, по крайней мере с функциональной точки зрения, генератор
списков является эквивалентом генератора-выражения, обернутого в вызов
встроенной функции list для принудительного получения сразу всего списка
с результатами:

\>>> list(x ** 2 for x in range(4))      # Эквивалент генератора списков
[0, 1, 4, 9]

 Однако с другой стороны, выражения-генераторы кардинально отличаются
от генераторов списков – вместо того, чтобы создавать в памяти список
с результатами, они возвращают объект-генератор, который в свою очередь
поддерживает протокол итераций, поставляя по одному элементу списка
за раз в любом итерационном контексте:

\>>> G = (x ** 2 for x in range(4))
\>>> next(G)
0
\>>> next(G)
1
\>>> next(G)
4
\>>> next(G)
9
\>>> next(G)
Traceback (most recent call last):
...остальной текст опущен...
StopIteration

 Как правило, нам не приходится наблюдать итерационную механику действий
выражений-генераторов, как в данном примере, потому что циклы for делают
это автоматически:

\>>> for num in (x ** 2 for x in range(4)):
...     print(‘%s, %s’ % (num, num / 2.0))
...
0, 0.0
1, 0.5
4, 2.0
9, 4.5

 Как мы уже знаем, именно таким способом работает любой итерационный
контекст, включая встроенные функции sum, map и sorted, генераторы
списков и другие итерационные инструменты, которые мы рассматривали
в главе 14, такие, как встроенные функции all, any и list.

 Обратите внимание, что круглые скобки вокруг выражения-генератора можно
опустить, если оно является единственным элементом, заключенным в другие
круглые скобки, например в вызове функции. Однако круглые скобки
необходимы во втором вызове функции sorted:

\>>> sum(x ** 2 for x in range(4))
14

\>>> sorted(x ** 2 for x in range(4))
[0, 1, 4, 9]

\>>> sorted((x ** 2 for x in range(4)), reverse=True)
[9, 4, 1, 0]

\>>> import math
\>>> list(map(math.sqrt, (x ** 2 for x in range(4))))
[0.0, 1.0, 2.0, 3.0]

 Выражения-генераторы в первую очередь оптимизируют использование
памяти – они не требуют создания в памяти полного списка с результатами,
как это делают генераторы списков в квадратных скобках. Кроме того,
на практике они могут работать несколько медленнее, поэтому их лучше
использовать, только когда объем результатов очень велик. Более точно
проверить это утверждение нам поможет сценарий хронометража, который
мы напишем ниже, в этой главе.


 Функции-генераторы и выражения-генераторы

 Интересно отметить, что одни и те же итерации часто можно реализовать
как в виде функции-генератора, так и в виде выражения-генератора.
Следующее выражение-генератор, например, четырежды повторяет каждый
символ в исходной строке:

\>>> G = (c * 4 for c in ‘SPAM’)         # Выражение-генератор
\>>> list(G)               # Принудительно получить сразу все результаты
[‘SSSS’, ‘PPPP’, ‘AAAA’, ‘MMMM’]

 Эквивалентная функция-генератор содержит чуть больше программного кода,
но, будучи функцией, при необходимости способна вместить в себя больший
объем логики и использовать больший объем информации:

\>>> def timesfour(S):         # Функция-генератор
...     for c in S:
...         yield c * 4
...
\>>> G = timesfour(‘spam’)
\>>> list(G)                   # Выполнит итерации автоматически
[‘ssss’, ‘pppp’, ‘aaaa’, ‘mmmm’]

 Обе разновидности генераторов поддерживают автоматическое и ручное
управление итерациями – в предыдущем примере вызов функции list
обеспечивает автоматическое выполнение итераций, а в следующем примере
демонстрируется выполнение итераций вручную:

 Генераторы – это объекты итераторов однократного применения

 И функции-генераторы, и выражения-генераторы имеют свои собственные
итераторы и потому поддерживают возможность лишь однократного выполнения
итераций – в отличие от некоторых встроенных типов, нет никакой
возможности получить несколько итераторов или выполнять позиционирование
итератора в множестве результатов. Например, для выражения-генератора
из предыдущего раздела итератором является сам генератор (фактически
вызов метода iter генератора не выполняет никаких действий):

\>>> G = (c * 4 for c in ‘SPAM’)
\>>> iter(G) is G        # Итератором генератора является сам генератор:
True                     # G имеет метод __next__

 Если попробовать выполнить обход результатов вручную, с помощью
нескольких итераторов, окажется, что все они ссылаются на одну и ту же
позицию в последовательности результатов:

\>>> G = (c * 4 for c in ‘SPAM’)      # Создать новый генератор
\>>> I1 = iter(G)                     # Выполнить итерацию вручную
\>>> next(I1)
‘SSSS’
\>>> next(I1)
‘PPPP’
\>>> I2 = iter(G)                     # Второй итератор
\>>> next(I2)                         # ссылается на ту же позицию!
‘AAAA’

 Кроме того, как только итерации достигнут конца, все результаты
окажутся исчерпаны – чтобы выполнить повторный обход результатов,
нам придется создать новый генератор:

\>>> list(I1)        # Выберет остатки результатов в I1
[‘MMMM’]
\>>> next(I2)        # Другие итераторы также окажутся исчерпанными
StopIteration
\>>> I3 = iter(G)    # То же относится и к вновь созданным итераторам
\>>> next(I3)
StopIteration

\>>> I3 = iter(c * 4 for c in ‘SPAM’)    # Создать новый генератор,
# чтобы выполнить повторный обход результатов
\>>> next(I3)
‘SSSS’

 То же относится и к функциям-генераторам – следующий эквивалентный
генератор, реализованный в виде функции, также обеспечивает возможность
однократного выполнения итераций:

\>>> def timesfour(S):
...     for c in S:
...         yield c * 4
...
\>>> G = timesfour(‘spam’)    # Функция-генератор действует точно так же
\>>> iter(G) is G
True
\>>> I1, I2 = iter(G), iter(G)
\>>> next(I1)
‘ssss’
\>>> next(I1)
‘pppp’
\>>> next(I2)                 # I2 находится в той же позиции, что и I1
‘aaaa’

 Некоторые встроенные типы имеют отличное поведение, поддерживают
возможность создания множества независимых итераторов и способны
отражать изменения объекта во всех активных итераторах:

\>>> L = [1, 2, 3, 4]
\>>> I1, I2 = iter(L), iter(L)
\>>> next(I1)
1
\>>> next(I1)
2
\>>> next(I2)     # Списки поддерживают множество независимых итераторов
1
\>>> del L[2:]    # Изменения отражаются на всех итераторах
\>>> next(I1)
StopIteration

 Когда в шестой части книги мы начнем создавать итераторы
на основе классов, то увидим, что мы в состоянии сами решать, какой тип
итераций будут поддерживать наши объекты, если они будут итерационными.


 Имитация функций zip и map с помощью инструментов итераций

 Чтобы продемонстрировать всю мощь инструментов итераций в действии,
рассмотрим несколько более сложных примеров. Освоив генераторы списков,
генераторы и другие инструменты итераций, вы обнаружите, что реализация
многих встроенных функций языка Python проста и наглядна.

 Например, мы уже видели, как встроенные функции zip и map позволяют
объединять итерируемые объекты и отображать на них функции
соответственно. При вызове с несколькими аргументами функция map
отображает заданную функцию на элементы, взятые из каждой
последовательности, практически тем же способом, каким функция zip
объединяет их:

\>>> S1 = ‘abc’
\>>> S2 = ‘xyz123’
\>>> list(zip(S1, S2))    # zip объединяет элементы итерируемых объектов
[(‘a’, ‘x’), (‘b’, ‘y’), (‘c’, ‘z’)]

# zip объединяет элементы, усекая результирующую последовательность
# по длине кратчайшей исходной последовательности
\>>> list(zip([-2, -1, 0, 1, 2]))     # Единственная последовательность:
[(-2,), (-1,), (0,), (1,), (2,)]      # 1-мерные кортежи
\>>> list(zip([1, 2, 3], [2, 3, 4, 5]))  # N последовательностей:
[(1, 2), (2, 3), (3, 4)]                 # N-мерные кортежи

# map передает объединенные элементы последовательностей
# указанной функции, усекая результирующую последовательность
# по длине кратчайшей исходной последовательности
\>>> list(map(abs, [-2, -1, 0, 1, 2]))  # Единственная
[2, 1, 0, 1, 2]                   # последовательность: 1-мерная функция
\>>> list(map(pow, [1, 2, 3], [2, 3, 4, 5]))  # N последовательностей:
[1, 8, 81]                                    # N-мерная функция

 Разумеется, эти функции имеют различное назначение, но если внимательно
изучить эти примеры, можно заметить определенную связь между
результатами функции zip и отображаемыми аргументами функции map,
которую мы будем использовать в следующем примере.


 Создание собственной версии функции map(func, ...)

 Встроенные функции map и zip показывают высокую производительность
и удобны в использовании, тем не менее мы всегда можем добиться той же
функциональности, написав несколько строк самостоятельно. В предыдущей
главе, например, мы видели реализацию функции, имитирующей поведение
встроенной функции map для случая, когда ей передается единственная
последовательность. Нам не составит большого труда распространить
эту версию на случай множества последовательностей:
"""


# map(func, seqs...) на основе использования zip
def mymap(func, *seqs):
    res = []
    for args in zip(*seqs):
        res.append(func(*args))
        
    return res


print(mymap(abs, [-2, -1, 0, 1, 2]))
print(mymap(pow, [1, 2, 3], [2, 3, 4, 5]))

"""
 Эта версия в значительной степени опирается на конструкцию *args 
передачи аргументов – она получает множество 
аргументов-последовательностей (в действительности – итерируемых
объектов), распаковывает их в аргументы функции zip, для последующего 
объединения, и затем распаковывает результаты вызова функции zip
в аргументы указанной функции func. То есть мы используем тот факт, 
что объединение элементов последовательностей, по сути, является 
промежуточной операцией при отображении. Проверочный программный
код, находящийся внизу сценария, применяет эту функцию сначала к одной
последовательности, а потом к двум и воспроизводит следующие результаты
(те же результаты дает применение встроенной функции map):

[2, 1, 0, 1, 2]
[1, 8, 81]

 Однако в действительности предыдущая версия функции представляет собой
классический шаблон генератора списков, конструируя список
с результатами с помощью цикла for. Учитывая это обстоятельство, 
мы можем сделать нашу версию функции map более компактной, реализовав 
все необходимое в виде однострочного генератора списков:
"""


# С использованием генератора списков
def mymap(func, *seqs):
    return [func(*args) for args in zip(*seqs)]


print(mymap(abs, [-2, -1, 0, 1, 2]))
print(mymap(pow, [1, 2, 3], [2, 3, 4, 5]))

"""
 Запустив этот пример, мы получим те же результаты, что и выше, 
но сама реализация получилась более компактной и, возможно, 
более быстрой (подробнее о производительности рассказывается в разделе
«Хронометраж итерационных альтернатив», ниже). Обе предыдущие версии 
функции mymap конструируют сразу весь список с результатами, 
что для крупных списков может привести к существенному увеличению 
потребления памяти. Теперь, когда мы познакомились 
с функциями-генераторами и выражениями-генераторами, мы легко можем 
создать две альтернативные версии, возвращающие результаты 
по требованию:


# С использованием генераторов: yield и (...)
def mymap(func, *seqs):
    res = []
    for args in zip(*seqs):
        yield func(*args)
        
        
def mymap(func, *seqs):
    return (func(*args) for args in zip(*seqs))
    
 Эти версии воспроизводят те же самые результаты, но возвращают
генераторы, поддерживающие протокол итераций, – первая версия поставляет
по одному результату за раз, а вторая возвращает результат 
выражения-генератора, который имеет тот же эффект. Если обернуть вызовы 
этих функций в вызов функции list, мы сможем получить сразу 
все результаты:

print(list(mymap(abs, [-2, -1, 0, 1, 2])))
print(list(mymap(pow, [1, 2, 3], [2, 3, 4, 5])))

 В действительности здесь не выполняется никакой работы, пока вызов 
функции list не запустит генераторы, активируя их посредством протокола 
итераций. Генераторы, возвращаемые этими функциями, как и генераторы,
возвращаемые встроенной функцией zip в Python 3.0, воспроизводят 
результаты только по требованию.


 Создание собственных версий функций zip(...) и map(None, ...)
 
 Конечно, тайной пружиной предыдущих примеров является использование
встроенной функции zip для объединения элементов из нескольких 
последовательностей. Можно также заметить, что наши версии функции map
на самом деле имитируют поведение функции map в Python 3.0, – 
они усекают длину последовательности результатов по кратчайшей исходной 
последовательности и не поддерживают возможность подстановки значений, 
когда длины исходных последовательностей отличаются, как это позволяет
функция map в Python 2.X, когда ей передается аргумент None:

C:\misc> c:\python26\python
>>> map(None, [1, 2, 3], [2, 3, 4, 5])
[(1, 2), (2, 3), (3, 4), (None, 5)]
>>> map(None, ‘abc’, ‘xyz123’)
[(‘a’, ‘x’), (‘b’, ‘y’), (‘c’, ‘z’), (None, ‘1’), (None, ‘2’), 
 (None, ‘3’)]

 Используя инструменты итераций, мы можем создать версии, имитирующие
усечение, как это делает функция zip, и дополнение, как это делает 
функция map в версии 2.6. Как оказывается, эти версии почти 
не отличаются от предыдущих:
"""


# Версии zip(seqs...) и map(None, seqs...) в Python 2.6
def myzip(*seqs):
    seqs = [list(S) for S in seqs]
    res = []
    while all(seqs):
        res.append(tuple(S.pop(0) for S in seqs))
        
    return res


def mymapPad(*seqs, pad=None):
    seqs = [list(S) for S in seqs]
    res = []
    while any(seqs):
        res.append(tuple((S.pop(0) if S else pad) for S in seqs))
        
    return res


S1, S2 = 'abc', 'xyz123'
print(myzip(S1, S2))
print(mymapPad(S1, S2))
print(mymapPad(S1, S2, pad=99))

"""
 Обе функции, представленные здесь, способны работать с любыми 
итерируемыми объектами, потому что они применяют к своим аргументам 
встроенную функцию list, вынуждая их сгенерировать все результаты 
(что, к примеру, позволяет передавать в качестве аргументов не только 
простые последовательности, такие как строки, но и файлы). 
Обратите внимание, что здесь используются встроенные функции all и any,
– они возвращают True, если все или хотя бы один элемент итерируемого 
объекта соответственно имеет истинное значение (то есть непустой). 
Эти встроенные функции позволяют остановить итерации, когда один 
или все аргументы, пропущенные через функцию list, превращаются в пустые
списки после удаления очередного элемента.

 Обратите также внимание на использование аргумента pad, который 
в Python 3.0 может передаваться только по имени, – в отличие 
от функции map в версии 2.6, наша версия позволяет указывать любые
объекты, которые будут использоваться вместо отсутствующих элементов 
(если вы пользуетесь версией 2.6, для поддержки этой возможности
используйте форму передачи именованных аргументов **kargs вместо 
pad=None; подробности ищите в главе 18). Запустив этот сценарий, 
вы получите следующие результаты – результат вызова функции zip 
и двух вызовов функции map, поддерживающей дополнение недостающих
элементов:

[(‘a’, ‘x’), (‘b’, ‘y’), (‘c’, ‘z’)]
[(‘a’, ‘x’), (‘b’, ‘y’), (‘c’, ‘z’), (None, ‘1’), (None, ‘2’), 
 (None, ‘3’)]
[(‘a’, ‘x’), (‘b’, ‘y’), (‘c’, ‘z’), (99, ‘1’), (99, ‘2’), (99, ‘3’)]

 Эти функции не могут быть преобразованы в генераторы списков 
из-за того, что в них используются слишком специфичные циклы. Однако, 
как и прежде, текущие версии функций zip и map конструируют и возвращают
сразу весь список с результатами и их точно так же легко можно
превратить в генераторы, поставляющие результаты по одному элементу 
за раз. Результаты получаются теми же самыми, что и прежде, но нам снова
придется использовать функцию list, чтобы получить сразу все значения 
для отображения:
"""


# С использованием генераторов: yield
def myzip(*seqs):
    seqs = [list(S) for S in seqs]
    while all(seqs):
        yield tuple(S.pop(0) for S in seqs)


def mymapPad(*seqs, pad=None):
    seqs = [list(S) for S in seqs]
    while any(seqs):
        yield tuple((S.pop(0) if S else pad) for S in seqs)


S1, S2 = 'abc', 'xyz123'
print(list(myzip(S1, S2)))
print(list(mymapPad(S1, S2)))
print(list(mymapPad(S1, S2, pad=99)))

"""
 Наконец, ниже приводятся альтернативные реализации наших версий функций 
zip и map – вместо того, чтобы удалять элементы из списков с помощью
метода pop, они выполняют свою работу за счет нахождения аргументов 
с минимальной и максимальной длиной. Вооружившись этими значениями, 
легко можно реализовать вложенные генераторы списков для обхода 
диапазонов индексов в аргументах:


# Альтернативные реализации с вычислением длин исходных 
# последовательностей
def myzip(*seqs):
    minlen = min(len(S) for S in seqs)
    return [tuple(S[i] for S in seqs) for i in range(minlen)]
    
    
def mymapPad(*seqs, pad=None):
    maxlen = max(len(S) for S in seqs)
    index = range(maxlen)
    return [tuple((S[i] if len(S) > i else pad) for S in seqs) 
                                                for i in index]
                                                
                                                
S1, S2 = ‘abc’, ‘xyz123’
print(myzip(S1, S2))
print(mymapPad(S1, S2))
print(mymapPad(S1, S2, pad=99))

 Поскольку в этих версиях используются функция len и операция 
извлечения элементов по индексам, они уже не предполагают, 
что их аргументы могут быть произвольными итерируемыми объектами. 
Внешний генератор списков здесь выполняет обход диапазона индексов 
в аргументе, а внутренний (передается функции tuple) выполняет обход 
полученных функцией последовательностей, одновременно извлекая из каждой 
по одному элементу. Если запустить этот пример, вы получите 
те же результаты, что и прежде.

 Больше всего в этом примере поражает широкое использование генераторов
и итераторов. Аргументы, которые передаются функциям min и max, являются 
выражениями-генераторами, которые заканчивают свои итерации еще до того, 
как вложенный генератор списков приступит к выполнению итераций.
Кроме того, вложенные генераторы списков содержат два уровня отложенных
операций – итератор, возвращаемый встроенной функцией range 
в Python 3.0, и выражение-генератор, которое передается, как аргумент
функции tuple.

 В действительности, пока поток управления не достигнет квадратных
скобок генератора списков, здесь не воспроизводится никаких 
результатов – именно в этом месте происходит запуск генераторов списков 
и выражений-генераторов. Чтобы эти версии функций возвращали не списки
с результатами, а генераторы, вместо квадратных скобок следует 
использовать круглые скобки. Ниже приводится преобразованная версия 
нашей функции zip:


# С использованием генераторов: (...)
def myzip(*seqs):
    minlen = min(len(S) for S in seqs)
    return (tuple(S[i] for S in seqs) for i in range(minlen))
    
    
print(list(myzip(S1, S2)))

 Чтобы получить сразу весь список результатов, воспроизводимых этой 
версией функции, ее необходимо обернуть в вызов функции list, которая 
активирует работу генераторов и итераторов, воспроизводящих результаты.
Поэкспериментируйте с этими версиями самостоятельно, чтобы лучше понять,
как они действуют. Разработку других альтернатив я оставляю вам 
в качестве самостоятельного упражнения (смотрите также врезку «Придется
держать в уме однократные итерации»).


 Придется держать в уме: однократные итерации
 
 В главе 14 мы видели, что некоторые встроенные функции (такие как map)
возвращают итераторы, поддерживают возможность только однократного 
обхода элементов и опустошаются по достижении конца итераций. Там же 
я обещал привести пример, насколько значимым может оказаться 
это обстоятельство на практике. Теперь, когда мы знаем об итерациях 
чуть больше, я готов выполнить свое обещание. Рассмотрим следующую
альтернативную реализацию нашей функции zip, которая является 
адаптированной версией функции, взятой из руководства по языку Python:

def myzip(*args):
    iters = map(iter, args)
    while iters:
        res = [next(i) for i in iters]
    yield tuple(res)

 Так как в этой версии используются функции iter и next, она способна
принимать любые итерируемые объекты. Обратите внимание, что нет никаких 
причин перехватывать исключение StopIteration, возбуждаемое вызовом
функции next(i) внутри генератора списков по исчерпании любого 
из аргументов-итераторов, – внутри функции-генератора это исключение 
дает тот же эффект, что и инструкция return. Инструкции while iters: 
вполне достаточно, чтобы организовать обход, когда функции был передан 
хотя бы один аргумент, и избежать зацикливания в противном случае 
(генератор списков в этом случае всегда будет возвращать пустой список).

 Эта функция прекрасно действует в Python 2.6, например:
 
>>> list(myzip(‘abc’, ‘lmnop’))
[(‘a’, ‘l’), (‘b’, ‘m’), (‘c’, ‘n’)]

 Но она попадает в бесконечный цикл в Python 3.0, потому что функция
map в версии 3.0 возвращает объект-итератор однократного пользования,
а не список, как в версии 2.6. В версии 3.0, как только внутри цикла
будет выполнен генератор списков, переменная iters навсегда останется
пустой (и переменная res будет ссылаться на пустой список []). 
Чтобы обеспечить работоспособность функции в версии 3.0, нам необходимо
с помощью встроенной функции list создать объект, который поддерживает 
многократные итерации:

def myzip(*args):
    iters = list(map(iter, args))
    ...остальная часть функции осталась без изменений...

 Опробуйте эту версию самостоятельно, чтобы понять, как она действует. 
Главный урок, который следует запомнить: обертывать вызовы функции map
в вызовы функции list в версии 3.0 приходится не только для отображения 
списков результатов в интерактивном сеансе!


 Генерирование значений во встроенных типах и классах
 
 Наконец, хоть мы и сосредоточились в этом разделе на реализации 
собственных генераторов значений, не забывайте, что многие встроенные
типы ведут себя похожим образом, – как мы видели в главе 14, словари, 
например, имеют собственные итераторы, которые во время итераций
воспроизводят ключи:

>>> D = {‘a’:1, ‘b’:2, ‘c’:3}
>>> x = iter(D)
>>> next(x)
‘a’
>>> next(x)
‘c’

 Подобно значениям, которые воспроизводятся нашими собственными 
генераторами, ключи словарей можно обойти вручную или с помощью 
автоматизированных инструментов итераций, включая циклы for, 
функцию map, генераторы списков и других, с которыми мы встречались 
в главе 14:

>>> for key in D:
...     print(key, D[key])
...
a 1
c 3
b 2

 Мы также видели, что при использовании итераторов файлов интерпретатор
Python просто загружает строки из файла по мере необходимости:

>>> for line in open(‘temp.txt’):
...     print(line, end=’’)
...
Tis but
a flesh wound.

 Хотя итераторы встроенных типов воспроизводят значения определенного 
типа, тем не менее в них используются те же концепции, что и в наших
выражениях-генераторах и функциях-генераторах. Инструменты итераций,
такие как циклы for, принимают любые итерируемые объекты, 
как определяемые пользователем, так и встроенные.

 Хотя это и выходит за рамки данной главы, тем не менее замечу, 
что существует возможность реализовать произвольные объекты-генераторы 
с помощью классов, которые поддерживают протокол итераций, и поэтому 
могут использоваться в циклах for и в других итерационных контекстах. 
Такие классы определяют специальный метод __iter__, вызываемый
функцией iter и возвращающий объект-итератор, обладающий методом 
__next__, который вызывается встроенной функцией next 
(при этом метод __getitem__ также остается доступным, как крайнее
средство обеспечения итераций через доступ к элементам по индексу).

 Экземпляры таких классов считаются итерируемыми объектами 
и могут использоваться в циклах for и во всех остальных итерационных 
контекстах. Однако при использовании классов мы получаем доступ к более 
богатым возможностям реализации логики выполнения и структурирования
данных, чем могут предложить другие конструкции генераторов.

 На этом история итераторов не заканчивается и нам еще предстоит узнать,
как они могут быть связаны с классами. А пока нам придется отложить 
эту тему,пока мы не познакомимся с итераторами на базе классов 
в главе 29.
"""

"""
Области видимости и вложенные функции

 Мы до сих пор не рассмотрели еще одну часть правила области видимости
в языке Python (просто потому, что с нею редко сталкиваются
на практике). Однако пришло время более пристально посмотреть на E
в правиле LEGB. Уровень E появился относительно недавно (он был добавлен
в Python 2.2) – это локальные области видимости объемлющих инструкций
def. Иногда объемлющие области видимости называют статически вложенными
областями видимости. В действительности вложение является лексическим –
вложенные области видимости соответствуют физически вложенным блокам
программного кода в исходных текстах программы.


 Вложенные области видимости

 С появлением областей видимости вложенных функций правила поиска
переменных стали немного более сложными. Внутри функции:

  При обращении к переменной (X) поиск имени X сначала производится
 в локальной области видимости (функции); затем в локальных областях
 видимости всех лексически объемлющих функций, изнутри наружу; затем
 в текущей глобальной области видимости (в модуле); и, наконец,
 во встроенной области видимости (модуль builtins). Поиск имен,
 объявленных в инструкции global, начинается сразу с глобальной
 (в модуле) области видимости.

  Операция присваивания (X = value) по умолчанию создает или изменяет
 имя X в текущей локальной области видимости. Если имя X объявлено
 глобальным внутри функции, операция присваивания создает или изменяет
 имя X в области видимости объемлющего модуля. Если имя X объявлено
 нелокальным внутри функции, операция присваивания создает или изменяет
 имя X в ближайшей области видимости объемлющей функции.

 Обратите внимание, что инструкция global отображает имена в область
видимости объемлющего модуля. Когда имеются вложенные функции, можно
получить значения переменных в объемлющих функциях, но чтобы их
изменить, переменные должны быть указаны в объявлении nonlocal.


 Примеры вложенных областей видимости

 Чтобы пояснить положения, описанные в предыдущем разделе, рассмотрим их
на примере программного кода. Ниже приводится пример вложенной области
видимости:

X = 99  # Имя в глобальной области видимости: не используется
def f1():
    X = 88  # Локальное имя в объемлющей функции
    def f2():
        print(X)  # Обращение к переменной во вложенной функции
    f2()
f1()

 Прежде всего – это вполне допустимый программный код на языке Python:
инструкция def – это обычная исполняемая инструкция, которая может
появляться в любом месте программы, где могут появляться другие
инструкции, включая вложение в другую инструкцию def. В этом примере
вложенная инструкция def исполняется в момент вызова функции f1 – она
создает функцию и связывает ее с именем f2, которое является локальным
и размещается в локальной области видимости функции f1. В некотором
смысле f2 – это временная функция, которая существует только во время
работы (и видима только для программного кода) объемлющей функции f1.

 Однако обратите внимание, что происходит внутри функции f2: когда
производится вывод переменной X, она ссылается на переменную X
в локальной области видимости объемлющей функции f1. Функции имеют
возможность обращаться к именам, которые физически располагаются в любых
объемлющих инструкциях def, и имя X в функции f2 автоматически
отображается на имя X в функции f1 в соответствии с правилом
поиска LEGB.

 Это правило поиска в объемлющих областях видимости выполняется, даже
если объемлющая функция фактически уже вернула управление. Например,
следующий фрагмент определяет функцию, которая создает и возвращает
другую функцию:

def f1():
    X = 88
    def f2():
        print(X)  # Сохраняет значение X в объемлющей области видимости
    return f2  # Возвращает f2, но не вызывает ее

action = f1()  # Создает и возвращает функцию
action()  # Вызов этой функции: выведет 88

 В этом фрагменте при вызове action фактически запускается функция,
созданная во время выполнения функции f1. Функция f2 помнит переменную X
в области видимости объемлющей функции f1, которая уже неактивна.


 Фабричные функции

 В зависимости от того, кому задается вопрос о том, как называется такое
поведение, можно услышать такие термины, как замыкание или фабричная
функция. Под этими терминами подразумевается объект функции, который
сохраняет значения в объемлющих областях видимости, даже когда
эти области могут прекратить свое существование. Классы (описываются
в шестой части книги) обычно лучше подходят для сохранения состояния,
потому что они позволяют делать это явно, посредством присваивания
значений атрибутам, тем не менее подобные функции обеспечивают другую
альтернативу.

 Например, фабричные функции иногда используются в программах, когда
необходимо создавать обработчики событий прямо в процессе выполнения,
в соответствии со сложившимися условиями (например, когда желательно
запретить пользователю вводить данные). Рассмотрим в качестве примера
следующую функцию:

\>>> def maker(N):
...     def action(X):  # Создать и вернуть функцию
...         return X ** N  # Функция action запоминает значение N
...     return action # в объемлющей области видимости
...

 Здесь определяется внешняя функция, которая просто создает и возвращает
вложенную функцию, не вызывая ее. Если вызвать внешнюю функцию:

\>>> f = maker(2)  # Запишет 2 в N
\>>> f
<function action at 0x014720B0>

 - она вернет ссылку на созданную ею вложенную функцию, созданную
при выполнении вложенной инструкции def. Если теперь вызвать то,
что было получено от внешней функции:

\>>> f(3)  # Запишет 3 в X, в N по-прежнему хранится число 2
9
\>>> f(4)  # 4 ** 2
16

 будет вызвана вложенная функция, с именем action внутри функции maker.
Самое необычное здесь то, что вложенная функция продолжает хранить число
2, значение переменной N в функции maker даже при том, что к моменту
вызова функции action функция maker уже завершила свою работу и вернула
управление. В действительности имя N из объемлющей локальной области
видимости сохраняется как информация о состоянии, присоединенная
к функции action, и мы получаем обратно значение аргумента, возведенное
в квадрат.

 Теперь, если снова вызвать внешнюю функцию, мы получим новую вложенную
функцию уже с другой информацией о состоянии, присоединенной к ней, –
в результате вместо квадрата будет вычисляться куб аргумента, но ранее
сохраненная функция по-прежнему будет возвращать квадрат аргумента:

\>>> g = maker(3)  # Функция g хранит число 3, а f – число 2
\>>> g(3)          # 3 ** 3
27
\>>> f(3)          # 3 ** 2
9

 Такое возможно благодаря тому, что при каждом обращении к фабричной
функции, как в данном примере, произведенные ею функции сохраняют свой
собственный блок данных с информацией о состоянии. В нашем случае
благодаря тому, что каждая из функций получает свой собственный блок
данных с информацией о состоянии, функция, которая присваивается
имени g, запоминает число 3 в переменной N функции maker,
а функция f – число 2.

 Это довольно сложный прием, который вам вряд ли часто придется часто
встречать на практике, впрочем, он распространен среди программистов,
обладающих опытом работы с функциональными языками программирования.
С другой стороны, с объемлющими областями видимости часто можно
встретиться в выражениях lambda (рассматриваются ниже в этой главе),
потому что они практически всегда используются внутри функций.
Кроме того, прием вложения функций обычно используется при разработке
декораторов (рассматриваются в главе 38); в некоторых ситуациях
это оказывается наиболее эффективным приемом.

 Вообще классы, которые будут обсуждаться позднее, лучше подходят
на роль «памяти», как в данном случае, потому что они обеспечивают явное
сохранение информации. Помимо классов, основными средствами хранения
информации о состоянии функций в языке Python являются глобальные
переменные, объемлющие области видимости, как в данном случае,
и аргументы по умолчанию. Полное описание аргументов со значениями
по умолчанию приводится в главе 18, но для того, чтобы начать
их использовать, достаточный объем вводной информации приводится
уже в следующем разделе.


 Сохранение состояния объемлющей области видимости
с помощью аргументов по умолчанию

 В первых версиях Python такой программный код, как в предыдущем
разделе, терпел неудачу из-за отсутствия вложенных областей видимости
в инструкциях def – при обращении к переменной внутри функции f2 поиск
производился сначала в локальной области видимости (f2), затем
в глобальной (программный код за пределами f1) и затем во встроенной
области видимости. Области видимости объемлющих функций
не просматривались, что могло приводить к ошибке. Чтобы разрешить
ситуацию, программисты обычно использовали аргументы со значениями
по умолчанию для передачи (сохранения) объектов, расположенных
в объемлющей области видимости:

def f1():
    x = 88
    def f2(x=x):  # Сохраняет значение переменной x в объемлющей области
        print(x)  # в виде аргумента
    f2()

f1()  # Выведет 88

 Этот фрагмент будет работать во всех версиях Python, и такой подход
по-прежнему можно встретить в существующих программах. В двух словах
замечу, что конструкция arg = val в заголовке инструкции def означает,
что аргумент arg по умолчанию будет иметь значение val, если функции
не передается какого-либо другого значения.

 В измененной версии f2 запись x=x означает, что аргумент x по умолчанию
будет иметь значение переменной x объемлющей области видимости.
Поскольку значение для второго имени x вычисляется еще до того,
как интерпретатор Python войдет во вложенную инструкцию def, оно все еще
ссылается на имя x в функции f1. В результате в значении по умолчанию
запоминается значение переменной x в функции f1 (то есть объект 88).

 Все это довольно сложно и полностью зависит от того, когда вычисляется
значение по умолчанию. Фактически поиск во вложенных областях видимости
был добавлен в Python, чтобы избавиться от такого способа использования
значений по умолчанию, – сейчас Python автоматически сохраняет любые
значения в объемлющей области видимости для последующего использования
во вложенных инструкциях def.

 Безусловно, наилучшей рекомендацией будет просто избегать вложения
инструкций def в другие инструкции def, так как это существенно упростит
программы. Ниже приводится фрагмент, который является эквивалентом
предшествующего примера, в котором просто отсутствует понятие
вложенности. Обратите внимание, что вполне допустимо вызывать функцию,
определение которой в тексте программы находится ниже функции, откуда
производится вызов, как в данном случае, при условии, что вторая
инструкция def будет исполнена до того, как первая функция попытается
вызвать ее, – программный код внутри инструкции def не выполняется,
пока не будет произведен фактический вызов функции:

\>>> def f1():
...     x = 88  # Передача значения x вместо вложения функций
...     f2(x)  # Опережающие ссылки считаются допустимыми
...
\>>> def f2(x):
...     print(x)
...
\>>> f1()
88

 При использовании такого способа можно забыть о концепции вложенных
областей видимости в языке Python, если вам не потребуется создавать
фабричные функции, обсуждавшиеся выше, – по крайней мере,
при использовании инструкций def. Выражения lambda, которые практически
всегда вкладываются в инструкции def, часто используют вложенные области
видимости, как описывается в следующем разделе.


 Вложенные области видимости и lambda-выражения

 Несмотря на то, что на практике вложенные инструкции def используются
достаточно редко, тем не менее вам наверняка придется столкнуться
с областями видимости вложенных функций, когда вы начнете использовать
выражения lambda. Мы не будем подробно рассматривать эти выражения
до главы 19, но в двух словах замечу, что это выражение генерирует
новую функцию, которая будет вызываться позднее, и оно очень похоже
на инструкцию def. Поскольку lambda – это выражение, оно может
использоваться там, где не допускается использование инструкции def,
например в литералах списков и словарей.

 Подобно инструкции def, выражение lambda сопровождается появлением
новой локальной области видимости. Благодаря наличию возможности поиска
имен в объемлющей области видимости выражения lambda способны обращаться
ко всем переменным, которые присутствуют в функциях, где находятся эти
выражения. Таким образом, следующий программный код будет работать
исключительно благодаря тому, что в настоящее время действуют правила
поиска во вложенных областях видимости:

def func():
    x = 4
    action = (lambda n: x ** n)  # запоминается x из объемлющей
    return action                # инструкции def

x = func()
print(x(2))  # Выведет 16, 4 ** 2

 До того как появилось понятие областей видимости вложенных функций,
для передачи значений из объемлющей области видимости в выражения lambda
программисты использовали значения по умолчанию; точно так же,
как и в случае с инструкциями def. Например, следующий фрагмент будет
работать во всех версиях Python:

def func():
    x = 4
    action = (lambda n, x=x: x ** n)  # Передача x вручную
    return action

 Поскольку lambda – это выражения, они естественно (и даже обычно)
вкладываются внутрь инструкций def. Следовательно, именно они извлекли
наибольшую выгоду от добавления областей видимости объемлющих функций
в правила поиска имен – в большинстве случаев отпадает необходимость
передавать в выражения lambda аргументы со значениями по умолчанию.


 Области видимости и значения по умолчанию
применительно к переменным цикла

 Существует одно известное исключение из правила, которое я только что
дал: если lambda-выражение или инструкция def вложены в цикл внутри
другой функции и вложенная функция ссылается на переменную из объемлющей
области видимости, которая изменяется в цикле, все функции, созданные
в этом цикле, будут иметь одно и то же значение – значение, которое
имела переменная на последней итерации.

 Например, ниже предпринята попытка создать список функций, каждая
из которых запоминает текущее значение переменной i из объемлющей
области видимости:

\>>> def makeActions():
...     acts = []
...     for i in range(5):  # Сохранить каждое значение i
...         acts.append(lambda x: i ** x)  # Все запомнят последнее
...     return acts                        # значение i!
...
\>>> acts = makeActions()
\>>> acts[0]
<function <lambda> at 0x012B16B0>

 Такой подход не дает желаемого результата, потому что поиск переменной
в объемлющей области видимости производится позднее, при вызове
вложенных функций, в результате все они получат одно и то же значение
(значение, которое имела переменная цикла на последней итерации).
То есть каждая функция в списке будет возвращать 4 во второй степени,
потому что во всех них переменная i имеет одно и то же значение:

\>>> acts[0](2)  # Все возвращают 4 ** 2, последнее значение i
16
\>>> acts[2](2)  # Здесь должно быть 2 ** 2
16
\>>> acts[4](2)  # Здесь должно быть 4 ** 2
16

 Это один из случаев, когда необходимо явно сохранять значение
из объемлющей области видимости в виде аргумента со значением
по умолчанию вместо использования ссылки на переменную из объемлющей
области видимости. То есть, чтобы этот фрагмент заработал, необходимо
передать текущее значение переменной из объемлющей области видимости
в виде значения по умолчанию. Значения по умолчанию вычисляются в момент
создания вложенной функции (а не когда она вызывается), поэтому
каждая из них сохранит свое собственное значение i:

\>>> def makeActions():
...     acts = []
...     for i in range(5):  # Использовать значения по умолчанию
...         acts.append(lambda x, i=i: i ** x)  # Сохранить текущее
...     return acts                             # значение i
...
\>>> acts = makeActions()
\>>> acts[0](2)  # 0 ** 2
0
\>>> acts[2](2)  # 2 ** 2
4
\>>> acts[4](2)  # 4 ** 2
16

 Это достаточно замысловатый случай, но с ним можно столкнуться
на практике, особенно в программном коде, который генерирует
функции-обработчики событий для элементов управления в графическом
интерфейсе (например, обработчики нажатия кнопок). Подробнее о значениях
по умолчанию мы поговорим в главе 18, а о lambda-выражениях –
в главе 19, поэтому позднее вам может потребоваться вернуться
к этому разделу.


 Произвольное вложение областей видимости

 Прежде чем закончить это исследование, я должен заметить, что области
видимости могут вкладываться произвольно, но поиск будет производиться
только в объемлющих функциях (не в классах, которые описываются
в шестой части книги):

\>>> def f1():
...      x = 99
...      def f2():
...          def f3():
...              print(x)  # Будет найдена в области видимости f1!
...          f3()
...      f2()
...
\>>> f1()
99

 Интерпретатор будет искать переменную в локальных областях видимости
всех объемлющих инструкций def, начиная от внутренних к внешним, выше
локальной области видимости и ниже глобальной области видимости модуля.
Однако такой программный код едва ли может получиться на практике.
В языке Python считается, что плоское лучше вложенного, – ваша жизнь
и жизнь ваших коллег будет проще, если вы сведете к минимуму количество
вложенных определений функций.


 Инструкция nonlocal

 В предыдущем разделе мы узнали, что вложенная функция может получать
значения переменных в области видимости объемлющей функции даже после
того, как эта функция вернет управление. Оказывается, в Python 3.0 также
имеется возможность изменять значения переменных в области видимости
объемлющей функции – при условии, что они объявлены с помощью инструкции
nonlocal. Эта инструкция позволяет вложенным функциям не только читать,
но и изменять значения переменных в областях видимости объемлющих
функций.

 Инструкция nonlocal – близкий родственник инструкции global, описанной
выше. Подобно инструкции global, nonlocal объявляет имена, которые будут
изменяться в теле функции и которые находятся в объемлющей области
видимости. Однако, в отличие от инструкции global, nonlocal применяется
только к областям видимости объемлющих функций и не затрагивает
глобальную область видимости модуля. Кроме того, в отличие от инструкции
global, имена, перечисленные в инструкции nonlocal, должны фактически
существовать в области видимости, вмещающей функцию, где встречается
это объявление, – они могут существовать только в объемлющей области
видимости и не могут быть созданы первой инструкцией присваивания
во вложенной функции.

 Другими словами, инструкция nonlocal позволяет присваивать значения
переменным в объемлющих областях видимости и ограничивает поиск таких
имен областями видимости объемлющих функций. В результате мы получаем
более очевидный и более надежный инструмент реализации изменения
информации в областях видимости для программ, где нежелательно
или невозможно использовать для этих же целей классы с атрибутами.


 Основы использования инструкции nonlocal

 В версии Python 3.0 появилась новая инструкция nonlocal, которая п
риобретает смысл только внутри функций:

def func():
    nonlocal name1, name2, ...

 Эта инструкция позволяет вложенным функциям изменять переменные,
которые определены в областях видимости синтаксически объемлющих
функций. В Python 2.X (включая 2.6), когда одна функция объявляется
внутри другой, вложенная функция может читать значения любых имен,
которые были определены с помощью инструкции присваивания в области
видимости объемлющей функции, но она не может изменять их. В 3.0
объявление имен, находящихся в объемлющей области видимости,
в инструкции nonlocal дает вложенной функции возможность присваивать
им новые значения.

 Благодаря этому для вложенных функций обеспечивается возможность
поддерживать доступную для изменения информацию о состоянии, которая
восстанавливается при последующих вызовах вложенной функции. Способность
изменять информацию о состоянии увеличивает практическую ценность
вложенных функций (например, представьте, что в объемлющей области
видимости хранится счетчик). В Python 2.X для достижения аналогичного
эффекта обычно используются классы или другие инструменты. Применение
вложенных функций стало практически стандартным приемом, когда требуется
обеспечить сохранение состояния, при этом инструкция nonlocal еще больше
расширяет область их применения.

 Кроме того, что инструкция nonlocal позволяет изменять значения
переменных в объемлющих функциях, она также ограничивает область поиска
имен – подобно инструкции global, инструкция nonlocal вынуждает
интерпретатор начинать поиск с областей видимости объемлющих функций,
пропуская локальную область видимости функции. То есть, кроме всего
прочего, инструкция nonlocal означает: «пропустить локальную область
видимости при поиске имен».

 На практике имена, перечисленные в инструкции nonlocal, должны быть
определены в объемлющих функциях к моменту, когда поток управления
достигнет инструкции nonlocal; в противном случае будет возбуждено
исключение. По своему действию инструкция nonlocal близко напоминает
global: объявление global означает, что имена находятся в глобальной
области видимости вмещающего модуля, а объявление nonlocal означает,
что они находятся в области видимости вмещающих функций. Впрочем,
инструкция nonlocal даже более строгая – она ограничивает область поиска
только областями видимости объемлющих функций. То есть нелокальные имена
могут присутствовать только в областях видимости объемлющих функций.

 Кроме того, инструкция nonlocal вообще не вносит никаких изменений
в правило поиска имен – поиск будет выполняться в полном соответствии
с правилом «LEGB», описанным выше. Основное назначение инструкции
nonlocal состоит в том, чтобы обеспечить возможность не только
получения, но и изменения значений переменных в объемлющих областях
видимости. Однако, если быть более точными, инструкции global и nonlocal
несколько ограничивают правила поиска:

  global вынуждает интерпретатор начинать поиск имен с области
 объемлющего модуля и позволяет присваивать переменным новые значения.
 Область поиска простирается вплоть до встроенной области видимости,
 если искомое имя не будет найдено в модуле, при этом операция
 присваивания значений глобальным именам всегда будет создавать
 или изменять переменные в области видимости модуля.

  nonlocal ограничивает область поиска областями видимости объемлющих
 функций; она требует, чтобы перечисленные в инструкции имена уже
 существовали, и позволяет присваивать им новые значения. В область
 поиска не входят глобальная и встроенная области видимости.

 В Python 2.6 допускается ссылаться на имена в областях видимости
объемлющих функций, но присвоить им новые значения невозможно. При этом
для сохранения информации о состоянии и достижения того же эффекта,
который дает применение инструкции nonlocal, вы можете использовать
классы с атрибутами (что в некоторых случаях является даже более удачным
решением). Иногда для аналогичных целей можно также использовать
глобальные переменные и атрибуты функций. Подробнее об этом мы поговорим
чуть ниже, а пока обратимся к программному коду, чтобы конкретизировать
все вышесказанное.


 Инструкция nonlocal в действии

 Все примеры, что приводятся ниже, выполнялись в Python 3.0. Обращение
к переменным в области видимости объемлющих функций действует точно
так же, как и в Python 2.6. Ниже приводится пример функции tester,
которая создает и возвращает вложенную функцию nested. Обращение
к переменной state из вложенной функции отображается на локальную
область видимости функции tester, с применением привычных правил поиска:

C:\\misc> c:\python30\python
\>>> def tester(start):
...     state = start       # Обращение к нелокальным переменным
...     def nested(label):  # действует как обычно
...         print(label, state)  # Извлекает значение state из области
...     return nested            # видимости объемлющей функции
...
\>>> F = tester(0)
\>>> F(‘spam’)
spam 0
\>>> F(‘ham’)
ham 0

 По умолчанию изменение значения переменной в объемлющей области
видимости не допускается – это нормальная ситуация и в версии 2.6:

\>>> def tester(start):
...     state = start
...     def nested(label):
...         print(label, state)
...         state += 1  # По умолчанию не изменяется (как и в 2.6)
...     return nested
...
\>>> F = tester(0)
\>>> F(‘spam’)
UnboundLocalError: local variable ‘state’ referenced before assignment


 Использование инструкции nonlocal для изменения переменных

 Если теперь (при условии, что используется Python 3.0) переменную
state, локальную для функции tester, объявить в функции nested с помощью
инструкции nonlocal, мы сможем изменять ее внутри функции nested.
Этот прием действует, даже несмотря на то, что функция tester
уже завершила работу к моменту, когда мы вызываем функцию nested через
имя F:

\>>> def tester(start):
...     state = start  # В каждом вызове сохраняется свое значение state
...     def nested(label):
...         nonlocal state  # Объект state находится
...         print(label, state)  # в объемлющей области видимости
...         state += 1
# Изменит значение переменной, объявленной как nonlocal
... return nested
...
\>>> F = tester(0)
\>>> F(‘spam’)  # Будет увеличивать значение state при каждом вызове
spam 0
\>>> F(‘ham’)
ham 1
\>>> F(‘eggs’)
eggs 2

 Как обычно, мы можем вызвать фабричную функцию tester множество раз,
и каждый раз в памяти будет создаваться отдельная копия переменной
state. Объект state, находящийся в объемлющей области видимости,
фактически прикрепляется к возвращаемому объекту функции nested – каждый
вызов функции tester создает новый, независимый объект state, благодаря
чему изменение state в одной функции не будет оказывать влияния
на другие. В следующем листинге приводится продолжение предыдущего
интерактивного сеанса:

\>>> G = tester(42)  # Создаст новую функцию, которая начнет счет с 42
\>>> G(‘spam’)
spam 42
\>>> G(‘eggs’)  # Обновит значение state до 43
eggs 43
\>>> F(‘bacon’)  # Но в функции F значение state останется прежним
bacon 3  # Каждая новая функция получает свой экземпляр state


 Граничные случаи

 Важно не упускать из виду несколько моментов. Во-первых, в отличие
от имен, перечисленных в инструкции global, имена в инструкции nonlocal
к моменту объявления уже должны существовать в области видимости
объемлющей функции, в противном случае интерпретатор возбудит
исключение – нельзя создавать имена в объемлющей области видимости
с помощью инструкции присваивания:

\>>> def tester(start):
...     def nested(label):
...         nonlocal state  # Нелокальные переменные должны
...         state = 0       # существовать!
...         print(label, state)
...     return nested
...
SyntaxError: no binding for nonlocal ‘state’ found

\>>> def tester(start):
...     def nested(label):
...         global state  # Глобальные переменные могут отсутствовать
...         state = 0  # Создаст переменную в области видимости модуля
...         print(label, state)
...     return nested
...
\>>> F = tester(0)
\>>> F(‘abc’)
abc 0
\>>> state
0

 Во-вторых, инструкция nonlocal ограничивает область поиска имен
переменных только областями видимости объемлющих функций – поиск
нелокальных переменных не производится за пределами инструкций def
ни в глобальной области видимости объемлющего модуля, ни во встроенной
области видимости, даже если переменные с такими именами там существуют:

\>>> spam = 99
\>>> def tester():
...     def nested():
...         nonlocal spam  # Переменная должна быть внутри def,
...         print(‘Current=’, spam)           # а не в модуле!
...         spam += 1
...     return nested
...
SyntaxError: no binding for nonlocal ‘spam’ found

 Эти ограничения станут понятны, как только вы поймете, что иначе
интерпретатор не смог бы определить, в какой из объемлющих областей
следует создавать совершенно новое имя. Например, где в предыдущем
примере должна была бы быть создана переменная spam при выполнении
инструкции присваивания – в функции tester или в объемлющем модуле?
Из-за этой неоднозначности интерпретатор вынужден определять
местоположение нелокальных имен в момент создания функции,
а не в момент ее вызова.


 Когда следует использовать инструкцию nonlocal?

 Учитывая сложность работы с вложенными функциями, у вас может
появиться вопрос: «Когда следует использовать инструкцию nonlocal?»
Хотя это трудно заметить по нашим маленьким примерам, тем не менее
проблема сохранения информации о состоянии имеет важное значение
во многих программах. В языке Python существуют различные способы
«сохранения» информации между вызовами функций и методов. Каждый
из способов имеет свои преимущества, однако, когда речь заходит
о переменных в областях видимости объемлющих функций, инструкция
nonlocal обеспечивает более оптимальное решение – она позволяет
создавать множество копий переменных, доступных для изменения,
и способна удовлетворить наиболее простые потребности там,
где использование классов может быть нежелательным.

 Как мы видели в предыдущем разделе, следующий программный код
позволяет сохранять и изменять переменные в объемлющей области
видимости. Каждый вызов функции tester создает небольшой самостоятельный
пакет информации, доступной для изменения, имена в котором не вступают
в конфликт с именами в других частях программы:

def tester(start):
    state = start  # Каждый вызов сохраняет отдельный экземпляр state
    def nested(label):
        nonlocal state  # Объект state находится в объемлющей области
        print(label, state)                               # видимости
        state += 1  # Изменит значение переменной,
    return nested   # объявленной как nonlocal

F = tester(0)
F(‘spam’)

 К сожалению, этот программный код будет работать только в Python 3.0.
Если вы используете Python 2.6, используйте другие способы,
в зависимости от преследуемых целей. В следующих двух разделах
приводятся некоторые альтернативные решения.


 Сохранение информации в глобальных переменных

 Обычно для достижения эффекта, который дает применение инструкции
nonlocal, в Python 2.6 и в более ранних версиях достаточно просто
переместить переменную state в глобальную область видимости (в область
видимости модуля):

\>>> def tester(start):
...      global state  # Переместить в область видимости модуля
...      state = start  # global позволяет изменять переменные,
...      def nested(label):  #  находящиеся в области видимости модуля
...         global state
...         print(label, state)
...         state += 1
...     return nested
...
\>>> F = tester(0)
\>>> F(‘spam’)  # Каждый вызов будет изменять глобальную
spam 0          # переменную state
\>>> F(‘eggs’)
eggs 1

 Этот прием может использоваться в данном конкретном случае,
но он требует наличия объявлений global в обеих функциях и может
приводить к конфликтам имен в глобальной области видимости
(что если имя «state» уже используется?). Хуже всего, что этот способ
позволяет создать в области видимости модуля лишь одну копию информации
о состоянии – если вызвать функцию tester еще раз, значение переменной
state будет сброшено в исходное состояние, то есть состояние, измененное
предыдущими вызовами, будет затерто:

\>>> G = tester(42) # Сбросит значение единственной копии state
\>>> G(‘toast’) # в глобальной области видимости
toast 42
\>>> G(‘bacon’)
bacon 43
\>>> F(‘ham’) # Ой – значение моего счетчика было затерто!
ham 44

 Как было показано выше, когда вместо инструкции global используется
инструкция nonlocal, каждый вызов функции tester сохраняет отдельную,
уникальную копию объекта state.


 Сохранение информации с помощью классов (предварительное знакомство)

 Другой способ сохранения доступной для изменения информации о состоянии
в Python 2.6 и в более ранних версиях заключается в использовании
классов с атрибутами. Он обеспечивает более явный доступ к информации,
по сравнению с неявной магией правил поиска имен в областях видимости.
В качестве дополнительного преимущества каждый экземпляр класса получает
свежую копию информации о состоянии, как естественный побочный эффект
объектной модели в языке Python.

 Мы еще не изучали классы во всех подробностях, но в качестве
предварительного знакомства взглянем на комбинацию функций
tester/nested, использовавшихся ранее, как на класс, – информация
о состоянии может быть записана в объекты явно, после их создания.
Чтобы понять следующий пример, вам необходимо знать, что инструкция def
внутри инструкции class действует точно так же, как и за ее пределами.
За исключением того, что функция, определяемая внутри класса,
автоматически получает аргумент self, ссылающийся на объект,
относительно которого был произведен вызов (экземпляр класса,
или объект, создается обращением к имени самого класса как к функции):

\>>> class tester:  # Альтернативное решение на основе классов
...     def __init__(self, start):  # Конструктор объекта,
...         self.state = start   # сохранение информации в новом объекте
...     def nested(self, label):
...         print(label, self.state)  # Явное обращение к информации
...         self.state += 1  # Изменения всегда допустимы
...
\>>> F = tester(0)  # Создаст экземпляр класса, вызовет __init__
\>>> F.nested(‘spam’)  # Ссылка на F будет передана в аргументе self
spam 0
\>>> F.nested(‘ham’)
ham 1
\>>> G = tester(42)   # Каждый экземпляр получает свою копию информации
\>>> G.nested(‘toast’)   # Изменения в одном объекте не сказываются
toast 42                 # на других
\>>> G.nested(‘bacon’)
bacon 43
\>>> F.nested(‘eggs’)  # В объекте F сохранилась прежняя информация
eggs 2
\>>> F.state  # Информация может быть получена за пределами класса
3

 Добавив чуть-чуть волшебства, которое мы еще будем изучать далее в этой
книге, мы могли бы заставить наш класс выглядеть, как обычная функция,
достаточно лишь выполнить перегрузку оператора. Если обратиться
к экземпляру класса, как к функции, то автоматически будет вызван метод
__call__. Благодаря этому мы можем ликвидировать необходимость вызова
именованного метода:

\>>> class tester:
...     def __init__(self, start):
...         self.state = start
...     def __call__(self, label):  # Вызывается при вызове экземпляра
...         print(label, self.state)  # Благодаря этому отпадает
...         self.state += 1           # необходимость в методе .nested()
...
\>>> H = tester(99)
\>>> H(‘juice’)  # Вызовет метод __call__
juice 99
\>>> H(‘pancakes’)
pancakes 100

 Главное сейчас – запомнить, что классы обеспечивают более очевидный
способ сохранения информации о состоянии, используя явное присваивание
атрибутам вместо поиска переменных в областях видимости.

 Даже при том, что классы обеспечивают отличный способ сохранения
информации о состоянии, они могут оказаться слишком тяжеловесным
механизмом в таких простых случаях, когда под информацией о состоянии
подразумевается единственный счетчик. Подобные тривиальные ситуации
встречаются в практике гораздо чаще, чем можно было бы подумать. В таких
случаях вложенные инструкции def могут оказаться более легковесным
способом, чем классы, особенно если учесть, что вы пока не знакомы
с объектно-ориентированным программированием. Кроме того, существуют
ситуации, когда вложенные инструкции def обеспечивают более высокую
производительность по сравнению с классами (смотрите описание метода,
основанного на применении декораторов, в главе 38, где приводятся
примеры, выходящие далеко за рамки этой главы)


 Сохранение информации в атрибутах функций

 В качестве последнего примера рассмотрим, как добиться того же эффекта,
что дает применение инструкции nonlocal, с помощью атрибутов функции –
эти атрибуты, определяемые пользователем, присоединяются непосредственно
к функции. Ниже приводится окончательная версия нашего примера,
основанного на применении этого приема, – в нем объявление nonlocal
замещается атрибутом, присоединяемым к вложенной функции. Кому-то это
может показаться недостаточно очевидным, но данный способ позволяет
получать информацию о состоянии за пределами вложенной функции (при
использовании инструкции nonlocal переменные, объявленные с ее помощью,
доступны только внутри вложенной инструкции def):

\>>> def tester(start):
...     def nested(label):
...         print(label, nested.state)  # nested – объемлющая область
...         nested.state += 1     # Изменит атрибут,           видимости
...         nested.state = start  # а не значение имени nested
...     return nested             # Инициализация после создания функции
...
\>>> F = tester(0)
\>>> F(‘spam’)  # F – это функция ‘nested’
spam 0          # с присоединенным атрибутом state
\>>> F(‘ham’)
ham 1
\>>> F.state  # Атрибут state доступен за пределами функции
2
\>>>
\>>> G = tester(42)  # G имеет собственный атрибут state,
\>>> G(‘eggs’)       # отличный от одноименного атрибута функции F
eggs 42
\>>> F(‘ham’)
ham 2

 Этот программный код опирается на тот факт, что имя функции nested
является локальной переменной в области видимости функции tester,
включающей имя nested, – на это имя можно ссылаться и внутри функции
nested. Кроме того, здесь используется то обстоятельство, что изменение
самого объекта не является операцией присваивания, – операция увеличения
значения nested.state изменяет часть объекта, на который ссылается
имя nested, а не саму переменную с именем nested. Поскольку во вложенной
функции не выполняется операция присваивания, необходимость в инструкции
nonlocal отпадает сама собой.

 Как видите, инструкции global и nonlocal, классы и атрибуты функций
обеспечивают возможность сохранения информации о состоянии между
вызовами. Глобальные переменные могут использоваться только
для поддержки совместно используемых данных; для применения классов
необходимо владеть приемами объектно-ориентированного программирования.
И классы, и атрибуты функций позволяют получать информацию о состоянии
за пределами вложенной функции. Как обычно, выбор наиболее оптимального
инструмента зависит от целей, преследуемых в программе.
"""

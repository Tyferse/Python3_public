"""
 Расширенные возможности функций


 Концепции проектирования функций

 Теперь, когда мы уже имеем некоторое представление об основах
использования функций в языке Python продолжим изучение темы
с нескольких рекомендаций. Когда начинают использоваться функции,
возникает проблема выбора, как лучше связать элементы между собой,
например как разложить задачу на функции (связность), как должны
взаимодействовать функции (взаимодействие) и так далее. Вы должны
учитывать такие особенности, как размер функций, потому что от них
напрямую зависит удобство сопровождения программного кода. Некоторые
из них относятся к категории структурного анализа и проектирования,
но они в равной степени могут применяться и к программному коду.

 Некоторые понятия, имеющие отношение к взаимодействию функций
и модулей, были представлены в главе 17, а здесь мы коротко рассмотрим
некоторые основные правила для тех, кто начинает осваивать язык Python:

  Взаимодействие: для передачи значений функции используйте аргументы,
 для возврата результатов – инструкцию return. Всегда следует стремиться
 сделать функцию максимально независимой от того, что происходит
 за ее пределами. Аргументы и инструкция return часто являются лучшими
 способами ограничить внешнее воздействие небольшим числом известных
 мест в программном коде.

  Взаимодействие: используйте глобальные переменные, только если это
 действительно необходимо. Глобальные переменные (то есть имена
 в объемлющем модуле) обычно далеко не самый лучший способ организации
 взаимодействий с функциями. Они могут порождать зависимости и проблемы
 согласованности, которые существенно осложняют отладку программ.

  Взаимодействие: не воздействуйте на изменяемые аргументы, если
 вызывающая программа не предполагает этого. Функции могут оказывать
 воздействие на части изменяемых объектов, получаемых в виде аргументов,
 но, как и в случае с глобальными переменными, это предполагает слишком
 тесную связь между вызывающей программой и вызываемой функцией,
 что может сделать функцию слишком специфичной и неустойчивой.

  Связность: каждая функция должна иметь единственное назначение.
 Хорошо спроектированная функция должна решать одну задачу, которую
 можно выразить в одном повествовательном предложении.
 Если это предложение допускает слишком широкое толкование (например:
 «эта функция реализует всю программу целиком») или содержит союзы
 (например: «эта функция дает возможность клиентам составлять
 и отправлять заказ на доставку пиццы»), то стоит подумать над тем,
 чтобы разбить ее на отдельные и более простые функции. В противном
 случае окажется невозможным повторно использовать программный код
 функции, в котором смешаны различные действия.

  Размер: каждая функция должна иметь относительно небольшой размер.
 Это условие естественным образом следует из предыдущего, однако если
 функция начинает занимать несколько экранов – это явный признак,
 что пора подумать о том, чтобы разбить ее. Особенно, если учесть
 краткость, присущую языку Python. Длинная функция с большой глубиной
 вложенности часто свидетельствует о промахах в проектировании.
 Сохраняйте функции короткими и простыми.

  Взаимодействие: избегайте непосредственного изменения переменных
 в другом модуле. Мы рассматривали эту концепцию в главе 17
 и еще вернемся к ней в следующей части книги, когда сконцентрируем свое
 внимание на модулях. Однако для справки напомню, что непосредственное
 изменение переменных в других модулях устанавливает тесную зависимость
 между модулями, так же как тесную зависимость устанавливает изменение
 глобальных переменных из функций – модули становятся сложными
 в понимании и малопригодными для многократного использования. Всегда,
 когда это возможно, для изменения переменных модуля вместо прямых
 инструкций присваивания используйте функции доступа.

 На рис. приводится схема организации взаимодействий функций с внешним
миром – входные данные поступают в функции из элементов слева,
а результаты могут возвращаться в любой из форм справа. Опытные
программисты предпочитают использовать для ввода только аргументы,
и для вывода – только инструкцию return.

 Конечно, из приведенных выше правил проектирования есть свои
исключения, включая те, что связаны с поддержкой ООП в языке Python.
Как вы увидите в шестой части книги, классы в языке Python зависят
от изменения передаваемого изменяемого объекта – функции воздействуют
на атрибуты аргумента self, получаемого автоматически, изменяя
информацию о его состоянии (например, self.name = ‘bob’). Кроме того,
когда нет возможности использовать классы, часто наилучший способ
сохранения информации о состоянии между вызовами функций представляют
глобальные переменные в модуле. Побочные эффекты опасны, только когда
их не ожидают.

 Однако в общем случае необходимо стремиться минимизировать внешние
зависимости функций и других компонентов программ. Чем более автономной
является функция, тем проще будет ее понять, использовать и изменять.


 Рекурсивные функции

 При обсуждении областей видимости, в начале главы 17, мы коротко
отметили, что язык Python поддерживает рекурсивные функции – функции,
которые могут вызывать сами себя, прямо или косвенно, образуя цикл.
Рекурсия – это достаточно сложная тема, и она относительно редко
встречается в программах на языке Python. Тем не менее это достаточно
полезный прием, чтобы знать о нем, позволяющий реализовывать обход
структур данных с произвольной и неизвестной заранее организацией.
Рекурсия даже является альтернативой простым циклам и итерациям,
хотя и не обязательно более простой или более производительной.


 Вычисление суммы с применением рекурсии

 Рассмотрим несколько примеров. Чтобы вычислить сумму чисел в списке
(или в другой последовательности), можно либо воспользоваться встроенной
функцией sum, либо написать свою, более специализированную, версию. Ниже
приводится пример такой специализированной функции вычисления суммы,
в которой используется прием рекурсии:

\>>> def mysum(L):
...     if not L:
...         return 0
...     else:
...         return L[0] + mysum(L[1:])   # Вызывает себя саму
\>>> mysum([1, 2, 3, 4, 5])
15

 На каждом уровне рекурсии эта функция вызывает саму себя,
чтобы получить сумму остатка списка, которая складывается с первым
элементом. Рекурсивный цикл заканчивается и возвращается ноль, когда
функция получит пустой список. Когда рекурсия используется, как показано
здесь, на каждом уровне рекурсии для функции создается собственная копия
локальной области видимости на стеке вызовов – в данном случае
это означает, что на каждом уровне создается собственная переменная L.

 Если вам трудно понять это (что вполне характерно для начинающих
программистов), попробуйте добавить в функцию вывод L и запустите пример
еще раз, чтобы увидеть содержимое списка на каждом уровне рекурсии:

\>>> def mysum(L):
...     print(L)     # Поможет отслеживать уровни рекурсии
...     if not L:    # На каждом уровне список L будет получаться короче
...         return 0
...     else:
...         return L[0] + mysum(L[1:])
...
\>>> mysum([1, 2, 3, 4, 5])
[1, 2, 3, 4, 5]
[2, 3, 4, 5]
[3, 4, 5]
[4, 5]
[5]
[]
15

 Как видите, на каждом уровне рекурсии список становится все меньше
и меньше, пока не опустеет, что вызовет конец рекурсивного цикла. Сумма
вычисляется уже в процессе обратного раскручивания рекурсии.


 Альтернативные решения

 Интересно отметить, что мы также можем использовать здесь трехместный
оператор if/else (описанный в главе 12), чтобы сделать программный код
компактнее. Кроме того, мы можем обобщить операцию вычисления суммы
для любых типов данных, поддерживающих операцию сложения (что легко
сделать, если предположить, что входная последовательность содержит
хотя бы один элемент, как это было сделано в главе 18, в примере функции
поиска минимального значения), и использовать расширенную операцию
присваивания последовательностей, имеющуюся в Python 3.0,
чтобы упростить деление последовательности на части первый/остаток
(как описано в главе 11):

def mysum(L):
    return 0 if not L else L[0] + mysum(L[1:])    # Трехместный оператор

def mysum(L):                                     # Суммирует любые типы
    return L[0] if len(L) == 1 else L[0] + mysum(L[1:])   # предполагает
                                       # наличие хотя бы одного значения

def mysum(L):                                   # Использует расширенную
    first, *rest = L                            # операцию присваивания
    return first if not rest else first + mysum(rest)
                                      # последовательностей в Python 3.0

 Последние две функции будут завершаться с ошибкой при получении пустого
списка, но они позволяют находить сумму последовательностей не только
чисел, но и объектов любых типов, поддерживающих операцию +:

\>>> mysum([1])  # mysum([]) будет завершаться ошибкой
1                # в 2 последних функциях
\>>> mysum([1, 2, 3, 4, 5])
15
\>>> mysum((‘s’, ‘p’, ‘a’, ‘m’))  # Но они могут суммировать данные
‘spam’                            # любых типов
\>>> mysum([‘spam’, ‘ham’, ‘eggs’])
‘spamhameggs’

 Если вы внимательно изучите эти три версии, вы обнаружите,
что последние две могут также работать с однострочным аргументом
(например, mysum (‘spam’)), потому что строка – это последовательность
односимвольных строк. Третья версия может работать с любыми итерируемыми
объектами, включая открытые для чтения файлы, однако другие версии такой
возможности не имеют, так как опираются на операцию индексирования.
Если в третьей версии заголовок функции изменить на
def mysum(first, * rest), она вообще работать не будет, потому что
в этом случае она будет ожидать два отдельных аргумента,
а не единственный итерируемый объект.

 Имейте в виду, что рекурсия может быть прямой, как в примерах выше,
или косвенной, как в следующем примере (когда функция вызывает другую
функцию, которая в свою очередь вызывает функцию, вызвавшую ее).
Конечный результат будет тем же самым, только в этом случае на каждом
уровне рекурсии будет выполняться два вызова функций вместо одного:

\>>> def mysum(L):
...     if not L: return 0
...     return nonempty(L)  # Вызов функции, которая вызовет эту функцию
...
\>>> def nonempty(L):
...     return L[0] + mysum(L[1:])  # Косвенная рекурсия
...
\>>> mysum([1.1, 2.2, 3.3, 4.4])
11.0


 Инструкции циклов вместо рекурсии

 Хотя прием рекурсии вполне может использоваться для вычисления сумм
элементов последовательностей, как было показано в предыдущем разделе,
тем не менее для данного случая рекурсия – это слишком тяжеловесный
механизм. В действительности в языке Python рекурсия используется
не так часто, как в более необычных языках программирования, таких как
Prolog или Lisp, потому что в языке Python особое значение придается
простым процедурным инструкциям, таким как циклы, которые более
естественно подходят для решения подобных задач. Цикл while, например,
часто привносит чуть больше конкретики и не требует, чтобы функция была
реализована как рекурсивная:

\>>> L = [1, 2, 3, 4, 5]
\>>> sum = 0
\>>> while L:
...     sum += L[0]
...     L = L[1:]
...
\>>> sum
15

 Инструкция for дает нам еще больше возможностей – выполняя итерации
автоматически, она в большинстве случаев позволяет избавиться
от рекурсии (которая обычно менее эффективна с точки зрения
использования памяти и скорости выполнения):

\>>> L = [1, 2, 3, 4, 5]
\>>> sum = 0
\>>> for x in L: sum += x
...
\>>> sum
15

 При использовании инструкций циклов отпадает необходимость создавать
для каждой итерации копии локальной области видимости в стеке вызовов
и ликвидируются потери времени, необходимые на вызов функции.
(В главе 20 приводится пример измерения скорости выполнения различных
вариантов, подобных этим.)


 Обработка произвольных структур данных

 С другой стороны, рекурсия (или эквивалентные ей алгоритмы, основанные
на использовании стека, которые мы рассмотрим здесь) может оказаться
востребованной для реализации обхода структур данных с произвольной
организацией. В качестве простого примера, который поможет оценить роль
рекурсии в данном контексте, рассмотрим задачу вычисления суммы всех
чисел в структуре, состоящей из вложенных списков, как показано ниже:

[1, [2, [3, 4], 5], 6, [7, 8]]            # Произвольно вложенные списки

 Простые инструкции циклов в этом случае не годятся, потому что
выполнить обход такой структуры с помощью линейных итераций не удастся.
Вложенные инструкции циклов также не могут использоваться, потому что
списки могут иметь произвольные уровни вложенности и иметь произвольную
организацию. Вместо этого следующий пример выполняет обход вложенных
списков с помощью рекурсии:

def sumtree(L):
    tot = 0
    for x in L:                # Обход элементов одного уровня
        if not isinstance(x, list):
            tot += x           # Числа суммируются непосредственно
        else:
            tot += sumtree(x)  # Списки обрабатываются рекурсивными
    return tot                 # вызовами

L = [1, [2, [3, 4], 5], 6, [7, 8]]       # Произвольная глубина вложения
print(sumtree(L))                        # Выведет 36
# Патологические случаи
print(sumtree([1, [2, [3, [4, [5]]]]])) # Выведет 15 (центр тяжести
print(sumtree([[[[[1], 2], 3], 4], 5])) # Выведет 15             справа)
                                        # (центр тяжести слева)

 Проанализируйте два последних вызова, чтобы понять, как эта функция
выполняет обход вложенных списков. Хотя данный пример достаточно
искусственный, тем не менее он является представительным для широкого
круга программ – деревья наследования и цепочки импортирования модулей,
например, могут иметь похожую структуру.

 Обычно в случае линейных итераций предпочтение должно отдаваться
инструкциям циклов по причине их простоты и эффективности, однако иногда
рекурсия может оказаться незаменимой, как будет показано в перечисленных
примерах.

 Кроме того, вы должны знать о возможности возникновения в программах
непреднамеренной рекурсии. Как будет показано ниже в этой книге,
некоторые методы перегрузки операторов в классах, такие как __setattr__
и __getattribute__, при неправильном использовании могут приводить
к рекурсии. Рекурсия – это мощный инструмент, но ее лучше использовать
только тогда, когда без нее невозможно обойтись!


 Функции – это объекты: атрибуты и аннотации


 Косвенный вызов функций

 Так как функции в языке Python являются объектами, можно написать такую
программу, которая будет работать с ними, как с обычными объектами.
Объекты функций могут присваиваться, передаться другим функциям,
сохраняться в структурах данных и так далее, как если бы они были
простыми числами или строками. Кроме того, объекты функций поддерживают
специальные операции: они могут вызываться перечислением аргументов
в круглых скобках, следующих сразу же за выражением функции.
Тем не менее функции принадлежат к категории обычных объектов.

 Мы встречали уже такие способы использования функций в более ранних
примерах, тем не менее краткий обзор поможет нам лучше понять модель
объектов. Например, в имени, которое используется в инструкции def,
нет ничего уникального: это всего лишь переменная, которая создается
в текущей области видимости, как если бы оно стояло слева от знака =.
После того как инструкция def будет выполнена, имя функции представляет
собой всего лишь ссылку на объект – ее можно присвоить другим именам
и вызывать функцию по любому из них (не только по первоначальному
имени):

\>>> def echo(message):    # Имени echo присваивается объект функции
... print(message)
...
\>>> echo(‘Direct call’)   # Вызов объекта по оригинальному имени
Direct call
\>>> x = echo              # Теперь на эту функцию ссылается еще и имя x
\>>> x(‘Indirect call!’)   # Вызов объекта по другому имени
Indirect call              # добавлением ()

 Поскольку аргументы передаются путем присваивания объектов, функции
легко можно передавать другим функциям в виде аргументов. В результате
вызываемая функция может вызвать переданную ей функцию простым
добавлением списка аргументов в круглых скобках:

\>>> def indirect(func, arg):
...     func(arg)                         # Вызов объекта добавлением ()
...
\>>> indirect(echo, ‘Argument call!’)     # Передача функции в функцию
Argument call!

 Существует даже возможность наполнять структуры данных функциями, как
если бы они были простыми числами или строками. В этом нет ничего
необычного, так как составные типы объектов могут содержать объекты
любых типов:

\>>> schedule = [ (echo, ‘Spam!’), (echo, ‘Ham!’) ]
\>>> for (func, arg) in schedule:
...      func(arg)             # Вызов функции, сохраненной в контейнере
...
Spam!
Ham!

 В этом фрагменте просто выполняется обход списка schedule
и производится вызов функции echo с одним аргументом (обратите внимание
на операцию присваивания кортежа в заголовке инструкции цикла for,
которая была представлена в главе 13). Как мы уже видели в главе 17,
функции могут также создаваться и возвращаться другими функциями:

\>>> def make(label):               # Создает функцию, но не вызывает ее
...     def echo(message):
...         print(label + ‘:’ + message)
...     return echo
...
\>>> F = make(‘Spam’) # Метка сохраняется во вложенной области видимости
\>>> F(‘Ham!’)        # Вызов функции, созданной функцией make
Spam:Ham!
\>>> F(‘Eggs!’)
Spam:Eggs!

 Универсальность модели объектов в языке Python и отсутствие
необходимости объявлять типы переменных обеспечивают функциям
невероятную гибкость.


 Интроспекция функций

 Функции являются обычными объектами, поэтому мы можем оперировать
функциями с помощью привычных инструментов. Функции обладают большей
гибкостью, чем можно было бы представить. Например, если мы создали
функцию, мы можем вызвать ее:

\>>> def func(a):
...     b = ‘spam’
...     return b * a
...
\>>> func(8)
‘spamspamspamspamspamspamspamspam’

 Но выражение вызова – это лишь одна из операций, которые могут
применяться к объектам функций. Кроме того, мы можем получить базовый
доступ к атрибутам функции (следующие результаты были получены
в Python 3.0; в версии 2.6 результаты будут похожими):

\>>> func.__name__
‘func’

\>>> dir(func)
[‘__annotations__’, ‘__call__’, ‘__class__’, ‘__closure__’, ‘__code__’,
...остальные имена опущены...
 ‘__repr__’, ‘__setattr__’, ‘__sizeof__’, ‘__str__’, ‘__subclasshook__’]

 Механизмы интроспекции позволяют нам также исследовать детали
реализации – каждая функция, например, имеет присоединенный к ней объект
с программным кодом, из которого можно получить такие сведения,
как список локальных переменных и аргументов:

\>>> func.__code__
<code object func at 0x0257C9B0, file “<stdin>”, line 1>

\>>> dir(func.__code__)
[‘__class__’, ‘__delattr__’, ‘__doc__’, ‘__eq__’, ‘__format__’,
 ‘__ge__’, ...остальные имена опущены...
 ‘co_argcount’, ‘co_cellvars’, ‘co_code’, ‘co_consts’, ‘co_filename’,
 ‘co_firstlineno’, ‘co_flags’, ‘co_freevars’, ‘co_kwonlyargcount’,
 ‘co_lnotab’, ‘co_name’, ‘co_names’, ‘co_nlocals’, ‘co_stacksize’,
 ‘co_varnames’]

\>>> func.__code__.co_varnames
(‘a’, ‘b’)

\>>> func.__code__.co_argcount
1

 Разработчики специализированных инструментов могут использовать эту
информацию для организации управления функциями.


 Атрибуты функций

 Перечень атрибутов, которые могут иметь объекты функций,
не ограничивается предопределенными атрибутами, которые были перечислены
в предыдущем разделе. Как мы узнали в главе 17, к функциям можно
присоединять и свои атрибуты:

\>>> func
<function func at 0x0257C738>

\>>> func.count = 0
\>>> func.count += 1
\>>> func.count
1

\>>> func.handles = ‘Button-Press’
\>>> func.handles
‘Button-Press’

\>>> dir(func)
[‘__annotations__’, ‘__call__’, ‘__class__’, ‘__closure__’, ‘__code__’,
 ...остальные имена опущены...
 __str__’, ‘__subclasshook__’, ‘count’, ‘handles’]

 Как было показано в указанной главе, такие атрибуты можно использовать
для хранения информации о состоянии непосредственно в объекте функции
и отказаться от использования других приемов, таких как применение
глобальных или нелокальных переменных и классов. В отличие
от нелокальных переменных, атрибуты функций доступны в любом месте
программы, где доступна сама функция. В некотором смысле атрибуты можно
рассматривать, как имитацию «статических локальных переменных»,
имеющихся в других языках программирования, – переменных, которые
являются локальными для функции, но сохраняют свои значения после выхода
из функции. Атрибуты связаны с объектами, а не с областями видимости,
но конечный эффект от их использования получается тот же.


 Аннотации функций в версии 3.0

 В Python 3.0 (но не в 2.6) имеется также возможность присоединять
к объектам функций краткое описание (аннотацию) – произвольные данные
об аргументах функции и о возвращаемом значении. Для создания аннотаций
в языке Python используется специальный синтаксис, но интерпретатор
не выполняет никаких операций с ними – аннотации совершенно
необязательны; если они присутствуют, они просто сохраняются в атрибутах
__annotations__ объектов функций и могут использоваться другими
инструментами.

 В предыдущей главе мы познакомились с новой особенностью версии Python
3.0 – с аргументами, которые могут передаваться только по именам.
Аннотации еще больше обобщают синтаксис заголовка функции. Взгляните
на следующую, неаннотированную, функцию, которая принимает три аргумента
и возвращает результат:

\>>> def func(a, b, c):
...     return a + b + c
...
\>>> func(1, 2, 3)
6

 Синтаксически аннотации функций находятся в заголовках инструкций def,
в виде произвольных выражений, ассоциированных с аргументами
и возвращаемыми значениями. Аннотации для аргументов указываются через
двоеточие, сразу после имени аргумента. Для возвращаемого значения –
после символов ->, вслед за списком аргументов. В следующем примере были
добавлены аннотации ко всем трем аргументам и возвращаемому значению
предыдущей функции:

\>>> def func(a: ‘spam’, b: (1, 10), c: float) -> int:
...     return a + b + c
...
\>>> func(1, 2, 3)
6

 Вызов аннотированной функции ничем не отличается от вызова обычной
функции, но если в объявлении функции присутствуют аннотации,
интерпретатор соберет их в словарь и присоединит его к объекту функции.
Имена аргументов станут ключами, аннотация возвращаемого значения будет
сохранена в ключе «return», а значениям ключей этого словаря будут
присвоены результаты выражений в аннотациях:

\>>> func.__annotations__
{‘a’: ‘spam’, ‘c’: <class ‘float’>, ‘b’: (1, 10),
 ‘return’: <class ‘int’>}

 Поскольку аннотация – это всего лишь объект, присоединенный к другому
объекту, ее легко можно обрабатывать. В следующем примере были
аннотированы два аргумента из трех, и затем выполнен обход
присоединенных аннотаций:

\>>> def func(a: ‘spam’, b, c: 99):
...     return a + b + c
...
\>>> func(1, 2, 3)
6

\>>> func.__annotations__
{‘a’: ‘spam’, ‘c’: 99}

\>>> for arg in func.__annotations__:
...     print(arg, ‘=>’, func.__annotations__[arg])
...
a => spam
c => 99

 Обратите внимание на два интересных момента. Во-первых,
в аннотированных аргументах все еще можно указывать значения
по умолчанию – аннотация (и символ :) находится перед значением
по умолчанию (и перед символом =). В следующем примере фрагмент
a: ‘spam’ = 4 означает, что аргумент a по умолчанию получает значение 4
и аннотирован строкой ‘spam’:

\>>> def func(a: ‘spam’ = 4, b: (1, 10) = 5, c: float = 6) -> int:
...     return a + b + c
...
\>>> func(1, 2, 3)
6
\>>> func()   # 4 + 5 + 6 (все аргументы получают значения по умолчанию)
15
\>>> func(1, c=10)  # 1 + 5 + 10 (именованные аргументы действуют
16                                                         # как обычно)
\>>> func.__annotations__
{‘a’: ‘spam’, ‘c’: <class ‘float’>, ‘b’: (1, 10),
 ‘return’: <class ‘int’>}

 Во-вторых, обратите внимание, что все пробелы в предыдущем примере
являются необязательными – вы можете использовать или не использовать
пробелы между компонентами в заголовках функций, однако отказ
от использования пробелов может ухудшить удобочитаемость программного
кода:

\>>> def func(a:’spam’=4, b:(1,10)=5, c:float=6)->int:
...     return a + b + c
...
\>>> func(1, 2) # 1 + 2 + 6
9
\>>> func.__annotations__
{‘a’: ‘spam’, ‘c’: <class ‘float’>, ‘b’: (1, 10),
 ‘return’: <class ‘int’>}

 Аннотации – это новая особенность, появившаяся в версии 3.0,
и исследованы не все аспекты их практического применения. Однако легко
представить себе, как аннотации могут использоваться для наложения
ограничений на типы или значения аргументов, и в крупных системах эта
особенность могла бы использоваться для регистрации информации
об интерфейсе. В главе 38 мы познакомимся с некоторыми применениями
аннотаций, когда будем рассматривать их как альтернативу аргументам
декораторов функций (более общая концепция, когда информация
располагается за пределами заголовка функции и потому не ограничивается
единственной ролью). Как и сам язык Python, аннотации – это инструмент,
область применения которого ограничивается лишь вашим воображением.

 Наконец, обратите внимание, что аннотации могут указываться только
в инструкциях def, – они не могут использоваться в lambda-выражениях,
потому что синтаксис lambda-выражений уже ограничивает область
использования функций, определяемых таким способом. На удивление,
lambda-выражения – это тема нашего следующего раздела.
"""

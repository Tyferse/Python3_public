"""
 Анонимные функции: lambda

 Помимо инструкции def в языке Python имеется возможность создавать
объекты функций в форме выражений. Из-за сходства с аналогичной
возможностью в языке LISP она получила название lambda. Подобно
инструкции def это выражение создает функцию, которая будет вызываться
позднее, но в отличие от инструкции def, выражение возвращает функцию,
а не связывает ее с именем. Именно поэтому lambda-выражения иногда
называют анонимными (то есть безымянными) функциями. На практике они
часто используются, как способ получить встроенную функцию или отложить
выполнение фрагмента программного кода.


 Основы lambda-выражений

 В общем виде lambda-выражение состоит из ключевого слова lambda,
за которым следуют один или более аргументов (точно так же, как список
аргументов в круглых скобках в заголовке инструкции def) и далее,
вслед за двоеточием, находится выражение:

 lambda argument1, argument2,... argumentN : выражение, использующее
аргументы В качестве результата lambda-выражения возвращают точно
такие же объекты функций, которые создаются инструкциями def, но здесь
есть несколько различий, которые делают lambda-выражения удобными
в некоторых специализированных случаях:

  lambda – это выражение, а не инструкция. По этой причине ключевое
 слово lambda может появляться там, где синтаксис языка Python
 не позволяет использовать инструкцию def, – внутри литералов
 или в вызовах функций, например. Кроме того, lambda-выражение
 возвращает значение (новую функцию), которое при желании можно
 присвоить переменной, в противовес инструкции def, которая всегда
 связывает функцию с именем в заголовке, а не возвращает ее
 в виде результата.

  Тело lambda – это не блок инструкций, а единственное выражение. Тело
 lambda-выражения сродни тому, что вы помещаете в инструкцию return
 внутри определения def, – вы просто вводите результат в виде выражения
 вместо его явного возврата. Вследствие этого ограничения
 lambda-выражения менее универсальны, чем инструкция def – в теле
 lambda-выражения может быть реализована только логика, не использующая
 такие инструкции, как if. Такая реализация предусмотрена заранее – она
 ограничивает возможность создания большого числа уровней вложенности
 программ: lambda-выражения предназначены для создания простых функций,
 а инструкции def – для решения более сложных задач.

 Если отвлечься от этих различий, def и lambda выполняют одну и ту же
работу. Например, мы уже видели, как создаются функции с помощью
инструкции def:

\>>> def func(x, y, z): return x + y + z
...
\>>> func(2, 3, 4)
9

 Но того же эффекта можно достигнуть с помощью lambda-выражения, явно
присвоив результат имени, которое позднее будет использоваться
для вызова функции:

\>>> f = lambda x, y, z: x + y + z
\>>> f(2, 3, 4)
9

 Здесь имени f присваивается объект функции, созданный
lambda-выражением, – инструкция def работает точно так же,
но присваивание выполняет автоматически.

 В lambda-выражениях точно так же можно использовать аргументы
со значениями по умолчанию:

\>>> x = (lambda a=”fee”, b=”fie”, c=”foe”: a + b + c)
\>>> x(“wee”)
‘weefiefoe’

 Для lambda-выражений используются те же самые правила поиска переменных
в областях видимости, что и для вложенных инструкций def.
lambda-выражения создают локальную область видимости, как и вложенные
инструкции def, и автоматически получают доступ к именам в объемлющих
функциях, в модуле и во встроенной области видимости (в соответствии
с правилом LEGB):

\>>> def knights():
...     title = ‘Sir’
...     action = (lambda x: title + ‘ ‘ + x)   # Заголовок в объемлющей
...     return action            # Возвращает функцию                def
...
\>>> act = knights()
\>>> act(‘robin’)
‘Sir robin’


 Когда можно использовать lambda-выражения?

 Вообще говоря, lambda-выражения очень удобны для создания очень
маленьких функций, к тому же они позволяют встраивать определения
функций в программный код, который их использует. Они не являются
предметом первой необходимости (вы всегда сможете вместо них
использовать инструкции def), но они позволяют упростить сценарии,
где требуется внедрять небольшие фрагменты программного кода.

 Например, позднее мы увидим, что функции обратного вызова часто
реализуются в виде lambda-выражений, встроенных непосредственно
в список аргументов, вместо инструкций def где-то в другом месте
в модуле и передаваемых по имени (примеры вы найдете во врезке
«Придется держать в уме: функции обратного вызова» ниже в этой главе).

 lambda-выражения также часто используются для создания таблиц
переходов, которые представляют собой списки или словари действий,
выполняемых по требованию. Например:

L = [lambda x: x**2,  # Встроенные определения функций
     lambda x: x**3,
     lambda x: x**4]  # Список из трех функций
for f in L:
    print(f(2))  # Выведет 4, 8, 16

print(L[0](3))  # Выведет 9

 lambda-выражения наиболее полезны в качестве сокращенного варианта
инструкции def, когда необходимо вставить маленькие фрагменты
исполняемого программного кода туда, где использование инструкций
недопустимо. Например, этот фрагмент программного кода создает список
из трех функций, встраивая lambda-выражения в литерал списка. Инструкция
def не может быть вставлена в литерал, потому что это – инструкция,
а не выражение. Для реализации эквивалентной таблицы переходов
с применением инструкций def потребовалось бы создать именованные
функции за пределами контекста их использования:

def f1(x): return x ** 2
def f2(x): return x ** 3  # Определения именованных функций
def f3(x): return x ** 4

L = [f1, f2, f3]  # Ссылка по имени

for f in L:
    print(f(2))  # Выведет 4, 8, 16

print(L[0](3))  # Выведет 9

 В действительности, подобные таблицы действий в языке Python можно
создавать с помощью словарей и других структур данных. Ниже приводится
другой пример, выполненный в интерактивном сеансе:

\>>> key = ‘got’
\>>> {‘already’: (lambda: 2 + 2),
...   ‘got’: (lambda: 2 * 4),
...   ‘one’: (lambda: 2 ** 6)}[key]()
8

 В данном случае, когда интерпретатор создает словарь, каждое
из вложенных lambda-выражений генерирует и оставляет после себя функцию
для последующего использования – обращение по ключу извлекает одну
из этих функций, а круглые скобки обеспечивают вызов извлеченной
функции. При таком подходе словарь превращается в более универсальное
средство множественного выбора, чем то, что я смог реализовать на основе
инструкции if в главе 12.

 Чтобы реализовать то же самое без использования lambda-выражений,
пришлось бы написать три отдельные инструкции def за пределами словаря,
в котором эти функции используются, и ссылаться на функции по их именам:

\>>> def f1(): return 2 + 2
...
\>>> def f2(): return 2 * 4
...
\>>> def f3(): return 2 ** 6
...
\>>> key = ‘one’
\>>> {‘already’: f1, ‘got’: f2, ‘one’: f3}[key]()
64

 Этот прием тоже будет работать, но ведь инструкции def могут
располагаться в файле модуля достаточно далеко, несмотря на то,
что они очень короткие. Близость программного кода, которую обеспечивают
lambda-выражения, особенно полезна, когда функции используются
в единственном месте – если три функции в этом фрагменте не используются
где-то еще, определенно имеет смысл встроить их в определение словаря
в виде lambda-выражений. Кроме того, инструкции def требуют даже
для маленьких функций указывать имена, а они могут вступить в конфликт
с другими именами в файле модуля (возможно, хотя и маловероятно).

 lambda-выражения также очень удобно использовать в списках аргументов
функций – для определения временных функций, которые больше нигде
в программе не используются, – мы увидим примеры такого использования
ниже, в этой главе, когда будем изучать функцию map.


 Как (не) запутать программный код на языке Python

 Тот факт, что lambda должно быть единственным выражением (а не серией
инструкций), казалось бы, устанавливает серьезное ограничение на объем
логики, которую можно упаковать в lambda-выражение. Однако если вы
понимаете, что делаете, большую часть инструкций языка Python можно
представить в форме выражений.

 Например, представим, что необходимо вывести некоторую информацию
из тела lambda-выражения, тогда достаточно просто записать sys.stdout.
write(str(x)+’\n’) вместо print(x) (в главе 11 объяснялось,
что это именно то действие, которое выполняет инструкция print).
Точно так же в lambda-выражение можно заложить логику в виде
трехместного выражения if/else, представленного в главе 12,
или использовать эквивалентную, хотя и более сложную комбинацию
операторов and/or, описанную там же. Как уже говорилось ранее,
следующую инструкцию:

if a:
    b
else:
    c

 можно представить в виде одного из следующих примерно эквивалентных
выражений:

b if a else c
((a and b) or c)

 Так как выражения, подобные этим, допустимо помещать внутрь
lambda-выражения, они могут использоваться для реализации логики выбора
внутри lambda-функций:

\>>> lower = (lambda x, y: x if x < y else y)
\>>> lower(‘bb’, ‘aa’)
‘aa’
\>>> lower(‘aa’, ‘bb’)
‘aa’

 Кроме того, если внутри lambda-выражения потребуется выполнять циклы,
их можно заменить вызовами функции map и генераторами списков (с ними мы
уже познакомились в предыдущих главах и вернемся к ним еще раз
в следующей главе):

\>>> import sys
\>>> showall = lambda x: list(map(sys.stdout.write, x))   # Функция list
                                                      # необходима в 3.0
\>>> t = showall([‘spam\n’, ‘toast\n’, ‘eggs\n’])
spam
toast
eggs

\>>> showall = lambda x: [sys.stdout.write(line) for line in x]
\>>> t = showall((‘bright\n’, ‘side\n’, ‘of\n’, ‘life\n’))
bright
side
of
life

 Теперь, когда я продемонстрировал вам некоторые уловки, я должен
просить вас использовать их только в случае крайней необходимости.
Без должной осторожности они могут сделать программный код нечитабельным
(запутанным). Вообще, простое лучше сложного, явное лучше неявного,
а понятные инструкции лучше заумных выражений. Именно поэтому lambda
ограничивается выражениями. Если необходимо реализовать сложную логику,
используйте инструкцию def – lambda-выражения должны использоваться
только для небольших фрагментов программного кода. С другой стороны,
при умеренном использовании эти приемы могут быть полезны.


 Вложенные lambda-выражения и области видимости

 lambda-выражения чаще других используют возможность поиска в области
видимости вложенной функции (символ E в названии правила LEGB, с которым
мы познакомились в главе 17). Например, следующее ниже lambda-выражение
находится внутри инструкции def – типичный случай – и потому получает
значение имени x из области видимости объемлющей функции, имевшееся
на момент ее вызова:

\>>> def action(x):
...     return (lambda y: x + y)  # Создать и вернуть ф-цию, запомнить x
\>>> act = action(99)
\>>> act
<function <lambda> at 0x00A16A88>
\>>> act(2)  # Вызвать функцию, созданную функцией action
101

 Ранее, когда обсуждались области видимости вложенных функций,
не говорилось о том, что lambda-выражения обладают доступом к именам
во всех объемлющих lambda-выражениях. Это сложно себе вообразить,
но представьте, что мы записали предыдущую инструкцию def в виде
lambda-выражения:

\>>> action = (lambda x: (lambda y: x + y))
\>>> act = action(99)
\>>> act(3)
102
\>>> ((lambda x: (lambda y: x + y))(99))(4)
103

 Эта структура lambda-выражений создает функцию, которая при вызове
создает другую функцию. В обоих случаях вложенное lambda-выражение имеет
доступ к переменной x в объемлющем lambda-выражении. Этот фрагмент будет
работать, но программный код выглядит весьма замысловато, поэтому
в интересах соблюдения удобочитаемости лучше избегать использования
вложенных друг в друга lambda-выражений.


 Придется держать в уме: функции обратного вызова

 Другое распространенное применение lambda-выражений состоит
в определении функций обратного вызова для tkinter GUI API (в Python 2.6
этот модуль называется Tkinter). Например, следующий фрагмент создает
кнопку, по нажатию которой на консоль выводится сообщение; при этом
предполагается, что модуль tkinter доступен на вашем компьютере
(в Windows и в других операционных системах он доступен по умолчанию):
"""

import sys
from tkinter import Button, mainloop  # Tkinter в Python 2.6
x = Button(text='Press me',
           command=(lambda: sys.stdout.write('Spam\n')))
x.pack()
mainloop()

"""
 Здесь в качестве обработчика события регистрируется функция, 
сгенерированная lambda-выражением в аргументе command. Преимущество
lambda-выражения перед инструкцией def в данном случае состоит в том,
что обработчик события нажатия на кнопку находится прямо здесь же,
в вызове функции, создающей эту кнопку.

 В действительности lambda-выражение откладывает исполнение обработчика
до того момента, пока не произойдет событие: вызов метода write 
произойдет, когда кнопка будет нажата, а не когда она будет создана.

 Поскольку правила областей видимости вложенных функций применяются 
и к lambda-выражениям, их проще использовать в качестве функций 
обратного вызова. Начиная с версии Python 2.2, они автоматически
получают доступ к переменным объемлющих функций и в большинстве
случаев не требуют передачи параметров со значениями по умолчанию.
Это особенно удобно при обращении к специальному аргументу экземпляра 
self, который является локальной переменной в объемлющих методах классов
(подробнее о классах рассказывается в шестой части книги):

class MyGui:
    def makewidgets(self):
        Button(command=(lambda: self.onPress(“spam”)))
    def onPress(self, message):
        ...использовать текст сообщения...
        
 В предыдущих версиях даже self приходилось передавать в виде аргумента
со значением по умолчанию.


 Отображение функций на последовательности: map
 
 Одна из наиболее часто встречающихся задач, которые решаются 
в программах, состоит в применении некоторой операции к каждому элементу
в списке или в другой последовательности и сборе полученных результатов.
Например, обновление всех счетчиков в списке может быть выполнено 
с помощью простого цикла for:

>>> counters = [1, 2, 3, 4]
>>>
>>> updated = []
>>> for x in counters:
...     updated.append(x + 10)  # Прибавить 10 к каждому элементу
...
>>> updated
[11, 12, 13, 14]

 Но так как такие операции встречаются достаточно часто, язык Python
предоставляет встроенную функцию, которая выполняет большую часть этой
работы. Функция map применяет указанную функцию к каждому элементу 
последовательности и возвращает список, содержащий результаты всех
вызовов функции. Например:

>>> def inc(x): return x + 10  # Функция, которая должна быть вызвана
...
>>> map(inc, counters)  # Сбор результатов
[11, 12, 13, 14]

 Функция map была представлена в главах 13 и 14 как средство применения
встроенной функции к элементам в итерируемом объекте. Здесь мы будем 
передавать пользовательскую функцию, которая будет применяться ко всем 
элементам списка – функция map вызывает функцию inc для каждого элемента
списка и собирает полученные результаты в новый список. Не забывайте, 
что функция map в Python 3.0 возвращает итерируемый объект, поэтому 
для вывода всех результатов в интерактивной оболочке мы используем 
функцию list; этого не требуется в Python 2.6.

 Функция map ожидает получить в первом аргументе функцию, поэтому здесь
часто можно встретить lambda-выражения:

>>> list(map((lambda x: x + 3), counters))  # Выражение-функция
[4, 5, 6, 7]

 В данном случае функция прибавляет число 3 к каждому элементу списка
counters, а так как эта функция нигде в другом месте больше 
не используется, она оформлена в виде lambda-выражения. Такой вариант
использования функции map представляет собой эквивалент цикла for,
поэтому, написав несколько строк, эту утилиту в общем виде вы можете
реализовать самостоятельно:

>>> def mymap(func, seq):
...     res = []
...     for x in seq: res.append(func(x))
...     return res

 Предположим, что функция inc осталась прежней, как было показано выше,
тогда мы можем отобразить ее на последовательность с помощью встроенной
функции map или нашей версии mymap:

>>> list(map(inc, [1, 2, 3]))  # Встроенная функция map возвращает
[11, 12, 13]                   # итератор
>>> mymap(inc, [1, 2, 3])      # Наша функция возвращает список 
[11, 12, 13]

 Однако функция map является встроенной функцией, поэтому она доступна 
всегда, всегда работает одним и тем же способом и обладает некоторыми
преимуществами производительности (как мы узнаем в следующей главе,
она выполняется быстрее, чем любой цикл for). Кроме того, функция map 
может использоваться в более сложных ситуациях, чем показано здесь.
Например, в данном случае имеется несколько аргументов
с последовательностями, а функция map извлекает их параллельно 
и передает как отдельные аргументы в функцию:

>>> pow(3, 4)  # 3 ** 4
81
>>> map(pow, [1, 2, 3], [2, 3, 4]) # 1**2, 2**3, 3**4 # 1**2, 2**3, 3**4
[1, 8, 81]

 При передаче нескольких последовательностей функция map предполагает, 
что ей будет передана функция, принимающая N аргументов 
для N последовательностей. Здесь функция pow при каждом вызове принимает
от функции map два аргумента – по одному из каждой последовательности. 
Мы могли бы реализовать свою собственную функцию, имитирующую
это действие, но вполне очевидно, что в этом нет никакой необходимости,
так как имеется высокопроизводительная встроенная функция.

 Этот вызов функции map напоминает генераторы списков, которые 
рассматривались в главе 14, и с которыми мы встретимся еще раз 
в следующей главе. Основное отличие состоит в том, что map применяет 
к каждому элементу последовательности не произвольное выражение, 
а функцию. Вследствие этого ограничения она обладает меньшей гибкостью. 
Однако, современная реализация map в некоторых случаях обладает более 
высокой производительностью, чем генераторы списков (например, когда 
отображается встроенная функция), и использовать ее проще.


 Средства функционального программирования: filter и reduce
 
 Функция map – это простейший представитель класса встроенных функций
в языке Python, используемых в функциональном программировании, то есть
функций, которые применяют другие функции к последовательностям 
и к другим итерируемым объектам. Родственные ей функции отфильтровывают
элементы с помощью функций, выполняющих проверку (filter), и применяют
функции к парам элементов, накапливая результаты (reduce). Например, 
следующий вызов функции filter отбирает элементы последовательности 
больше нуля:

>>> list(range(-5, 5))  # Итератор в Python 3.0
[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]
>>> filter((lambda x: x > 0), range(-5, 5))  # Итератор в Python 3.0
[1, 2, 3, 4]

 Элементы последовательности, для которых применяемая функция возвращает 
истину, добавляются в список результатов. Как и map, функция filter 
является примерным эквивалентом цикла for, только она – встроенная
функция и обладает высокой скоростью выполнения:

>>> res = [ ]
>>> for x in range(-5, 5):
...     if x > 0:
...         res.append(x)
...
>>> res
[1, 2, 3, 4]

 Функция reduce в Python 2.6 была простой встроенной функцией,
но в версии 3.0 она была перемещена в модуль functools и стала более 
сложной. Она принимает итератор, но сама возвращает не итератор,
а одиночный объект. Ниже приводятся два вызова функции reduce, которые 
вычисляют сумму и произведение элементов списка:

>>> from functools import reduce             # В 3.0 требуется выполнить 
>>> reduce((lambda x, y: x + y), [1, 2, 3, 4])          # импортирование
10
>>> reduce((lambda x, y: x * y), [1, 2, 3, 4])
24

 На каждом шаге функция reduce передает текущую сумму или произведение
вместе со следующим элементом списка lambda-функции. По умолчанию первый
элемент последовательности принимается в качестве начального значения.
Ниже приводится цикл for, эквивалентный первому вызову, с жестко 
заданной операцией сложения внутри цикла:

>>> L = [1,2,3,4]
>>> res = L[0]
>>> for x in L[1:]:
...     res = res + x
...
>>> res
10

 Написать свою версию функции reduce достаточно просто. Следующая 
функция имитирует большинство особенностей встроенной функции 
и помогает понять принцип ее действия:

>>> def myreduce(function, sequence):
...     tally = sequence[0]
...     for next in sequence[1:]:
...         tally = function(tally, next)
...
...     return tally
...
>>> myreduce((lambda x, y: x + y), [1, 2, 3, 4, 5])
15
>>> myreduce((lambda x, y: x * y), [1, 2, 3, 4, 5])
120

 Кроме того, встроенная функция reduce может принимать третий
необязательный аргумент, который используется в качестве начального 
значения и служит значением по умолчанию, когда передаваемая 
последовательность не содержит ни одного элемента, но я оставлю
тестирование этой особенности вам в качестве упражнения.

 Если этот пример разжег ваш интерес, загляните также во встроенный 
модуль operator, содержащий функции, соответствующие встроенным
выражениям, которые могут пригодиться при использовании некоторых 
функциональных инструментов (за дополнительными подробностями 
об этом модуле обращайтесь к руководству по стандартной
библиотеке Python):

>>> import operator, functools
>>> functools.reduce(operator.add, [2, 4, 6]) 
12                                      # Оператор сложения в виде ф-ции
>>> functools.reduce((lambda x, y: x + y), [2, 4, 6])
12

 Вместе с функцией map, filter и reduce поддерживают мощные приемы
функционального программирования. Некоторые программисты могут
также дополнить комплект средств функционального программирования языка 
Python lambda-выражениями, рассматривавшимися выше, и генераторами 
списков, которые рассматриваются в следующей главе.
"""

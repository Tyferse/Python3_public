"""
 Короткий пример: интерактивные циклы

 Мы увидим все эти синтаксические правила в действии, когда будем
совершать турне по конкретным составным инструкциям языка Python
в нескольких следующих главах, но эти правила работают одинаково везде
в языке Python. Для начала рассмотрим короткий практический пример,
который продемонстрирует способ применения синтаксических правил
к оформлению инструкций и вложенных блоков на практике и попутно
познакомит вас с некоторыми инструкциями.


 Простой интерактивный цикл

 Предположим, что от нас требуется написать программу на языке Python,
которая взаимодействует с пользователем в окне консоли. Возможно,
программа будет принимать информацию для дальнейшей передачи
в базу данных или числа для выполнения расчетов. Независимо
от конечной цели, вам необходимо написать цикл, который будет считывать
одну или более строк, введенных пользователем с клавиатуры,
и выводить их обратно на экран. Другими словами, вам нужно написать
классический цикл, выполняющий операции чтения/вычисления/вывода.

 В языке Python для реализации таких интерактивных циклов используется
типичный шаблон, который выглядит, как показано ниже:

while True:
    reply = input(‘Enter text:’)
    if reply == ‘stop’: break
    print(reply.upper())

 В этом фрагменте использованы несколько новых для вас идей:

  Программный код выполняется в цикле while, который в языке Python
является наиболее универсальной инструкцией цикла. Подробнее
об инструкции while мы будем говорить позднее, но в двух словах замечу,
что она состоит из слова while, за которым следует условное выражение.
Результат этого выражения интерпретируется как истина или как ложь.
Далее следует вложенный блок программного кода, который продолжает
выполняться в цикле, пока условное выражение возвращает истину (слово
True здесь всегда возвращает значение истины).

  Встроенная функция input, с которой мы уже встречались ранее
в этой книге, используется здесь как универсальное средство получения
ввода с клавиатуры – она выводит подсказку, текст которой содержится
в необязательном строковом аргументе, и возвращает введенный
пользователем ответ в виде строки.

  Однострочная инструкция if, которая оформлена в соответствии
 со специальным правилом для вложенных блоков: тело инструкции if
 располагается в той же строке, что и основная инструкция, после символа
 двоеточия, а не на отдельной строке под ней с соответствующим отступом.
 Она одинаково хорошо работала бы при любом из двух вариантов
 оформления, но при таком подходе нам удалось сэкономить одну строку.

  Наконец, для немедленного выхода из цикла использована инструкция
 break – она просто выполняет выход за пределы инструкции цикла
 и программа продолжает свою работу с первой инструкции, которая
 расположена вслед за циклом. Без этой инструкции цикл while работал бы
 вечно, поскольку его условное выражение всегда возвращает истину.

 В результате такая комбинация инструкций означает следующее:
«читать строки, введенные пользователем,4 и выводить их после
преобразования всех символов в верхний регистр, пока пользователь
не введет строку “stop”». Существуют и другие способы записи такого
цикла, но данная форма очень часто встречается в программах
на языке Python.

 Обратите внимание, что все три строки, вложенные в инструкцию цикла
while, имеют одинаковые отступы, благодаря этому они визуально образуют
вертикальную линию блока программного кода, ассоциированного
с инструкцией цикла while. Тело цикла завершается либо с концом файла,
либо с первой инструкцией, имеющей меньший отступ.

 Запустив этот фрагмент, мы получили следующий порядок взаимодействий
с ним:

Enter text:spam
SPAM
Enter text:42
42
Enter text:stop


 Математическая обработка данных пользователя

 Итак, наш сценарий работает, а теперь предположим, что вместо
преобразования символов текстовой строки в верхний регистр
нам необходимо выполнить некоторые математические действия
над введенными пользователем числами, – например, вычислить квадраты
чисел, что может получиться не совсем так, как ожидают наиболее молодые
и нетерпеливые пользователи. Для достижения желаемого эффекта мы могли
бы попробовать использовать следующие инструкции:

\>>> reply = ‘20’
\>>> reply ** 2
...текст сообщения об ошибке опущен...
TypeError: unsupported operand type(s) for ** or pow(): ‘str’ and ‘int’

 Этот прием не работает, потому что (как обсуждалось в предыдущей части
книги) интерпретатор выполняет преобразование типов объектов
в выражениях, только если они являются числами, а ввод пользователя
всегда передается сценарию в виде строки. Мы не можем возвести строку
цифр в степень, не преобразовав ее в целое число вручную:

\>>> int(reply) ** 2
400

 Вооружившись этой информацией, мы можем переделать наш цикл
для выполнения математических действий:

while True:
    reply = input(‘Enter text:’)
    if reply == ‘stop’: break
    print(int(reply) ** 2)
print(‘Bye’)

 В этом сценарии используется однострочная инструкция if, которая,
как и прежде, производит выход из цикла по получении от пользователя
строки “stop”, а кроме того, выполняется преобразование введенной строки
для выполнения необходимой математической операции. В данную версию
сценария также было добавлено сообщение, которое выводится в момент
завершения работы сценария. Поскольку инструкция print в последней
строке не имеет такого же отступа, как инструкции вложенного блока,
она не считается частью тела цикла и будет выполняться только один раз –
после выхода из цикла:

Enter text:2
4
Enter text:40
1600
Enter text:stop
Bye

 Небольшое примечание: я предполагаю, что этот фрагмент был сохранен
в файле сценария и запускается из него. Если вы вводите этот программный
код в интерактивном сеансе, не забудьте добавить пустую строку
(- то есть нажать клавишу Enter дважды) перед заключительной
инструкцией print, чтобы завершить тело цикла. Впрочем,
нет никакого смысла вводить последнюю инструкцию print
в интерактивном сеансе (вы будете вводить ее уже после того,
как завершите ввод чисел в цикле!).


 Обработка ошибок проверкой ввода

 Пока все идет хорошо, но посмотрите, что произойдет, если пользователь
введет неверную строку:

Enter text:xxx
...текст сообщения об ошибке опущен...
ValueError: invalid literal for int() with base 10: ‘xxx’

 Встроенная функция int возбуждает исключение, когда сталкивается
с ошибкой. Если нам необходимо обеспечить устойчивость сценария,
мы должны предварительно проверить содержимое строки с помощью
строкового метода isdigit:

\>>> S = ‘123’
\>>> T = ‘xxx’
\>>> S.isdigit(), T.isdigit()
(True, False)

 Для этого в наш пример необходимо добавить вложенные операторы.
В следующей версии нашего интерактивного сценария используется полная
версия условной инструкции if, с помощью которой предотвращается
возможность появления исключений:

while True:
    reply = input(‘Enter text:’)
    if reply == ‘stop’:
        break
    elif not reply.isdigit( ):
        print(‘Bad!’ * 8)
    else:
        print(int(reply) ** 2)
print ‘Bye’

 Более подробно мы будем рассматривать инструкцию if в главе 12.
Это очень простой инструмент программирования логики выполнения
сценария. В своей полной форме инструкция содержит слово if,
за которым следуют выражение проверки условия и вложенный блок кода,
один или более необязательных проверок elif (“else if”)
и соответствующих им вложенных блоков кода и необязательная часть else
со связанным с ней блоком кода, который выполняется при несоблюдении
условия. Интерпретатор выполняет первый блок кода, для которого проверка
дает в результате истину, проходя инструкцию сверху вниз,
либо часть else, если все проверки дали в результате ложь.

 Части if, elif и else в предыдущем примере принадлежат одной и той же
инструкции, так как вертикально они расположены на одной линии (то есть
имеют одинаковые отступы). Инструкция if простирается до начала
инструкции print в последней строке. В свою очередь, весь блок
инструкции if является частью цикла while, потому что вся она смещена
вправо относительно основной инструкции цикла. Вложение инструкций
станет для вас естественным, как только вы приобретете соответствующие
навыки.

 Теперь новый сценарий будет обнаруживать ошибки прежде, чем они будут
обнаружены интерпретатором, и выводить (возможно, глупое) сообщение:

Enter text:5
25
Enter text:xyz
Bad!Bad!Bad!Bad!Bad!Bad!Bad!Bad!
Enter text:10
100
Enter text:stop


 Обработка ошибок с помощью инструкции try

 Предыдущее решение работает, но, как будет показано далее в книге,
в языке Python существует более универсальный способ, который состоит
в том, чтобы перехватывать и обрабатывать ошибки с помощью инструкции
try. Эта инструкция подробно будет рассматриваться в последней части
книги, но, использовав инструкцию try в качестве предварительного
знакомства, мы можем упростить программный код предыдущей версии
сценария:

while True:
    reply = input(‘Enter text:’)
    if reply == ‘stop’: break
    try:
        num = int(reply)
    except:
        print(‘Bad!’ * 8)
    else:
        print(int(reply) ** 2)
print ‘Bye’

 Эта версия работает точно так же, как и предыдущая, только здесь
мы заменили явную проверку наличия ошибки программным кодом, который
предполагает, что преобразование будет выполнено и выполняет обработку
исключения, если такое преобразование невозможно. Эта инструкция try
состоит из слова try, вслед за которым следует основной блок кода
(действие, которые мы пытаемся выполнить), с последующей частью except,
где располагается программный код обработки исключения. Далее следует
часть else, программный код которой выполняется, если в части try
исключение не возникло. Интерпретатор сначала выполняет часть try,
затем выполняет либо часть except (если возникло исключение),
либо часть else (если исключение не возникло).

 В терминах вложенности инструкций, так как слова try, except и else
имеют одинаковые отступы, все они считаются частью одной и той же
инструкции try. Обратите внимание, что в данном случае часть else
связана с инструкцией try, а не с условной инструкцией if. Как будет
показано далее в книге, ключевое слово else в языке Python может
появляться не только в инструкции if, но и в инструкции try и в циклах –
величина отступа наглядно показывает, частью какой инструкции оно
является. В данном случае инструкция try начинается со слова try
и продолжается до конца вложенного блока кода, следующего за словом
else, потому что else располагается на том же расстоянии от левого края,
что и try. Инструкция if в этом примере занимает всего одну строку
и завершается сразу же за словом break.

 Напомню, что к инструкции try мы еще вернемся далее в этой книге.
А пока вам достаточно будет знать, что эта инструкция может
использоваться для перехвата любых ошибок, уменьшения объема
программного кода, проверяющего наличие ошибок, и представляет собой
достаточно универсальный подход к обработке необычных ситуаций.
Если бы нам, к примеру, потребовалось обеспечить поддержку ввода
не целых, а вещественных чисел, использование инструкции try существенно
упростило бы реализацию по сравнению с проверкой – нам достаточно
было бы просто вызвать функцию float и перехватить исключение вместо
того, чтобы пытаться анализировать все возможные способы записи
вещественных чисел.


 Три уровня вложенности программного кода

 Теперь рассмотрим последнюю версию сценария. В случае необходимости мы
могли бы создать еще один уровень вложенности, например, чтобы выполнить
проверку правильности ввода, основываясь на величине введенного числа:

while True:
    reply = input(‘Enter text:’)
    if reply == ‘stop’:
        break
    elif not reply.isdigit():
        print(‘Bad!’ * 8)
    else:
        num = int(reply)
        if num < 20:
            print(‘low’)
        else:
            print(num ** 2)
print(‘Bye’)

 В эту версию сценария добавлена еще одна инструкция if, вложенная
в выражение else другой условной инструкции if, которая в свою очередь
вложена в цикл while. Когда код выполняется по некоторому условию
или в цикле, как в данном случае, достаточно просто выполнить
дополнительный отступ вправо. В результате сценарий работает так же,
как и предыдущая версия, но для чисел меньше 20 выводит слово «low»
(низкое значение):

Enter text:19
low
Enter text:20
400
Enter text:spam
Bad!Bad!Bad!Bad!Bad!Bad!Bad!Bad!
Enter text:stop
Bye
"""

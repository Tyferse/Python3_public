"""
 Типичные ошибки программирования

 Прежде чем перейти к упражнениям этой части книги, рассмотрим некоторые
наиболее распространенные ошибки, которые допускают начинающие
программисты в инструкциях и программах на языке Python. Многие из этих
ошибок, уже упоминавшиеся ранее в этой части книги, я привел здесь для
полноты картины. С ростом опыта использования языка Python вы научитесь
избегать их, но несколько слов, сказанных сейчас, помогут вам избегать
их с самого начала:

  Не забывайте про двоеточия. Никогда не забывайте вводить символ
 двоеточия в конце заголовков составных инструкций (первая строка таких
 инструкций, как if, while, for и других).

  Начинайте с первой позиции в строке. Программный код верхнего уровня
 (не вложенный) должен начинаться с первой позиции в строке.

  Пустые строки имеют особый смысл в интерактивной оболочке. Пустые
 строки в теле составных инструкций внутри файлов модулей всегда
 игнорируются, но когда программный код вводится в интерактивной
 оболочке, они завершают составные инструкции. Другими словами, ввод
 пустой строки сообщает интерактивной командной оболочке,
 что вы закончили ввод составной инструкции, – если вам необходимо
 продолжить ввод такой инструкции, не нажимайте клавишу Enter,
 когда отображается строка приглашения к вводу ... (или в IDLE),
 пока вы действительно не закончите ее ввод.

  Используйте отступы непротиворечивым способом. Старайтесь не смешивать
 символы табуляции и пробелы при оформлении отступов в блоке, если вы
 не знаете точно, как текстовый редактор интерпретирует символы
 табуляции. В противном случае интерпретатор Python будет видеть совсем
 не то, что вы видите на экране, когда он будет выполнять преобразование
 символов табуляции в пробелы.

  Не пишите на языке C. Напоминаю программистам, использующим C/C++:
 нет никакой необходимости заключать условные выражения в круглые скобки
 в инструкциях if и while (например, if (X == 1):). Это допустимо
 (любое выражение можно заключить в круглые скобки), но в данном
 контексте они совершенно излишни. Кроме того, не заканчивайте все
 инструкции точками с запятой – это также вполне допустимо в языке
 Python, но они совершенно бесполезны, если в каждой строке находится
 всего одна инструкция (конец строки обычно обозначает конец
 инструкции). И помните – не встраивайте инструкции присваивания
 в условные выражения циклов while, и не заключайте блоки в фигурные
 скобки {} (вложенные блоки оформляются с помощью отступов).

  Вместо циклов while и функции range старайтесь использовать простые
 циклы for. Еще одно напоминание: простые циклы for (например,
 for x in seq:) практически всегда проще и выполняются быстрее,
 чем счетные циклы while или основанные на использовании функции range.
 Так как в простых циклах for извлечение элементов последовательностей
 производится внутренними механизмами интерпретатора, они выполняются
 порой в два раза быстрее, чем эквивалентные циклы while. Избегайте
 искушения считать что-либо в циклах на языке Python!

  Будьте внимательны, выполняя присваивание изменяемых объектов. Об этом
 уже говорилось в главе 11: следует быть особенно внимательным
 при использовании изменяемых объектов в инструкциях множественного
 присваивания (a = b = []), а также в комбинированных инструкциях
 присваивания (a += [1, 2]). В обоих случаях непосредственные изменения
 могут затронуть другие переменные.

  Не ожидайте получения результатов от функций, выполняющих
 непосредственные изменения в объектах. Мы уже сталкивались с этим
 ранее: операции, выполняющие непосредственное изменение, такие как
 методы list.append и list.sort, представленные в главе 8, не имеют
 возвращаемых значений (кроме None), поэтому их следует вызывать
 без присваивания возвращаемого значения. Начинающие программисты часто
 допускают ошибку, используя примерно такой программный код:
 mylist = mylist.append(X), пытаясь получить результат метода append,
 но в действительности в этом случае в переменную mylist записывается
 ссылка на объект None, а не на измененный список (фактически такая
 инструкция ведет к полной потере ссылки на список).

  Менее явный пример такой ошибки в Python 2.X – когда выполняется
 попытка обойти элементы словаря в порядке сортировки. Очень часто можно
 увидеть, например, такой программный код: for k in D.keys().sort():.
 Он почти работает – метод keys создает список ключей, а метод sort
 упорядочивает его, но так как метод sort возвращает объект None,
 цикл for терпит неудачу, потому что, в конечном счете, выполняется
 попытка обойти элементы объекта None (который не является
 последовательностью). Данный способ терпит неудачу даже в Python 3.0,
 потому что метод keys возвращает объект представления, а не список!
 Этот алгоритм можно реализовать либо с помощью новой встроенной функции
 sorted, которая возвращает отсортированный список, либо необходимо
 разделить вызовы методов на инструкции: Ks = list(D.keys()),
 затем Ks.sort(), и наконец for k in Ks:. Это один из случаев, когда
 может потребоваться явный вызов метода keys для организации обхода
 элементов словаря в цикле вместо использования итераторов словарей,
 так как итераторы не выполняют сортировку.

  Всегда используйте круглые скобки при вызове функций. При вызове
 функций после их имен всегда следует добавлять круглые скобки
 независимо от наличия входных аргументов (например, вызов функции
 должен выглядеть как function(), а не function).

  Не используйте расширения имен файлов в инструкциях import и reload.
 Не указывайте полные пути к файлам и расширения в инструкциях import
 (например, следует писать import mod, а не import mod.py).


 Упражнения к третьей части

 Теперь, когда вы узнали, как описывается логика работы программы,
в следующих упражнениях вам будет предложено реализовать решение
некоторых простых задач с использованием инструкций. Самым большим
является упражнение 4, где вам будет предложено рассмотреть
альтернативные варианты реализации. Одна и та же задача всегда может
быть решена разными способами, и отчасти изучение языка Python
заключается в том, чтобы находить более оптимальные решения.

 1. Основы циклов.

 a. Напишите цикл for, который выводит ASCII-коды всех символов в строке
с именем S. Для преобразования символов в целочисленные ASCII-коды
используйте встроенную функцию ord(character). (Поэкспериментируйте
с ней в интерактивной оболочке, чтобы понять, как она работает.)

 b. Затем измените цикл так, чтобы он вычислял сумму кодов ASCII всех
символов в строке.

 c. Наконец, измените свой программный код так, чтобы он возвращал
новый список, содержащий ASCII-коды всех символов в строке. Дает ли
выражение map(ord, S) похожий результат?
"""

S = 'Reverting Chrismas?'
L = [ord(c) for c in S]

print(L)


k = 0
for c in S:
    k += ord(c)

print(k)


L = list(map(ord, S))

print(L)

"""
 2. Символы обратного слэша. Что произойдет, если в интерактивной
оболочке ввести следующий программный код?

for i in range(50):
    print(‘hello %d\n\a’ % i)
    
 Будьте осторожны при запуске этого примера не в среде IDLE, он может
сгенерировать звуковой сигнал, что может не понравиться окружающим.
Среда разработки IDLE вместо этого выводит малопонятные символы.
"""

for i in range(50):
    print('hello %d\n\a' % i)

"""
 3. Сортировка словарей. В главе 8 мы видели, что словари представляют 
собой неупорядоченные коллекции. Напишите цикл for, который выводит
элементы словаря в порядке возрастания. (Подсказка: используйте метод
keys словаря и метод списка sort или новую встроенную функцию sorted.)
"""

D = dict(zip(list('saamepm'), list(range(7))))

for key in sorted(D):
    print(key, D[key], sep=' - ')

"""
 4. Программирование альтернативной логики. Изучите следующий фрагмент,
где для поиска числа 2 в пятой степени (32) в списке степеней числа 2, 
используется цикл while и флаг found. Этот фрагмент хранится в файле 
power.py.

L = [1, 2, 4, 8, 16, 32, 64]
X = 5
found = False
i = 0
while not found and i < len(L):
    if 2 ** X == L[i]:
        found = 1
    else:
        i = i + 1
        
if found:
    print(‘at index’, i)
else:
    print(X, ‘not found’)
    
C:\book\tests> python power.py
at index 5

 В этом примере не используются обычные приемы программирования, 
принятые в языке Python. Следуя указаниям ниже, попробуйте улучшить его
(вы можете вносить изменения в интерактивной оболочке или сохранять
в файле сценария и запускать его из командной строки системы – 
использование файла существенно упростит это упражнение):

 a. Сначала добавьте в цикл while блок else, чтобы избавиться от флага 
found и последней инструкции if.

 b. Затем перепишите пример с циклом for и блоком else, чтобы избавиться
от логики вычисления индексов в списке. (Подсказка: получить индекс
элемента можно с помощью метода index (L.index(X)), возвращающего
смещение первого элемента со значением X в списке.)

 c. Затем вообще избавьтесь от цикла, реализовав решение на основе 
оператора in проверки вхождения. (Подробности вы найдете в главе 8 
или попробуйте ввести такое выражение: 2 in [1,2,3].)

 d. Наконец, вместо литерала списка L используйте цикл for и метод 
append для заполнения списка степеней двойки.

 Более глубокие улучшения:
 
 e. Как вы думаете, повысится ли производительность, если выражение
2 ** X вынести за пределы циклов? Как это можно сделать?

 f. Как мы видели в упражнении 1, Python включает в себя функцию
map(function, list), которая может создать список степеней числа 2:
map(lambda x: 2 ** x, range(7)). Попробуйте выполнить этот программный
код в интерактивной оболочке; с инструкцией lambda мы познакомимся
в главе 19.
"""

L = list(map(lambda x: 2**x, range(10)))
X = 5
i = 0
n = 2 ** X
if n in L:
    print('at index', L.index(n))
else:
    print(X, 'not found')

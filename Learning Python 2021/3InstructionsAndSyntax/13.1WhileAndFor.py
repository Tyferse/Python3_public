"""
 Циклы while и for


 Циклы while

 Инструкция while является самой универсальной конструкцией организации
итераций в языке Python. Проще говоря, она продолжает выполнять блок
инструкций (обычно с отступами) до тех пор, пока условное выражение
продолжает возвращать истину. Она называется «циклом», потому что
управление циклически возвращается к началу инструкции, пока условное
выражение не вернет ложное значение. Как только в результате проверки
будет получено ложное значение, управление будет передано первой
инструкции, расположенной сразу же за вложенным блоком тела цикла while.
В результате тело цикла продолжает выполняться снова и снова, пока
условное выражение возвращает истинное выражение, а если условное
выражение сразу вернет ложное значение, тело цикла никогда не будет
выполнено.


 Общий формат

 В своей наиболее сложной форме инструкция while состоит из строки
заголовка с условным выражением, тела цикла, содержащего одну или более
инструкций с отступами, и необязательной части else, которая
выполняется, когда управление передается за пределы цикла
без использования инструкции break. Интерпретатор продолжает вычислять
условное выражение в строке заголовка и выполнять вложенные инструкции
в теле цикла, пока условное выражение не вернет ложное значение:

while <test>:  # Условное выражение test
<statements1>  # Тело цикла
else:  # Необязательная часть else
<statements2>  # Выполняется, если выход из цикла производится не
               # инструкцией break


 Примеры

 Для иллюстрации рассмотрим несколько простых циклов while в действии.
Первый, который содержит инструкцию print, вложенную в цикл while,
просто выводит сообщение до бесконечности. Не забывайте, что True –
это всего лишь особая версия целого числа 1, и оно обозначает истинное
значение, поэтому результатом этого условного выражения всегда будет
истина, и интерпретатор бесконечно будет выполнять тело цикла, пока вы
не прервете его выполнение. Такие циклы обычно называются бесконечными:

\>>> while True:
... print(‘Type Ctrl-C to stop me!’)

 Следующий фрагмент продолжает вырезать из строки первый символ, пока
она не опустеет и в результате не превратится в ложное значение. Это
обычная практика – проверка истинности объектов осуществляется
непосредственно вместо использования более растянутого эквивалента
(while x != ‘’:). Далее в этой главе мы рассмотрим другие способы обхода
элементов строки с помощью цикла for.

\>>> x = ‘spam’
\>>> while x:  # Пока x не пустая строка
... print(x, end=’ ‘)
... x = x[1:]  # Вырезать первый символ из x
...
spam pam am m

 Обратите внимание на именованный аргумент end=’ ‘, который обеспечивает
вывод значений в одну строку через пробел. Если вы забыли, чем это
объясняется, обращайтесь к главе 11. Следующий фрагмент перебирает
значения от a до b, не включая значение b. Ниже мы рассмотрим более
простой способ выполнения этих же действий с помощью цикла for
и встроенной функции range:

\>>> a=0; b=10
\>>> while a < b:  # Один из способов организации циклов перечисления
... print(a, end=’ ‘)
... a += 1  # Или, a = a + 1
...
0 1 2 3 4 5 6 7 8 9
Наконец, обратите внимание, что в языке Python отсутствует цикл
«do until», имеющийся в других языках программирования. Однако его можно
имитировать, добавив в конец тела цикла условную инструкцию и инструкцию
break:

while True:
    ...тело цикла...
    if exitTest(): break

 Чтобы окончательно понять, как эта структура работает, нам необходимо
перейти к следующему разделу и поближе познакомиться
с инструкцией break.


 break, continue, pass и else

 Теперь, когда мы познакомились с несколькими циклами в действии,
настало время обратить внимание на две простые инструкции, которые могут
использоваться только внутри циклов – инструкции break и continue.
Раз уж мы занялись изучением необычных инструкций, заодно рассмотрим
здесь часть else, потому что она некоторым образом связана с инструкцией
break, и заодно пустую инструкцию-заполнитель pass (которая не имеет
прямого отношения к циклам, а относится к категории простых инструкций,
состоящих из одного слова). В языке Python:

break

 Производит переход за пределы объемлющего цикла (всей инструкции
цикла).

continue

 Производит переход в начало цикла (в строку заголовка).

pass

 Ничего не делает: это пустая инструкция, используемая как заполнитель.

Блок else

 Выполняется, только если цикл завершился обычным образом
(без использования инструкции break).


 Общий формат цикла

 С учетом инструкций break и continue цикл while в общем виде выглядит,
как показано ниже:

while <test1>:
    <statements1>
    if <test2>: break  # Выйти из цикла, пропустив часть else
    if <test3>: continue  # Перейти в начало цикла, к выражению test1
else:
    <statements2>  # Выполняется, если не была использована
                   # инструкция ‘break’

 Инструкции break и continue могут появляться в любом месте внутри тела
цикла while (или for), но как правило, они используются в условных
инструкциях if, чтобы выполнить необходимое действие в ответ
на некоторое условие.


 pass

 Инструкция pass не выполняет никаких действий и используется в случаях,
когда синтаксис языка требует наличия инструкции, но никаких полезных
действий в этой точке программы выполнить нельзя. Она часто используется
в качестве пустого тела составной инструкции. Например, создать
бесконечный цикл, который ничего не делает, можно следующим образом:

while 1: pass  # Нажмите Ctrl-C, чтобы прервать цикл!

 Поскольку тело цикла – это всего лишь пустая инструкция, интерпретатор
«застрянет» в этом цикле. Грубо говоря, pass в мире инструкций –
это то же, что None в мире объектов, – явное ничто. Обратите внимание,
что тело этого цикла while находится в той же строке, что и заголовок,
после двоеточия. Как и в случае с инструкцией if, такой прием можно
использовать только в случае, когда тело цикла образует несоставная
инструкция.

 Этот пример вечно делает «ничто». Вероятно, это самая бесполезная
программа (если только вы не хотите погреться у своего ноутбука
в холодный зимний день!), которая когда-либо была написана
на языке Python, и, тем не менее, я не смог придумать лучший пример
применения инструкции pass.

 Далее мы увидим, где эта инструкция может использоваться
с большим смыслом, например, для того, чтобы игнорировать исключение
в инструкции try, или для определения пустых классов, реализующих
объекты, которые ведут себя подобно структурам и записям
в других языках. Иногда инструкция pass используется как заполнитель,
вместо того, «что будет написано позднее», и в качестве временного
фиктивного тела функций:

def func1():
    pass  # Реализация функции будет добавлена позже

def func2():
    pass

 Задание пустого тела функции вызовет синтаксическую ошибку, поэтому
в подобных ситуациях можно использовать инструкцию pass.


 continue

 Инструкция continue вызывает немедленный переход в начало цикла. Она
иногда позволяет избежать использования вложенных инструкций.
В следующем примере инструкция continue используется для пропуска
нечетных чисел. Этот фрагмент выводит четные числа меньше 10 и больше
или равные 0. Вспомним, что число 0 означает ложь, а оператор %
вычисляет остаток от деления, поэтому данный цикл выводит числа
в обратном порядке, пропуская значения, не кратные 2
(он выводит 8 6 4 2 0):

x = 10
while x:
    x = x-1 # Или, x -= 1
    if x % 2 != 0: continue  # Нечетное? – пропустить вывод
    print(x, end=’ ‘)

 Так как инструкция continue выполняет переход в начало цикла,
нам не потребовалось вкладывать инструкцию print в инструкцию if –
она будет задействована, только если инструкция continue не будет
выполнена. Если она напоминает вам инструкцию «goto», имеющуюся
в других языках, то это справедливо. В языке Python нет инструкции
«goto», но так как инструкция continue позволяет выполнять переходы
внутри программы, большинство замечаний, касающихся удобочитаемости
и простоты сопровождения, которые вы могли слышать в отношении
инструкции «goto», применимы и к инструкции continue. Не злоупотребляйте
использованием этой инструкции, особенно когда вы только начинаете
работать с языком Python. Например, последний пример выглядел
бы понятнее, если бы инструкция print была вложена в инструкцию if:

x = 10
while x:
    x = x-1
    if x % 2 == 0:  # Четное? - вывести
        print(x, end=’ ‘)


 break

 Инструкция break вызывает немедленный выход из цикла. Так как
программный код, следующий в цикле за этой инструкцией, не выполняется,
если эта инструкция запущена, то ее также можно использовать, чтобы
избежать вложения. Например, ниже приводится простой интерактивный цикл
(вариант более крупного примера, рассматривавшегося в главе 10),
где производится ввод данных с помощью функции input (raw_input
в Python 2.6) и производится выход из цикла, если в ответ на запрос
имени будет введена строка «stop»:

\>>> while 1:
... name = input(‘Enter name:’)
... if name == ‘stop’: break
... age = input(‘Enter age: ‘)
... print(‘Hello’, name, ‘=>’, int(age) ** 2)
...
Enter name:mel
Enter age: 40
Hello mel => 1600
Enter name:bob
Enter age: 30
Hello bob => 900
Enter name:stop

 Обратите внимание, как в этом примере выполняется преобразование строки
age в целое число с помощью функции int, перед тем как возвести его
во вторую степень. Как вы помните, это совершенно необходимо, потому что
функция input возвращает ввод пользователя в виде строки. В главе 35
вы увидите, что функция input также возбуждает исключение при получении
символа конца файла (например, когда пользователь нажимает комбинацию
клавиш Ctrl-Z или Ctrl-D). Если это может иметь влияние, оберните вызов
функции input инструкцией try.


 else

 При объединении с частью else инструкция break часто позволяет
избавиться от необходимости сохранять флаг состояния поиска, как это
делается в других языках программирования. Например, следующий фрагмент
определяет, является ли положительное целое число y простым числом,
выполняя поиск делителей больше 1:

x = y // 2 # Для значений y > 1
while x > 1:
    if y % x == 0:  # Остаток
        print(y, ‘has factor’, x)
        break  # Перешагнуть блок else
    x -= 1
else:  # Нормальное завершение цикла
    print(y, ‘is prime’)

 Вместо того чтобы устанавливать флаг, который будет проверен
по окончании цикла, достаточно вставить инструкцию break в месте,
где будет найден делитель. При такой реализации управление будет
передано блоку else, только если инструкция break не была выполнена,
то есть когда с уверенностью можно сказать, что число является простым.

 Блок else цикла выполняется также в том случае, когда тело цикла
ни разу не выполнялось, поскольку в этой ситуации инструкция break также
не выполняется. В циклах while это происходит, когда первая же проверка
условия в заголовке дает ложное значение. Вследствие этого в предыдущем
примере будет получено сообщение «is prime» (простое число), если
изначально x меньше или равно 1 (то есть, когда y равно 2).


 Еще о блоке else в цикле

 Так как блок else в цикле является уникальной особенностью
языка Python, он нередко становится источником недопонимания для тех,
кто только начинает осваивать его. В общих чертах, блок else в циклах
обеспечивает явный синтаксис представления распространенной ситуации –
эта программная структура позволяет обработать «другой» способ выхода
из цикла, без необходимости устанавливать и проверять флаги или условия.

 Предположим, например, что вы создаете цикл поиска некоторого значения
в списке и после выхода из цикла вам необходимо узнать, было ли найдено
значение. Эту задачу можно решить следующим способом:

found = False
while x and not found:
    if match(x[0]):  # Искомое значение является первым?
        Print(‘Ni’)
        found = True
    else:
        x = x[1:]  # Вырезать первое значение и повторить

if not found:
    print(‘not found’)

 Здесь мы инициализируем, устанавливаем и проверяем флаг, чтобы
определить, увенчался поиск успехом или нет. Это вполне корректный
программный код для языка Python, и он работает, однако это именно тот
случай, когда можно использовать блок else в цикле. Ниже приводится
эквивалентный фрагмент:

while x:  # Выйти, когда x опустеет
    if match(x[0]):
        print(‘Ni’)
        break  # Выход, в обход блока else
    x = x[1:]
else:
    print(‘Not found’)  # Этот блок отработает,
                        # только если строка x исчерпана

 Эта версия более компактна. Нам удалось избавиться от флага и заменить
инструкцию if за циклом на блок else (по вертикали находится на одной
линии со словом while). Так как выход из цикла while по инструкции break
минует блок else, его можно рассматривать как более удобный способ
обработки случая неудачного поиска.

 Некоторые из вас могли бы заметить, что в предыдущем примере блок else
можно заменить проверкой строки x после выхода из цикла (например,
if not x:). Для данного примера это вполне возможно, но часть else
обеспечивает явный синтаксис реализации этого шаблона программирования
(здесь – это более очевидный блок обработки ситуации неудачного поиска),
и кроме того, подобная проверка не всегда возможна. Часть else в циклах
становится еще более полезной, когда используется в сочетании
с инструкцией цикла for – темой следующего раздела, потому что обход
последовательностей выполняется неподконтрольно вам.


 Придется держать в уме: имитация циклов while языка C

 В разделе главы 11, где рассматривались инструкции выражений,
утверждалось, что язык Python не предусматривает возможность выполнять
присваивание там, где ожидается выражение. Это означает, что следующий,
широко используемый, шаблон программирования языка C неприменим
в языке Python:

while ((x = next()) != NULL) {...обработка x...}

 Операции присваивания в языке C возвращают присвоенное значение,
но в языке Python присваивание – это всего лишь инструкция,
а не выражение. Благодаря этому ликвидируется обширный класс ошибок,
свойственных языку C (в языке Python невозможно по ошибке оставить
знак = там, где подразумевается ==). Но в случае необходимости в циклах
while языка Python подобное поведение можно реализовать как минимум
тремя способами, без встраивания инструкции присваивания в условное
выражение. Операцию присваивания можно переместить в тело цикла вместе
с инструкцией break:

while True:
    x = next()
    if not x: break
    ...обработка x...

 или вместе с инструкцией if:

x = True
while x:
    x = next()
    if x:
        ...обработка x...

 или вынести первое присваивание за пределы цикла:

x = next()
while x:
    ...обработка x...
    x = next()

 Из этих трех вариантов первый, как могут полагать некоторые, – наименее
структурированный, но он же представляется наиболее простым и наиболее
часто используемым. Простейший цикл for в языке Python также может
заменить некоторые циклы языка C.


 Циклы for

 Цикл for является универсальным итератором последовательностей в языке
Python: он может выполнять обход элементов в любых упорядоченных
объектах последовательностей. Инструкция for способна работать
со строками, списками, кортежами, с другими встроенными объектами,
поддерживающими возможность выполнения итераций, и с новыми объектами,
которые создаются с помощью классов, как будет показано позже. Мы уже
встречались с этой инструкцией, когда рассматривали типы
последовательностей, а теперь познакомимся с ней поближе.


 Общий формат

 Циклы for в языке Python начинаются со строки заголовка,
где указывается переменная для присваивания (или – цель),
а также объект, обход которого будет выполнен. Вслед за заголовком
следует блок (обычно с отступами) инструкций, которые требуется
выполнить:

for <target> in <object>:  # Связывает элементы объекта с переменной
    <statements>  # Повторяющееся тело цикла: использует
else:             # переменную цикла
    <statements>  # Если не попали на инструкцию ‘break’

 Когда интерпретатор выполняет цикл for, он поочередно, один за другим,
присваивает элементы объекта последовательности переменной цикла
и выполняет тело цикла для каждого из них. Для обращения к текущему
элементу последовательности в теле цикла обычно используется переменная
цикла, как если бы это был курсор, шагающий от элемента к элементу.

 Имя, используемое в качестве переменной цикла (возможно, новой),
которое указывается в заголовке цикла for, обычно находится в области
видимости, где располагается сама инструкция for. О ней почти нечего
сказать; хотя она может быть изменена в теле цикла, тем не менее ей
автоматически будет присвоен следующий элемент последовательности,
когда управление вернется в начало цикла. После выхода из цикла эта
переменная обычно все еще ссылается на последний элемент
последовательности, если цикл не был завершен инструкцией break.

 Инструкция for также поддерживает необязательную часть else, которая
работает точно так же, как и в циклах while, – она выполняется,
если выход из цикла производится не инструкцией break (то есть, если
в цикле был выполнен обход всех элементов последовательности).
Инструкции break и continue, представленные выше, в циклах for работают
точно так же, как и в циклах while.

 Полная форма цикла for имеет следующий вид:

for <target> in <object>:  # Присваивает элементы объекта
    <statements>           # с переменной цикла
    if <test>: break  # Выход из цикла, минуя блок else
    if <test>: continue  # Переход в начало цикла
else:
    <statements>  # Если не была вызвана инструкция ‘break’


 Примеры


 Типичные варианты использования

 Как упоминалось ранее, цикл for может выполнять обход элементов в любых
объектах последовательностей. В нашем первом примере, например,
мы поочередно, слева направо, присвоим переменной x каждый из трех
элементов списка и выведем каждый из них с помощью инструкции print.
Внутри инструкции print (в теле цикла) имя x ссылается на текущий
элемент списка:

\>>> for x in [“spam”, “eggs”, “ham”]:
... print(x, end=’ ‘)
...
spam eggs ham

 В следующих двух примерах вычисляется сумма и произведение всех
элементов в списке. В этой главе и далее в книге мы познакомимся
с инструментами, которые применяют такие операции, как + и *,
к элементам списка автоматически, но обычно для этого используется
цикл for:

\>>> sum = 0
\>>> for x in [1, 2, 3, 4]:
... sum = sum + x
...
\>>> sum
10
\>>> prod = 1
\>>> for item in [1, 2, 3, 4]: prod *= item
...
\>>> prod
24


 Другие типы данных

 Цикл for, будучи универсальным инструментом, может применяться к любым
последовательностям. Например, цикл for может применяться
к строкам и кортежам:

\>>> S = “lumberjack”
\>>> T = (“and”, “I’m”, “okay”)
\>>> for x in S: print(x, end=’ ‘)  # Обход строки
...
l u m b e r j a c k

\>>> for x in T: print(x, end=’ ‘)  # Обход элементов кортежа
...
and I’m okay

 Фактически, как будет показано чуть ниже, циклы for могут применяться
даже к объектам, которые вообще не являются последовательностями,
например к файлам и словарям!


 Присваивание кортежа в цикле for

 Если выполнить обход последовательности кортежей, переменная цикла сама
фактически будет кортежем. Это лишь еще один случай операции
присваивания кортежа. Не забывайте, что инструкция цикла for присваивает
элементы объекта последовательности переменной цикла, а операция
присваивания везде выполняется одинаково:

\>>> T = [(1, 2), (3, 4), (5, 6)]
\>>> for (a, b) in T:  # Операция присваивания кортежа в действии
... print(a, b)
...
1 2
3 4
5 6

 Здесь первый проход цикла действует подобно инструкции (a, b) = (1, 2),
второй проход – инструкции (a, b) = (3, 4) и так далее. В результате
в каждой итерации автоматически выполняется операция присваивания
кортежа.

 Такая форма присваивания в цикле for часто выполняется с использованием
функции zip, с которой мы встретимся ниже в этой главе, – когда будем
рассматривать возможность одновременного обхода сразу нескольких
последовательностей. Эта же форма цикла часто используется при работе
с базами данных, когда ответ на запрос SQL возвращается в виде
последовательности последовательностей, таких как список в данном
примере, – внешний список представляет таблицу в базе данных, вложенные
кортежи – строки в таблице, а инструкция присваивания кортежа извлекает
значения полей.

 Кортежи в циклах for можно использовать для обхода ключей и значений
словарей, применяя метод items, что гораздо удобнее, чем выполнять
обход ключей и затем с помощью операции индексирования извлекать з
начения:

\>>> D = {‘a’: 1, ‘b’: 2, ‘c’: 3}
\>>> for key in D:
... print(key, ‘=>’, D[key])  # Используется итератор словаря
...                           # и операция индексирования
a => 1
c => 3
b => 2
\>>> list(D.items())
[(‘a’, 1), (‘c’, 3), (‘b’, 2)]
\>>> for (key, value) in D.items():
... print(key, ‘=>’, value)  # Обход ключей и значений одновременно
...
a => 1
c => 3
b => 2

 Важно отметить, что операция присваивания кортежей в инструкции цикла
for не является каким-то особым случаем – синтаксически после слова for
выполняется присваивание переменной цикла любого вида. С другой стороны,
мы всегда можем выполнить распаковывание кортежа внутри цикла:

\>>> T
[(1, 2), (3, 4), (5, 6)]
\>>> for both in T:
... a, b = both  # Эквивалентный вариант с присваиванием вручную
... print(a, b)
...
1 2
3 4
5 6

 Использование кортежей в заголовке цикла позволяет сэкономить одну
операцию в теле цикла при обходе последовательности последовательностей.
Как уже упоминалось в главе 11, этот способ можно использовать даже
для автоматического распаковывания вложенных структур в цикле for:

\>>> ((a, b), c) = ((1, 2), 3)  # Вложенные структуры также могут
\>>> a, b, c                    # использоваться
(1, 2, 3)
\>>> for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: print(a, b, c)
...
1 2 3
4 5 6

 Это также не является каким-то специальным случаем – просто в каждой
итерации инструкция for выполняет операцию присваивания, аналогичную
той, что продемонстрирована чуть выше цикла. Таким способом может быть
распакована последовательность любых структур, – просто благодаря
универсальности операции присваивания последовательностей:

\>>> for ((a, b), c) in [([1, 2], 3), [‘XY’, 6]]: print(a, b, c)
...
1 2 3
X Y 6


 Расширенная операция присваивания последовательностей в циклах for
в версии Python 3.0

 Фактически благодаря тому, что к переменной цикла в инструкции цикла
for может применяться присваивание любого типа, в Python 3.0 мы можем
использовать синтаксис присваивания расширенной операции распаковывания
последовательностей, извлекая элементы и фрагменты последовательностей.
В действительности это тоже не какой-то особый случай, а просто новая
форма присваивания, появившаяся в версии 3.0 (которая рассматривалась
в главе 11). Так как этот синтаксис может применяться в инструкциях
присваивания, его также можно использовать в циклах for.

 Вернемся к форме присваивания кортежей, рассматривавшейся в предыдущем
разделе. В каждой итерации кортеж значений присваивается кортежу
переменных, точно так же, как в обычной инструкции присваивания:

\>>> a, b, c = (1, 2, 3)  # Присваивание кортежа
\>>> a, b, c
(1, 2, 3)
\>>> for (a, b, c) in [(1, 2, 3), (4, 5, 6)]:
# Используется в цикле for
... print(a, b, c)
...
1 2 3
4 5 6

 Благодаря тому, что в Python 3.0 появилась возможность выполнить
присваивание последовательности множеству переменных, где имени
со звездочкой может быть присвоено сразу множество элементов, мы можем
использовать тот же прием для извлечения фрагментов вложенных
последовательностей в цикле for:

\>>> a, *b, c = (1, 2, 3, 4)  # Расширенная инструкция
\>>> a, b, c  # распаковывания последовательностей
(1, [2, 3], 4)
\>>> for (a, *b, c) in [(1, 2, 3, 4), (5, 6, 7, 8)]:
... print(a, b, c)
...
1 [2, 3] 4
5 [6, 7] 8

 На практике этот подход можно использовать для выборки нескольких полей
из записей с данными, представленными в виде вложенных
последовательностей. В Python 2.X не поддерживается расширенная операция
распаковывания последовательностей, однако того же эффекта можно
добиться с помощью операции извлечения среза. Единственное отличие
состоит в том, что операция извлечения среза возвращает результат,
зависящий от типа исходной последовательности, тогда как расширенная
операция распаковывания последовательностей всегда возвращает список:

\>>> for all in [(1, 2, 3, 4), (5, 6, 7, 8)]:  # Извлечение среза в 2.6
... a, b, c = all[0], all[1:3], all[3]
... print(a, b, c)
...
1 (2, 3) 4
5 (6, 7) 8

 Подробнее об этой форме присваивания рассказывается в главе 11.


 Вложенные циклы for

 Теперь рассмотрим более сложный вариант цикла for. Следующий пример
иллюстрирует использование блока else и вложенный цикл for. Имея список
объектов (items) и список ключей (tests), этот фрагмент пытается
отыскать каждый ключ в списке объектов и сообщает о результатах поиска:

\>>> items = [“aaa”, 111, (4, 5), 2.01]  # Множество объектов
\>>> tests = [(4, 5), 3.14]  # Ключи, которые требуется отыскать
\>>>
\>>> for key in tests:  # Для всех ключей
...     for item in items:  # Для всех элементов
...         if item == key:  # Проверить совпадение
...             print(key, “was found”)
...             break
...     else:
...         print(key, “not found!”)
...
(4, 5) was found
3.14 not found!

 Поскольку при обнаружении совпадения вложенная инструкция if вызывает
инструкцию break, можно утверждать, что блок else будет выполняться
только в случае, когда поиск завершится неудачей. Обратите внимание
на вложение инструкций. Если запустить этот фрагмент, одновременно будут
выполняться два цикла: внешний цикл будет выполнять обход списка ключей,
а внутренний будет выполнять обход списка элементов в поисках каждого
ключа. Уровень вложенности блока else имеет большое значение –
он находится на уровне строки заголовка внутреннего цикла for, поэтому
он соответствует внутреннему циклу (не инструкции if и не внешнему
циклу for).

 Примечательно, что этот пример можно упростить, если использовать
оператор in для проверки вхождения ключа. Поскольку оператор in неявно
выполняет обход списка в поисках совпадения, он заменяет собой
внутренний цикл:

\>>> for key in tests:  # Для всех ключей
...     if key in items:  # Позволить интерпретатору отыскать совпадение
...         print(key, “was found”)
...     else:
...         print(key, “not found!”)
...
(4, 5) was found
3.14 not found!

 Вообще, ради компактности кода и скорости вычислений всегда правильнее
будет переложить на плечи интерпретатора как можно больше работы,
как это сделано в данном примере.

 Следующий пример с помощью цикла for решает типичную задачу обработки
данных – выборку одинаковых элементов из двух последовательностей
(из строк). Это достаточно простая задача поиска пересечения двух
множеств. После того как цикл for выполнится, переменная res будет
ссылаться на список, содержащий все одинаковые элементы, обнаруженные
в seq1 и seq2:

\>>> seq1 = “spam”
\>>> seq2 = “scam”
\>>>
\>>> res = []  # Изначально список пуст
\>>> for x in seq1:  # Выполнить обход первой последовательности
...     if x in seq2:  # Общий элемент?
...         res.append(x)  # Добавить в конец результата
...
\>>> res
[‘s’, ‘a’, ‘m’]

 К сожалению, этот фрагмент работает только с двумя определенными
переменными: seq1 и seq2. Было бы замечательно, если бы этот цикл можно
было привести к более универсальному виду, тогда его можно было бы
использовать многократно. Эта простая идея ведет нас к функциям,
теме следующей части книги.


 Придется держать в уме: сканирование файлов

 Циклы удобно использовать там, где надо повторно выполнять некоторые
действия или многократно обрабатывать данные. Файлы содержат множество
символов и строк, поэтому они могут рассматриваться как один из типичных
объектов применения циклов. Чтобы загрузить содержимое файла в строку
одной инструкцией, достаточно вызвать метод read:

file = open(‘test.txt’, ‘r’)  # Прочитать содержимое файла в строку
print(file.read())

 Но для загрузки файла по частям обычно используется либо цикл while,
завершающийся инструкцией break по достижении конца файла, либо цикл
for. Чтобы выполнить посимвольное чтение, достаточно любого из следующих
фрагментов:

file = open(‘test.txt’)
while True:
    char = file.read(1) # Читать по одному символу
    if not char: break
    print(char)

for char in open(‘test.txt’).read():
    print(char)

 Тут цикл for выполняет обработку каждого отдельного символа,
но загрузка содержимого файла в память производится однократно. Чтение
строками или блоками циклом while реализуется следующим образом:

file = open(‘test.txt’)
while True:
    line = file.readline()  # Читать строку за строкой
    if not line: break
    print(line, end=’ ‘)  # Прочитанная строка уже содержит символ \n

file = open(‘test.txt’, ‘rb’)
while True:
    chunk = file.read(10) # Читать блоками по 10 байтов
    if not chunk: break
    print(chunk)

 Двоичные данные обычно читаются блоками определенного размера. Однако
в случае текстовых данных построчное чтение с помощью цикла for выглядит
проще и работает быстрее:

for line in open(‘test.txt’).readlines():
    print(line, end=’’)

for line in open(‘test.txt’):  # Использование итератора: лучший способ
    print(line, end=’’)  # чтения текста

 Метод файлов readlines загружает файл целиком в список строк, тогда как
при использовании итератора файла в каждой итерации загружается только
одна строка (итераторы подробно рассматриваются в главе 14). Подробности
об использованных здесь функциях вы найдете в руководстве по стандартной
библиотеке языка Python.
"""

"""
 Другие контексты итераций

 Далее в этой книге мы увидим, что в своих классах также можно
реализовать поддержку протокола итераций. Поэтому иногда бывает важно
знать, какие встроенные инструменты могут использоваться для этого, –
любой инструмент, использующий протокол итераций, автоматически сможет
работать с любыми встроенными и пользовательскими классами, реализующими
его поддержку. До настоящего момента я демонстрировал итераторы
в контексте инструкции цикла for, потому что в этой части книги основное
внимание уделяется инструкциям. Однако имейте в виду, что каждый
инструмент, который выполняет обход объектов слева направо, использует
итерационный протокол. В число этих инструментов входят и циклы for,
как уже было показано выше:

\>>> for line in open(‘script1.py’):  # Использовать итератор файла
...      print(line.upper(), end=’’)
...
IMPORT SYS
PRINT(SYS.PATH)
X = 2
PRINT(2 ** 33)

 Генераторы списков, оператор in, встроенная функция map и другие
встроенные средства, такие как функции sorted и zip, также основаны
на применении итерационного протокола. Когда все эти инструменты
применяются к файлу, они автоматически используют итератор объекта файла
для построчного чтения:

\>>> uppers = [line.upper() for line in open(‘script1.py’)]
\>>> uppers
[‘IMPORT SYS\n’, ‘PRINT(SYS.PATH)\n’, ‘X = 2\n’, ‘PRINT(2 ** 33)\n’]

\>>> map(str.upper, open(‘script1.py’))  # в 3.0 функция map возвращает
<map object at 0x02660710>               # итератор
\>>> list(map(str.upper, open(‘script1.py’)))
[‘IMPORT SYS\n’, ‘PRINT(SYS.PATH)\n’, ‘X = 2\n’, ‘PRINT(2 ** 33)\n’]

\>>> ‘y = 2\n’ in open(‘script1.py’)
False
\>>> ‘x = 2\n’ in open(‘script1.py’)
True

 Используемая здесь функция map, с которой мы познакомились в предыдущей
главе, представляет собой инструмент, вызывающий заданную функцию для
каждого элемента итерируемого объекта. Функция map напоминает генераторы
списков, хотя и с ограничениями, потому что ей можно передать только
функцию, а не произвольное выражение. Кроме того, в Python 3.0 она
возвращает итерируемый объект, поэтому нам пришлось обернуть обращение
к этой функции в вызов функции list, чтобы получить сразу все значения,
 – подробнее об этом изменении рассказывается ниже в этой главе.
Так как функция map, как и генераторы списков, связана с циклами for
и с функциями, мы снова вернемся к их исследованию в главах 19 и 20.

 В языке Python имеются различные встроенные функции, позволяющие
обрабатывать итерируемые объекты: функция sorted сортирует элементы
итерируемого объекта, функция zip объединяет элементы итерируемых
объектов, функция enumerate создает пары из элементов итерируемых
объектов и их позиций, функция filter отбирает элементы, для которых
указанная функция возвращает истинное значение, а функция reduce
выполняет указанную операцию, объединяя все элементы в итерируемом
объекте. Все эти функции принимают итерируемые объекты, при этом
в Python 3.0 функции zip, enumerate и filter еще и возвращают
итерируемые объекты, подобно функции map. Следующий пример демонстрирует
эти функции в действии, где они применяются к итератору файла
и автоматически сканируют его строка за строкой:

\>>> sorted(open(‘script1.py’))
[‘import sys\n’, ‘print(2 ** 33)\n’, ‘print(sys.path)\n’, ‘x = 2\n’]

\>>> list(zip(open(‘script1.py’), open(‘script1.py’)))
[(‘import sys\n’, ‘import sys\n’), (‘print(sys.path)\n’,
 ‘print(sys.path)\n’),

(‘x = 2\n’, ‘x = 2\n’), (‘print(2 ** 33)\n’, ‘print(2 ** 33)\n’)]
\>>> list(enumerate(open(‘script1.py’)))
[(0, ‘import sys\n’), (1, ‘print(sys.path)\n’), (2, ‘x = 2\n’),
(3, ‘print(2 ** 33)\n’)]

\>>> list(filter(bool, open(‘script1.py’)))
[‘import sys\n’, ‘print(sys.path)\n’, ‘x = 2\n’, ‘print(2 ** 33)\n’]

\>>> import functools, operator
\>>> functools.reduce(operator.add, open(‘script1.py’))
‘import sys\nprint(sys.path)\nx = 2\nprint(2 ** 33)\n’

 Все они являются инструментами итераций, но каждая из них играет свою,
уникальную роль. С функциями zip и enumerate мы встречались в предыдущей
главе. С функциями filter и reduce мы познакомимся в главе 19, когда
будем рассматривать тему функционального программирования, поэтому
пока мы не будем погружаться в их особенности.

 С функцией sorted мы встретились в первый раз в главе 4 и использовали
её при работе со словарями в главе 8. sorted – это встроенная функция,
использующая протокол итераций, – она похожа на метод sort списков,
но возвращает новый отсортированный список и принимает любые итерируемые
объекты. Обратите внимание, что в отличие от функции map и других,
в версии Python 3.0 функция sorted возвращает фактический список,
а не итерируемый объект.

 Другие встроенные функции также поддерживают протокол итераций
(но, если честно, для них сложнее придумать достаточно интересный пример
обработки файлов). Например, функция sum вычисляет сумму всех чисел
в любом итерируемом объекте. Встроенные функции any и all возвращают
True, если любой (any) или все (all) элементы итерируемого объекта
являются истинными значениями соответственно. Функции max и min
возвращают наибольший и наименьший элемент итерируемого объекта
соответственно. Как и функция reduce, все эти инструменты принимают
любые итерируемые объекты и используют протокол итераций для их обхода,
но возвращают единственное значение, как показано в следующем примере:

\>>> sum([3, 2, 4, 1, 5, 0])  # sum работает только с числами
15
\>>> any([‘spam’, ‘’, ‘ni’])
True
\>>> all([‘spam’, ‘’, ‘ni’])
False
\>>> max([3, 2, 5, 1, 4])
5
\>>> min([3, 2, 5, 1, 4])
1

 Строго говоря, функции max и min могут применяться и к файлам –
они автоматически используют протокол итераций для обхода содержимого
файла и выбора строк с наибольшим и наименьшим строковым значением
соответственно (однако я оставлю вам самим определить правильные случаи
использования):

\>>> max(open(‘script1.py’))  # Поиск строк с максимальным и минимальным
‘x = 2\n’ # строковым значением
\>>> min(open(‘script1.py’))
‘import sys\n’

 Интересно, что область влияния итерационного протокола в языке Python
в настоящее время гораздо шире, чем было продемонстрировано в примерах,
– любые встроенные инструменты в языке Python, которые выполняют обход
объектов слева направо, по определению используют итерационный протокол
при работе с объектами. Сюда относятся даже такие замысловатые
инструменты, как встроенные функции list и tuple (которые создают новые
объекты из итерируемых объектов), строковый метод join (который
вставляет подстроку между строками, содержащимися в итерируемом объекте)
и даже операция присваивания последовательностей. Благодаря этому все
они могут применяться к открытому файлу и автоматически выполнять чтение
по одной строке за раз:

\>>> list(open(‘script1.py’))
[‘import sys\n’, ‘print(sys.path)\n’, ‘x = 2\n’, ‘print(2 ** 33)\n’]

\>>> tuple(open(‘script1.py’))
(‘import sys\n’, ‘print(sys.path)\n’, ‘x = 2\n’, ‘print(2 ** 33)\n’)

\>>> ‘&&’.join(open(‘script1.py’))
‘import sys\n&&print(sys.path)\n&&x = 2\n&&print(2 ** 33)\n’

\>>> a, b, c, d = open(‘script1.py’)
\>>> a, d
(‘import sys\n’, ‘print(2 ** 33)\n’)

\>>> a, *b = open(‘script1.py’) # Расширенная форма в 3.0
\>>> a, b
(‘import sys\n’, [‘print(sys.path)\n’, ‘x = 2\n’, ‘print(2 ** 33)\n’])

 Ранее мы видели, что встроенная функция dict может принимать
итерируемые объекты, возвращаемые функцией zip. То же самое относится
к встроенной функции set и к новым генераторам множеств и словарей,
появившимся в Python 3.0, с которыми мы встречались в главах 4, 5 и 8:

\>>> set(open(‘script1.py’))
{‘print(sys.path)\n’, ‘x = 2\n’, ‘print(2 ** 33)\n’, ‘import sys\n’}

\>>> {line for line in open(‘script1.py’)}
{‘print(sys.path)\n’, ‘x = 2\n’, ‘print(2 ** 33)\n’, ‘import sys\n’}

\>>> {ix: line for ix, line in enumerate(open(‘script1.py’))}
{0:’import sys\n’, 1:’print(sys.path)\n’, 2:’x = 2\n’,
 3:’print(2 ** 33)\n’}

 Фактически оба типа генераторов – множеств и словарей – поддерживают
расширенный синтаксис генераторов списков, с которым мы познакомились
в этой главе, включая проверку условия if:

\>>> {line for line in open(‘script1.py’) if line[0] == ‘p’}
{‘print(sys.path)\n’, ‘print(2 ** 33)\n’}

\>>> {ix: line for (ix, line) in enumerate(open(‘script1.py’))
     if line[0]==’p’}
{1: ‘print(sys.path)\n’, 3: ‘print(2 ** 33)\n’}

 Подобно генераторам списков, обе эти конструкции просматривают
содержимое файла строку за строкой и отбирают строки, начинающиеся
с символа «p». В результате они создают множество и словарь
соответственно, выполняя всю необходимую нам работу.

 В качестве предварительного знакомства рассмотрим еще один, последний
итерационный контекст, заслуживающий внимания: в главе 18 мы будем
рассматривать специальную форму аргументов *arg, которая используется
в вызовах функций для распаковывания значений коллекций в отдельные
аргументы. Как вы уже наверняка поняли, в виде этой синтаксической
конструкции можно передать любой итерируемый объект, включая и файлы
(более подробно синтаксис вызова функций рассматривается в главе 18):

\>>> def f(a, b, c, d): print(a, b, c, d, sep=’&’)
...
\>>> f(1, 2, 3, 4)
1&2&3&4
\>>> f(*[1, 2, 3, 4])  # Распаковывание списка в аргументы
1&2&3&4
\>>> f(*open(‘script1.py’))  # Можно даже выполнить обход строк в файле!
import sys
&print(sys.path)
&x = 2
&print(2 ** 33)

 Фактически в виде синтаксической конструкции распаковывания аргументов
в вызовах функций допускается передавать любые итерируемые объекты.
Благодаря этому существует возможность использовать встроенную функцию
zip для распаковывания упакованных кортежей, передавая ей результаты
другого вызова функции zip (внимание: возможно, вам не следует читать
следующий пример, если в ближайшее время вам предстоит управлять тяжелой
техникой!):

\>>> X = (1, 2)
\>>> Y = (3, 4)
\>>>
\>>> list(zip(X, Y)) # Упаковать кортежи: возвратит итерируемый объект
[(1, 3), (2, 4)]
\>>>
\>>> A, B = zip(*zip(X, Y)) # Распаковать упакованные кортежи!
\>>> A
(1, 2)
\>>> B
(3, 4)


 Новые итерируемые объекты в Python 3.0

 Одно из фундаментальных отличий Python 3.0 от 2.X заключается в том,
что в версии 3.0 делается сильный акцент на использование итераторов.
Вдобавок к тому, что итераторы были ассоциированы со многими встроенными
типами данных, такими как файлы и словари, в Python 3.0 методы keys,
values и items словарей также возвращают итерируемые объекты, как и
встроенные функции range, map, zip и filter. Как было показано
в предыдущем разделе, три последние функции не только возвращают
итераторы, но и выполняют обработку данных в них. Все эти инструменты
в Python 3.0 не создают списки с результатами, как в версии 2.6,
а возвращают результаты по требованию.

 Итераторы позволяют экономнее расходовать память, однако
в некоторых случаях они могут оказать существенное влияние
на стиль программирования. Например, ранее в этой книге
вам уже приходилось видеть, как мы обертывали вызовы различных функций
и методов в вызов функции list(...), чтобы сразу получить
все результаты, воспроизводимые итерируемым объектом:

\>>> zip(‘abc’, ‘xyz’)  # Итерируемый объект в Python 3.0 (список в 2.6)
<zip object at 0x02E66710>
\>>> list(zip(‘abc’, ‘xyz’))  # Принудительное создание списка
[(‘a’, ‘x’), (‘b’, ‘y’), (‘c’, ‘z’)] # результатов для отображения в 3.0

 Этого не требуется в версии 2.6, потому что функции, такие как zip,
возвращают список результатов. Но в версии 3.0 они возвращают
итерируемые объекты, которые воспроизводят результаты по требованию.
Это означает необходимость ввода дополнительного программного кода для
отображения результатов в интерактивной оболочке (и, возможно,
в некоторых других случаях), однако в крупных программах подобные
отложенные вычисления позволяют экономить память и ликвидировать паузы,
необходимые на вычисление длинных списков результатов. Давайте теперь
рассмотрим некоторые новые, появившиеся в версии 3.0, итерируемые
объекты в действии.


 Итератор range

 В предыдущей главе мы уже познакомились с основами встроенной функции
range. В версии 3.0 она возвращает итератор, который не создает сразу
весь список целых чисел в заданном диапазоне, а генерирует их по
требованию. Она действует точно так же, как прежняя функция xrange
в версии 2.X (смотрите примечание, касающееся различий между версиями,
ниже), и в случае, когда необходимо получить сразу весь список
с результатами (например, для отображения), обращение к ней следует
обернуть в вызов функции list(range(...)):

C:\\misc> c:\python30\python
\>>> R = range(10)  # range возвращает итератор, а не список
\>>> R
range(0, 10)
\>>> I = iter(R)  # Вернет итератор для диапазона
\>>> next(I)  # Переход к следующему результату
0 # То же происходит в циклах for, генераторах списков и пр.
\>>> next(I)
1
\>>> next(I)
2
\>>> list(range(10))  # При необходимости можно принудительно
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] # сгенерировать список

 В отличие от списков, возвращаемых вызовом этой функции в версии 2.Х,
объекты, возвращаемые функцией range в версии 3.0, поддерживают только
возможность итераций, операцию обращения к элементам по индексам
и функцию len. Они не поддерживают никакие другие операции
над последовательностями (если вам потребуется выполнить другие операции
над списками, используйте конструкцию list(...)):

\>>> len(R)  # Диапазоны поддерживают функцию len и операцию
10  # Другие операции над последовательностями            индексирования
\>>> R[0]                  # не поддерживаются
0
\>>> R[-1]
9

\>>> next(I)  # Выборка данных будет продолжена с того места,
3 # где она была прекращена
\>>> I.__next__()  # Метод .next() был переименован в .__next__(),
4                  # но лучше использовать новую функцию next()


 Итераторы map, zip и filter

 Подобно функции range, встроенные функции map, zip и filter
в версии 3.0 также возвращают итераторы вместо того, чтобы
воспроизводить сразу весь список с результатами. В версии 3.0 все три
функции не только принимают итерируемые объекты в виде аргументов,
но и возвращают итерируемые объекты в виде результатов. Однако,
в отличие от функции range, их результаты сами и являются этими
итераторами, – после однократного получения отдельного результата этот
результат исчезает. Другими словами, вы не сможете на основе результатов
организовать проход по этим результатам нескольких итераторов, который
обеспечил бы возможность извлечения результатов в разных позициях.

 Ниже приводится пример использования встроенной функции map, с которой
мы встречались в предыдущей главе. Как и при использовании других
итераторов, имеется возможность с помощью функции list(...) получить
сразу весь список с результатами, но поведение функции map по умолчанию
ориентировано на экономию существенных объемов памяти при работе
с большими наборами результатов:

\>>> M = map(abs, (-1, 0, 1))  # map возвращает итератор, а не список
\>>> M
<map object at 0x0276B890>
\>>> next(M)  # Непосредственное использование итератора:
1             # результаты исчерпываются безвозвратно.
\>>> next(M)  # Они не поддерживают функцию len()
0             # и операцию индексирования
\>>> next(M)
1
\>>> next(M)
StopIteration

\>>> for x in M: print(x)  # Теперь итератор map пуст:
... # возможен только один проход
\>>> M = map(abs, (-1, 0, 1))  # Чтобы выполнить второй проход,
                               # необходимо снова создать итератор
\>>> for x in M: print(x)  # В контексте итераций функция next()
...                        # вызывается автоматически
1
0
1
\>>> list(map(abs, (-1, 0, 1)))  # При необходимости можно получить
[1, 0, 1]                        # сразу весь список с результатами

 Встроенная функция zip, представленная в предыдущей главе, возвращает
итератор, который действует точно так же:

\>>> Z = zip((1, 2, 3), (10, 20, 30))  # zip также возвращает итератор,
\>>> Z                # который позволяет выполнить только один проход
<zip object at 0x02770EE0>
\>>> list(Z)
[(1, 10), (2, 20), (3, 30)]

\>>> for pair in Z: print(pair)  # Результаты исчерпываются после
...                              # первого прохода
\>>> Z = zip((1, 2, 3), (10, 20, 30))

\>>> for pair in Z: print(pair)  # Итератор можно использовать
...                              # вручную или автоматически
(1, 10)
(2, 20)
(3, 30)
\>>> Z = zip((1, 2, 3), (10, 20, 30))
\>>> next(Z)
(1, 10)
\>>> next(Z)
(2, 20)

 Встроенная функция filter, которую мы детально будем изучать
в следующей части книги, действует аналогичным образом. Она возвращает
только те элементы итерируемых объектов, для которых указанная функция
возвращает значение True (как мы уже знаем, в языке Python значение True
в логическом контексте получают любые непустые объекты):

\>>> filter(bool, [‘spam’, ‘’, ‘ni’])
<filter object at 0x0269C6D0>
\>>> list(filter(bool, [‘spam’, ‘’, ‘ni’]))
[‘spam’, ‘ni’]

 Подобно большинству других инструментов, обсуждавшихся в этом разделе,
в версии 3.0 функция filter не только принимает итерируемые объекты для
обработки, но и возвращает итерируемый объект, воспроизводящий
результаты по требованию.


 Поддержка множественных и единственных итераторов

 Многим интересно будет увидеть, в чем заключаются различия между
объектом диапазона, возвращаемым функцией range, и объектами,
возвращаемыми другими встроенными функциями, которые описываются
в этом разделе, – результат функции range поддерживает функцию len
и операцию доступа к элементам по индексу, но сам не является итератором
(итератор можно получить вызовом функции iter и использовать
для выполнения итераций вручную); кроме того, он поддерживает
возможность применения к результату нескольких итераторов, которые
отслеживают свое положение в последовательности целых чисел независимо
друг от друга:

\>>> R = range(3)  # Объект диапазона позволяет получить множество
\>>> next(R)       # итераторов
TypeError: range object is not an iterator

\>>> I1 = iter(R)
\>>> next(I1)
0
\>>> next(I1)
1
\>>> I2 = iter(R)  # Два итератора для одного диапазона
\>>> next(I2)
0
\>>> next(I1)  # I1 находится в другой позиции, не совпадающей
2              # с позицией I2

 Функции zip, map и filter, напротив, не поддерживают возможность
получения различных активных итераторов для одного и того же результата:

\>>> Z = zip((1, 2, 3), (10, 11, 12))
\>>> I1 = iter(Z)
\>>> I2 = iter(Z)  # Два итератора для одного и того же результата zip
\>>> next(I1)
(1, 10)
\>>> next(I1)
(2, 11)
\>>> next(I2)  # Позиции итераторов I2 и I1 совпадают!
(3, 12)

\>>> M = map(abs, (-1, 0, 1))  # То же относится к функции map
\>>> I1 = iter(M); I2 = iter(M)                   # (и filter)
\>>> print(next(I1), next(I1), next(I1))
1 0 1
\>>> next(I2)
StopIteration

\>>> R = range(3)               # А для объекта диапазона можно получить
\>>> I1, I2 = iter(R), iter(R)  # множество итераторов
\>>> [next(I1), next(I1), next(I1)]
[0 1 2]
\>>> next(I2)
0

 Когда мы будем учиться создавать собственные итерируемые объекты
с помощью классов (глава 29), мы увидим, что поддержка множественных
итераторов обычно обеспечивается за счет создания новых объектов,
которые могут передаваться функции iter. Если поддерживается
единственный итератор, функция iter обычно возвращает тот же объект,
который она получила. В главе 20 мы также узнаем, что функции-генераторы
и выражения-генераторы своим поведением напоминают скорее функции map
и zip, чем range, поддерживая единственный активный итератор. В этой
главе мы также познакомимся с некоторыми тонкостями использования
единственных итераторов в циклах, которые пытаются использовать
их многократно.


 Итераторы представлений словарей

 Как мы уже видели в главе 8, в Python 3.0 методы keys, values и items
словарей возвращают итерируемые объекты представлений, которые
возвращают результаты по одному за раз вместо того, чтобы сразу
создавать списки с результатами. Элементы представлений сохраняют
физический порядок следования в словаре, и все изменения, выполняемые
в словаре, отражаются на его представлениях. Теперь мы знаем
об итераторах достаточно много и готовы двигаться дальше:

\>>> D = dict(a=1, b=2, c=3)
\>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}

\>>> K = D.keys()  # Объект представления в версии 3.0
\>>> K             # не является списком
<dict_keys object at 0x026D83C0>

\>>> next(K)  # Представления не являются итераторами
TypeError: dict_keys object is not an iterator

\>>> I = iter(K)  # Из представлений можно получить итераторы
\>>> next(I)      # и с их помощью выполнять итерации вручную,
‘a’               # но они не поддерживают функцию len()
\>>> next(I)      # и операцию доступа к элементам по индексу
‘c’

\>>> for k in D.keys(): print(k, end=’ ‘)  # Во всех итерационных
...                           # контекстах итераторы используются
a c b                         # автоматически

 Как и при работе с любыми другими итераторами, в версии 3.0 вы всегда
можете получить полный список элементов представления словаря, передав
его встроенной функции list. Однако на практике этого обычно
не требуется, за исключением случаев, когда требуется вывести все
элементы в интерактивном сеансе или применить операции над списками,
такие как доступ к элементам по индексу:

\>>> K = D.keys()
\>>> list(K)  # При необходимости всегда можно получить полный список
[‘a’, ‘c’, ‘b’]

\>>> V = D.values()  # То же относится к представлениям values()
\>>> V               # и items()
<dict_values object at 0x026D8260>

\>>> list(V)
[1, 3, 2]
\>>> list(D.items())
[(‘a’, 1), (‘c’, 3), (‘b’, 2)]

\>>> for (k, v) in D.items(): print(k, v, end=’ ‘)
...
a 1 c 3 b 2

 Кроме того, в версии 3.0 словари по-прежнему поддерживают собственные
итераторы, которые возвращают последовательности ключей. То есть
в следующем контексте нет никакой необходимости вызывать метод keys:

\>>> D                    # Словари поддерживают собственные итераторы,
{‘a’: 1, ‘c’: 3, ‘b’: 2}  # возвращающие следующий ключ
\>>> I = iter(D)          # в каждой итерации
\>>> next(I)
‘a’
\>>> next(I)
‘c’

\>>> for key in D: print(key, end=’ ‘)  # Нет никакой необходимости
...                      # вызывать метод keys(), однако этот метод
a c b                    # в версии 3.0 также возвращает итератор!

 В заключение напомню еще раз: теперь метод keys больше не возвращает
список, поэтому традиционный способ обхода словарей по отсортированному
списку ключей больше не работает в версии 3.0. Вместо этого нужно
преобразовать представление ключей в список с помощью функции list
или вызвать функцию sorted, предав ей либо представление ключей,
либо сам словарь, как показано ниже:

\>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}
\>>> for k in sorted(D.keys())): print(k, D[k], end=’ ‘)
...
a 1 b 2 c 3

\>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}
\>>> for k in sorted(D): print(k, D[k], end=’ ‘)  # Лучший способ
...                                               # сортировки ключей
a 1 b 2 c 3


 Другие темы, связанные с итераторами

 Еще больше о генераторах списков и об итераторах мы узнаем в главе 20,
когда будем рассматривать их в контексте функций, и еще раз вернемся
к ним в главе 29, когда будем знакомиться с классами. Позднее
вы узнаете, что:

  С помощью инструкции yield пользовательские функции можно превратить
 в итерируемые функции-генераторы.

  Генераторы списков можно трансформировать в итерируемые
 выражения-генераторы, заключив их в круглые скобки.

  В пользовательские классы можно добавить поддержку итераций с помощью
 методов перегрузки операторов __iter__ или __getitem__.

 В частности, реализация пользовательских итераторов с помощью классов
позволяет обеспечить возможность использования произвольных объектов
в любых итерационных контекстах, с которыми мы познакомились здесь.
"""

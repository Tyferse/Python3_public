"""
 Правила именования переменных

 Теперь, когда мы исследовали инструкции присваивания, настало время
более формально подойти к вопросу выбора имен переменных. В языке Python
имена появляются в момент, когда им присваиваются некоторые значения,
однако существует несколько правил, которым желательно следовать
при выборе имен для всего сущего в ваших программах:

 Синтаксис: (символ подчеркивания или алфавитный символ) + (любое число
символов, цифр или символов подчеркивания)

  Имена переменных должны начинаться с символа подчеркивания
 или с алфавитного символа, за которым может следовать произвольное
 число алфавитных символов, цифр или символов подчеркивания. Допустимыми
 именами являются: _spam, spam и Spam_1, а 1_Spam, spam$ и @#! –
 недопустимыми.

 Регистр символов в именах имеет значение: имена SPAM и spam считаются
различными

  В языке Python регистр символов всегда принимается во внимание, как
 в именах, которые вы создаете, так и в зарезервированных словах.
 Например, имена X и x – это две разные переменные. Для обеспечения
 переносимости регистр символов учитывается и в именах импортируемых
 модулей, даже на платформах, где файловые системы не учитывают регистр
 символов.

 Запрещено использовать зарезервированные слова

  Имена определяемых вами переменных не могут совпадать
 с зарезервированными словами, имеющими в языке Python специальное
 назначение. Например, если попытаться использовать переменную с именем
 class, интерпретатор выведет сообщение о синтаксической ошибке, однако
 имена klass и Class являются вполне допустимыми. В табл. перечислены
 слова, которые в настоящее время зарезервированы языком Python
 (и, следовательно, запрещены для использования в качестве
 имен переменных).

  False   class     finally  is        return
  None    continue  for      lambda    try
  True    def       from     nonlocal  while
  and     del       global   not       with
  as      elif      if       or        yield
  assert  else      import   pass
  break   except    in       raise


 В более ранних версиях Python ситуация с зарезервированными словами
складывалась почти так же, с небольшими отклонениями:

  with и as не были зарезервированными словами до версии Python 2.6,
 в которой впервые официально появились менеджеры контекста.

  yield не было зарезервированным словом до версии Python 2.3, в которой
 впервые появились функции-генераторы.

  В версии 2.5 инструкция yield была преобразована в выражение,
 но не стала встроенной функцией, а осталась зарезервированным словом.

 В большинстве своем, зарезервированные слова языка Python записываются
символами нижнего регистра, и они действительно зарезервированы –
в отличие от имен в области видимости по умолчанию, о которой будет
рассказываться в следующей части книги, вы не можете переопределять
зарезервированные слова посредством операции присваивания (например,
and = 1 приведет к появлению ошибки).

 Кроме того, что первые три зарезервированных слова в табл. 11.3, True,
False и None, записываются символами разных регистров, они еще имеют
не совсем обычное назначение – они определены в области видимости
по умолчанию, о которой рассказывается в главе 17, и с технической точки
зрения являются именами переменных, которым присвоены объекты. Однако
во всех остальных смыслах они являются зарезервированными словами
и не могут использоваться для других целей, кроме как представлять
присвоенные им объекты. Все остальные зарезервированные слова являются
частью синтаксиса языка Python и могут появляться только
в определенном контексте.

 Кроме того, поскольку имена модулей в инструкции import становятся
переменными в ваших сценариях, это накладывает ограничения на имена
файлов с модулями. Вы можете создать файлы с именами and.py
и my-code.py, но вы не сможете импортировать их, потому что их имена
без расширения «.py» в программном коде будут преобразованы в имена
переменных и поэтому должны следовать только что обозначенным правилам
(зарезервированные слова запрещены, а символы дефиса являются
недопустимыми, хотя можно использовать символы подчеркивания).
Мы еще вернемся к этой теме в пятой части книги.


 Соглашения по именованию

 Помимо указанных правил существует еще целый ряд соглашений – правил,
которые не являются обязательными, но которым обычно следуют
на практике. Например, имена с двумя символами подчеркивания в начале
и в конце (например, __name__) обычно имеют особый смысл
для интерпретатора, поэтому вам следует избегать их использования
для именования своих переменных. Ниже приводится список соглашений,
которым было бы желательно следовать:

  Имена, начинающиеся с одного символа подчеркивания (_X),
 не импортируются инструкцией from module import *
 (описывается в главе 22).

  Имена, имеющие два символа подчеркивания в начале и в конце (__X__),
 являются системными именами, которые имеют особый смысл
 для интерпретатора.

  Имена, начинающиеся с двух символов подчеркивания и не оканчивающиеся
 двумя символами подчеркивания (__X), являются локальными
 («искаженными») для объемлющего класса (смотрите обсуждение
 псевдочастных атрибутов в главе 30).

  Имя, состоящее из единственного символа подчеркивания (_), хранит
 результат последнего выражения при работе в интерактивной оболочке.

 В дополнение к этим соглашениям существует еще ряд других соглашений,
которым обычно стремятся следовать программисты. Например, далее
в книге мы увидим, что имена классов обычно начинаются с заглавного
символа, а имена модулей – со строчного. Что имя self, хотя
и не являющееся зарезервированным, играет особую роль в классах.
В главе 17 мы познакомимся с еще одной крупной категорией имен,
которые называются встроенными, то есть предопределенными,
но не зарезервированными (вследствие чего они допускают переопределение:
инструкция open = 42 является вполне допустимой, но иногда вы можете
пожалеть, что это так!).


 Имена не имеют типа, тип – это характеристика объектов

 По большей части это лишь краткий обзор, но вы должны помнить,
что крайне важно сохранить четкое понимание различий между именами
и объектами в языке Python. Как говорилось в главе 6, объекты имеют тип
(например, целое число, список) и могут быть изменяемыми или нет.
С другой стороны, имена (они же переменные) всегда являются всего лишь
ссылками на объекты – они не имеют информации об изменяемости или о типе
отдельно от типа объекта, на который они ссылаются в данный момент
времени.

 Это вполне нормально, когда в разные моменты времени одно и то же имя
связывается с объектами разных типов:

\>>> x = 0  # Имя x связывается с целочисленным объектом
\>>> x = “Hello”  # Теперь оно представляет строку
\>>> x = [1, 2, 3]  # А теперь – список

 В последующих примерах вы увидите, что такая универсальная природа имен
может рассматриваться как существенное преимущество при программировании
на языке Python.1 В главе 17 вы узнаете, что имена находятся внутри
области видимости, которая определяет, где эти имена могут
использоваться, – место, где выполняется присваивание, определяет,
где это имя будет видимо.


 Инструкции выражений

 В языке Python выражения также могут использоваться в качестве
инструкций (то есть в отдельной строке). Однако, поскольку результат
вычисления таких выражений не сохраняется, использовать такую
возможность имеет смысл только в том случае, если выражение выполняет
какие-то полезные действия в виде побочного эффекта. В качестве
инструкций выражения используются обычно в двух ситуациях:

 Для вызова функций и методов

  Некоторые функции и методы выполняют огромный объем работы,
 не возвращая никакого значения. В других языках программирования такие
 функции иногда называют процедурами. Поскольку они не возвращают
 значений, которые могло бы потребоваться сохранить, вы можете вызывать
 эти функции в инструкциях выражений.

 Для вывода значений в интерактивной оболочке

  В ходе интерактивного сеанса интерпретатор автоматически выводит
 результаты вводимых выражений. С технической точки зрения они также
 являются инструкциями выражений и играют роль сокращенной версии
 инструкции print.


  Операция                Интерпретация
  spam(eggs, ham)         Вызов функции

  spam.ham(eggs)          Вызов метода

  spam                    Вывод значения переменной в интерактивной
                          оболочке интерпретатора

  print(a, b, c, sep=’’)  Операция ввода в Python 3.0

  yield x ** 2            Инструкция выражения yield


 Последние две строки в таблице представляют специальные случаи: как
будет показано далее в этой главе, инструкция вывода в версии Python 3.0
была преобразована в функцию, вызов которой обычно оформляется в виде
отдельной строки, и операция yield в функциях-генераторах
(рассматриваются в главе 20) также часто оформляется как инструкция.
В действительности оба случая являются всего лишь примерами инструкций
выражений.

 Например, даже при том, что функция print вызывается в отдельной
строке, как инструкция выражения, тем не менее она возвращает значение,
как и любая другая функция (она возвращает значение None –
оно возвращается всеми функциями, которые явно не возвращают какого-либо
значимого значения):

\>>> x = print(‘spam’)  # print – это выражение вызова функции
spam                    # в версии 3.0,
\>>> print(x)  # но может использоваться, как инструкция выражения
None

 Несмотря на то, что выражения могут играть роль инструкций
в языке Python, сами инструкции не могут использоваться в качестве
выражений. Например, язык Python не допускает встраивание инструкции
присваивания (=) в выражения. Сделано это специально, чтобы помочь
избежать ошибок, – вы могли бы случайно изменить переменную, введя
вместо оператора проверки равенства == оператор присваивания =.
В главе 13 будет показано, как отсутствие такой возможности может быть
компенсировано в языке Python, когда мы будем обсуждать цикл while.


 Инструкции выражений и непосредственное изменение объектов

 Инструкции выражений являются причиной распространенной ошибки при
программировании на языке Python. Инструкции выражений часто
используются для вызова методов списка, которые непосредственно изменяют
сам список:

\>>> L = [1, 2]
\>>> L.append(3)  # Метод append изменяет сам список
\>>> L
[1, 2, 3]

 Однако начинающие программисты нередко записывают такие операции в виде
инструкций присваивания, пытаясь связать имя L со списком:

\>>> L = L.append(4)  # Но метод append возвращает значение None, а не L
\>>> print L  # Поэтому мы теряем весь список!
None

 Такая операция дает неверный результат – такие методы списка,
как append, sort и reverse, всегда выполняют непосредственное изменение
объекта, но они не возвращают список, который был изменен с их помощью.
В действительности они возвращают объект None. Если результат такой
операции присвоить той же переменной, вы потеряете список (скорее всего,
он будет уничтожен в ходе процесса сборки мусора!).

 Поэтому не делайте этого. Мы еще раз вернемся к этому явлению в разделе
«Распространенные ошибки программирования» в конце этой части книги,
потому что подобные ситуации могут складываться в контексте выполнения
некоторых операторов цикла, с которыми мы познакомимся в последующих
главах.


 Операция print

 В языке Python инструкция print – это просто удобный для программистов
интерфейс к стандартному потоку вывода.

 С технической точки зрения эта инструкция преобразует объекты
в текстовое представление и либо посылает результат в поток стандартного
вывода, либо передает другому объекту, похожему на файл. Инструкция
print тесно связана с понятием файлов и потоков в языке Python.


 Методы объектов файлов

  В главе 9 мы рассматривали некоторые методы для работы с файлами,
 которые выводят текст (например, file.write(str)). Инструкция print
 чем-то похожа на них, но она имеет более специализированное назначение:
 инструкция print по умолчанию записывает объекты в поток stdout
 (с соблюдением некоторого форматирования), в то время как методы файлов
 записывают строки в произвольные файлы. В отличие от методов файлов,
 инструкция print не требует преобразовывать объекты в строковое
 представление.

 Поток стандартного вывода

  Поток стандартного вывода в языке Python (известный под именем
 stdout) – это просто объект, куда программы выводят текст. Наряду
 с потоками стандартного ввода и стандартного вывода сообщений
 об ошибках, поток стандартного вывода является одним из трех потоков,
 которые создаются в момент запуска сценария. Поток стандартного вывода
 обычно отображается на окно терминала, где была запущена программа
 на языке Python, если явно не было выполнено перенаправление вывода
 в файл или в конвейер системной командной оболочки.

 Так как поток стандартного вывода в языке Python доступен
в виде объекта stdout из встроенного модуля sys (то есть sys.stdout),
вполне возможно имитировать поведение инструкции print с помощью методов
записи в файл, хотя использование print выглядит проще.

 Операция вывода является одной из тех, в которых различия между
Python 3.0 и 2.6 оказались наиболее заметными. Фактически различия
в реализации этой операции являются одной из основных причин,
обусловливающих невозможность выполнения программ, написанных
для версии 2.X, под управлением версии 3.X без внесения изменений
в программный код. В частности, от версии интерпретатора зависит способ
оформления операции print:

  В Python 3.X инструкция print превратилась во встроенную функцию,
 которая принимает именованные аргументы, определяющие специальные
 режимы вывода.

  В Python 2.X print – это инструкция, имеющая свой характерный
 синтаксис.

 Так как в этой книге рассматриваются обе версии интерпретатора,
3.0 и 2.6, мы рассмотрим особенности реализации print в каждой из них
по отдельности. Если вам повезло настолько, что вы работаете
с программами, написанными для какой-то одной версии Python, вы можете
прочитать только тот раздел, который подходит для вашего случая.
Однако ваша ситуация может измениться, поэтому для вас не будет лишним
познакомиться с обеими версиями.


 Функция print в Python 3.0

 Строго говоря, print не является разновидностью инструкции
в версии 3.0, это просто одна из инструкций выражений, с которыми
мы познакомились в предыдущем разделе.

 Обычно вызов встроенной функции print оформляется в виде отдельной
строки, потому что она не возвращает никакого значения (точнее,
она возвращает объект None), о сохранении которого стоило бы
позаботиться. Так как в версии 3.0 print – это обычная функция,
для обращения к ней используется не какая-то специальная форма,
а стандартный синтаксис вызова функций. Вследствие этого специальные
режимы работы определяются с помощью именованных аргументов. Такая форма
не только более универсальна, но и обеспечивает лучшую поддержку
будущих расширений.

 Для сравнения, инструкция print в версии Python 2.6 имеет
специализированный синтаксис поддержки таких особенностей,
как подавление вывода символа конца строки и перенаправление вывода
в файл. Кроме того, инструкция print в версии 2.6 вообще не позволяет
определить строки-разделители – в версии 2.6 вам намного чаще придется
конструировать строки заранее, чем в версии 3.0.


 Формат вызова

 Синтаксис вызова функции print в версии 3.0 имеет следующий вид:

print([object, ...][, sep=’ ‘][, end=’\n’][, file=sys.stdout])

 Здесь элементы в квадратных скобках являются необязательными и могут
быть опущены, а значения, следующие за знаком =, определяют значения
по умолчанию. Проще говоря, эта встроенная функция выводит в файл stream
один или более объектов в текстовом представлении, разделенных строкой
sep, и завершает вывод строкой end.

 Параметры sep, end и file, если они необходимы, должны передаваться
не в виде позиционных, а в виде именованных аргументов, то есть
с использованием специального синтаксиса «имя=значение». Именованные
аргументы подробно рассматриваются в главе 18, но они достаточно просты
в использовании. Именованные аргументы могут указываться в любом порядке
в вызове функции, но после объектов, предназначенных для вывода,
и определяют параметры вывода:

  sep – строка, которая должна вставляться между объектами при выводе.
 По умолчанию состоит из одного пробела. Чтобы подавить вывод
 строки-разделителя, в этом аргументе следует передать пустую строку.

  end – строка, добавляемая в конец выводимого текста. По умолчанию
 содержит символ конца строки \n. Если в этом аргументе передать пустую
 строку, следующий вызов функции print начнет вывод текста с позиции,
 где закончился вывод текущей строки.

  file – объект файла, стандартный поток или другой объект, похожий на
 файл, куда будет выводиться текст. По умолчанию используется объект
 sys.stdout стандартного потока вывода. В этом аргументе можно передать
 любой объект, поддерживающий метод файлов write(string); если
 передается настоящий объект файла, он должен уже быть открыт
 для записи.

 Текстовое представление любого объекта, который передается для вывода,
функция print получает с помощью встроенной функции str. Как мы уже з
наем, эта функция возвращает «удобочитаемое» строковое представление
любого объекта.1 При вызове без аргументов функция print просто выведет
символ конца строки в поток стандартного вывода, что выглядит, как вывод
пустой строки.


 Функция print в действии

 Пользоваться функцией print в версии 3.0 намного проще, чем можно было
бы предположить, после знакомства с некоторыми ее особенностями.
Для иллюстрации выполним несколько коротких примеров. Ниже
демонстрируется порядок вывода объектов различных типов в поток
стандартного вывода, используемый по умолчанию, со строкой-разделителем
по умолчанию и с добавлением символа конца строки (эти значения
параметров вывода были выбраны значениями по умолчанию, потому что они
используются в подавляющем большинстве случаев):

C:\misc> c:\python30\python
\>>>
\>>> print() # Выведет пустую строку
\>>> x = ‘spam’
\>>> y = 99
\>>> z = [‘eggs’]
\>>>
\>>> print(x, y, z) # Выведет три объекта
spam 99 [‘eggs’]

 В данном примере нет никакой необходимости преобразовывать объекты
в строки, как этого требуют методы записи в файлы. По умолчанию функция
print выводит символ пробела между объектами. Чтобы подавить вывод
пробела, достаточно просто передать пустую строку в именованном
аргументе sep или указать иную строку-разделитель:

\>>> print(x, y, z, sep=’’)  # Строка-разделитель выводиться не будет
spam99[‘eggs’]
\>>>
\>>> print(x, y, z, sep=’, ‘)  # Нестандартная строка-разделитель
spam, 99, [‘eggs’]

 Кроме того, в конце выводимой строки функция print добавляет символ
конца строки. Вывод этого символа можно подавить, передав пустую строку
в именованном аргументе end. Точно так же в этом аргументе можно
передать иной разделитель строк (включая символ \n, чтобы вручную
обеспечить перевод строки):

\>>> print(x, y, z, end=’’)  # Подавление вывода символа конца строки
spam 99 [‘eggs’]>>>
\>>>
\>>> print(x, y, z, end=’’); print(x, y, z)  # Вывод двух строк
spam 99 [‘eggs’]spam 99 [‘eggs’]  # в одной строке
\>>> print(x, y, z, end=’...\n’)  # Нестандартный разделитель строк
spam 99 [‘eggs’]...
\>>>

 Допускается одновременное использование именованных аргументов,
определяющих разделители между объектами в строке и между строками, –
они могут указываться в любом порядке, но только после объектов,
которые требуется вывести:

\>>> print(x, y, z, sep=’...’, end=’!\n’)  # Несколько именованных
spam...99...[‘eggs’]!                     # аргументов
\>>> print(x, y, z, end=’!\n’, sep=’...’)  # Порядок не имеет значения
spam...99...[‘eggs’]!

 Ниже демонстрируется порядок использования именованного аргумента
file – с его помощью можно перенаправить вывод текста в файл, открытый
для записи, или в другой объект, совместимый с операцией вывода
(в действительности – это разновидность перенаправления потоков,
о чем будет рассказываться ниже в этом разделе):

\>>> print(x, y, z, sep=’...’, file=open(‘data.txt’, ‘w’))  # Вывод
\>>> print(x, y, z) # Вывод в поток stdout                    в файл
spam 99 [‘eggs’]
\>>> print(open(‘data.txt’).read())  # Вывод содержимого
spam...99...[‘eggs’]                 # текстового файла

 Наконец, имейте в виду, что возможность определить строку-разделитель
объектов в строке и разделитель строк, предоставляемая функцией print, –
это всего лишь подручное средство. При необходимости получить более
сложное форматирование совсем не обязательно использовать
эту возможность. Вместо этого можно сконструировать строку заранее
или прибегнуть к помощи инструментов форматирования, с которыми мы
встречались в главе 7, внутри вызова функции print, и вывести
сконструированную строку единственным вызовом print:

\>>> text = ‘%s: %-.4f, %05d’ % (‘Result’, 3.14159, 42)
\>>> print(text)
Result: 3.1416, 00042

\>>> print(‘%s: %-.4f, %05d’ % (‘Result’, 3.14159, 42))
Result: 3.1416, 00042

 Как мы увидим в следующем разделе, практически все, что было сказано
о функции print в Python 3.0, точно так же применимо и к инструкции
print в версии 2.6, особенно если учесть, что функция задумывалась
как дальнейшее развитие и улучшение поддержки операции вывода в 2.6.


 Перенаправление потока вывода вручную

 Итак, зачем я показал более сложный способ вывода? Как оказывается,
объект sys.stdout обеспечивает возможность вывода, эквивалентную базовой
методике, используемой в языке Python. Вообще говоря, инструкция print
и объект sys.stdout связаны между собой следующим образом. Инструкция:

print(X, Y)  # Или print X, Y в версии 2.6

 является эквивалентом более длинной:

import sys
sys.stdout.write(str(X) + ‘ ‘ + str(Y) + ‘\n’)

 которая вручную выполняет преобразование объекта в строку с помощью
функции str, добавляет символ конца строки с помощью оператора +
и вызывает метод write потока вывода. А как бы вы выполнили
ту же задачу? (Этим примером мне хотелось бы подчеркнуть дружественную
природу инструкции print...)

 Очевидно, что более длинная форма сама по себе менее удобна
в использовании. Однако полезно знать, что она является точным
эквивалентом инструкции print, потому что существует возможность
переназначить sys.stdout на что-то, отличное от стандартного потока
вывода. Другими словами, эта эквивалентность обеспечивает возможность
заставить инструкцию print выводить текст в другое место. Например:

import sys
sys.stdout = open(‘log.txt’, ‘a’)  # Перенаправить вывод в файл
...
Print(x, y, x)  # Текст появится в файле log.txt

 Здесь мы вручную перенаправили объект sys.stdout в файл, открытый
вручную в режиме добавления (так как мы добавляем новое содержимое).
После этого все инструкции print в программе будут выводить текст
в конец файла log.txt, а не в стандартный поток вывода. Инструкции print
благополучно продолжают вызывать метод write объекта sys.stdout
независимо от того, куда он ссылается. Поскольку в каждом процессе
существует всего один модуль sys, перенаправление sys.stdout таким
способом будет воздействовать на все инструкции print в программе.

 Фактически, как будет говориться в ближайшей врезке, описывающей
инструкцию print и объект stdout, существует возможность перенаправить
sys.stdout в объект, который даже не является файлом, при условии,
что он поддерживает ожидаемый интерфейс: метод write, принимающий
строковый аргумент. Этот объект может быть классом, способным
обрабатывать и перенаправлять выводимый текст произвольным образом.

 Этот прием с перенаправлением потока вывода в первую очередь может
оказаться полезен в программах, изначально рассчитанных на использование
инструкции print. Если известно, что весь вывод должен отправляться
в файл, вы всегда сможете организовать вызов методов записи в файл.
При перенаправлении потока вывода в программах, основанных
на использовании инструкции print, настройка объекта sys.stdout
обеспечивает удобную альтернативу изменению поведения всех инструкций
print или применению перенаправления средствами командной оболочки
системы.


 Автоматическое перенаправление потоков

 Прием перенаправления вывода текста за счет назначения файла в объекте
sys.stdout очень часто используется на практике. Однако в программном
коде предыдущего раздела имеется одна потенциальная проблема –
отсутствует прямой способ восстановления первоначального потока вывода,
если вдруг после вывода данных в файл потребуется вернуться
к выводу на экран. Но поскольку sys.stdout является обычным объектом,
вы всегда можете в случае необходимости сохранить его и восстановить
позднее:

C:\misc> c:\python30\python
\>>> import sys
\>>> temp = sys.stdout  # Сохранить для последующего восстановления
\>>> sys.stdout = open(‘log.txt’, ‘a’)  # Перенаправить вывод в файл
\>>> print(‘spam’)  # Выведет в файл, а не на экран
\>>> print(1, 2, 3)
\>>> sys.stdout.close()  # Вытолкнуть буферы на диск
\>>> sys.stdout = temp  # Восстановить первоначальный поток
\>>> print(‘back here’)  # Вывести на экран
back here
\>>> print(open(‘log.txt’).read())  # Результаты более ранних обращений
spam                                # к инструкции print
1 2 3

 Потребность в таком перенаправлении возникает на удивление часто,
а ручное сохранение и восстановление оригинального потока вывода –
процедура достаточно сложная, что привело к появлению расширения
для инструкции print, которое делает такое перенаправление ненужным.

 В версии 3.0 именованный аргумент file позволяет перенаправить в файл
вывод единственного вызова функции print, не прибегая к переустановке
значения sys.stdout. Так как такое перенаправление носит временный
характер, обычные вызовы функции print продолжают выводить текст
в оригинальный поток вывода. В версии 2.6 того же эффекта можно
добиться, указав в начале инструкции print символы >> и вслед за ними –
объект файла (или другой совместимый объект). Например, следующий
фрагмент выводит текст в файл log.txt:

log = open(‘log.txt’, ‘a’) # 3.0
print(x, y, z, file=log)  # Вывести в объект, напоминающий файл
print(a, b, c)  # Вывести в оригинальный поток вывода
log = open(‘log.txt’, ‘a’) # 2.6
print >> log, x, y, z  # Вывести в объект, напоминающий файл
print a, b, c  # Вывести в оригинальный поток вывода

 Эти способы перенаправления удобно использовать, когда в одной
и той же программе необходимо организовать вывод и в файл,
и в стандартный поток вывода. Однако если вы собираетесь использовать
эти формы вывода, вам потребуется создать объект-файл (или объект,
который имеет метод write, как и объект файла) и передавать инструкции
этот объект, а не строку с именем файла:

C:\misc> c:\python30\python
\>>> log = open(‘log.txt’, ‘w’)
\>>> print(1, 2, 3, file=log)  # В 2.6: print >> log, 1, 2, 3
\>>> print(4, 5, 6, file=log)
\>>> log.close()
\>>> print(7, 8, 9)  # В 2.6: print 7, 8, 9
7 8 9
\>>> print(open(‘log.txt’).read())
1 2 3
4 5 6

 Эти расширенные формы инструкции print нередко используются для вывода
сообщений об ошибках в стандартный поток ошибок, sys.stderr. Вы можете
либо использовать его метод write и форматировать выводимые строки
вручную, либо использовать синтаксис перенаправления:

\>>> import sys
\>>> sys.stderr.write((‘Bad!’ * 8) + ‘\n’)
Bad!Bad!Bad!Bad!Bad!Bad!Bad!Bad!
\>>> print(‘Bad!’ * 8, file=sys.stderr)  # В 2.6:
Bad!Bad!Bad!Bad!Bad!Bad!Bad!Bad!        # print >> sys.stderr, ‘Bad’ * 8

 Теперь, когда вы знаете все о перенаправлении вывода, эквивалентность
функции print и метода write файлов должна показаться вам очевидной.
В следующем примере демонстрируется вывод текста обоими способами
в версии 3.0, затем демонстрируется перенаправление вывода во внешний
файл и выполняется проверка содержимого текстовых файлов:

\>>> X = 1; Y = 2
\>>> print(X, Y)  # Вывод: простой способ
1 2
\>>> import sys  # Вывод: сложный способ
\>>> sys.stdout.write(str(X) + ‘ ‘ + str(Y) + ‘\n’)
1 2
4
\>>> print(X, Y, file=open(‘temp1’, ‘w’))  # Перенаправление в файл
\>>> open(‘temp2’, ‘w’).write(str(X) + ‘ ‘ + str(Y) + ‘\n’)  # Запись
4                                                            # в файл
\>>> print(open(‘temp1’, ‘rb’).read())  # Двоичный режим
b’1 2\r\n’
\>>> print(open(‘temp2’, ‘rb’).read())
b’1 2\r\n’

 Как видите, для отображения текста лучше пользоваться операцией print,
если только вы не получаете особое удовольствие от ввода с клавиатуры.
Другой пример, демонстрирующий эквивалентность использования операции
print и метода write файлов, – пример имитации функции print для Python
версий 2.6 и более ранних, вы найдете в главе 18.


 Реализация вывода, не зависящая от версии интерпретатора

 Наконец, для тех, кто не может ограничиться только версией Python 3.0
и ищет способ организации вывода, совместимый с 3.0, имеется несколько
вариантов на выбор. Первый состоит в том, чтобы использовать инструкции
print для версии 2.6 и затем автоматически преобразовывать их
в эквивалентные вызовы функции print для версии 3.0 с помощью сценария
2to3. Дополнительные подробности об этом сценарии вы найдете
в документации к Python 3.0 – он пытается преобразовать программный код,
написанный для версии 2.X, так, чтобы он мог выполняться под управлением
Python 3.0.

 Второй заключается в том, чтобы использовать функцию print
для версии 3.0 в программах, выполняющихся под управлением Python 2.6,
включив возможность использования этой функции с помощью инструкции:

from __future__ import print_function

 Эта инструкция включает поддержку разновидности инструкции print
в интерпретаторе Python 2.6, которая точно соответствует функции print
в версии 3.0. Благодаря этому вы сможете использовать все возможности
функции print в версии 2.6, и при этом позднее вам не придется менять
операции вывода при переходе на новую версию 3.0.

Кроме того, имейте в виду, что простые случаи использования операции
вывода, как в первой строке табл. 11.5, будут действовать в любой версии
Python. Благодаря тому, что синтаксис языка позволяет заключать
в круглые скобки любые выражения, мы всегда можем имитировать вызов
функции print версии 3.0 в программном коде для версии 2.6, просто
добавив скобки. Единственный недостаток такого подхода состоит в том,
что он образует кортеж из выводимых объектов, когда их более одного –
в выводимом тексте они будут заключены в круглые скобки. В версии 3.0,
например, в круглых скобках, в вызове функции, может быть указано
произвольное количество объектов:

C:\misc> c:\python30\python
\>>> print(‘spam’)  # Синтаксис вызова функции print в 3.0
spam
\>>> print(‘spam’, ‘ham’, ‘eggs’)  # Вызов с нескольким аргументами
spam ham eggs

 В первом случае в версии 2.6 результат будет тот же самый, но во втором
случае будет создан кортеж:

C:\misc> c:\python26\python
\>>> print(‘spam’)  # 2.6: использование скобок в инструкции
spam
\>>> print(‘spam’, ‘ham’, ‘eggs’)  # В действительности –
(‘spam’, ‘ham’, ‘eggs’)            # это объект кортежа!

 Чтобы обеспечить настоящую независимость от версии интерпретатора,
необходимо сначала сконструировать строку, используя оператор
форматирования строк, или метод format, или другие инструменты
для работы со строками, с которыми мы познакомились в главе 7:

\>>> print(‘%s %s %s’ % (‘spam’, ‘ham’, ‘eggs’))
spam ham eggs
\>>> print(‘{0} {1} {2}’.format(‘spam’, ‘ham’, ‘eggs’))
spam ham eggs

 Придется держать в уме: print и stdout

 Эквивалентность инструкции print и метода write объекта sys.stdout
имеет большое значение. Она позволяет перенаправить объект sys.stdout
в определяемый пользователем объект, который поддерживает тот же самый
метод write, что и файлы. Так как инструкция print всего лишь передает
текст методу sys.stdout.write, вы можете перехватывать выводимый текст,
перенаправив sys.stdout в объект, обладающий методом write
для обработки текста.

 Например, можно отправить текст в окно графического интерфейса
или отправить его в несколько мест, определив объект с методом write,
который выполнит все необходимые действия. Пример использования такой
возможности вы увидите в шестой части этой книги, когда мы будем изучать
классы, но в общих чертах это выглядит примерно так:

class FileFaker:
    def write(self, string):
        # Выполнить какие-либо действия со строкой

import sys
sys.stdout = FileFaker()
print someObjects  # Передает строку методу write класса

 Этот прием возможен благодаря тому, что инструкция print является тем,
что в следующей части книги мы назовем полиморфной операцией, – она
не интересуется тем, что из себя представляет объект sys.stdout,
ей нужен всего лишь метод (то есть интерфейс) с именем write. Такое
перенаправление в объекты может быть реализовано еще проще с помощью
именованного аргумента file в версии 3.0 и расширенной формы >>
инструкции print в версии 2.6, благодаря чему нам не требуется явно
перенаправлять объект sys.stdout – обычные операции вывода по-прежнему
будут выводить текст в объект sys.stdout:

myobj = FileFaker()  # 3.0: Перенаправление вывода для одной инструкции
print(someObjects, file=myobj)  # Не влияет на объект sys.stdout
myobj = FileFaker()  # 2.6: Перенаправление вывода для одной инструкции
print >> myobj, someObjects  # Не влияет на объект sys.stdout

 Встроенная функция input в языке Python читает данные из файла
sys.stdin, благодаря чему существует возможность перенаправить ввод
аналогичным образом, используя классы, реализующие метод read. Смотрите
пример использования функции input и цикла while, который приводится
в главе 10, чтобы лучше представлять себе, о чем речь. Обратите
внимание, что вывод текста осуществляется в поток stdout, – это
обеспечивает возможность вывода документов HTML в CGI-сценариях. Кроме
того, это позволяет выполнить перенаправление ввода и вывода
для сценария на языке Python обычными средствами командной строки
операционной системы:

python script.py < inputfile > outputfile
python script.py | filterProgram

 Механизм перенаправления операций вывода в языке Python является
альтернативой этим видам перенаправления средствами командной оболочки.
"""

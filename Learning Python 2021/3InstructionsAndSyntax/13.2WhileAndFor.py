"""
 Приемы программирования циклов

 Цикл for относится к категории счетных циклов. Обычно он выглядит проще
и работает быстрее, чем цикл while, поэтому его нужно рассматривать
в самую первую очередь, когда возникает необходимость выполнить обход
последовательности. Однако существуют ситуации, когда необходимо
выполнять обход каким-то особенным способом. Например, как быть, если
необходимо выполнить обход каждого второго или каждого третьего элемента
в списке или попутно выполнить изменения в списке? Или если необходимо
реализовать параллельный обход более чем одной последовательности
в одном и том же цикле for? Такие уникальные ситуации всегда можно
запрограммировать с помощью цикла while и извлечения элементов вручную,
но Python предоставляет две встроенные возможности, позволяющие
управлять обходом элементов в цикле for:

  Встроенная функция range возвращает непрерывную последовательность
 увеличивающихся целых чисел, которые можно использовать в качестве
 индексов внутри цикла for.

  Встроенная функция zip возвращает список кортежей, составленных
 из элементов входных списков с одинаковыми индексами, который может
 использоваться для одновременного обхода нескольких последовательностей
 в цикле for.

 Обычно циклы for выполняются быстрее, чем аналогичные им счетные циклы
на базе инструкции while, поэтому везде, где только возможно, лучше
пользоваться такими инструментами, которые позволят использовать цикл
for. Рассмотрим каждый из этих встроенных инструментов по очереди.


 Счетные циклы: while и range

 Функция range является по-настоящему универсальным инструментом,
который может использоваться в самых разных ситуациях. Чаще всего она
используется для генерации индексов в цикле for, но вы можете
использовать ее везде, где необходимы списки целых чисел. В Python 3.0
функция range возвращает итератор, который генерирует элементы
по требованию, поэтому, чтобы отобразить результаты ее работы, мы должны
обернуть вызов этой функции в вызов функции list (подробнее
об итераторах рассказывается в главе 14):

\>>> list(range(5)), list(range(2, 5)), list(range(0, 10, 2))
([0, 1, 2, 3, 4], [2, 3, 4], [0, 2, 4, 6, 8])

 Функция range с одним аргументом генерирует список целых чисел
в диапазоне от нуля до указанного в аргументе значения, не включая его.
Если функции передать два аргумента, первый будет рассматриваться
как нижняя граница диапазона. Необязательный третий аргумент определяет
шаг – в этом случае интерпретатор будет добавлять величину шага
при вычислении каждого последующего значения (по умолчанию шаг равен 1).
Существует возможность воспроизводить последовательности чисел
в диапазоне отрицательных значений и в порядке убывания:

\>>> list(range(-5, 5))
[-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]
\>>> list(range(5, -5, -1))
[5, 4, 3, 2, 1, 0, -1, -2, -3, -4]

 Такое использование функции range само по себе может быть полезным,
однако чаще всего она используется в циклах for. Прежде всего, она
обеспечивает простой способ повторить действие определенное число раз.
Например, чтобы вывести три строки, можно использовать функцию range
для создания соответствующего количества целых чисел – в версии 3.0
инструкция for автоматически извлекает все значения из итератора range,
поэтому нам не потребовалось использовать функцию list:

\>>> for i in range(3):
...     print(i, ‘Pythons’)
...
0 Pythons
1 Pythons
2 Pythons

 Функция range также часто используется для косвенного обхода
последовательностей. Самый простой и самый быстрый способ выполнить
обход последовательности заключается в использовании цикла for, когда
основную работу выполняет интерпретатор:

\>>> X = ‘spam’
\>>> for item in X: print(item, end=’ ‘)  # Простейший цикл
...
s p a m

 При таком использовании все задачи, касающиеся выполнения итераций,
решаются внутренними механизмами цикла for. Если вам действительно
необходимо явно управлять логикой доступа к элементам, можно
воспользоваться циклом while:

\>>> i = 0
\>>> while i < len(X):  # Обход с помощью цикла while
...     print(X[i], end=’ ‘)
...     i += 1
...
s p a m

 Однако управлять индексами вручную можно и в цикле for, если
использовать функцию range для воспроизведения списка индексов. Это
многоэтапный процесс, но он вполне пригоден для генерирования смещений,
а не элементов с этим смещениями:

\>>> X
‘spam’
\>>> len(X)  # Длина строки
4
\>>> list(range(len(X)))  # Все допустимые смещения в X
[0, 1, 2, 3]
\>>>
\>>> for i in range(len(X)): print(X[i],end=’ ‘)  # Извлечение элементов
...                                               # вручную
s p a m

 В этом примере выполняется обход списка смещений в строке X,
а не фактических элементов строки – нам пришлось внутри цикла обращаться
к строке X, чтобы извлечь каждый элемент.


 Обход части последовательности: range и срезы

 Последний пример в предыдущем разделе вполне работоспособен, но он
выполняется гораздо медленнее, чем мог бы. Кроме того, нам пришлось
выполнить больше работы, чем требуется для решения такой задачи. Если вы
не предъявляете особых требований к индексам, всегда лучше использовать
простейшую форму цикла for – используйте цикл for вместо while везде,
где только возможно, и используйте функцию range в циклах for, только
если это действительно необходимо. Следующее простое решение является
лучшим:

\>>> for item in X: print(item)  # Простейшая итерация
...

 Однако прием, представленный в предшествующем примере, позволяет нам
управлять порядком обхода последовательности, например пропускать
элементы:

\>>> S = ‘abcdefghijk’
\>>> list(range(0, len(S), 2))
[0, 2, 4, 6, 8, 10]
\>>> for i in range(0, len(S), 2): print(S[i], end=’ ‘)
...
a c e g i k

 Здесь в цикле выбирается каждый второй элемент строки S при обходе
списка значений, сгенерированных функцией range. Чтобы извлечь каждый
третий элемент, достаточно изменить третий аргумент функции range,
передав в нем значение 3, и так далее. Таким образом, функция range
позволяет пропускать элементы, сохраняя при этом простоту цикла for.

 Однако, на сегодняшний день это, пожалуй, не самый лучший способ. Если
вам действительно необходимо пропустить элементы последовательности,
можно использовать расширенную форму операции извлечения среза с тремя
пределами, представленную в главе 7, которая обеспечивает более простой
путь к достижению цели. Чтобы получить каждый второй символ из строки S,
можно извлечь срез с шагом 2:

\>>> S = ‘abcdefghijk’
\>>> for c in S[::2]: print(c, end=’ ‘)
...
a c e g i k


 Изменение списков: range

 Еще одно место, где можно использовать комбинацию функции range и цикла
for, – это циклы, изменяющие список в процессе его обхода. Например,
предположим, что по тем или иным причинам нам необходимо прибавить 1
к каждому элементу списка. Можно попытаться использовать для этой цели
простейшую форму цикла for, но скорее всего это не то, что нам нужно:

\>>> L = [1, 2, 3, 4, 5]
\>>> for x in L:
...     x += 1
...
\>>> L
[1, 2, 3, 4, 5]
\>>> x
6

 Такое решение вообще ничего не дает – здесь изменяется переменная
цикла x, а не список L. Причину такого поведения трудно заметить. Всякий
раз, когда цикл выполняет очередную итерацию, переменная x ссылается
на очередное целое число, которое уже было извлечено из списка. В первой
итерации, например, переменная x является целым числом 1. На следующей
итерации в переменную x будет записана ссылка на другой объект –
целое число 2, но это никак не повлияет на список, откуда было взято
число 1.

 Чтобы действительно изменить список во время его обхода, нам необходимо
использовать операцию присваивания по индексу и изменить значения
во всех позициях, по которым осуществляется цикл. Необходимые нам
индексы можно воспроизвести с помощью комбинации функций len/range:

\>>> L = [1, 2, 3, 4, 5]
\>>> for i in range(len(L)):  # Прибавить 1 к каждому элементу
...     L[i] += 1 # Или L[i] = L[i] + 1           # в списке L
...
\>>> L
[2, 3, 4, 5, 6]

 При такой реализации список изменяется в процессе обхода. Простой цикл
for x in L: такого результата дать не может, потому что в таком цикле
выполняется обход фактических элементов, а не позиций в списке.
А возможно ли создать эквивалентный цикл while? Для этого нам
потребуется приложить немного больше усилий, и такой цикл наверняка
будет работать медленнее:

\>>> i = 0
\>>> while i < len(L):
...     L[i] += 1
... i += 1
...
\>>> L
[3, 4, 5, 6, 7]

 В данном случае решение на базе функции range может быть неидеальным.
Генератор списка в виде

[x+1 for x in L]

 - также даст желаемый результат, но первоначальный список при это
не изменится (мы могли бы присвоить получившийся новый список обратно
переменной L, но это выражение не изменит другие ссылки
на первоначальный список). Поскольку эта концепция циклов занимает такое
важное положение, мы еще раз вернемся к ней, когда будем рассматривать
генераторы списков ниже в этой главе.


 Параллельный обход: zip и map

 Как было показано выше, встроенная функция range позволяет выполнять
обход отдельных частей последовательностей. В том же духе встроенная
функция zip позволяет использовать цикл for для обхода нескольких
последовательностей параллельно. Функция zip принимает одну
или несколько последовательностей в качестве аргументов и возвращает
список кортежей, составленных из соответствующих элементов этих
последовательностей. Например, предположим, что мы выполняем обработку
двух списков:

\>>> L1 = [1,2,3,4]
\>>> L2 = [5,6,7,8]

 Для объединения элементов этих списков можно использовать функцию zip,
которая создаст список кортежей из пар элементов (подобно функции range,
в версии 3.0 функция zip возвращает итерируемый объект, поэтому, чтобы
вывести все результаты, возвращаемые этой функцией, необходимо обернуть
ее вызов вызовом функции list, – подробнее об итераторах рассказывается
в следующей главе):

\>>> zip(L1, L2)
<zip object at 0x026523C8>
\>>> list(zip(L1,L2))  # Функция list необходима в 3.0, но не в 2.6
[(1, 5), (2, 6), (3, 7), (4, 8)]

 Такой результат может пригодиться в самых разных ситуациях,
но применительно к циклу for он обеспечивает возможность выполнения
параллельных итераций:

\>>> for (x, y) in zip(L1, L2):
...     print(x, y, ‘--’, x+y)
...
1 5 -- 6
2 6 -- 8
3 7 -- 10
4 8 -- 12

 Здесь выполняется обход результата обращения к функции zip,
то есть пар, составленных из элементов двух списков. Обратите внимание,
что в этом цикле используется операция присваивания кортежей
для получения элементов каждого кортежа, полученного от функции zip.
На первой итерации она будет выглядеть, как если бы была выполнена
инструкция (x, y) = (1, 5). Благодаря этому мы можем сканировать
оба списка L1 и L2 в одном цикле. Тот же эффект можно получить с помощью
цикла while, в котором доступ к элементам производится вручную,
но такой цикл будет сложнее в реализации и наверняка медленнее,
чем прием, основанный на использовании for/zip.

 Функция zip на самом деле более универсальна, чем можно было бы
представить на основе этого фрагмента. Например, она принимает
последовательности любого типа (в действительности – любые итерируемые
объекты, включая и файлы) и позволяет указывать более двух аргументов.
При вызове с тремя аргументами, как показано в следующем примере,
она конструирует список кортежей, состоящих из трех элементов, выбирая
элементы из каждой последовательности с одним и тем же смещением
(с технической точки зрения, из N аргументов функция zip создает
N-мерный кортеж):

\>>> T1, T2, T3 = (1,2,3), (4,5,6), (7,8,9)
\>>> T3
(7, 8, 9)
\>>> list(zip(T1,T2,T3))
[(1, 4, 7), (2, 5, 8), (3, 6, 9)]

 Длина списка, возвращаемого функцией zip, равна длине кратчайшей
из последовательностей, если аргументы имеют разную длину. В следующем
примере выполняется объединение двух строк с целью параллельной
обработки их символов, при этом результат содержит столько кортежей,
сколько было элементов в кратчайшей последовательности:

\>>> S1 = ‘abc’
\>>> S2 = ‘xyz123’
\>>>
\>>> list(zip(S1, S2))
[(‘a’, ‘x’), (‘b’, ‘y’), (‘c’, ‘z’)]


 Эквивалентная функция map в Python 2.6

 В Python 2.X имеется родственная встроенная функция map, объединяющая
элементы последовательностей похожим образом, но она не усекает
результат по длине кратчайшей последовательности, а дополняет
недостающие элементы значениями None, если аргументы имеют разную длину:

\>>> S1 = ‘abc’
\>>> S2 = ‘xyz123’
\>>> map(None, S1, S2)  # Только в 2.X
[(‘a’, ‘x’), (‘b’, ‘y’), (‘c’, ‘z’),
 (None, ‘1’), (None, ‘2’), (None,’3’)]

 В этом примере используется вырожденная форма обращения к встроенной
функции map, которая больше не поддерживается в Python 3.0. Обычно она
принимает функцию и одну или более последовательностей и собирает
результаты вызова функции с соответствующими элементами, извлеченными
из последовательностей. Подробнее функция map будет рассматриваться
в главах 19 и 20. Ниже приводится короткий пример, где встроенная
функция ord применяется к каждому символу в строке и собирает результаты
в список (подобно функции zip, в версии 3.0 map возвращает генератор,
и поэтому, чтобы получить все ее результаты в интерактивном сеансе,
обращение к ней следует заключить в вызов функции list):

\>>> list(map(ord, ‘spam’))
[115, 112, 97, 109]

 Тот же результат можно получить с помощью следующего цикла,
но реализация на основе функции map зачастую выполняется быстрее:

\>>> res = []
\>>> for c in ‘spam’: res.append(ord(c))
\>>> res
[115, 112, 97, 109]


 Конструирование словаря с помощью функции zip

 В 8 главе я говорил, что функцию zip, используемую здесь, удобно
применять для создания словарей, когда ключи и значения вычисляются
во время выполнения программы. Теперь, когда мы поближе познакомились
с этой функцией, я объясню, какое отношение она имеет к конструированию
словарей. Как вы уже знаете, словарь всегда можно создать с помощью
литерала словаря или присваивая значения ключам:

\>>> D1 = {‘spam’:1, ‘eggs’:3, ‘toast’:5}
\>>> D1
{‘toast’: 5, ‘eggs’: 3, ‘spam’: 1}
\>>> D1 = {}
\>>> D1[‘spam’] = 1
\>>> D1[‘eggs’] = 3
\>>> D1[‘toast’] = 5

 Но как быть, если программа получает ключи и значения для словаря
в виде списков во время выполнения, уже после того, как сценарий
был написан? Например, предположим, что имеются следующие списки ключей
и значений:

\>>> keys = [‘spam’, ‘eggs’, ‘toast’]
\>>> vals = [1, 3, 5]

 Один из способов превратить их в словарь состоит в том, чтобы передать
списки функции zip и затем выполнить обход полученного результата
в цикле for:

\>>> list(zip(keys, vals))
[(‘spam’, 1), (‘eggs’, 3), (‘toast’, 5)]
\>>> D2 = {}
\>>> for (k, v) in zip(keys, vals): D2[k] = v
...
\>>> D2
{‘toast’: 5, ‘eggs’: 3, ‘spam’: 1}

 Однако, начиная с версии Python 2.2, можно обойтись без цикла for
и просто передать результат вызова функции zip встроенному конструктору
dict:

\>>> keys = [‘spam’, ‘eggs’, ‘toast’]
\>>> vals = [1, 3, 5]
\>>> D3 = dict(zip(keys, vals))
\>>> D3
{‘toast’: 5, ‘eggs’: 3, ‘spam’: 1}

 Встроенное имя dict в языке Python в действительности является именем
типа (больше об именах типов и о создании подтипов вы узнаете
в главе 31). Этот вызов производит преобразование списка в словарь,
но в действительности это вызов конструктора объекта. В следующей главе
мы рассмотрим родственное, но более широкое понятие генераторов списков,
которые позволяют создавать списки с помощью единственного выражения.
Мы также вернемся еще раз к генераторам словарей, появившихся
в версии 3.0, которые являются альтернативой вызову dict для пар
ключ/значение, объединенных в последовательность.


 Генерирование индексов и элементов: enumerate

 Ранее мы рассматривали использование функции range для генерации
индексов (смещений) элементов в строке вместо получения самих элементов
с этими индексами. Однако в некоторых программах необходимо получить
и то, и другое: и элемент, и его индекс. При традиционном подходе можно
было бы использовать простой цикл for, в котором вести счетчик текущего
индекса:

\>>> S = ‘spam’
\>>> offset = 0
\>>> for item in S:
...     print(item, ‘appears at offset’, offset)
...     offset += 1
...
s appears at offset 0
p appears at offset 1
a appears at offset 2
m appears at offset 3

 Этот способ вполне работоспособен, но в последних версиях языка Python
те же самые действия можно выполнить с помощью встроенной функции
с именем enumerate:

\>>> S = ‘spam’
\>>> for (offset, item) in enumerate(S):
...     print(item, ‘appears at offset’, offset)
...
s appears at offset 0
p appears at offset 1
a appears at offset 2
m appears at offset 3


 Функция enumerate возвращает объект-генератор – разновидность объекта,
который поддерживает протокол итераций, который мы будем рассматривать
в следующей главе, и более подробно будем обсуждать в следующей части
книги. В двух словах: он имеет метод __next__, вызываемый встроенной
функцией next и возвращающий кортеж (index, value) для каждого элемента
списка. Мы можем использовать эти кортежи для присваивания в цикле for
(точно так же, как и в случае с функцией zip):

\>>> E = enumerate(S)
\>>> E
<enumerate object at 0x02765AA8>
\>>> next(E)
(0, ‘s’)
\>>> next(E)
(1, ‘p’)
\>>> next(E)
(2, ‘a’)

 Обычно мы не видим всю эту механику, потому что во всех случаях
(включая генераторы списков – тема главы 14) протокол итераций
выполняется автоматически:

\>>> [c * i for (i, c) in enumerate(S)]
[‘’, ‘p’, ‘aa’, ‘mmm’]

 Чтобы окончательно разобраться с такими понятиями итераций, как функции
enumerate, zip и генераторы списков, нам необходимо перейти к следующей
главе, где производится разбор этих понятий с более формальной точки
зрения.
"""

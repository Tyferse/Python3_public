"""
 Особенности использования исключений


 Инструкция try/except/else

 Теперь, когда вы познакомились с основами, пришло время приступить
к исследованию деталей. В следующем обсуждении я сначала представлю
try/except/else и try/finally как разные инструкции, потому что они
имеют разное предназначение и не могут комбинироваться в версиях Python
ниже, чем 2.5. Как уже говорилось, начиная с версии Python 2.5, except
и finally могут смешиваться в одной инструкции try – я объясню суть
этого изменения после того как будут исследованы две оригинальные формы
по отдельности.

 Инструкция try – это составная инструкция. Полная ее форма приводится
ниже. Она начинается со строки заголовка try, вслед за которой
располагается блок инструкций (как правило) с отступами, затем следует
одно или более предложений except, которые определяют обрабатываемые
исключения, и затем следует необязательное предложение else. Слова try,
except и else должны располагаться с одним и тем же отступом (то есть
должны быть выровнены по вертикали). Для справки ниже приводится полный
формат инструкции:

try:
    <statements>  # Сначала выполняются эти действия
except <name1>:
    <statements>  # Запускается, если в блоке try возникло
except (name2, name3):   исключение name1
    <statements>   # Запускается, если возникло любое из этих исключений
except <name4> as <data>:
    <statements>   # Запускается в случае исключения name4
                   # и получает экземпляр исключения
except:
    <statements>  # Запускается для всех (остальных)
else:               возникших исключений
    <statements>  # Запускается, если в блоке try не возникло исключения

 В этой инструкции блок под заголовком try представляет основное
действие инструкции – программный код, который следует попытаться
выполнить. Предложения except определяют обработчики исключений,
возникших в ходе выполнения блока try, а предложение else
(если присутствует) определяет обработчик для случая отсутствия
исключений. Элемент <data> имеет отношение к особенности инструкций
raise, которая будет обсуждаться далее в этой главе.

 Ниже описывается принцип действия инструкции try. Когда запускается
инструкция try, интерпретатор помечает текущий контекст программы, чтобы
вернуться к нему, если возникнет исключение. В первую очередь
выполняются инструкции, расположенные под заголовком try. Что произойдет
дальше, зависит от того, будет ли возбуждено исключение в блоке try:

  Если исключение возникнет во время выполнения инструкций в блоке try,
 интерпретатор вернется к инструкции try и выполнит первое предложение
 except, соответствующее возбужденному исключению. После выполнения
 блока except управление будет передано первой инструкции, находящейся
 за всей инструкцией try (при условии, что в блоке except не возникло
 другого исключения).

  Если в блоке try возникло исключение и не было найдено ни одного
 соответствия среди предложений except, исключение будет передано
 инструкции try, стоящей выше в программе, или на верхний уровень
 процесса (что вынудит интерпретатор аварийно завершить работу программы
 и вывести сообщение об ошибке по умолчанию).

  Если в процессе выполнения блока try не возникло исключение,
 интерпретатор выполнит инструкции в блоке else (если имеются)
 и затем выполнение продолжится с первой инструкции, находящейся
 за всей инструкцией try.

 Другими словами, предложения except перехватывают любые исключения,
которые могут возникнуть при выполнении блока try, а блок else
выполняется только в случае отсутствия исключений в блоке try.

 В предложениях except находятся обработчики исключений – они
перехватывают исключения, которые возникли только в инструкциях блока
try. Однако инструкции в блоке try могут вызывать функции, расположенные
в разных частях программы, поэтому сам источник исключения может
располагаться за пределами самой инструкции try. Мы еще поговорим
об этом, когда будем исследовать вложенные инструкции try в главе 35.


 Предложения инструкции try

 В инструкции try могут присутствовать разные предложения,
располагающиеся вслед за блоком try. В табл. приводятся все возможные
формы, из которых хотя бы одна должна присутствовать. Мы уже встречали
некоторые из них: как вы уже знаете, предложение except перехватывает
исключения, предложение finally выполняется при выходе из инструкции,
а предложение else выполняется, когда в блоке try не возникло
исключение.

 С точки зрения синтаксиса, в инструкции может присутствовать несколько
предложений except, но только одно предложение else. Вплоть до версии
Python 2.4 предложение finally должно было быть единственным
(без предложений else или except). В действительности try/finally –
это отдельная инструкция. Однако начиная с версии Python 2.5 предложение
finally может присутствовать в той же инструкции, что и предложения
except и else (подробнее о правилах, определяющих порядок их следования,
будет рассказываться ниже в этой главе, когда будет обсуждаться
объединенная инструкция try).

  Форма предложения                Интерпретация
  except:                          Перехватывает все (остальные) типы
                                   исключений.

  except name:                     Перехватывает только указанное
                                   исключение.

  except name as value:            Перехватывает указанное исключение
                                   и получает соответствующий экземпляр.

  except (name1, name2):           Перехватывает любое из перечисленных
                                   исключений.

  except (name1, name2) as value:  Перехватывает любое из перечисленных
                                   исключений и получает соответствующий
                                   экземпляр.

  else:                            Выполняется, если не было исключений.

  finally:                         Этот блок выполняется всегда.

 Исследованием дополнительного значения as value мы займемся, когда
будем рассматривать инструкцию raise. Оно обеспечивает доступ к объекту,
который играет роль исключения.

 Новыми здесь для нас являются первая и четвертая строки в табл.:

  Предложения except, в которых отсутствуют имена исключений (except:),
 перехватывают все исключения, ранее не перечисленные в инструкции try.

  Предложения except, где в круглых скобках перечислены имена исключений
 (except (e1, e2, e3):), перехватывают любое из перечисленных
 исключений.

 Интерпретатор Python просматривает предложения except сверху вниз
в поисках соответствия, поэтому версию предложения с круглыми скобками
можно рассматривать как аналог нескольким отдельным выражениям except,
по одному для каждого исключения из списка, только в этом случае тело
обработчика является общим для всех указанных исключений.
Ниже приводится пример использования нескольких предложений except,
который демонстрирует порядок определения обработчиков:

try:
    action()
except NameError:
    ...
except IndexError
    ...
except KeyError:
    ...
except (AttributeError, TypeError, SyntaxError):
    ...
else:
    ...

 В этом примере, если при выполнении функции action возникает
исключение, интерпретатор возвращается к инструкции try и пытается
отыскать первое предложение except, в котором указано возникшее
исключение. Поиск среди предложений except ведется сверху вниз,
слева направо, и выполняются инструкции в первом найденном совпадении.
Если совпадений не будет найдено, исключение продолжит распространение
выше этой инструкции try. Обратите внимание, что блок else выполняется
только при отсутствии исключения в функции action – этот блок
не выполняется при наличии исключения, которому не было найдено
соответствующее предложение except.

 Если вам действительно необходимо организовать перехват всех
исключений, используйте пустое предложение except:

try:
    action()
except NameError:
    ...  # Обработать исключение NameError
except IndexError:
    ...  # Обработать исключение IndexError
except:
    ...  # Обработать все остальные исключения
else:
    ...  # Обработка случая отсутствия исключений

 Предложение except без имени исключения – это своего рода шаблонный
символ, потому что оно перехватывает любые исключения, что позволяет
вам создавать и универсальные, и специфичные обработчики по своему
усмотрению.

 В некоторых случаях эта форма может быть более удобна, чем перечисление
всех возможных исключений в инструкции try. Так, в следующем примере
выполняется перехват всех исключений:

try:
    action()
except:
    ...  # Перехватить все возможные исключения

 Однако применение пустых предложений except влечет за собой
определенные проблемы проектирования. Несмотря на удобство, они могут
перехватывать нежелательные системные исключения, не связанные с работой
вашего программного кода, и по случайности прерывать распространение
исключений, предназначенных для других обработчиков. Например,
даже выход из программы в языке Python возбуждает исключение, и поэтому
было бы желательно, чтобы это исключение было пропущено. Кроме того,
такая конструкция будет перехватывать исключения, вызванные обычными
ошибками программирования, которые вам наверняка хотелось бы обнаружить.
Мы вернемся к этой проблеме в конце этой части книги. А пока
я скажу лишь, что предложение except требует внимательного отношения.

 В Python 3.0 была введена альтернатива, решающая одну из этих проблем,
– предложение except Exception имеет практически тот же эффект,
что и пустое предложение except, но оно не перехватывает исключения,
имеющие отношение к завершению программы:

try:
    action()
except Exception:
    ...  # Перехватит все исключения, кроме завершения программы

 Данная форма обеспечивает практически те же удобства, что и пустое
предложение except, но при этом таит в себе практически те же самые
опасности. Мы исследуем работу этой формы в следующей главе, когда будем
изучать классы исключений.


 Предложение try/else

 Назначение предложения else в инструкции try на первый взгляд не всегда
очевидно для тех, кто только начинает осваивать язык Python.
Тем не менее без этого предложения нет никакого другого способа узнать
(не устанавливая и не проверяя флаги) – выполнение программы
продолжилось потому, что исключение в блоке try не было возбуждено,
или потому, что исключение было перехвачено и обработано:

try:
    ...выполняемый код...
except IndexError:
    ...обработка исключения...
# Программа оказалась здесь потому, что исключение было обработано
# или потому, что его не возникло?

 Точно так же, как предложение else в операторах цикла делает причину
выхода из цикла более очевидной, предложение else в инструкции try
однозначно и очевидно сообщает о произошедшем:

try:
    ...выполняемый код...
except IndexError:
    ...обработка исключения...
else:
    ...исключение не было возбуждено...

 То же самое поведение можно имитировать, переместив содержимое блока
else в блок try:

try:
    ...выполняемый код...
    ...исключение не было возбуждено...
except IndexError:
    ...обработка исключения...

 Но это может привести к некорректной классификации исключения. Если
какая-либо из инструкций в блоке «исключение не было возбуждено»
приведет к появлению исключения IndexError, оно будет зарегистрировано
как ошибка в блоке try и соответственно, ошибочно будет передано
обработчику исключения ниже (тонко, но верно!). При явном использовании
выражения else логика выполнения становится более очевидной
и гарантируется, что обработчики исключений будут вызываться только
для обработки истинных ошибок в блоке, обернутом инструкцией try,
а не при выполнении действий, предусматриваемых в блоке else.


 Пример: поведение по умолчанию

 Поскольку объяснить порядок выполнения программы проще на языке Python,
чем на естественном языке, рассмотрим несколько примеров, иллюстрирующих
основы исключений. Я уже упоминал, что исключения, не перехваченные
инструкциями try, распространяются до самого верхнего уровня процесса
и запускают логику обработки исключений по умолчанию (то есть
интерпретатор аварийно завершает работающую программу и выводит
стандартное сообщение об ошибке). Рассмотрим пример. При попытке
запустить следующий модуль bad.py возникает исключение деления на ноль:

def gobad(x, y):
    return x / y

def gosouth(x):
    print(gobad(x, 0))

gosouth(1)

 Так как программа сама не обрабатывает это исключение, интерпретатор
завершает ее и выводит сообщение:

% python bad.py
Traceback (most recent call last):
  File “bad.py”, line 7, in <module>
    gosouth(1)
  File “bad.py”, line 5, in gosouth
    print(gobad(x, 0))
  File “bad.py”, line 2, in gobad
    return x / y
ZeroDivisionError: int division or modulo by zero
(ZeroDivisionError: целочисленное деление или деление по модулю на ноль)

 Я запускал этот пример под управлением Python 3.0. Сообщение состоит
из содержимого стека вызовов («Traceback»)
и имени (с дополнительными данными) исключения.
В содержимом стека перечислены все строки, которые были активны
в момент появления исключения, в порядке от более старых к более новым.
Обратите внимание: так как в данном случае мы работаем
в командной строке системы, а не в интерактивной оболочке
интерпретатора, имена файлов и номера строк содержат полезную для нас
информацию. Например, здесь видно, что ошибка произошла во 2-й строке
в файле bad.py в инструкции return.

 Как уже упоминалось в предыдущей главе, текст сообщений и отладочная
информация могут изменяться в зависимости от версии интерпретатора
и от используемой оболочки. Поэтому не надо беспокоиться, если ваши
сообщения не соответствуют в точности тем, что приводятся здесь.
Например, когда я запускал этот пример в среде IDLE, входящей в состав
Python 3.0, в тексте сообщения выводились полные пути к файлам.

 Так как интерпретатор Python определяет и сообщает обо всех ошибках,
появившихся во время выполнения программы, возбуждая исключения,
эти исключения тесно связаны с идеями обработки ошибок и отладки вообще.
Если вы работали с примерами из этой книги, вы без сомнений встречались
с несколькими исключениями – даже опечатки нередко приводят
к возбуждению исключения SyntaxError или других при импортировании
и выполнении файла (- то есть, когда запускается компилятор).
По умолчанию интерпретатор выводит полезные информативные сообщения,
как показано выше, которые позволяют легко отыскать источник проблем.

 Нередко стандартные сообщения об ошибках – это все, что необходимо для
разрешения проблем в программном коде. Для более надежной отладки своих
программ вы можете перехватывать исключения с помощью инструкций try
или использовать средства отладки, которые будут представлены в главе 35
(такие, как модуль pdb из стандартной библиотеки).


 Пример: перехват встроенных исключений

 Обработка исключений, которая выполняется интерпретатором по умолчанию,
зачастую удовлетворяет всем нашим потребностям, особенно
для программного кода верхнего уровня, где ошибки должны приводить
к немедленному завершению программы. Для большинства программ нет
никакой необходимости предусматривать какие-то особые варианты обработки
ошибок.

 Однако иногда бывает необходимо перехватить ошибку и выполнить
восстановительные действия после нее. Если для вас нежелательно, чтобы
программа завершалась, когда интерпретатор возбуждает исключение,
достаточно просто перехватить его, обернув участок программы
в инструкцию try. Это очень важная возможность для таких программ,
как серверы сети, которые должны продолжать работать постоянно.
Например, следующий фрагмент перехватывает и обрабатывает исключение
TypeError, которое возбуждается интерпретатором при попытке выполнить
операцию конкатенации для списка и строки (оператор + требует,
чтобы слева и справа были указаны последовательности одного
и того же типа):
"""


def kaboom(x, y):
    print(x + y)  # Возбуждает исключение TypeError


try:
    kaboom([0, 1, 2], 'spam')
except TypeError:  # Исключение перехватывается и обрабатывается здесь
    print('Hello world!')
    
print('resuming here')  # Программа продолжает работу независимо
# от того было ли исключение или нет

"""
 Когда в функции kaboom возникает исключение, управление передается 
предложению except в инструкции try, где выводится текст сообщения. 
После того, как исключение перехватывается, оно становится неактуальным,
поэтому программа продолжает выполнение ниже инструкции try вместо того, 
чтобы завершиться. Программный код действительно обрабатывает 
и ликвидирует ошибку:

% python kaboom.py
Hello world!
resuming here

 Обратите внимание: как только ошибка будет перехвачена, выполнение
продолжается с того места, где ошибка была перехвачена (то есть после 
инструкции try), – нет никакой возможности вернуться к тому месту, 
где возникла ошибка (в данном случае – в функцию kaboom). В некотором 
смысле это делает исключения более похожими на инструкции перехода, 
чем на вызовы функций, – нет никакой возможности вернуться 
к программному коду, вызвавшему ошибку.


 Инструкция try/finally
 
 Другая разновидность инструкции try специализируется на выполнении
заключительных операций. Если в инструкцию try включено предложение
finally, интерпретатор всегда будет выполнять этот блок инструкций 
при «выходе» из инструкции try независимо от того, произошло ли 
исключение во время выполнения инструкций в блоке try. Общая форма 
этой инструкции имеет следующий вид:

try:
    <statements>  # Выполнить эти действия первыми
finally:
    <statements>  # Всегда выполнять этот блок кода при выходе

 При использовании этой инструкции интерпретатор Python в первую очередь
выполняет инструкции в блоке try. Что произойдет дальше,
зависит от того, возникло ли исключение в блоке try:

  Если во время выполнения инструкций в блоке try исключение 
 не возникло, интерпретатор переходит к выполнению блока finally и затем 
 продолжает выполнять программу ниже инструкции try.
 
  Если во время выполнения инструкций в блоке try возникло исключение,
 интерпретатор также выполнит инструкции в блоке finally, но после этого
 исключение продолжит свое распространение до вышестоящей инструкции
 try или до обработчика исключений по умолчанию – программа не будет
 выполняться вслед за инструкцией try. То есть инструкции в блоке 
 finally будут выполнены, даже если исключение будет возбуждено, 
 но в отличие от предложения except, предложение finally не завершает
 распространение исключения – оно остается актуальным после выполнения
 блока finally. Форму try/finally удобно использовать, когда необходимо 
 гарантировать выполнение некоторых действий независимо от реакции 
 программы на исключение. С практической точки зрения, эта форма 
 инструкции позволяет определять завершающие действия, которые должны 
 выполняться всегда, такие как закрытие файлов или закрытие соединений
 с сервером.

 Обратите внимание: в Python 2.4 и в более ранних версиях предложение 
finally не может использоваться в той же инструкции try, 
где уже используется предложение except или else, поэтому форму 
try/finally лучше считать отдельной формой инструкции при работе 
со старыми версиями. Однако в Python 2.5 предложение finally может 
присутствовать в инструкции try вместе с предложениями except и else, 
поэтому в настоящее время существует единая инструкция try, 
которая может употребляться с несколькими необязательными предложениями
(вскоре мы поговорим об этом подробнее). Какую бы версию Python 
вы не использовали, назначение предложения funally остается прежним – 
определить завершающие действия, которые должны выполняться всегда, 
независимо от возникновения исключений.


 Пример: реализация завершающих действий 
с помощью инструкции try/finally

 Выше мы видели несколько простых примеров применения инструкции 
try/finally. Ниже приводится более близкий к действительности пример, 
иллюстрирующий типичное применение этой инструкции:
"""


class MyError(Exception):
    pass


def stuff(file):
    raise MyError()


file = open('data', 'w')  # Открыть файл для вывода
try:
    # stuff(file)  # Возбуждает исключение
    pass
finally:
    file.close()  # Всегда закрывать файл, чтобы вытолкнуть буферы
    
print('not reached')  # Продолжить с этого места,
#                       только если не было исключения

"""
 В этом фрагменте мы обернули вызов функции в инструкцию try
с предложением finally, чтобы гарантировать, что файл будет закрыт 
при любых обстоятельствах, независимо от того, будет возбуждено 
исключение в функции или нет. При таком подходе расположенный далее 
программный код может быть уверен, что содержимое выходных буферов файла 
было вытолкнуто из памяти на диск. Подобная структура программного кода 
может гарантировать закрытие соединения с сервером и так далее.

 Как мы узнали в главе 9, объекты файлов автоматически закрываются 
на этапе сборки мусора, что особенно удобно при работе с временными 
файлами, которые не присваиваются каким-либо переменным. Однако далеко 
не всегда можно предсказать, когда будет выполняться сборка мусора, 
особенно в крупных программах. Инструкция try позволяет сделать операцию 
закрытия файла более явной, предсказуемой и принадлежащей определенному 
блоку программного кода. Она гарантирует, что файл будет закрыт
при выходе из блока, независимо от того, произошло исключение или нет.

 Функция в этом примере не делает ничего полезного (она просто 
возбуждает исключение), но обернув ее в инструкцию try/finally,
мы гарантируем, что действия по завершению будут выполняться всегда. 
Напомню еще раз, что интерпретатор всегда выполняет программный код 
в блоке finally независимо от того, было возбуждено исключение
в блоке try или нет.

 Когда функция в этом примере возбуждает исключение, управление 
передается обратно инструкции try и начинает выполняться блок finally,
в котором производится закрытие файла. После этого исключение продолжает
свое распространение либо пока не встретит другую инструкцию try, 
либо пока не будет достигнут обработчик по умолчанию, который выведет 
стандартное сообщение об ошибке и остановит работу программы – 
инструкция, находящаяся ниже инструкции try, никогда не будет
достигнута. Если бы функция в этом примере не возбуждала исключение, 
программа точно так же выполнила бы блок finally, чтобы закрыть файл,
и затем продолжила бы свое выполнение ниже инструкции try.

 Кроме того, обратите внимание, что здесь исключение опять определено
как класс – как будет показано в следующей главе, 
в версиях Python 2.6 и 3.0 все исключения должны быть классами.


 Объединенная инструкция try/except/finally
 
 Во всех версиях Python, вышедших до версии 2.5 (в течение первых 15 лет
жизни или что-то около того), инструкция try существовала в двух 
разновидностях, и в действительности имелось две отдельные инструкции.
Мы могли либо использовать предложение finally, чтобы гарантировать 
выполнение завершающего программного кода, либо писать блоки except, 
чтобы перехватывать определенные исключения и выполнять действия
по восстановлению после них и при желании использовать предложение else,
которое выполняется в случае отсутствия исключений.

 То есть предложение finally нельзя было смешивать с предложениями 
except и else. Такое положение дел сохранялось отчасти из-за проблем 
с реализацией, а отчасти из-за неясности смысла такого смешивания –
перехват и восстановление после исключений выглядит никак не связанным 
с выполнением заключительных операций.

 Однако в Python 2.5 (а также в Python 2.6 и 3.0, которые описываются
в этой книге) две инструкции были объединены. Сейчас у нас имеется 
возможность смешивать предложения funally, except и else в одной 
и той же инструкции. То есть теперь можно написать инструкцию, имеющую
следующий вид:

try:                   # Объединенная форма
    основное действие
except Exception1:
    обработчик1
except Exception2:
    обработчик2
...
else:
    блок else
finally:
    блок finally
    
 Первым, как обычно, выполняется программный код в блоке основное 
действие. Если при выполнении этого блока возбуждается исключение, 
выполняется проверка всех блоков except, одного за другим, 
в поисках блока, соответствующего возникшему исключению.
Если было возбуждено исключение Exception1, будет выполнен 
блок обработчик1, исключение Exception2 приведет к запуску обработчика2
и так далее. Если исключение не было возбуждено, будет выполнен 
блок else.

 Независимо от того, что происходило раньше, блок finally будет выполнен
только после выполнения основных действий и после обработки любых 
возникших исключений. В действительности, блок finally будет выполнен,
даже если исключение возникнет в самом обработчике исключения 
или в блоке else. Как всегда, предложение finally не прекращает 
распространение исключения – если к моменту выполнения блока finally 
имеется активное исключение, оно продолжает свое распространение 
после выполнения блока finally и управление передается куда-то 
в другое место программы (другой инструкции try или обработчику
по умолчанию). Если к моменту, когда блок finally будет выполнен,
нет активного исключения, выполнение программы продолжится сразу же
вслед за инструкцией try.

 Таким образом, блок finally выполняется всегда, когда:
 
  В блоке основного действия возникло исключение и было обработано.
  
  В блоке основного действия возникло исключение и не было обработано.
  
  В блоке основного действия не возникло исключение.
  
  В одном из обработчиков возникло новое исключение.
  
 Напомню еще раз, предложение finally служит, чтобы организовать
выполнение завершающих действий, которые должны выполняться всегда 
при выходе из инструкции try независимо от того, было ли возбуждено
исключение и было ли оно обработано.


 Синтаксис объединенной инструкции try
 
 Инструкция try, как минимум, должна содержать либо предложение except,
либо предложение finally, и составляющие ее части должны следовать
в таком порядке:

  try -> except -> else -> finally

 где предложения else и finally являются необязательными и может 
присутствовать ноль или более предложений except, 
но в случае присутствия предложения else должно быть указано хотя бы
одно предложение except. В действительности инструкция try состоит 
из двух частей: из предложений except с необязательным предложением else
и/или предложения finally.

 Фактически более правильным будет изобразить синтаксис объединенной 
инструкции, как показано ниже (квадратные скобки означают, 
что заключенное в них предложение является необязательным, 
а звездочка означает «ноль или более раз»):

try:                     # Формат 1
    statements
except [type [as value]]:    # [type [, value]] в Python 2
    statements
[except [type [as value]]:
    statements]*
[else:
    statements]
[finally:
    statements]
    
try:                     # Формат 2
    statements
finally:
    statements
    
 Согласно этим правилам предложение else может присутствовать, 
только если в инструкции присутствует хотя бы одно предложение except, 
и всегда допускается одновременно указывать предложения except 
и finally, независимо от присутствия предложения else. Кроме того,
допускается одновременно указывать предложения finally и else, 
но только если в инструкции присутствует предложение except (при этом
допускается указывать предложение except без имени перехватываемого 
исключения, чтобы перехватывать любые исключения и запускать инструкцию 
raise, которая описывается ниже, чтобы повторно возбудить текущее 
обрабатываемое исключение). Если порядок следования предложений 
в инструкции будет нарушен, интерпретатор возбудит исключение, 
свидетельствующее о синтаксической ошибке, еще до того, 
как программный код будет выполнен.


 Объединение finally и except вложением

 До появления версии Python 2.5 существовала возможность объединять 
предложения finally и except в инструкции try за счет вложения 
инструкции try/except в блок try инструкции try/finally (более полно
этот прием будет рассматриваться в главе 35). В действительности
фрагмент ниже имеет тот же эффект, что и новая форма инструкции,
представленная в начале этого раздела:

try:        # Вложенные инструкции, эквивалентные объединенной форме
    try:
        основное действие
    except Exception1:
        обработчик1
    except Exception2:
        обработчик2
    ...
    else:
        нет ошибок
finally:
    завершающие действия
    
 Здесь также блок finally всегда выполняется при выходе 
из инструкции try независимо от того, что произошло в блоке основного 
действия, и независимо от того, выполнялись ли обработчики исключений
во вложенной инструкции try (представьте, как в этом случае 
будут развиваться четыре варианта событий, перечисленные выше,
и вы увидите, что все будет выполняться точно так же). Поскольку
предложение else всегда требует наличия хотя бы одного предложения 
except, эта вложенная форма имеет те же ограничения, что и объединенная
форма инструкции, представленная в предыдущем разделе.

 Однако этот эквивалент выглядит менее понятным,
чем новая, объединенная, форма инструкции, и для ее записи
требуется больше программного кода (по крайней мере,
на одну четырех символьную строку). Смешанная форма инструкции
проще в написании и выглядит понятнее, поэтому такая форма записи
считается в настоящее время предпочтительной.


 Пример использования объединенной инструкции try

 Ниже приводится демонстрационный пример использования объединенной
формы инструкции try. В следующем файле mergedexc.py представлены четыре
типичных варианта с инструкциями print, описывающими значение 
каждого из них:
"""


sep = '-' * 32 + '\n'
print(sep + 'EXCEPTION RAISED AND CAUGHT')

try:
    x = 'spam'[99]
except IndexError:
    print('except run')
finally:
    print('finally run')

print('after run')

print(sep + 'NO EXCEPTION RAISED')
try:
    x = 'spam'[3]
except IndexError:
    print('except run')
finally:
    print('finally run')

print('after run')

print(sep + 'NO EXCEPTION RAISED, WITH ELSE')
try:
    x = 'spam'[3]
except IndexError:
    print('except run')
else:
    print('else run')
finally:
    print('finally run')

print('after run')

print(sep + 'EXCEPTION RAISED BUT NOT CAUGHT')
try:
    x = 1 / 0
except IndexError:
    print('except run')
finally:
    print('finally run')

"""
 После запуска под управлением Python 3.0 этот пример выводит на экран 
следующий ниже текст (фактически при запуске под управлением Python 2.6 
выводятся те же результаты, потому что каждый вызов функции print 
выводит единственный элемент). Исследуйте программный код, чтобы понять,
как работает каждый из вариантов:

c:\misc> C:\Python30\python mergedexc.py
------------------------------
EXCEPTION RAISED AND CAUGHT
except run
finally run
after run
------------------------------
NO EXCEPTION RAISED
finally run
after run
------------------------------
NO EXCEPTION RAISED, WITH ELSE
else run
finally run
after run
------------------------------
EXCEPTION RAISED BUT NOT CAUGHT
finally run

Traceback (most recent call last):
  File “mergedexc.py”, line 36, in <module>
    x = 1 / 0
ZeroDivisionError: int division or modulo by zero
(ZeroDivisionError: целочисленное деление или деление по модулю на ноль)

 Этот пример для возбуждения исключений в основном действии использует
встроенные операции и полагается на тот факт, что интерпретатор всегда 
определяет появление ошибок во время выполнения программного кода. 
В следующем разделе будет показано, как возбуждать исключения вручную.
"""

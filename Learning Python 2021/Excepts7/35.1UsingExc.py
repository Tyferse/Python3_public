"""
 Использование исключений


 Вложенные обработчики исключений

 До сих пор в наших примерах для перехвата исключений использовалась
единственная инструкция try, но что произойдет, если одну инструкцию try
вложить внутрь другой? И, раз уж на то пошло, что произойдет,
если внутри инструкции try вызывается функция, которая выполняет
другую инструкцию try? С технической точки зрения инструкции могут
вкладываться друг в друга как синтаксически, так и по пути следования
потока управления через программный код.

 Оба эти варианта проще будет понять, если вы узнаете, что интерпретатор
складывает инструкции try стопкой во время выполнения. Когда возникает
исключение, интерпретатор возвращается к самой последней инструкции try,
содержащей соответствующее предложение except. Поскольку каждая
инструкция try оставляет метку, интерпретатор может возвращаться
к более ранним инструкциям try, двигаясь по стопке меток. Такое вложение
активных обработчиков и есть то, что подразумевается, когда мы говорим
о распространении исключений вверх, к обработчикам
«более высокого уровня». Эти обработчики являются обычными инструкциями
try, в которые поток управления ходом выполнения программы вошел раньше.

 Рисунок иллюстрирует, что происходит, когда возникает вложение
инструкций try/except во время выполнения. Объем программного кода,
который выполняется в инструкции try, может оказаться весьма
существенным (например, он может содержать вызовы функций) и нередко
вызывает другой программный код, который готов перехватить те же самые
исключения. Когда исключение наконец возбуждается, интерпретатор
переходит к самой последней инструкции try, в которой указано
имя исключения, запускает блок except и продолжает выполнение программы
ниже этой инструкции try.

 Как только такое исключение будет перехвачено, его жизнь заканчивается
 – управление не передается всем соответствующим инструкциям try,
содержащим имя исключения, – только первая из них получает возможность
обработать исключение. Например, на рис. инструкция raise в функции
func2 возвращает управление обработчику в функции func1, после чего
программа продолжает выполнение внутри func1.

 Напротив, когда исключение возникает во вложенных инструкциях
try/finally, выполняется каждый блок finally по очереди – интерпретатор
продолжает передавать исключение вверх по цепочке вложенных инструкций
try, пока не будет достигнут обработчик по умолчанию верхнего уровня
(который выводит стандартные сообщения об ошибках). Как показано
на рис., предложения finally не останавливают распространение исключений
 – они лишь определяют программный код, который должен выполняться
на выходе из инструкции try в процессе движения исключения.
Если к моменту возникновения исключения имелось несколько активных
инструкций try/finally, они все будут выполнены, если только где-то
на пути исключения не встретится инструкция try/except,
которая перехватит его.

 Другими словами, куда будет выполнен переход при возникновении
исключения, полностью зависит от того, где оно возникло,
– это определяется ходом выполнения программы, а не только синтаксисом.
Распространение исключения, по сути, происходит в порядке,
обратном порядку вхождения в инструкции try. Это движение
останавливается, когда управление переходит к соответствующему блоку
except, и продолжается, когда управление проходит через предложения
finally.


 Пример: вложение в потоке управления

 Обратимся к примеру, чтобы рассмотреть этот тип вложения более
конкретно. В следующем файле модуля nestexc.py определяются две функции.
Функция action2 возбуждает исключение (нельзя складывать числа
и последовательности), функция action1 обертывает вызов функции action2
в инструкцию try, которая перехватывает исключение:
"""


def action2():
    print(1 + [])  # Возбуждает исключение TypeError


def action1():
    try:
        action2()
    except TypeError:  # Самая последняя соответствующая инструкция try
        print('inner try')


try:
    action1()
except TypeError:  # Этот обработчик будет выполнен, только если
    print('outer try')  # action1 повторно возбудит исключение

"""
 Обратите внимание, что на верхнем уровне модуля, внизу файла, вызов
функции action1 также обернут инструкцией try. В тот момент,
когда функция action2 возбуждает исключение TypeError, существуют 
две активные инструкции try – одна в функции action1 и одна 
в программном коде на верхнем уровне модуля. Интерпретатор выбирает 
и запускает самую последнюю инструкцию try с соответствующим 
предложением except, которой в данном случае является инструкция try 
в функции action1.

 Как уже говорилось, место, куда будет выполнен переход в случае
исключения, зависит от того, в каком месте программы находится поток 
управления. Поэтому, чтобы знать, куда будет выполнен переход,
необходимо знать место, где находится поток управления. В данном случае
выбор места, где будет обработано исключение, больше зависит от того, 
где находится поток управления, чем от синтаксиса. Однако мы можем
организовать синтаксическое вложение обработчиков – эквивалентный
случай рассматривается в следующем разделе.


 Пример: синтаксическое вложение
 
 В главе 33, когда рассматривалась новая объединенная инструкция 
try/except/finally, я уже говорил, что вполне возможно вкладывать
инструкции try синтаксически, задавая вложение в программном коде:
"""

try:
    try:
        action2()
    except TypeError:  # Самая последняя соответствующая инструкция try
        print('inner try')
except TypeError:  # Этот обработчик будет выполнен, только если
    print('outer try')  # вложенный обработчик повторно
    #                     возбудит исключение

"""
 Этот программный код задает ту же структуру вложенных обработчиков,
что и предыдущий пример (и ведущую себя точно так же). Фактически
инструкции, вложенные синтаксически, работают точно так же, 
как показано на рис. 35.1 и 35.2; единственное отличие заключается 
в том, что вложенные обработчики физически объединены в блоке инструкции 
try, а не находятся в разных функциях. Например, исключение пройдет 
через все блоки finally независимо от того, вложены они синтаксически 
или в ходе выполнения программы происходит вложение физически отдельных 
фрагментов программного кода:
"""

try:
    try:
        # raise IndexError
        pass
    finally:
        print('spam')
finally:
    print('SPAM')

"""
 Графическая иллюстрация порядка выполнения этого фрагмента показана
на рис. 35.2 – результат получается тот же самый, но сама логика 
выполнения в данном случае образована вложенными инструкциями.
Более интересный пример синтаксического вложения в действии приводится
в следующем файле except-finally.py:
"""


def raise1(): raise IndexError
def noraise(): return
def raise2(): pass  # raise SyntaxError


for func in (raise1, noraise, raise2):
    print('\n', func, sep=' ')
    try:
        try:
            func()
        except IndexError:
            print('caught IndexError')
    finally:
        print('finally run')
"""
 Этот фрагмент перехватывает исключение, если оно будет возбуждено,
и выполняет завершающие действия в блоке finally независимо от того, 
возникло исключение или нет. Чтобы понять это, может потребоваться
некоторое время на изучение фрагмента, но результат очень напоминает
объединение предложений except и finally в единственной инструкции try 
в версии Python 2.5 или выше:

% python except-finally.py
<function raise1 at 0x026ECA98>
caught IndexError
finally run

<function noraise at 0x026ECA50>
finally run

<function raise2 at 0x026ECBB8>
finally run

Traceback (most recent call last):
  File “except-finally.py”, line 9, in <module>
    func()
  File “except-finally.py”, line 3, in raise2
    def raise2(): raise SyntaxError
SyntaxError: None

 Как мы видели в главе 33, начиная с версии Python 2.5, появилась 
возможность использовать предложения except и finally в одной инструкции
try. Это делает описанный здесь прием синтаксического вложения ненужным, 
однако он по-прежнему работает, его можно встретить в программном коде,
написанном до выхода версии Python 2.5, и он может использоваться 
для реализации альтернативных конструкций обработки исключений.


 Идиомы исключений
 
 
 Исключения не всегда являются ошибками
 
 В языке Python все ошибки являются исключениями, но не все исключения
являются ошибками. Например, в главе 9 мы видели, что по достижении
конца файла метод чтения объекта файла возвращает пустую строку. 
Напротив, встроенная функция input (с которой мы впервые встретились 
в главе 3 и которую использовали в интерактивном цикле в главе 10)
читает по одной строке текста при каждом вызове из стандартного потока
ввода sys.stdin и возбуждает исключение EOFError по достижении конца 
файла (в Python 2.6 эта функция называется raw_input).

 В отличие от методов объекта файла, данная функция не возвращает пустую
строку; пустая строка, полученная от функции input, означает всего лишь
пустую строку. Несмотря на свое название, исключение EOFError в данном
контексте – это всего лишь сигнал, а не ошибка. По этой причине чтобы
избежать преждевременного завершения работы сценария, функцию input 
обертывают инструкцией try, которую вкладывают в цикл,
как показано ниже:

while 1:
    try:
        line = input() # Прочитать строку из потока stdin
    except EOFError:
        break # Выход по достижении конца файла
    else:
        ...обработка следующей строки...
        
 Существуют и другие встроенные исключения, которые являются сигналами,
а не ошибками, – вызов функции sys.exit() и нажатие комбинации клавиш
Ctrl-C, например, возбуждают исключение SystemExit и KeyboardInterrupt 
соответственно. В языке Python имеется также ряд встроенных исключений,
которые являются скорее предупреждениями, чем ошибками. Некоторые из них
применяются, чтобы сообщить о нежелательности использования некоторых 
особенностей языка (которые вскоре будут удалены). За дополнительной 
информацией по предупреждениям обращайтесь к описанию встроенных 
исключений в руководстве по стандартной библиотеке и к модулю warnings.


 Передача сигналов из функций по условию

 Исключения, определяемые программой, также могут служить сигналами
об условиях, которые не являются ошибками. Например, процедура поиска 
может предусматривать возбуждение исключения в случае нахождения 
соответствия вместо того, чтобы возвращать флаг состояния,
который должен интерпретироваться вызывающей программой. В следующем
примере инструкция try/except/else играет роль инструкции if/else, 
предназначенной для проверки возвращаемого значения:

class Found(Exception): pass

def searcher():
    if ...успех...:
        raise Found()
    else:
        return
try:
    searcher()
except Found:     # Исключение, если элемент найден
    ...успех...
else:             # иначе: элемент не найден
    ...неудача...
    
 В более широком смысле такая организация программного кода может 
с успехом использоваться для любой функции, которая не может вернуть
специальный признак, свидетельствующий об успехе или неудаче. Например, 
если любое возвращаемое значение является допустимым, невозможно выбрать
какое-то одно значение, которое сигнализировало бы о необычных 
состояниях. Исключения обеспечивают способ подать сигнал, не возвращая
значение:

class Failure(Exception): pass

def searcher():
    if ...успех...:
        return ...найденный_элемент...
    else:
        raise Failure()
        
try:
    item = searcher()
except Failure:
    ...сообщение о неудаче...
else:
    ...обработка найденного элемента...
    
 Поскольку язык Python является динамически типизированным и в своей
основе поддерживает полиморфизм, исключения, а не возвращение
специального признака являются более предпочтительным способом сообщать
о таких состояниях.


 Закрытие файлов и соединений с сервером
 
 Мы уже сталкивались с похожими примерами в главе 33. Тем не менее 
повторю еще раз, что инструменты обработки исключений также часто 
используются с целью обеспечить освобождение системных ресурсов
независимо от того, возникло исключение в процессе работы или нет.

 Например, некоторые серверы требуют, чтобы по завершении сеанса работы
соединение было закрыто. Аналогично, после операции вывода в файл может
потребоваться закрыть его, чтобы вытолкнуть содержимое буферов на диск,
а неиспользуемые файлы, открытые для чтения, могут понапрасну занимать
файловые дескрипторы – объекты файлов автоматически закрываются 
сборщиком мусора, но иногда бывает очень сложно знать,
когда это произойдет на самом деле.

 Наиболее простой и очевидный способ гарантировать выполнение 
заключительных операций для какого-то конкретного блока программного 
кода заключается в использовании инструкции try/finally:

myfile = open(r’C:\misc\script’, ‘w’)

try:
    ...обработать myfile...
finally:
    myfile.close()

 Как мы видели в главе 33, некоторые объекты в Python 2.6 и 3.0 
еще больше упрощают такую возможность, предоставляя менеджеры 
контекстов, которые могут использоваться совместно с инструкцией 
with/as, позволяющие автоматически выполнять заключительные операции:

with open(r’C:\misc\script’, ‘w’) as myfile:
    ...обработать myfile...

 Так какой же вариант лучше? Как обычно, это зависит от вашей программы.
В сравнении с инструкцией try/finally менеджеры контекста 
менее очевидны, что противоречит общей философии языка Python. 
Кроме того, менеджеры контекста менее универсальны – они доступны лишь 
для некоторых типов объектов, к тому же создание собственных менеджеров
контекста, реализующих заключительные операции, вообще является более 
трудоемкой задачей, чем использование инструкции try/finally.

 С другой стороны, использование существующих менеджеров контекста 
требует меньше программного кода, чем применение инструкции try/finally, 
как видно из предыдущих примеров. Кроме того, протокол менеджеров 
контекста кроме заключительных операций предусматривает также 
возможность реализации начальных операций, выполняемых на входе.
Инструкция try/finally, вероятно, используется более широко, однако 
менеджеры контекста могут оказаться предпочтительнее там, 
где они доступны или где сложность их создания оправдывается удобством 
использования.


 Отладка с помощью внешних инструкций try
 
 Обработчики исключений можно также использовать как замену обработчика
по умолчанию. Обернув всю программу (или вызов ее) во внешнюю инструкцию
try, можно перехватывать любые исключения, которые только будут 
возникать во время работы программы, отменяя тем самым способ завершения
программы, заданный по умолчанию.

 В следующем фрагменте пустое предложение except перехватывает любые 
необработанные исключения, возникшие в ходе выполнения программы. Чтобы
получить доступ непосредственно к самому исключению, вызовите встроенную 
функцию sys.exc_info из модуля sys – она возвращает кортеж, в котором
первые два элемента содержат имя исключения и экземпляр класса
возбужденного исключения (вскоре мы подробнее рассмотрим функцию 
sys.exc_info):

try:
    ...запуск программы...
except:        # Сюда попадут все необработанные исключения
    import sys
    print(‘uncaught!’, sys.exc_info()[0], sys.exc_info()[1])
    
 Этот прием часто используется во время разработки, так как он 
позволяет сохранить программу активной даже после ошибки – с его помощью
можно производить дополнительные проверки без необходимости 
перезапускать программу. Это прием может также использоваться 
для тестирования другого программного кода, как описано в следующем 
разделе.


 Запуск тестов в рамках единого процесса
 
 Некоторые из приемов, которые мы только что рассмотрели, 
можно было бы объединить в тестовом приложении, которое позволяет 
тестировать другой программный код в рамках одного и того же процесса:


import sys
log = open('testlog', 'a')


def testdriver():
    while moreTests():
        try:
            runNextTest()
        except:
            print('FAILED', testName(), sys.exc_info()[:2], file=log)
        else:
            print('PASSED', testName(), file=log)
            
            
testdriver()

 Здесь функция testdriver выполняет в цикле серию тестов 
(модуль testapi – некая абстракция в этом примере). Поскольку в обычной 
ситуации необработанное исключение приводило бы к завершению самого 
тестового приложения, можно обернуть вызовы очередного теста инструкцией
try, чтобы обеспечить продолжение процесса тестирования после 
неудачного завершения любого из тестов. Здесь, как обычно, 
пустое предложение except перехватывает любые необработанные исключения,
возникшие в ходе выполнения теста, и регистрирует в файле информацию
об исключении, полученную с помощью функции sys. exc_info. Предложение 
else выполняется в случае отсутствия исключений – когда тест завершился 
благополучно.

 Такой подход типичен для систем, которые тестируют функции, модули 
и классы, запуская их в рамках того же самого процесса, что и само 
тестовое приложение. Однако на практике тестирование может оказаться
процедурой гораздо более сложной, чем показано здесь. Например,
чтобы протестировать внешнюю программу, может потребоваться проверять
коды состояния или вывод, создаваемый такими средствами запуска 
программ, как os.system и os. popen, описания которых вы найдете
в стандартном руководстве по библиотеке (такие инструменты вообще
не возбуждают исключений в случае появления ошибок во внешней программе 
– фактически тест выполняется параллельно с программой, 
выполняющей тестирование).

 В конце этой главы мы познакомимся с некоторыми законченными 
платформами тестирования, предоставляемыми интерпретатором Python, 
такими как doctest и PyUnit, которые обеспечивают возможность сравнения 
ожидаемого вывода с фактическими результатами.


 Подробнее о функции sys.exc_info
 
 Функция sys.exc_info, результаты которой использовались в последних 
двух разделах, позволяет обработчикам исключений получить доступ
к последнему возбужденному исключению. Ее особенно удобно использовать 
в пустых предложениях except, которые перехватывают все исключения, 
чтобы определить, что именно произошло:

try:
    ...
except:
    # sys.exc_info()[0:2] – класс исключения и экземпляр
    
 Если в момент ее вызова никакое исключение не обрабатывается,
функция возвращает кортеж с тремя объектами None. В противном случае 
возвращаются (тип, значение, трассировочная_информация), где:

  Тип – это класс обрабатываемого исключения.
  
  Значение – это экземпляр класса возбужденного исключения.
  
  Трассировочная информация – это объект, который представляет 
 стек вызовов в точке, где возникло исключение (в документации к модулю 
 traceback описываются инструменты, которые могут использоваться 
 вместе с этим объектом для создания сообщений об ошибках вручную).

 Как мы уже видели в предыдущей главе, иногда функция sys.exc_info может
также использоваться, чтобы определить конкретный тип исключения, когда
выполняется перехват по имени супер-класса категории исключений. Однако,
как мы видели, в подобном случае тип исключения можно также определить
с помощью атрибута __class__ экземпляра, который можно получить 
с помощью ключевого слова as, поэтому функция sys.exc_info чаще всего 
используется в пустых предложениях except:

try:
    ...
except General as instance:
    # instance.__class__ – класс исключения
    
 Кроме того, используя интерфейсы объектов экземпляров и опираясь 
на полиморфизм, часто бывает лучше просто использовать методы класса 
исключения, чем проверять его тип:

try:
    ...
except General as instance:
    # instance.method() выполнит действия, ожидаемые от этого экземпляра
    
 Как обычно, проверять типы объектов в языке Python означает
ограничивать гибкость программного кода. Реализации, основанные 
на использовании полиморфизма, как в последнем примере, 
обычно обеспечивают лучшую поддержку возможных изменений в будущем.


 Советы по применению и типичные проблемы исключений
 
 
 Что должно быть обернуто
 
 В принципе, можно было бы обернуть каждую инструкцию в сценарии в свою
собственную инструкцию try, но это будет выглядеть достаточно глупо 
(тогда инструкции try тоже следовало бы обернуть в инструкции try!). 
Это настоящая проблема проектирования, которая никак не связана 
с конкретным языком программирования и становится более очевидной 
на практике. Однако ниже приводится несколько правил, выработанных 
на практике:

  В инструкции try следует заворачивать операции, для которых неудача 
 не является чем-то необычным. Например, операции, взаимодействующие
 с системой (открытие файлов, взаимодействия с сокетами и т. д.), 
 являются первыми кандидатами для заключения их в инструкции try.

  При этом из первого правила есть исключение – в простых сценариях
 бывает желательно, чтобы подобные неудачи приводили к завершению
 работы программы. Это особенно верно, когда неудачи ожидаемы.
 Неудачи в языке Python приводят к выводу полезных сообщений 
 (только не в случае краха программы), и они часто представляют собой 
 лучший результат, на который только можно надеяться.

  Завершающие операции должны заключаться в инструкции try/finally,
 чтобы гарантировать их выполнение. Эта форма инструкции
 позволяет выполнять программный код независимо от того, возникло 
 исключение или нет.
 
  Иногда более удобно завернуть вызов крупной функции в единственную
 инструкцию try, чем засорять эту функцию несколькими инструкциями try.
 При таком подходе все исключения, возникшие в функции, будут 
 перехвачены инструкцией try, окружающей вызов, за счет чего можно 
 уменьшить объем программного кода внутри самой функции.
 
 Влияние на количество обработчиков исключений нередко оказывает тип 
программы. Например, серверные программы должны работать постоянно, 
и поэтому в них инструкции try наверняка будут необходимы, чтобы 
перехватывать исключения и выполнять восстановительные операции 
после них. В программах тестирования, как мы видели в этой главе, 
также необходимо выполнять обработку исключений. Однако в более простых
сценариях часто можно вообще игнорировать
исключения, потому что неудача на любом этапе выполнения
требует прекращения работы сценария.


 Не перехватывайте слишком много: избегайте пустых предложений except
 
 К вопросу о степени универсальности обработчика. Язык Python позволяет
явно указывать, какие исключения должны перехватываться, и иногда бывает
необходимо проявлять осторожность, чтобы не перехватывать слишком много.
Например, вы уже знаете, что пустое предложение except перехватывает 
все исключения, которые только могут возникнуть в блоке try.

 Сделать это несложно и иногда даже желательно, но это может привести
к тому, что будет перехвачена ошибка, обработка которой предусмотрена 
в инструкции try на более высоком уровне вложенной структуры. В примере 
ниже обработчик исключения перехватывает и деактивирует все исключения,
которые достигнут его, независимо от того, ожидает ли какие-либо
исключения обработчик уровнем выше:

def func():
    try:
        ...   # Здесь возбуждается исключение IndexError
    except:
        ...   # Но все исключения попадают сюда!
try:
    func()
except IndexError: #  Исключение должно обрабатываться здесь
    ...
    
 Что еще хуже, такой программный код может перехватывать исключения,
которые вообще не имеют никакого отношения к программе. Даже такие 
ситуации, как ошибки работы с памятью, настоящие ошибки 
в программном коде, прекращение итераций, прерывание с клавиатуры
и выход из программы, возбуждают исключения. Обычно такие исключения 
не должны перехватываться.

 Например, сценарии обычно завершают работу, когда поток управления
достигает конца главного файла. Однако в языке Python имеется 
специальная функция sys.exit(statuscode), с помощью которой можно
завершить работу программы. Чтобы завершить программу, эта функция
в действительности возбуждает исключение SystemExit, благодаря чему 
имеется возможность реализовать выполнение завершающих операций
в инструкции try/finally, а в специализированных программах – 
перехватить это событие.1 По этой причине инструкция try с пустым 
предложением except может непреднамеренно перехватить такое важное 
исключение, как показано в следующем файле (exiter.py):
"""

import sys


def bye():
    sys.exit(40)  # Серьезная ошибка: завершить работу немедленно!


try:
    bye()
except:
    print('got it')  # Ой! Мы проигнорировали команду на завершение
    
print('continuing...')

"""
 % python exiter.py
got it
continuing...

 Вы просто не сможете предугадать все исключения, которые могут 
произойти во время выполнения операции. Решить проблему в данном 
конкретном случае можно с помощью использования встроенных классов 
исключений, представленных в предыдущей главе, благодаря тому, 
что супер-класс Exception не наследуется классом SystemExit:

try:
    bye()
except Exception:  # Не будет препятствовать завершению программы,
    ...            # но БУДЕТ перехватывать массу других исключений
    
 Однако в других случаях такой подход ничуть не лучше использования 
пустого предложения except – так как Exception является супер-классом
всех встроенных исключений, кроме исключений завершения программы, 
при его использовании будут перехватываться все исключения, 
обрабатывать которые, возможно, предполагается где-то в другом месте 
в программе. Вероятно, хуже всего то, что пустое предложение except
может перехватить настоящие ошибки в программном коде, которым 
желательно было бы позволить пройти дальше. Фактически пустые 
предложения except могут отключать механизм интерпретатора, 
предназначенный для вывода сообщений об ошибках, скрывая возможные
ошибки в программном коде. Например, рассмотрим такой фрагмент:

mydictionary = {...}
...
try:
    x = myditctionary[‘spam’] # Ой: опечатка
except:
    x = None # А мы предполагаем, что получили KeyError
...продолжение работы с x...

 Здесь программист предполагает, что в данной ситуации возможен 
единственный тип ошибки – это ошибка отсутствующего ключа. Но поскольку 
в имени словаря myditctionary была допущена опечатка (должно быть
mydictionary), интерпретатор возбуждает исключение NameError, 
встретив ссылку на неопределенное имя, которое благополучно будет
перехвачено и проигнорировано обработчиком. Обработчик неправильно 
запишет в переменную значение по умолчанию, замаскировав ошибку 
в программе. Кроме того, использование имени Exception в предложении 
except даст тот же эффект, что и использование пустого предложения 
except. Если этот программный код будет находиться достаточно далеко
от места, где используется выбранное значение, его отладка превратится
в весьма захватывающую задачу!

 Возьмите за правило специализировать свои обработчики, насколько 
это возможно – пустые предложения except удобны в использовании, 
но они потенциально опасны. Так, в последнем примере было бы лучше
использовать предложение except KeyError:, чтобы более явно обозначить
свои намерения и избежать возможности перехвата посторонних событий.
В более простых сценариях подобные проблемы могут иметь не такое 
существенное значение, чтобы перевесить удобство использования,
но в общем случае универсальные обработчики обычно доставляют массу 
неприятностей.


 Не перехватывайте слишком мало: используйте категории
 
 С другой стороны, было бы нежелательно делать обработчики слишком 
узкоспециализированными. Когда в инструкции try перечисляются конкретные
исключения, перехватываться будут только те исключения,
которые были перечислены. Это не обязательно плохо, но если в процессе 
развития программы появится новое исключение, вам может потребоваться
вернуться и добавить это исключение в список обрабатываемых в своем
программном коде.

 Мы сталкивались с этой проблемой в предыдущей главе. Например,
следующий обработчик интерпретирует исключения MyExcept1  и MyExcept2 
как нормальную ситуацию, а все остальные – как ошибку. Если в будущем 
будет добавлено исключение MyExcept3, оно будет обрабатываться 
как ошибка, если не добавить его в список исключений:

try:
    ...
except (MyExcept1, MyExcept2):  # Работает неправильно при добавлении 
    ...                         # Нет ошибки                   MyExcept3
else:
    ...                         # Рассматривается как ошибка
    
 К счастью, при осторожном использовании исключений на основе классов,
обсуждавшихся в главе 33, можно полностью избавиться от этой ловушки.
Как мы уже видели, если перехватывать общий супер-класс, в будущем можно
будет добавлять и возбуждать более конкретные подклассы исключений
без необходимости изменять список исключений в предложении except – 
супер-класс становится легко расширяемой категорией исключений:

try:
    ...
except SuccessCategoryName:  # Работает правильно при добавлении 
    ...                      # Нет ошибки                      MyExcept3
else:
    ...                      # Рассматривается как ошибка
    
 Другими словами, порой придется пройти длинный путь, чтобы найти 
оптимальное решение. Мораль этой истории состоит в том, что вам следует
с особым тщанием подходить к выбору степени детализации, чтобы 
обработчики исключений не были ни слишком универсальными, ни слишком 
узкоспециализированными. Политика исключений должна быть составной 
частью общего дизайна, особенно в крупных программах.
"""
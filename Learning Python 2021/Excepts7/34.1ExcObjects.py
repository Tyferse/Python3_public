"""
 Объекты исключений


 Исключения: назад в будущее

 Когда-то давно (до выхода версий Python 2.6 и 3.0) было возможно
определять исключения двумя разными способами. Это усложняло
использование инструкций try и raise, да и сам язык Python.
На сегодняшний день существует только один способ определения
исключений. Это была отличная идея – удалить из языка всякий хлам,
накопившийся из-за необходимости сохранять обратную совместимость.
Поскольку знакомство со старым способом поможет понять, почему
исключения стали такими, какие они есть сейчас, а также потому что
невозможно стереть полностью все то, что использовалось миллионами
программистов на протяжении почти двух десятилетий, мы начнем
наше исследование с беглого обзора прошлого.


 Строковые исключения ушли в прошлое!

 До выхода версий Python 2.6 и 3.0 имелась возможность определять
исключения в виде экземпляров классов и в виде объектов строк.
Строковые исключения генерировали предупреждения о нежелательности
их использования в Python 2.5 и были удалены в Python 2.6 и 3.0,
поэтому в настоящее время допускается использовать только исключения
на основе классов, которые рассматриваются в этой книге. Тем не менее
если вам приходится сопровождать старые программы, вы все еще можете
столкнуться со строковыми исключениями. Кроме того, они могут
встретиться вам в Интернете и в разнообразных руководствах, написанных
несколько лет тому назад (что воспринимается как вечность
с точки зрения Python!).

 Строковые исключения были достаточно просты в использовании –
допускалось использовать любые строки, а сопоставление выполнялось
по идентичности объекта, но не по значению (то есть с помощью оператора
is, а не ==).

C:\misc> C:\Python25\python
\>>> myexc = “My exception string” # Неужели мы были когда-то молодыми?
\>>> try:
...     raise myexc
... except myexc:
...     print(‘caught’)
...
caught

 Эта форма исключений была ликвидирована, потому что строковые
исключения не так удобны в крупных программах, как классы, и сложнее
в сопровождении. Хотя в настоящее время вы и не можете использовать
строковые исключения, тем не менее, они обеспечивают естественный
переход к представлению модели исключений на основе классов.


 Исключения на основе классов

 Строки обеспечивают самый простой способ определения исключений.
Однако, как описывалось ранее, классы предоставляют дополнительные
преимущества, которые заслуживают, чтобы познакомиться с ними. Наиболее
важное преимущество заключается в том, что классы позволяют организовать
исключения в категории и они обладают большей гибкостью, чем простые
строки. Кроме того, классы обеспечивают естественный способ
присоединения к исключениям дополнительной информации и поддерживают
наследование. Они обеспечивают лучшее решение, и в настоящее время
представляют единственную возможность определения новых исключений.

 Помимо отличий в программном коде главное различие между строковыми
исключениями и исключениями на базе классов заключается в способе
идентификации возбужденных исключений в предложениях except
инструкции try:

  Строковые исключения идентифицируются по идентичности объекта:
 идентификация возбужденного исключения в предложении except выполняется
 с помощью оператора is.

  Исключения на основе классов идентифицируются отношением наследования:
 возбужденное исключение считается соответствующим предложению except,
 если в данном предложении указан класс исключения или любой
 из его супер-классов.

 То есть, когда в инструкции try предложение except
содержит супер-класс, оно будет перехватывать экземпляры
этого супер-класса, а также экземпляры всех его подклассов,
расположенных ниже в дереве наследования. Благодаря этому
исключения на основе классов поддерживают возможность
создания иерархий исключений: супер-классы превращаются
в имена категорий, а подклассы соответствуют различным видам исключений
внутри категории. Используя имя общего супер-класса, предложение except
сможет перехватывать целую категорию исключений – каждый конкретный
подкласс будет соответствовать этому предложению.

 Строковые исключения не поддерживают эту концепцию: поскольку
идентификация строковых исключений производится простой операцией
проверки идентичности объектов, нет никакого простого способа
организовать строковые исключения в более гибкие категории или группы.
В результате обработчики были жестко связаны с наборами исключений,
из-за чего существенно усложнялась возможность их модификации.

 В дополнение к этой идее исключения на основе классов обеспечивают
лучшую поддержку информации о состоянии (присоединенной к экземплярам)
и позволяют исключениям принимать участие в иерархиях наследования
(с целью обрести общие черты поведения). Благодаря тому, что они
обладают всеми преимуществами классов и ООП в целом, они представляют
собой более мощную альтернативу ныне отсутствующим строковым исключениям
при незначительном увеличении объемов программного кода.


 Создание классов исключений

 Давайте рассмотрим на примере программного кода, как работают классы
исключений. В следующем файле classexc.py определяется супер-класс
с именем General и два подкласса с именами Specific1 и Specific2.
Этот пример иллюстрирует понятие категорий исключений, где General –
это имя категории, а два подкласса – это определенные типы исключений
внутри категории. Обработчики, которые перехватывают исключение General,
так же будут перехватывать и все его подклассы, в том числе Specific1
и Specific2:
"""


class General(Exception):
    pass


class Specific1(General):
    pass


class Specific2(General):
    pass


def raiser0():
    X = General()  # Возбуждает экземпляр супер-класса исключения
    raise X


def raiser1():
    X = Specific1()  # Возбуждает экземпляр подкласса исключения
    raise X


def raiser2():
    X = Specific2()  # Возбуждает экземпляр другого подкласса исключения
    raise X


for func in (raiser0, raiser1, raiser2):
    try:
        func()
    except General:  # Перехватывает исключения General
        #              и любые его подклассы
        import sys
        print('caught:', sys.exc_info()[0])

"""
 C:\python30> python classexc.py
caught: <class ‘__main__.General’>
caught: <class ‘__main__.Specific1’>
caught: <class ‘__main__.Specific2’>

 Этот фрагмент достаточно прост для понимания, однако у меня имеется
несколько примечаний к реализации:

 Супер-класс Exception
 
  К классам, используемым для построения дерева категорий исключений,
 предъявляется не так много требований. Фактически все классы в этом
 примере – пустые. Тела этих классов не содержат ничего кроме инструкции
 pass. Однако обратите внимание, что здесь класс верхнего уровня 
 наследует встроенный класс Exception. Это является обязательным 
 требованием в Python 3.0 – классические классы в Python 2.6 также 
 могут играть роль исключений, но если класс исключения наследует класс 
 встроенного исключения, он автоматически становится классом 
 нового стиля, каковыми являются все классы в версии 3.0. Класс 
 Exception предоставляет немало полезных особенностей, 
 как мы увидим далее. Мы не использовали их в этом примере, 
 тем не менее, идею наследовать его можно считать удачной в любой версии
 Python.
 
 Возбуждение экземпляров
 
  В этом примере мы создаем экземпляры классов в инструкциях raise. 
 В модели исключений, основанной на классах, мы всегда возбуждаем 
 и перехватываем объекты экземпляров классов. Если в инструкции raise 
 имена классов указываются без круглых скобок, интерпретатор будет 
 автоматически создавать экземпляры, вызывая их конструкторы 
 без аргументов. Экземпляры исключений могут создаваться до вызова 
 инструкции raise, как сделано в данном примере, или внутри нее.

 Перехватывание категорий

  В этом примере определены функции, которые возбуждают экземпляры
 всех трех классов исключений, а на верхнем уровне модуля определена
 инструкция try, которая вызывает функции и перехватывает исключения
 класса General. Та же инструкция try перехватывает и два более 
 специфических исключения, потому что они являются подклассами класса 
 General.

 Информация об исключении

  В этом примере обработчик исключений использует функцию sys.exc_info –
 как мы узнаем в следующей главе, эта функция обеспечивает обобщенный
 способ получить последнее возбужденное исключение. В двух словах, 
 первый элемент в полученном результате – это класс возбужденного 
 исключения, а второй – фактический экземпляр исключения. В подобных 
 предложениях except, перехватывающих все исключения, принадлежащие 
 некоторой категории, как в данном примере, функция sys.exc_info
 является единственным способом точно определить, что произошло. 
 В данном случае ее можно рассматривать, как эквивалент обращения 
 к атрибуту __class__ экземпляра. Как мы увидим в следующей главе, 
 функция sys.exc_info часто используется в обработчиках пустых
 предложений except, которые перехватывают все возможные исключения.

 Последний пункт требует дополнительных пояснений. Внутри обработчика
можно быть уверенным, что возбужденный экземпляр является экземпляром
класса, указанного в предложении except, или одного из его подклассов.
Благодаря этому тип исключения можно также получить из атрибута
__class__ экземпляра. Ниже приводится фрагмент, который действует 
точно так же, как и предыдущий пример:
"""


class General(Exception):
    pass


class Specific1(General):
    pass


class Specific2(General):
    pass


def raiser0(): raise General()
def raiser1(): raise Specific1()
def raiser2(): raise Specific2()


for func in (raiser0, raiser1, raiser2):
    try:
        func()
    except General as X:  # X – возбужденный экземпляр
        print('caught:', X.__class__)  # То же, что и sys.exc_info()[0]

"""
 Так как тип исключения можно определить с помощью атрибута __class__ 
возбужденного экземпляра исключения, как в данном примере, функцию 
sys.exc_info удобнее использовать в обработчиках пустых предложений
except, где нет другого способа получить доступ к экземпляру 
или к его классу. Кроме того, в действующих программах обычно 
не приходится беспокоиться о конкретном типе возбужденного исключения – 
вызывая методы экземпляра, мы автоматически получаем поведение, присущее
возбужденному исключению. Подробнее об этом и о функции sys.exc_info 
будет рассказываться в следующей главе. Кроме того, если вы забыли
назначение атрибута __class__ в экземплярах, обращайтесь к главе 28 
и ко всей шестой части в целом.


 В чем преимущества иерархий исключений?
 
 Поскольку в примере предыдущего раздела имеется всего три возможных
исключения, он действительно не может продемонстрировать 
все преимущества применения классов исключений. На самом деле 
мы могли бы достичь того же эффекта, указав в предложении except
список имен исключений в круглых скобках. Как это можно сделать, 
показано в файле stringexc.py:

try:
    func()
except (General, Specific1, Specific2): 
                                      # Перехватывает все эти исключения
    ...
    
 Такой подход мог применяться и при использовании ныне отсутствующих
строковых исключений. Однако в случае разветвленных или глубоких 
иерархий исключений, может оказаться гораздо проще перехватывать 
категории, используя классы, чем перечислять в предложении except
все исключения, входящие в категорию. Кроме того, иерархии категорий 
можно расширять, добавляя новые подклассы, не ломая при этом 
существующий программный код. Предположим, что вы занимаетесь 
разработкой библиотеки, реализующей функции обработки числовой
информации, которая используется широким кругом людей. Во время работы
над библиотекой вы обнаруживаете две ситуации, которые могут приводить 
к таким ошибкам, как деление на ноль и переполнение. Вы описываете 
эти ошибки как исключения, которые могут возбуждаться библиотекой:


# mathlib.py
class Divzero(Exception): pass
class Oflow(Exception): pass


def func():
    ...
    raise Divzero()
    
    
 Теперь те, кто будет использовать вашу библиотеку, станут стремиться 
обертывать вызовы ваших функций или классов инструкцией try, чтобы
перехватывать два ваших исключения (если они не будут перехватывать их,
эти исключения будут приводить к аварийному завершению программ):

# client.py
import mathlib

try:
    mathlib.func(...)
except (mathlib.Divzero, mathlib.Oflow):
    ...обработка и восстановление после ошибки...

 Все работает просто замечательно и многие начинают использовать вашу 
библиотеку. Однако шесть месяцев спустя вы, просматривая программный код
(программисты обычно склонны делать это), обнаруживаете еще одну 
ситуацию, которая может приводить к другой ошибке – потере значимых
разрядов, после чего добавляете новое исключение:


# mathlib.py
class Divzero(Exception): pass
class Oflow(Exception): pass
class Uflow(Exception): pass


 К сожалению, выпуском новой версии своей библиотеки вы создаете 
проблему для тех, кто ею пользуется. Если они явно указывали имена ваших 
исключений, теперь им придется вернуться к своим программам и внести 
соответствующие изменения везде, где производятся обращения к вашей 
библиотеке, чтобы включить вновь добавленное имя исключения:

# client.py
import mathlib

try:
    mathlib.func(...)
except (mathlib.Divzero, mathlib.Oflow, mathlib.Uflow):
    ...обработка и восстановление после ошибки...
    
 Вероятно, это не конец света. Если ваша библиотека предназначена 
исключительно для внутреннего использования, вы могли бы внести все 
необходимые изменения самостоятельно. Вы могли бы также написать
сценарий, который попытается ликвидировать проблему автоматически 
(едва ли такой сценарий будет насчитывать более дюжины строк 
и на его создание уйдет совсем немного времени). Однако если многим 
людям придется изменять все инструкции try всякий раз, 
когда вы изменяете свой набор исключений, такая политика обновления 
определенно не будет расцениваться как самая вежливая.

 Ваши пользователи могут попытаться избежать этой ловушки, определяя 
пустые предложения except, которые перехватывают все исключения:

# client.py
try:
    mathlib.func(...)
except: # Перехватывать все исключения
    ...обработка и восстановление после ошибки...
    
 Но при таком решении могут перехватываться посторонние исключения, 
даже такие, которые вызваны опечатками в именах переменных, ошибками
работы с памятью, прерываниями работы программы с клавиатуры (Ctrl-C)
и исключения, генерируемые программой при завершении, а для вас было бы
нежелательно, чтобы перехваченные исключения ошибочно классифицировались
как ошибки в библиотеке.

 И действительно, в подобных ситуациях пользователи стремятся 
перехватывать и обрабатывать только определенные исключения,
возбуждаемые библиотекой, как описывается в документации к ней – 
если в ходе работы библиотечной функции возникает какое-то другое 
исключение, они чаще всего расценивают это как ошибку в самой библиотеке
(и обычно сообщают об этом разработчику!). Как правило, при обработке 
исключений чем больше определенности, тем лучше (к этой идее мы еще
вернемся в разделе с описанием типичных проблем, в следующей главе).

 Так как же быть? Исключения на основе классов полностью ликвидируют эту
проблему. Вместо того чтобы определять библиотечные исключения 
как простой набор независимых классов, их можно оформить в виде дерева 
классов с одним общим супер-классом, охватывающим целую категорию
исключений:


# mathlib.py
class NumErr(Exception): pass
class Divzero(NumErr): pass
class Oflow(NumErr): pass
...
def func():
    ...
    raise Divzero()
    
 При таком подходе пользователям вашей библиотеки достаточно будет 
указать общий супер-класс (то есть категорию), чтобы перехватывать
все исключения, возбуждаемые библиотекой, причем, как существующие,
так и те, что появятся в будущем:

# client.py
import mathlib
...
try:
    mathlib.func(...)
except mathlib.NumErr:
    ...вывод сообщения и восстановление после ошибки...
    
 Когда вы опять вернетесь к работе над библиотекой, новые исключения
можно будет добавлять как новые подклассы от общего супер-класса:

# mathlib.py
...
class Uflow(NumErr): pass


 В результате программный код пользователей, перехватывающий исключения
вашей библиотеки, останется работоспособным без каких-либо изменений. 
Вы свободно сможете добавлять, удалять и изменять исключения 
произвольным образом – пока клиенты используют имя супер-класса,
они могут не беспокоиться об изменениях в вашем наборе исключений. 
Другими словами, исключения на основе классов лучше отвечают требованиям
сопровождения, чем строки.

 Кроме того, исключения на основе классов могут поддерживать хранение
информации о состоянии и наследование, что идеально подходит для крупных
программ. Однако чтобы разобраться в этих концепциях, нам сначала нужно
понять, как соотносятся классы исключений, определяемые пользователем,
с классами встроенных исключений, которые они наследуют.


 Классы встроенных исключений
 
 Примеры в предыдущем разделе возникли не на пустом месте. 
Все встроенные исключения, которые могут возбуждаться интерпретатором,
являются объектами предопределенных классов. Кроме того, 
они организованы в неглубокую иерархию с общими супер-классами категорий
и подклассами определенных типов исключений, практически так же, 
как в примере выше. 

 В Python 3.0 все знакомые исключения, с которыми нам уже приходилось
встречаться (например, SyntaxError), в действительности являются 
обычными классами, доступными в виде встроенных имен в модуле builtins
(в Python 2.6 этот модуль называется __builtin__) и в виде атрибутов 
модуля exceptions, входящего в состав стандартной библиотеки.
Кроме того, в языке Python встроенные исключения организованы в иерархию
с целью поддержки различных режимов перехвата исключений. Например:

 BaseException
 
  Корневой супер-класс исключений. Этот класс не предназначен
 для непосредственного наследования пользовательскими классами 
 (для этого следует использовать класс Exception).
 Он содержит реализацию по умолчанию вывода сообщений и обеспечивает
 сохранение информации о состоянии. Если встроенной функции str
 передать экземпляр этого класса (например, с помощью функции print),
 класс вернет строку с аргументами, которые передавались конструктору
 при создании экземпляра (или пустую строку, если конструктор вызывался
 без аргументов). Кроме того, если подклассы не переопределяют
 конструктор этого класса, все аргументы, передаваемые ему при создании
 экземпляра, сохраняются в атрибуте args экземпляра в виде кортежа.

 Exception

  Корневой супер-класс всех прикладных исключений. Это прямой потомок
 супер-класса BaseException и супер-класс для всех других встроенных
 исключений, кроме классов, связанных с событиями завершения программы
 (SystemExit, KeyboardInterrupt и GeneratorExit). Почти все 
 пользовательские классы исключений должны наследовать этот класс,
 а не BaseException. При соблюдении этого соглашения предложения except 
 инструкции try, в которых указано исключение Exception, 
 будут перехватывать все исключения, кроме событий завершения программы, 
 которые обычно обрабатывать не требуется. В результате использование
 имени Exception в инструкции try обеспечивает более точную 
 избирательность, чем пустое предложение except.
 
 ArithmeticError
 
  Супер-класс всех арифметических ошибок (и подкласс класса Exception).
  
 OverflowError
 
  Подкласс класса ArithmeticError, идентифицирующий конкретную 
 арифметическую ошибку.

 И так далее. Подробнее познакомиться с этой структурой можно либо 
в справочных руководствах, таких как «Pocket Reference», 
или в руководстве по библиотеке Python. Обратите внимание, 
что деревья классов исключений в Python 3.0 и 2.6 немного отличаются.
Следует также заметить, что структуру дерева классов можно посмотреть
в тексте справки для модуля exceptions только в Python 2.6 (этот модуль
был исключен из Python 3.0). Описание функции help приводится 
в главах 4 и 15:

>>> import exceptions
>>> help(exceptions)
...объемный текст справки опущен...


 Категории встроенных исключений
 
 Дерево встроенных классов позволяет определять, насколько конкретными
или универсальными будут ваши обработчики исключений. Например,
встроенное исключение ArithmeticError – это супер-класс для таких более
конкретных исключений, как OverflowError и ZeroDivisionError. Указав имя
ArithmeticError в инструкции try, вы будете перехватывать 
все арифметические ошибки, а указав имя OverflowError, вы будете 
перехватывать только ошибки определенного типа и никакие другие.

 Точно так же можно использовать исключение Exception – супер-класс всех
прикладных исключений в Python 3.0, чтобы организовать обработку всех 
исключений. Использование этого класса по своему действию напоминает 
пустое предложение except, но позволяет игнорировать исключения, 
связанные с завершением программы:

try:
    action()
except Exception:
    ...обработать все прикладные исключения...
else:
    ...обработать ситуацию отсутствия исключений...
    
 Однако данный прием не настолько универсален в Python 2.6, потому что
исключения, определяемые пользователем как классические классы, 
не являются подклассами корневого класса Exception. Этот способ обладает
более высокой надежностью в Python 3.0, так как в этой версии требуется, 
чтобы все классы исключений наследовали какие-либо встроенные
исключения. Однако даже в Python 3.0 этому приему свойственны те же 
потенциальные ловушки, характерные для пустого предложения except. 
Как описывалось в предыдущей главе – в этом случае могут перехватываться 
исключения, которые предполагается обрабатывать в другом месте,
что может скрыть подлинные ошибки программирования. Так как эта проблема 
встречается достаточно часто, мы вернемся к ней, когда будем обсуждать
проблемы исключений в следующей главе.

 Неважно, будете вы использовать категории в дереве встроенных классов 
или нет, этот подход служит отличным примером; при использовании 
подобных методов к созданию своих собственных исключений вы сможете
реализовать гибкие наборы исключений, которые легко можно изменять.


 Операция вывода по умолчанию и сохранение информации
 
 Встроенные исключения предоставляют реализацию вывода сообщения, 
используемую по умолчанию, и сохранение информации о состоянии, 
что обеспечивает значительную долю логики работы исключений, в которых 
нуждаются пользовательские классы. Если, наследуя встроенные классы 
исключений, вы не переопределяете конструктор супер-класса,
любые аргументы, передаваемые конструктору, будут сохраняться
в атрибуте args экземпляра и автоматически включаться в текст сообщения 
при выводе экземпляра (если конструктор вызывался без аргументов, 
будут выведены пустой кортеж и стандартная строка сообщения).

 Это объясняет, почему аргументы, передаваемые конструкторам классов
встроенных исключений, включаются в текст сообщения об ошибке – 
все аргументы присоединяются конструктором к экземпляру и отображаются 
при попытке вывести его:

>>> raise IndexError # То же, что и IndexError(): нет аргументов
Traceback (most recent call last):
  File “<stdin>”, line 1, in <module>
IndexError
>>> raise IndexError(‘spam’) # Конструктор присоединит аргумент
Traceback (most recent call last):
  File “<stdin>”, line 1, in <module>
IndexError: spam
>>> I = IndexError(‘spam’) # Аргументы доступны в виде атрибута
>>> I.args
(‘spam’,)

 То же относится и к пользовательским исключениям, потому что они 
наследуют от встроенных супер-классов конструктор и методы вывода:
"""


class E(Exception):
    pass


try:
    raise E('spam')
except E as X:
    print(X, X.args)  # Выведет аргументы, сохраненные конструктором


try:
    raise E('spam', 'eggs', 'ham')
except E as X:
    print(X, X.args)

"""
 Обратите внимание, что объекты экземпляров исключений сами по себе 
не являются строками, но они используют протокол перегрузки операторов,
который мы изучали в главе 29, и реализуют метод __str__, обеспечивающий 
преобразование экземпляра в строку. Чтобы выполнить конкатенацию 
экземпляра с настоящей строкой, его необходимо вручную преобразовать 
в строковое представление: str(X) + “string”.

 Автоматическая поддержка вывода и сохранения информации удобна 
сама по себе, тем не менее, чтобы организовать сохранение дополнительной 
информации и вывод специфических сообщений, вы всегда можете 
переопределить унаследованные методы, такие как __str__ и __init__, 
в подклассах класса Exception, о чем рассказывается в следующем разделе.


 Определение текста исключения
 
 Как мы видели в предыдущем разделе, по умолчанию исключения на основе
классов выводят значения всех аргументов, которые были переданы 
конструктору класса, если их перехватить и вывести:
"""


class MyBad(Exception):
    pass


try:
    raise MyBad('Sorry--my mistake!')
except MyBad as X:
    print(X)

"""
 Эта же унаследованная модель отображения используется, когда исключение
отображается в составе сообщения об ошибке, если оно не будет 
перехвачено программой:

>>> raise MyBad(‘Sorry--my mistake!’)
Traceback (most recent call last):
  File “<stdin>”, line 1, in <module>
__main__.MyBad: Sorry--my mistake!

 Во многих случаях этого вполне достаточно. Однако, чтобы улучшить 
сообщение, необходимо переопределить в классе исключения один из двух
методов перегрузки операции вывода (__repr__ или __str__), 
чтобы возвращалась желаемая строка, которая будет отображаться
при выводе исключения. Строка, возвращаемая методом, будет отображаться 
при выводе экземпляра исключения вручную или когда исключение 
будет перехвачено обработчиком по умолчанию:
"""


class MyBad(Exception):
    def __str__(self):
        return 'Always look on the bright side of life...'


try:
    raise MyBad()
except MyBad as X:
    print(X)

"""
 >>> raise MyBad()
Traceback (most recent call last):
  File “<stdin>”, line 1, in <module>
__main__.MyBad: Always look on the bright side of life...

 Важно отметить, что в подобных ситуациях предпочтительнее
переопределять метод __str__, потому что встроенные супер-классы
уже имеют метод __str__, который в большинстве случаев (включая операцию
вывода) пользуется преимуществом перед методом __repr__. Если
переопределить метод __repr__, операция вывода благополучно вызовет 
метод __str__ вместо вашей версии метода __repr__! Подробнее об этих 
специальных методах рассказывается в главе 29. 

 Независимо от того, что вернет ваш метод, это значение будет включено
в текст сообщения об ошибке для не перехваченных исключений
и использовано при попытке вывести экземпляр явно. В данном примере 
метод возвращает жестко определенную строку, однако он может выполнять 
любую обработку текста и использовать информацию о состоянии, 
присоединенную к объекту экземпляра. В следующем разделе мы рассмотрим
возможности, которые можно использовать при работе с этой информацией.
"""

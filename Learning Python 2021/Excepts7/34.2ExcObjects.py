"""
 Передача данных в экземплярах и реализация поведения

 Помимо поддержки гибких иерархий классы исключений также являются
удобным местом для хранения дополнительной информации в виде атрибутов
экземпляров. Как мы уже видели выше, супер-классы встроенных исключений
реализуют конструктор по умолчанию, который автоматически сохраняет
аргументы в экземпляре, в виде кортежа, в атрибуте с именем args.
И хотя конструктора по умолчанию в большинстве случаев вполне
достаточно, иногда возникает необходимость определить собственный
конструктор. Кроме того, классы могут определять дополнительные методы
для использования в обработчиках, предоставляя тем самым
предопределенную логику обработки исключений.


 Передача дополнительной информации об исключении

 Когда возбуждается исключение, оно способно пересекать границы модулей
 – инструкция raise, запускающая исключение, и инструкция try,
перехватывающая его, могут находиться в разных модулях. В общем случае
глобальные переменные не подходят для сохранения дополнительной
информации, потому что программный код в инструкции try может не знать,
в каком модуле находятся эти переменные. Передача дополнительной
информации внутри самого экземпляра исключения обеспечивает более
надежный способ получить ее в инструкции try.

 При использовании классов это может происходить почти автоматически.
Как мы уже видели, при возбуждении исключения вместе с ним интерпретатор
передает экземпляр класса. Обработчики в инструкциях try могут получить
доступ к экземплярам возбужденных исключений, если в предложении except
указать имя переменной после ключевого слова as. Этот прием обеспечивает
естественный способ передачи данных и поведения обработчику.

 Программа, выполняющая анализ файлов, может, например, сообщать
об ошибке форматирования, возбуждая экземпляр исключения, который
заполняется дополнительной информацией об ошибке:
"""


class FormatError(Exception):
    def __init__(self, line, file):
        self.line = line
        self.file = file


def parser():
    raise FormatError(42, file='spam.txt')  # Если обнаружена ошибка


try:
    parser()
except FormatError as X:
    print('Error at', X.file, X.line)

"""
 В этом примере переменной X в предложении except присваивается ссылка 
на экземпляр, который был сгенерирован во время возбуждения исключения.
Благодаря этой переменной мы получаем доступ к атрибутам, присоединенным 
к экземпляру нашей реализацией конструктора. Конечно, мы могли бы
положиться на реализацию сохранения информации, имеющуюся во встроенных
супер-классах, но такой способ хуже подходит для нашего приложения:
"""


class FormatError(Exception):
    pass  # Наследует конструктор по умолчанию


def parser():
    raise FormatError(42, 'spam.txt')  # Именованные аргументы
    #                                    недопустимы!


try:
    parser()
except FormatError as X:
    print('Error at:', X.args[0], X.args[1])  # Не так удобно
    #                                           для данного приложения

"""
 Предоставление методов исключений
 
 Помимо возможности передавать дополнительную информацию о состоянии
адаптированные классы могут использоваться для реализации специфического
поведения объектов исключений. То есть класс исключения может определять
дополнительные методы для использования в обработчиках. Ниже приводится
пример класса исключения, который реализует дополнительный метод, 
использующий информацию о состоянии для регистрации ошибки в файле:
"""


class FormatError(Exception):
    logfile = 'formaterror.txt'

    def __init__(self, line, file):
        self.line = line
        self.file = file

    def logerror(self):
        log = open(self.logfile, 'a')
        print('Error at', self.file, self.line, file=log)


def parser():
    raise FormatError(40, 'spam.txt')


try:
    parser()
except FormatError as exc:
    exc.logerror()

"""
 Если запустить этот сценарий, в ответ на вызов метода внутри 
обработчика исключения он запишет сообщение об ошибке в файл:

C:\misc> C:\Python30\python parse.py
C:\misc> type formaterror.txt
Error at spam.txt 40

 При использовании подобных классов методы (такие, как loggeror) могут
наследоваться подклассами, а атрибуты экземпляра
(такие, как line и file) предоставляют возможность сохранения информации
о состоянии, обеспечивая дополнительный контекст для последующих вызовов
методов. Кроме того, классы исключений легко могут адаптироваться
и расширяться благодаря наследованию. Другими словами, так как
исключения определяются в виде классов, все преимущества ООП, о которых 
мы узнали в шестой части книги, доступны и при работе с исключениями.
"""

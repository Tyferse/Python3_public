"""
 Основы исключений


 Зачем нужны исключения?

 В двух словах, исключения позволяют перепрыгнуть через фрагмент
программы произвольной длины. Рассмотрим пример с машиной
по приготовлению пиццы, о которой говорилось ранее в этой книге.
Предположим, что мы более чем серьезно отнеслись к этой идее
и действительно построили такую машину. Чтобы приготовить пиццу,
наш кулинарный автомат должен выполнить программу, написанную на языке
Python: она должна принимать заказ, приготовить тесто, выбрать добавки,
выпечь основу и так далее.

 Теперь предположим, что что-то пошло совсем не так во время «выпекания
основы». Возможно, сломалась печь или, возможно, наш робот ошибся
в расчетах расстояния до печи и воспламенился. Совершенно очевидно,
что нам необходимо предусмотреть быстрый переход к программному коду,
который быстро обрабатывает такие ситуации. Кроме того, поскольку
в таких необычных условиях у нас нет никакой надежды на успешное
окончание процесса приготовления пиццы, мы могли бы также вообще
отказаться от выполнения всего плана целиком.

 Это именно то, что позволяют делать исключения: программа может перейти
к обработчику исключения за один шаг, отменив все вызовы функций. После
этого обработчик исключения может выполнить действия, соответствующие
ситуации (например, вызвать пожарную охрану!).

 Исключение – это своего рода «супер-goto». Обработчик исключений
(инструкция try) ставит метку и выполняет некоторый программный код.
Если затем где-нибудь в программе возникает исключение, интерпретатор
немедленно возвращается к метке, отменяя все активные вызовы функций,
которые были произведены после установки метки. Такой подход позволяет
соответствующим способом реагировать на необычные события. Кроме того,
переход к обработчику исключения выполняется немедленно, поэтому обычно
нет никакой необходимости проверять коды возврата каждой вызванной
функции, которая могла потерпеть неудачу.


 Назначение исключений

 В программах на языке Python исключения могут играть разные роли. Ниже
приводятся некоторые из них, являющиеся наиболее типичными:

 Обработка ошибок

  Интерпретатор возбуждает исключение всякий раз, когда обнаруживает
 ошибку во время выполнения программы. Программа может перехватывать
 такие ошибки и обрабатывать их или просто игнорировать. Если ошибка
 игнорируется, интерпретатор выполняет действия, предусмотренные
 по умолчанию, – он останавливает выполнение программы и выводит
 сообщение об ошибке. Если такое поведение по умолчанию является
 нежелательным, можно добавить инструкцию try, которая позволит
 перехватывать обнаруженные ошибки и продолжить выполнение программы
 после инструкции try.

 Уведомления о событиях

  Исключения могут также использоваться для уведомления о наступлении
 некоторых условий, что устраняет необходимость передавать куда-либо
 флаги результата или явно проверять их. Например, функция поиска может
 возбуждать исключение в случае неудачи, вместо того чтобы возвращать
 целочисленный признак в виде результата (и надеяться, что этот признак
 всегда будет интерпретироваться правильно).

 Обработка особых ситуаций

  Некоторые условия могут наступать так редко, что было бы слишком
 расточительно предусматривать проверку наступления таких условий
 с целью их обработки. Нередко такие проверки необычных ситуаций можно
 заменить обработчиками исключений.

 Заключительные операции

  Как будет показано далее, инструкция try/finally позволяет
 гарантировать выполнение завершающих операций независимо от наличия
 исключений.

 Необычное управление потоком выполнения

  И, наконец, так как исключения – это своего рода оператор «goto»,
 их можно использовать как основу для экзотического управления потоком
 выполнения программы. Например, обратная трассировка не является частью
 самого языка, но она может быть реализована с помощью исключений
 и некоторой логики поддержки, выполняющей раскручивание операций
 присваивания. В языке Python отсутствует оператор «goto» (к счастью!),
 но исключения иногда могут с успехом заменить его.

 Далее в этой части книги мы увидим примеры этих типичных применений.
А пока начнем с обзора средств языка Python, предназначенных
для обработки исключений.


 Обработка исключений: краткий обзор

 В сравнении с некоторыми другими основными возможностями, которые
рассматривались в этой книге, исключения в языке Python представляют
собой чрезвычайно легкий инструмент. Поскольку они так просты, перейдем
сразу к первому примеру.


 Обработчик исключений по умолчанию

 Предположим, что у нас имеется следующая функция:

\>> def fetcher(obj, index):
...     return obj[index]
...

 Эта функция делает не так много – она просто извлекает элемент
из объекта по заданному индексу. При нормальном стечении обстоятельств
она возвращает результат:

\>>> x = ‘spam’
\>>> fetcher(x, 3) # Все равно, что x[3]
‘m’

 Однако если передать функции индекс, выходящий за пределы строки,
то при попытке выполнить выражение obj[index] будет возбуждено
исключение. Обнаруживая выход за пределы последовательности,
интерпретатор сообщает об этом, возбуждая встроенное исключение
IndexError:

>>> fetcher(x, 4) # Обработчик по умолчанию – интерактивная оболочка
Traceback (most recent call last):
  File “<stdin>”, line 1, in <module>
  File “<stdin>”, line 2, in fetcher
IndexError: string index out of range
(IndexError: выход индекса за пределы диапазона)

 Поскольку наш программный код не перехватывает это исключение явно,
оно возвращает выполнение на верхний уровень программы и вызывает
обработчик исключений по умолчанию, который просто выводит стандартное
сообщение об ошибке. К настоящему моменту вы наверняка видели в своих
программах подобные сообщения об ошибках. Они включают тип исключения,
а также диагностическую информацию – список строк и функций, которые
были активны в момент появления исключения.

 Текст сообщения об ошибке, который приводится выше, был получен
в Python 3.0 – он может несколько отличаться в разных версиях
интерпретатора. При работе в интерактивной оболочке файлом является
«<stdin>», то есть стандартный поток ввода. При работе в IDLE файлом
является «<pyshell>» и дополнительно выводятся номера строк.
В любом случае номера строк не несут сколько-нибудь полезной информации
(далее в этой книге вы увидите куда более интересные сообщения
об ошибках):

\>>> fetcher(x, 4) # Обработчик по умолчанию - IDLE GUI
Traceback (most recent call last):
  File “<pyshell#6>”, line 1, in <module>
    fetcher(x, 4)
  File “<pyshell#3>”, line 2, in fetcher
    return obj[index]
IndexError: string index out of range

 В настоящей программе, запущенной не в интерактивной оболочке,
после вывода сообщения обработчик по умолчанию сразу же завершает
работу программы. Такое действие имеет смысл для простых сценариев –
как правило, ошибки в таких сценариях должны быть фатальными и лучшее,
что можно сделать при их появлении, – это ознакомиться
с текстом сообщения.


 Обработка исключений

 Иногда это совсем не то, что нам требуется. Например, серверные
программы обычно должны оставаться активными даже после появления
внутренних ошибок. Если вам требуется избежать реакции на исключение
по умолчанию, достаточно просто перехватить исключение, обернув вызов
функции инструкцией try:

\>>> try:
...     fetcher(x, 4)
... except IndexError:  # Перехватывает и обрабатывает исключение
...     print(‘got exception’)
...
got exception
\>>>

 Теперь, когда исключение будет возникать при выполнении инструкций
в блоке try, интерпретатор будет автоматически переходить к вашему
обработчику (блок под предложением except, в котором указано
имя исключения). При работе в интерактивной оболочке,
как в примере выше, после выполнения блока except происходит возврат
в приглашение к вводу. В настоящих программах инструкции try не только
перехватывают исключения, но и выполняют действия по восстановлению
после ошибок:

\>>> def catcher():
...     try:
...         fetcher(x, 4)
...     except IndexError:
...         print(‘got exception’)
...     print(‘continuing’)
...
\>>> catcher()
got exception
continuing
\>>>

 На этот раз, после того, как исключение было перехвачено и обработано,
программа продолжила выполнение ниже всей инструкции try –
именно поэтому в данном примере было выведено сообщение «continuing».
Стандартное сообщение об ошибке не появилось на экране, и программа
продолжила работу как ни в чем не бывало.


 Возбуждение исключений

 До сих пор все исключения, которые мы наблюдали, возбуждались
интерпретатором, когда он встречал наши ошибки (на сей раз ошибка была
допущена нарочно!), однако наши сценарии также способны возбуждать
исключения – то есть исключения могут возбуждаться интерпретатором
или самой программой и могут перехватываться или не перехватываться.
Чтобы возбудить исключение вручную, достаточно просто выполнить
инструкцию raise. Исключения, определяемые программой, перехватываются
точно так же, как и встроенные исключения. Следующий фрагмент, возможно,
содержит не самый полезный программный код, когда-либо написанный,
но он проясняет вышесказанное:

\>>> try:
...     raise IndexError # Возбуждает исключение вручную
...  except IndexError:
...     print(‘got exception’)
...
got exception

 Если исключение, определяемое программой, не перехватывается, оно будет
передано обработчику исключений по умолчанию, что приведет к завершению
программы с выводом стандартного сообщения об ошибке:

\>>> raise IndexError
Traceback (most recent call last):
  File “<stdin>”, line 1, in <module>
IndexError

 Как будет показано в следующей главе, исключения могут также
возбуждаться с помощью инструкции assert – это условная форма инструкции
raise, которая используется в основном для отладки в процессе
разработки:

\>>> assert False, ‘Nobody expects the Spanish Inquisition!’

Traceback (most recent call last):
  File “<stdin>”, line 1, in <module>
AssertionError: Nobody expects the Spanish Inquisition!


 Исключения, определяемые пользователем

 Инструкция raise, представленная в предыдущем разделе, возбуждает
встроенные исключения, которые определены во встроенной области
видимости. Как вы узнаете далее в этой части книги, вы также можете
определять новые исключения для внутренних нужд своих программ.
Пользовательские исключения создаются в виде классов, наследующих один
из классов встроенных исключений, – обычно класс с именем Exception.
Исключения на базе классов позволяют сценариям создавать категории
исключений, наследовать поведение и добавлять к ним информацию
о состоянии:

\>>> class Bad(Exception):  # Пользовательское исключение
...     pass
...
\>>> def doomed():
...     raise Bad()  # Возбудит экземпляр исключения
...
\>>> try:
...     doomed()
... except Bad:  # Перехватить исключение по имени класса
...     print(‘got Bad’)
...
got Bad
\>>>


 Заключительные операции

 Наконец, инструкции try могут включать блоки finally. Эти блоки
выглядят точно так же, как обработчики except. Комбинация try/finally
определяет завершающие действия, которые всегда выполняются «на выходе»,
независимо от того, возникло исключение в блоке try или нет:

\>>> try:
...     fetcher(x, 3)
... finally:  # Заключительные операции
...     print(‘after fetch’)
...
‘m’
after fetch
\>>>

 Здесь, если блок try выполнится без ошибок, будет выполнен блок finally
и программа продолжит свою работу дальше. В этом случае данная
инструкция кажется бессмысленной – мы могли бы просто добавить
инструкцию print сразу вслед за вызовом функции и вообще убрать
инструкцию try:

fetcher(x, 3)
print(‘after fetch’)

 Однако в таком подходе имеется одна проблема: если в функции возникнет
исключение, инструкция print не будет выполнена. Комбинация try/finally
позволяет ликвидировать эту проблему – когда в блоке try действительно
произойдет исключение, блок finally будет выполнен, пока программа будет
раскручиваться:

\>>> def after():
...     try:
...         fetcher(x, 4)
...     finally:
...         print(‘after fetch’)
...     print(‘after try?’)
...
\>>> after()
after fetch
Traceback (most recent call last):
  File “<stdin>”, line 1, in <module>
  File “<stdin>”, line 3, in after
  File “<stdin>”, line 2, in fetcher
IndexError: string index out of range
(IndexError: выход индекса за пределы диапазона)
\>>>

 Здесь мы не получили сообщение «after try?», потому что
работа программы не была продолжена после блока try/finally, когда
возникло исключение. Вместо этого интерпретатор выполнил действия,
предусмотренные блоком finally, после чего исключение достигло
предыдущего обработчика (в данном случае – обработчик по умолчанию).
Если изменить вызов внутри функции action, чтобы он не вызывал
исключение, блок finally все равно будет выполнен, но программа
продолжит работу после выхода из инструкции try:

\>>> def after():
...     try:
...         fetcher(x, 3)
...     finally:
...         print(‘after fetch’)
...     print(‘after try?’)
...
\>>> after()
after fetch
after try?
\>>>

 На практике комбинацию try/except удобно использовать для перехвата
и восстановления после исключений, а комбинацию try/finally – в случаях,
когда необходимо гарантировать выполнение заключительных действий
независимо от того, возникло исключение в блоке try или нет. Например,
комбинацию try/except можно было бы использовать для перехвата ошибок,
возникающих в импортированной библиотеке, созданной сторонним
разработчиком, а комбинацию try/finally – чтобы гарантировать закрытие
файлов и соединений с сервером. Некоторые из таких практических примеров
будут показаны далее в этой книге. Несмотря на то, что эти
две комбинации служат двум различным целям, тем не менее, начиная
с версии Python 2.5, появилась возможность смешивать предложения
except и finally в одной и той же инструкции try – блок finally будет
выполняться всегда, независимо от того, было ли перехвачено исключение
предложением except.

 Как мы узнаем в следующей главе, в Python 2.6 и 3.0 существует
альтернатива конструкции try/finally, используемая при работе
с некоторыми типами объектов. Инструкция with/as выполняет логику,
предусмотренную реализацией объекта, гарантируя выполнение
заключительных операций:

\>>> with open(‘lumberjack.txt’, ‘w’) as file:  # Всегда закрывает файл
...     file.write(‘The larch!\n’) # при выходе

 Такой подход позволяет сократить объем программного кода, однако
он может применяться при работе лишь с некоторыми типами объектов,
поэтому конструкция try/finally представляет более универсальный способ,
гарантирующий выполнение заключительных операций. С другой стороны,
конструкция with/as способна выполнять начальные операции и поддерживает
возможность определять пользовательскую реализацию управления
контекстом.


 Придется держать в уме: проверка ошибок

 Один из способов увидеть, насколько полезными могут быть исключения,
состоит в том, чтобы сравнить стили программирования на языке Python
и на языке, не имеющем исключений. Например, если вы хотите написать
надежную программу на языке C, вам потребуется проверять возвращаемые
значения или коды состояния после выполнения каждой операции,
которая может быть выполнена с ошибкой, и передавать результаты проверок
в ходе выполнения программы:

doStuff()
{                                  # Программа на языке C
    if (doFirstThing() == ERROR)  # Проверить наличие ошибки
        return ERROR;            # даже если здесь она не обрабатывается
    if (doNextThing() == ERROR)
        return ERROR;
    ...
    return doLastThing();
}

main()
{
    if (doStuff() == ERROR)
        badEnding();
    else
        goodEnding();
}

 Фактически в настоящих программах на языке C значительная доля всего
программного кода выполняет проверку наличия ошибок. Но в языке Python
не требуется так же настойчиво и методично выполнять проверки.
Достаточно просто обернуть произвольные участки программы обработчиками
исключений и писать эти участки в предположении, что никаких ошибок
возникать не будет:

def doStuff():        # Программный код на языке Python
    doFirstThing()    # Нас не беспокоят возможные исключения,
    doNextThing()     # поэтому можно не выполнять проверку
    ...
    doLastThing()

if__name__ == ‘__main__’:
    try:
        doStuff()   # Здесь нас интересуют возможные результаты,
    except:         # поэтому это единственное место, где нужна проверка
        badEnding()
    else:
        goodEnding

 Так как в случае исключения управление немедленно будет передано
обработчику, здесь нет никакой необходимости разбрасывать проверки
по всему программному коду, чтобы обезопасить себя от ошибок.
Кроме того, благодаря тому, что интерпретатор Python автоматически
обнаруживает ошибки, ваши программы обычно не требуют выполнять подобные
проверки вообще. Таким образом, исключения позволяют в значительной
степени игнорировать возможные необычные ситуации и отказаться
от использования программного кода, выполняющего проверки на наличие
ошибок.
"""

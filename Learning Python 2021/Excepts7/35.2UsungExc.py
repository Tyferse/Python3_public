"""
 Заключение по основам языка


 Набор инструментальных средств языка Python

 Начиная с этого момента, ваша будущая карьера программиста на языке
Python в значительной степени будет состоять из овладения
инструментальными средствами, доступными для прикладного
программирования на языке Python. Это может занять немало времени.
Стандартная библиотека, например, содержит сотни модулей,
а разработчиками сообщества предлагается еще больше. Чтобы познакомиться
со всеми этими инструментами, может потребоваться лет десять,
а то и больше, особенно если учесть, что постоянно появляются новые
(можете мне поверить!).

 Вообще говоря, Python обеспечивает следующую иерархию инструментальных
средств:

 Встроенные

  Встроенные типы, такие как строки, списки и словари, помогают быстро
 создавать несложные программы.

 Расширения на языке Python

  Для решения более сложных задач вы можете расширить возможности
 Python своими собственными функциями, модулями и классами.

 Компилируемые расширения

  Хотя мы и не касались данной темы в этой книге, тем не менее,
 возможности Python можно расширять с помощью модулей, написанных
 на других языках программирования, таких как C или C++.

 Благодаря такой многоуровневой организации инструментальных средств
вы можете выбирать, насколько глубоко погружаться в эту иерархию
при создании своих программ, – для простых сценариев достаточно будет
встроенных средств, для крупных программ могут потребоваться
дополнительные расширения на языке Python, а компилируемые расширения –
для решения необычных задач. В этой книге мы охватили первые
две категории, и этого вполне достаточно, чтобы начать писать
на языке Python серьезные программы.

 В табл. приводятся некоторые из встроенных и других функциональных
возможностей, доступных в языке Python, исследованием которых вы будете
заниматься остаток вашей карьеры программиста на языке Python.
До настоящего момента наши примеры были очень маленькими
и самостоятельными. Главная их цель состояла в том, чтобы помочь вам
освоить основы. Но теперь, когда вы узнали все о базовом языке,
настало время учиться использовать встроенные интерфейсы Python,
чтобы быть в состоянии выполнять настоящую работу. Вы обнаружите,
что такой простой язык, как Python, делает решение наиболее
распространенных задач намного более легким делом,
чем можно было бы ожидать.

  Категория                 Примеры
  Типы объектов             Списки, словари, файлы, строки

  Функции                   len, range, open

  Исключения                IndexError, KeyError

  Модули                    os, tkinter, pickle, re

  Атрибуты                  __dict__, __name__, __class__

  Внешние инструменты       NumPy, SWIG, Jython, IronPython,
                            Django и др.


 Инструменты разработки крупных проектов

 Как только вы овладеете основами языка, вы обнаружите, что ваши
программы становятся существенно больше, чем примеры, с которыми вы
экспериментировали до сих пор. Для разработки крупных программ
и в Python, и в общем доступе имеется целый набор инструментов
разработки. Некоторые из них вы видели в действии, некоторые
я только упомянул. Чтобы помочь вам на вашем нелегком пути, я приведу
краткое описание некоторых наиболее часто используемых инструментов:

 PyDoc и строки документирования

  Функция help и HTML-интерфейсы модуля PyDoc были представлены
 в главе 15. Модуль PyDoc реализует систему документирования для модулей
 и объектов и интегрирован со строками документирования. Это стандартная
 часть системы Python, поэтому за дополнительными подробностями
 обращайтесь к справочному руководству по библиотеке. Кроме того,
 в главе 4 даются подсказки с указанием на источники документации
 и другие информационные ресурсы по языку Python.

 PyChecker

  Python – это динамический язык программирования, поэтому некоторые
 ошибки сложно обнаружить, пока программа не будет запущена (например,
 синтаксические ошибки можно выявить при запуске или во время
 импортирования файла). Это не такой большой недостаток –
 как и для большинства языков программирования, это лишь означает,
 что прежде чем распространять свой программный код, его необходимо
 тестировать. При использовании языка Python этап компиляции замещается
 этапом начального тестирования. Кроме того, динамическая природа языка
 Python, автоматический вывод сообщений об ошибках и модель исключений
 позволяют быстрее и проще отыскивать и исправлять ошибки, чем в других
 языках программирования (например, в отличие от языка C, интерпретатор
 Python не вызывает крах системы при появлении ошибок).

  Системы PyChecker и PyLint обеспечивают возможность выявления широкого
 круга наиболее часто встречающихся ошибок еще до того, как сценарий
 будет запущен. Они играют роль, похожую на ту, какую играет программа
 lint в разработке на языке C. Некоторые коллективы разработчиков
 проверяют свой программный код на языке Python с помощью PyChecker
 еще до его тестирования или распространения, чтобы выявить все скрытые
 проблемы. В действительности даже стандартная библиотека языка Python
 регулярно проверяется с помощью PyChecker перед выпуском. PyChecker
 и PyLint – это сторонние пакеты, распространяемые с открытыми исходными
 текстами.

 PyUnit (он же unittest)

  В главе 24 мы видели, как в файлы модулей добавляется программный код
 самопроверки, который использует результат проверки
 __name__ == ‘__main__’. Дополнительно для нужд тестирования в состав
 Python входят два инструмента. Первый, PyUnit (в руководстве
 по библиотеке называется unittest), обеспечивает комплект классов,
 с помощью которых можно определить и настроить варианты тестов
 и указать ожидаемые результаты. Он напоминает библиотеку JUnit
 в языке Java. Это сложная основанная на классах система, подробное
 описание которой вы найдете в справочном руководстве по библиотеке
 Python.

 doctest

  Модуль doctest, входящий в состав стандартной библиотеки, реализует
 второй и более простой подход к регрессивному тестированию. Он основан
 на использовании строк документирования в языке Python.
 В первом приближении, чтобы воспользоваться модулем doctest, следует
 скопировать результаты тестирования в интерактивном сеансе в строки
 документирования в файле с исходным текстом. После этого модуль doctest
 извлечет эти строки документирования, вычленит из них описание тестов
 с ожидаемыми результатами и повторно выполнит тесты, чтобы сравнить
 полученные результаты с ожидаемыми. Функциональные возможности doctest
 могут использоваться разными способами, о чем подробнее рассказывается
 в справочном руководстве по стандартной библиотеке Python.

 Интегрированные среды разработки

  В главе 3 мы уже рассматривали интегрированные среды разработки
 для языка Python. Такие интегрированные среды, как IDLE, обеспечивают
 графический интерфейс для редактирования, запуска, отладки и просмотра
 программ на языке Python. Некоторые мощные интегрированные среды
 разработки (такие, как Eclipse, Komodo, NetBeans и W ing) поддерживают
 решение дополнительных задач разработки, включая интеграцию с системами
 контроля версий, интерактивные построители графического интерфейса,
 создание файлов проектов и многих других.

 Профилировщики

  Поскольку язык Python является высокоуровневым и динамическим языком
 программирования, интуитивные представления о производительности,
 которые следуют из опыта работы с другими языками программирования,
 неприменимы к программному коду на языке Python. Чтобы выявить узкие
 места в программе, вам необходимо добавить логику, выполняющую замеры
 временных интервалов с помощью инструментов, определяемых в модулях
 time или timeit, или запустить свой программный код под управлением
 модуля profile. Мы уже видели модули измерения времени в действии,
 когда сравнивали скорость работы итерационных инструментов в главе 20.
 Профилирование – это обычно самый первый шаг, который выполняется
 на этапе оптимизации, позволяющий выявить узкие места, после чего
 можно начинать поиск альтернативных, более производительных решений.

  Модуль profile – это модуль стандартной библиотеки, который реализует
 профилирование исходных текстов программ на языке Python. Он выполняет
 строку, которую вы ему передадите (например, импорт файла или вызов
 функции), и затем по умолчанию выводит в стандартный поток вывода
 отсчёт, в котором собрана информация о производительности –
 количество вызовов каждой функции, время, потраченное каждой функцией,
 и многое другое.

  Модуль profile может запускаться как самостоятельный сценарий,
 импортироваться и допускает возможность дополнительной настройки –
 например, он может сохранять полученную информацию в файле
 для последующего анализа с помощью модуля pstats. Чтобы выполнить
 профилирование в интерактивном режиме, импортируйте модуль profile
 и вызовите функцию profile.run(‘code’), передав ей строку с программным
 кодом (например, вызов функции или инструкцию импортирования целого
 модуля), производительность которого требуется оценить. Чтобы выполнить
 профилирование из системной командной оболочки, можно воспользоваться
 командой вида python -m profile main.py args... (подробнее формат этой
 команды описывается в приложении A).

  Описание других инструментов профилирования вы найдете в руководстве
 по стандартной библиотеке Python – модуль cProfile, например, имеет
 практически тот же интерфейс, что и модуль profile, но более низкие
 накладные расходы, вследствие чего он лучше подходит для профилирования
 программ, выполнение которых занимает длительное время.

 Отладчики

  В главе 3 мы также обсуждали возможные способы отладки (смотрите в
 резку «Отладка программ на языке Python»). Многие интегрированные среды
 разработки поддерживают отладку с использованием графического
 интерфейса. Кроме того, стандартная библиотека языка Python включает
 модуль отладчика исходных текстов с именем pdb. Этот модуль работает
 подобно отладчику командной строки в языке C (например, dbx, gdb):

  Подобно профилировщику отладчик pdb может запускаться в интерактивном
 режиме, из системной командной строки, импортироваться как модуль
 или вызываться, как функция из модуля pdb (например,
 pdb.run(“main()”)), после чего можно вводить команды отладчика
 в интерактивном режиме pdb. Чтобы запустить pdb из системной командной
 строки, можно воспользоваться командой вида
 python -m pdb main.py args... (подробнее формат этой команды
 описывается в приложении A). Кроме того, отладчик pdb включает полезную
 функцию для проведения послеаварийного анализа – pdb.pm(), которая
 позволяет выполнять отладку после появления исключения.

  Многие интегрированные среды разработки, такие как IDLE, включают
 интерфейсы «указал и щелкнул», поэтому pdb в наши дни используется
 относительно редко, за исключением случаев, когда графический интерфейс
 недоступен или когда требуется более полный контроль над процессом
 отладки. Советы по использованию отладчика с графическим интерфейсом
 в IDLE вы найдете в главе 3. Честно говоря, отладчик pdb
 и интегрированные среды разработки тоже используются не слишком часто.
 Как отмечалось в главе 3, большинство практикующих программистов
 предпочитают отлаживать свой программный код вставкой инструкций print
 в критических точках или просто просматривают сообщения об ошибках
 (не самый современный способ, зато самый быстрый!).

 Варианты распространения

  В главе 2 были представлены инструменты, используемые для упаковки
 программ на языке Python. Такие инструменты, как py2exe, PyInstaller
 и freeze, могут упаковывать байт-код и виртуальную машину
 с интерпретатором Python в «фиксированные двоичные файлы», способные
 выполняться, как самостоятельные программы. Они не требуют установки
 Python и полностью скрывают программный код. Кроме того, в главе 2
 мы узнали, что программы на языке Python могут распространяться в виде
 исходных текстов (.py) или в виде байт-кода (.pyc), а также
 о существовании программных ловушек, обеспечивающих возможность
 реализации специализированных приемов работы с пакетами, таких как
 автоматическое извлечение файлов из архивов в формате .zip
 и шифрование байт-кода.

  Мы также познакомились с модулем distutils, входящим в состав
 стандартной библиотеки, который обеспечивает упаковку модулей и пакетов
 на языке Python и расширений, написанных на языке C,
 – за дополнительной информацией обращайтесь к справочным руководствам
 по языку Python.

  Способы оптимизации

  Существует два основных инструмента оптимизации программ на языке
 Python. В главе 2 была описана система Psyco, позволяющая
 оптимизировать программы по скорости выполнения. Она предоставляет
 динамический компилятор, выполняющий трансляцию байт-кода в двоичный
 машинный код, и Shedskin – транслятор исходных текстов с языка Python
 на язык C++. Иногда вам могут встретиться файлы .pyo с оптимизированным
 байт-кодом, которые создаются при запуске интерпретатора Python
 с ключом командной строки –O (обсуждается в главах 21 и 33), но так как
 этот способ обеспечивает весьма скромное увеличение производительности,
 он обычно не используется.

  Наконец, для повышения производительности можно отдельные части своих
 программ перенести на компилирующий язык программирования, такой как C,
 – подробнее о расширениях на языке C рассказывается в книге
 «Программирование на Python» и в стандартных руководствах по языку
 Python. Вообще говоря, скорость работы интерпретатора Python постоянно
 увеличивается, поэтому старайтесь использовать самую свежую его версию,
 когда это возможно.

 Другие советы по разработке крупных проектов

  Кроме всего прочего, в этой книге мы познакомились с различными
 особенностями языка, удобство которых особенно ярко проявляется
 при работе с крупными проектами. Среди них: пакеты модулей (глава 23);
 исключения на основе классов (глава 33); псевдочастные атрибуты класса
 (глава 30); строки документирования (глава 15); файлы с настройками
 пути поиска модулей (глава 21); сокрытие имен, импортируемых
 инструкцией from * с помощью списков __all__ и имен в формате _X
 (глава 24); добавление программного кода самопроверки с использованием
 приема __name__ == ‘__main__’ (глава 24); использование общих правил
 проектирования при создании функций и модулей (главы 17, 19 и 24),
 использование шаблонов ООП (глава 30 и другие) и т. д.


 Упражнения к седьмой части

 Мы достигли конца этой части книги, поэтому настало время выполнить
несколько упражнений на применение исключений, чтобы попрактиковаться
в основах. Исключения действительно являются очень простым инструментом
– если вы пользуетесь ими, значит вы владеете ими в полной мере.

 1. try/except. Напишите функцию с именем oops, которая при вызове явно
возбуждает исключение IndexError. Затем напишите другую функцию,
вызывающую функцию oops внутри инструкции try/except, которая
перехватывает ошибку. Что произойдет, если изменить функцию oops так,
чтобы вместо IndexError она возбуждала исключение KeyError?
Где располагаются имена KeyError и IndexError?
"""


def oops():
    raise IndexError


def tro():
    try:
        oops()
    except IndexError:
        print('Got it!')


tro()

"""
 2. Объекты исключений и списки. Измените функцию oops, которую вы 
только что написали так, чтобы она возбуждала ваше собственное 
исключение с именем MyError. Определите свое исключение в виде класса.
Затем расширьте инструкцию try в функции, которая вызывает функцию oops,
так чтобы кроме исключения IndexError она перехватывала бы еще 
и это исключение и выводила бы перехваченный экземпляр на экран.
"""


class MyError(Exception):
    def __str__(self):
        return self.__class__.__name__


def oops():
    raise MyError


def tro():
    try:
        oops()
    except (MyError, IndexError) as E:
        print('Got', E)


tro()

"""
 3. Обработка ошибок. Напишите функцию safe(func, *args), которая 
запускает указанную функцию func, передавая ей произвольное количество 
аргументов с использованием синтаксиса *name, перехватывает любые
исключения, возникающие в ходе выполнения этой функции и выводит 
информацию об исключении с использованием функции exc_info из модуля 
sys. Затем с помощью своей функции safe запустите функцию oops 
из упражнения 1 или 2. Поместите функцию safe в модуль с именем tools.py
и передайте ей функцию oops в интерактивном режиме. Какие сообщения 
об ошибках вы получили? Наконец, расширьте свою функцию safe так,
чтобы при возникновении исключения она выводила содержимое стека вызовов
с помощью встроенной функции print_exc, расположенной в стандартном
модуле traceback (за дополнительной информацией обращайтесь 
к руководству по библиотеке языка Python).
"""


def safe(func, *args):
    try:
        func(*args)
    except Exception:
        import sys, traceback
        
        print(*sys.exc_info())
        traceback.print_exc()


safe(oops)

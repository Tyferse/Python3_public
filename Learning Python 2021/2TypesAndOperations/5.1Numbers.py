"""
 Числа

 Базовые числовые типы

 Числа в языке Python представлены не единственным типом,
а целой категорией родственных типов. Язык Python поддерживает обычные
числовые типы (целые и вещественные), а также литералы –
для их создания, и выражения – для их обработки. Кроме того,
Python предоставляет дополнительную поддержку чисел и объектов
для работы с ними. Ниже приводится полный перечень числовых типов
и инструментов, поддерживаемых в языке Python:

  Целые и вещественные числа

  Комплексные числа

  Числа фиксированной точности

  Рациональные числа

  Множества

  Логические значения

  Целые числа неограниченной точности

  Различные встроенные функции и модули для работы с числами


 Числовые литералы

 Помимо базовых типов данных язык Python предоставляет самые обычные
числовые типы: целые числа (положительные и отрицательные)
и вещественные числа (с дробной частью), которые иногда называют числами
с плавающей точкой. Язык Python позволяет записывать целые числа
в виде шестнадцатеричных, восьмеричных и двоичных литералов.
Поддерживает комплексные числа и обеспечивает неограниченную точность
представления целых чисел (количество цифр в целых числах ограничивается
лишь объемом доступной памяти). В табл. 5.1 показано, как выглядят числа
различных типов в языке Python в тексте программы (то есть
в виде литералов).

  Литерал                                 Интерпретация
  1234, -24, 0, 9999999999999999999  Обычные целые числа
                                     (с неограниченной точностью
                                      представления)
  1.23, 1., 3.14e-10, 4E210, 4.0e+210     Вещественные числа
  0177, 0x9ff, 0b101010                  Восьмеричные, шестнадцатеричные
                                         и двоичные литералы целых чисел
                                         в версии 2.6
  0o177, 0x9ff, 0b101010                 Восьмеричные, шестнадцатеричные
                                         и двоичные литералы целых чисел
                                         в версии 3.0
  3+4j, 3.0+4.0j, 3J                      Литералы комплексных чисел


 Литералы целых и вещественных чисел

 Целые числа записываются как строки, состоящие из десятичных цифр.
Вещественные числа могут содержать символ десятичной точки и/или
необязательную экспоненту со знаком, которая начинается с символа e
или E. Если в записи числа обнаруживается точка или экспонента,
интерпретатор Python создает объект вещественного числа
и использует вещественную (не целочисленную) математику, когда такой
объект участвует в выражении. Правила записи вещественных чисел
в языке Python ничем не отличаются от правил записи чисел типа double
в языке C и потому вещественные числа в языке Python обеспечивают
такую же точность представления значений, как и в языке C


 Целые числа в Python 3.0: один тип

 В Python 3.0 обычные и длинные целые числа были объединены в один тип
целых чисел, который автоматически поддерживает неограниченную точность,
как длинные целые в Python 2.6. По этой причине теперь не требуется
завершать литералы целых чисел символом l или L, и при выводе целых
чисел этот символ никогда не выводится. Кроме того, для большинства
программ это изменение в языке никак не скажется на
их работоспособности, при условии, что они явно не проверяют числа
на принадлежность к типу длинных целых, имеющемуся в версии 2.6.


 Шестнадцатеричные, восьмеричные и двоичные литералы

 Целые числа могут записываться как десятичные (по основанию 10),
шестнадцатеричные (по основанию 16), восьмеричные (по основанию 8)
и двоичные (по основанию 2). Шестнадцатеричные литералы начинаются
с комбинации символов 0x или 0X, вслед за которыми следуют
шестнадцатеричные цифры (0-9 и A-F). Шестнадцатеричные цифры могут
вводиться как в нижнем, так и в верхнем регистре. Литералы восьмеричных
чисел начинаются с комбинации символов 0o или 0O (ноль и следующий
за ним символ "о" в верхнем или нижнем регистре), вслед за которыми
следуют восьмеричные цифры (0-7). В Python 2.6 и в более ранних версиях
восьмеричные литералы могут начинаться только с символа 0
(без буквы «o»), но в версии 3.0 такая форма записи считается
недопустимой (при использовании прежней формы записи восьмеричные числа
легко можно перепутать с десятичными, поэтому была принята
новая форма записи, когда восьмеричные литералы начинаются
с комбинации символов 0o). Двоичные литералы впервые появились
в версиях 2.6 и 3.0, они начинаются с комбинации символов 0b или 0B,
вслед за которыми следуют двоичные цифры (0 – 1)

 Примечательно, что все эти литералы создают объекты целых чисел –
они являются всего лишь альтернативными формами записи значений. Для
преобразования целого числа в строку с представлением в любой из трех
систем счисления можно использовать встроенные функции hex(I), oct(I)
и bin(I), кроме того, с помощью функции int(str, base) можно
преобразовать строку в целое число с учетом указанного основания
системы счисления.


 Комплексные числа

 Литералы комплексных чисел в языке Python записываются в формате
действительная_часть+мнимая_часть, где мнимая_часть завершается
символом j или J. С технической точки зрения, действительная_часть
является необязательной, поэтому мнимая_часть может указываться
без действительной составляющей. Во внутреннем представлении
комплексное число реализовано в виде двух вещественных чисел,
но при работе с числами этого типа используется математика
комплексных чисел. Комплексные числа могут также создаваться
с помощью встроенной функции complex(real, imag).


 Литералы других числовых типов

 Как мы увидим ниже в этой главе, существуют и другие числовые типы,
не включенные в табл. 5.1. Объекты некоторых из этих типов создаются
с помощью функций, объявленных в импортируемых модулях (например,
вещественные числа с фиксированной точностью и рациональные числа),
другие имеют свой синтаксис литералов (например, множества).


 Встроенные числовые операции и расширения

 Помимо числовых литералов, которые приводятся в табл. 5.1, язык Python
предоставляет набор операций для работы с числовыми объектами:

  Операторы выражений
  +, -, *, /, >>, **, & и другие.

  Встроенные математические функции
  pow, abs , round, int, hex, bin и другие.

  Вспомогательные модули
  random, math и другие.

 По мере продвижения мы встретимся со всеми этими компонентами.

 Для работы с числами в основном используются выражения, встроенные
функции и модули, при этом числа имеют ряд собственных, специфических
методов, с которыми мы также встретимся в этой главе.
Вещественные числа, например, имеют метод as_integer_ratio,
который удобно использовать для преобразования вещественного числа
в рациональное, а также метод is_integer method, который проверяет –
можно ли представить вещественное число как целое значение.
Целые числа тоже обладают различными атрибутами, включая новый метод
bit_length, который появился в версии Python 3.1, – он возвращает
количество битов, необходимых для представления значения числа.
Кроме того, множества, отчасти являясь коллекциями, а отчасти числами,
поддерживают собственные методы и операторы выражений.

 Так как выражения наиболее часто используются при работе с числами,
мы рассмотрим их в первую очередь.


 Операторы выражений

 Пожалуй, самой фундаментальной возможностью обработки чисел являются
выражения: комбинации чисел (или других объектов) и операторов,
которые возвращают значения при выполнении интерпретатором Python.
Выражения в языке Python записываются с использованием обычной
математической нотации и символов операторов. Например, сложение
двух чисел X и Y записывается в виде выражения X + Y, которое
предписывает интерпретатору Python применить оператор + к значениям
с именами X и Y. Результатом выражения X + Y будет другой
числовой объект.

  Операторы                     Описание
  yield x                       Поддержка протокола send
                                в функциях-генераторах

  lambda args: expression       Создает анонимную функцию

  x if y else z                 Трехместный оператор выбора
                                (значение x вычисляется,
                                только если значение y истинно)

  x or y                        Логическая операция ИЛИ
                                (значение y вычисляется,
                                только если значение x ложно)

  x and y                       Логический оператор И
                                (значение y вычисляется,
                                только если значение x истинно)

  not x                         Логическое отрицание

  x in y, x not in y            Проверка на вхождение
                                (для итерируемых объектов и множеств)

  x is y, x is not y            Проверка идентичности объектов

  x < y, x <= y, x > y,         Операторы сравнения, проверка на
  x >= y                        подмножество и надмножество

  x == y, x != y                Операторы проверки на равенство

  x | y                         Битовая операция ИЛИ,
                                объединение множеств

  x ^ y                         Битовая операция «исключающее ИЛИ»
                                (XOR), симметрическая разность множеств

  x & y                         Битовая операция И, пересечение множеств

  x << y, x >> y                Сдвиг значения x влево или вправо
                                на y битов

  x, + y                        Сложение, конкатенация

  x – y                         Вычитание, разность множеств

  x * y                         Умножение, повторение

  x % y                         Остаток, формат

  x / y, x // y                 Деление: истинное и с округлением вниз

  -x, +x                        Унарный знак «минус», тождественность

  ~x                            Битовая операция НЕ (инверсия)

  x ** y                        Возведение в степень

  x[i]                          Индексация (в последовательностях,
                                отображениях и других объектах)

  x[i:j:k]                      Извлечение среза

  x(...)                        Вызов (функций, классов
                                и других вызываемых объектов)

  x.attr                        Обращение к атрибуту

  (...)                         Кортеж, подвыражение,
                                выражение-генератор

  [...]                         Список, генератор списков

  {...}                         Словарь, множество,
                                генератор словарей и множеств

 Инструкция yield в функциях-генераторах возвращает аргументы функции
send(...); оператор выбора if/else является краткой формой записи
многострочной инструкции if. Если инструкция yield – не единственное,
что находится справа от оператора присваивания, она должна
заключаться в круглые скобки.

 Операторы отношений могут объединяться в цепочки: например X < Y < Z
воспроизводит тот же результат, что и конструкция X < Y and Y < Z.
Подробности приводятся в разделе «Операции сравнения:
простые и составные», ниже.

 В последних версиях Python выражение извлечения среза X[I:J:K] является
эквивалентом операции индексирования с применением объекта среза:
X[slice(I, J, K)].

 В Python 3.0 не допускается сравнивать несовместимые типы,
не являющиеся числами, а попытка такого сравнения вызывает исключение.

 Операторы отношений для словарей также больше не поддерживаются
в Python 3.0 (однако поддерживается операция проверки на равенство).
Один из возможных способов сравнивания словарей заключается
в использовании функции sorted(dict.items()).


 Смешанные операторы и определение старшинства операторов

 Как и в большинстве других языков программирования, в языке Python
можно создавать сложные выражения, объединяя несколько операторов
из табл. в одной инструкции. Например, вычисление суммы двух
произведений можно записать следующим образом:

  A * B + C * D

 Как в этом случае интерпретатор узнает, какие операторы должны
выполняться в первую очередь? Ответ на этот вопрос заключается
в старшинстве операторов. Когда интерпретатор Python встречает
выражение, содержащее более одного оператора, он делит его
на отдельные части в соответствии с правилами старшинства
и определяет порядок вычисления этих частей выражения. В табл.
операторы расположены в порядке возрастания старшинства:

 Чем выше приоритет оператора, тем ниже он находится в таблице, и тем
раньше он выполняется в смешанных выражениях.

 Если в выражении имеется несколько операторов, находящихся в табл.
в одной строке, они выполняются в направлении слева направо
(исключение составляет оператор возведения в степень – эти операторы
выполняются справа налево, и операторы отношений, которые объединяются
в направлении слева направо).

 Например, если вы запишете выражение X + Y * Z, интерпретатор Python
сначала выполнит умножение (Y * Z), а затем прибавит результат
к значению X, потому что оператор * имеет более высокий приоритет
(в табл. он находится ниже), чем оператор +. Точно так же в первом
примере этого раздела сначала будут найдены произведения
(A * B и C * D), а затем будет выполнено сложение.


 Группировка подвыражений с помощью круглых скобок

 Вы можете навсегда забыть о старшинстве операторов, если будете
группировать части выражений с помощью круглых скобок. Когда часть
выражения заключается в круглые скобки, они отменяют правила старшинства
операторов – Python всегда в первую очередь вычисляет подвыражения
в круглых скобках, а затем использует их результаты в объемлющем
выражении. Например, выражение X + Y * Z можно записать одним
из следующих способов, чтобы вынудить Python произвести вычисления
в требуемом порядке:

(X + Y) * Z
X + (Y * Z)

 В первом случае сначала будет выполнено сложение значений X и Y,
потому что это подвыражение заключено в круглые скобки. Во втором случае
первой будет выполнена операция умножения (точно так же, как если бы
скобки вообще отсутствовали). Вообще говоря, использование
круглых скобок в сложных выражениях можно только приветствовать –
они не только определяют порядок выполнения вычислений, но и повышают
удобочитаемость.


 Смешивание типов и их преобразование

 Помимо смешивания операторов вы можете также смешивать различные
числовые типы. Допустим, что требуется найти сумму целого
и вещественного числа:

40 + 3.14

 Но это влечет за собой другой вопрос: какого типа будет результат –
целое число или вещественное число? Ответ прост, особенно для тех,
кто уже имеет опыт работы с любыми другими языками программирования:
в выражениях, где участвуют значения различных типов, интерпретатор
сначала выполняет преобразование типов операндов к типу самого сложного
операнда, а потом применяет математику, специфичную для этого типа.

 Когда в выражении участвуют целое число и вещественное число,
как в предыдущем примере, то целое число сначала будет преобразовано
в вещественное число, а затем будет выполнена операция из математики
вещественных чисел, что дает в результате вещественное число.
Точно так же, когда один из операндов в выражении является
комплексным числом, другой операнд будет преобразован в комплексное
число, и выражение вернет в результате также комплексное число.

 Существует возможность принудительного преобразования типов с помощью
встроенных функций:

\>>> int(3.1415)  # Усекает дробную часть вещественного числа
3

\>>> float(3)  # Преобразует целое число в вещественное
3.0

 Однако в обычных ситуациях делать это не приходится, потому что Python
автоматически выполняет преобразование типов и тип результата,
как правило, соответствует вашим ожиданиям.

 Кроме того, имейте в виду, что все эти преобразования производятся
только при смешивании числовых типов (то есть целых
и вещественных чисел) в выражении, включая выражения, выполняющие
математические операции и операции сравнения. Вообще, Python
не выполняет автоматическое преобразование других типов. Например,
попытка выполнить операцию сложения строки и числа приведет
к появлению ошибки, если вы вручную не выполните преобразование
типа одного из операндов.


 Обзор: перегрузка операторов и полиморфизм

 Несмотря на то, что сейчас в центре нашего внимания находятся
встроенные числа, вы должны знать, что в языке Python существует
возможность выполнить (то есть реализовать) перегрузку любого оператора
с помощью классов Python или расширений на языке C для работы
с создаваемыми объектами. Например, как будет показано позже, объекты,
реализованные в виде классов, могут участвовать в операции сложения,
индексироваться с помощью выражения [i] и так далее.

 Кроме того, Python сам автоматически перегружает некоторые операторы,
чтобы с их помощью можно было выполнять различные действия,
в зависимости от типа встроенных объектов. Например, оператор +
выполняет операцию сложения, когда применяется к числам, но когда
он применяется к последовательностям, таким как строки или списки,
он выполняет операцию конкатенации. В действительности оператор + может
выполнять любые действия, когда применяется к объектам, которые вы
определяете с помощью классов.

 Как было показано в предыдущей главе, эта особенность обычно называется
полиморфизмом – этот термин означает, что выполняемая операция зависит
от типов объектов-операндов, над которыми она выполняется.
Мы еще вернемся к этому понятию в главе 16, когда будем рассматривать
функции, потому что в этом контексте суть полиморфизма становится
более очевидной.


 Числа в действии


 Переменные и простые выражения

 Прежде всего, рассмотрим основные арифметические операции.
Для начала присвоим двум переменным (a и b) целочисленные значения,
чтобы потом использовать их в более сложных выражениях. Переменные –
это всего лишь имена, создаваемые в языке Python, которые используются
для обозначения информации в программах. Об этом мы будем говорить
более подробно в следующей главе, а пока вы должны знать,
что в языке Python:

  Переменные создаются с помощью операции присваивания.

  При вычислении выражений имена переменных замещаются их значениями.

  Прежде чем переменная сможет участвовать в выражениях,
 ей должно быть присвоено значение.

  Переменные являются ссылками на объекты
 и никогда не объявляются заранее.

 Другими словами, следующие операции присваивания автоматически
приводят к созданию переменных a и b:

% python
\>>> a = 3 # Создается имя
\>>> b = 4

 Здесь я также использовал комментарий. Вспомните, что в программном
коде на языке Python текст, следующий за символом #, считается
комментарием и игнорируется интерпретатором. Комментарии – это один
из способов описать программный код на удобном для восприятия языке.
Поскольку программный код, который пишется в ходе интерактивного сеанса,
является временным, вам не требуется писать комментарии, я же буду
добавлять их в примеры, чтобы объяснять работу программного кода.

 В настоящий момент переменные a и b все еще имеют значения 3 и 4
соответственно. Когда переменные, подобные этим, участвуют в выражении,
они замещаются их значениями, а при работе в интерактивном режиме
результат вычисления выражения тут же выводится на экран:

\>>> a + 1, a - 1  # Сложение (3 + 1), вычитание (3 - 1)
(4, 2)
\>>> b * 3, b / 2  # Умножение (4 * 3), деление (4 / 2)
(12, 2.0)
\>>> a % 2, b ** 2  # Деление по модулю (остаток), возведение в степень
(1, 16)
\>>> 2 + 4.0, 2.0 ** b  # Смешивание типов, выполняется преобразование
(6.0, 16.0)

 С технической точки зрения результатами этих инструкций являются
кортежи, состоящие из двух значений, потому что вводимые строки содержат
по два выражения, разделенные запятыми. Именно по этой причине
результаты отображаются в круглых скобках. Следует заметить,
что эти выражения выполняются без ошибок потому, что ранее переменным
a и b были присвоены значения. Если использовать переменную,
которой еще не было присвоено значение, Python выведет сообщение
об ошибке:

\>>> c * 2
Traceback (most recent call last):
File “<stdin>”, line 1, in ?
NameError: name ‘c’ is not defined

 В языке Python от вас не требуется заранее объявлять переменные,
но прежде чем их можно будет использовать, им должны быть присвоены
некоторые значения. На практике это означает, что перед тем как
к счетчикам можно будет прибавлять некоторые значения,
их необходимо инициализировать нулевым значением; прежде чем к спискам
можно будет добавлять новые элементы, их необходимо инициализировать
пустыми списками, и так далее. Ниже приводятся два более сложных
выражения, чтобы проиллюстрировать порядок выполнения операторов
и производимые преобразования:

\>>> b / 2 + a  # То же, что и ((4 / 2) + 3)
5.0
\>>> print(b / (2.0 + a))  # То же, что и (4 / (2.0 + 3))
0.8

 В первом выражении отсутствуют круглые скобки, поэтому интерпретатор
Python автоматически группирует компоненты выражения в соответствии
с правилами определения старшинства – оператор / находится ниже в табл.,
чем оператор +, поэтому его приоритет считается выше, и он выполняется
первым. Результат вычисляется так, как если бы выражение включало
скобки, как показано в комментарии.

 В Python 3.0 будет выполнена операция истинного деления и получен
результат, как показано в примере. Если в версии 3.0 потребуется
выполнить целочисленное деление, выражение можно записать так:
b // 2 + a.

 Во втором выражении круглые скобки окружают операцию сложения, чтобы
вынудить интерпретатор выполнить ее в первую очередь
(то есть до операции /). Кроме того, один из операндов является
вещественным числом, т. к. в нем присутствует десятичная точка:
2.0. Вследствие такого смешения типов перед выполнением операции
сложения Python преобразует целое число, на которое ссылается имя a,
в вещественное число (3.0). Если бы все числа в этом выражении были
целыми, то операция целочисленного деления (4 / 5) в Python 2.6 вернула
бы число 0, но в Python 3.0 она возвращает вещественное число 0.8


 Форматы отображения чисел

 Обратите внимание: в последнем примере была использована инструкция
print. Без этой инструкции результат мог бы показаться немного странным:

\>>> b / (2.0 + a)  # Автоматический вывод: выводится большее число цифр
0.80000000000000004
\>>> print(b / (2.0 + a))  # Инструкция print отбрасывает лишние цифры
0.8

 Причина появления такого немного странного результата кроется
в ограничениях аппаратных средств, реализующих вещественную математику,
и в невозможности обеспечить точное представление некоторых значений.
Обсуждение аппаратной архитектуры компьютера выходит далеко
за рамки этой книги, тем не менее, я замечу, что все цифры
в первом результате действительно присутствуют в аппаратной
части компьютера, выполняющей операции над числами с плавающей точкой,
просто вы не привыкли видеть их. Я использовал этот пример,
чтобы продемонстрировать различия в форматах отображения чисел –
при автоматическом выводе результатов в ходе интерактивного сеанса
отображается больше цифр, чем при использовании инструкции print.
Если вы не желаете, чтобы выводились лишние цифры, используйте
инструкцию print.

 Однако надо заметить, что не всегда значения отображаются
с таким большим числом цифр:

\>>> 1 / 2.0
0.5

 и что кроме применения функции print и автоматического вывода
результатов существуют и другие способы отображения чисел:

\>>> num = 1 / 3.0
\>>> num  # Автоматический вывод
0.33333333333333331
\>>> print num  # Инструкция print выполняет округление
0.333333333333

\>>> “%e” % num  # Вывод с использованием выражения форматирования строк
‘3.333333e-001’
\>>> ‘%4.2f’ % num  # Альтернативный формат представления
‘0.33’              # вещественных чисел
\>>> ‘{0:4.2f}’.format(num)  # Метод форматирования строк
‘0.33’

 В последних трех случаях была использована операция форматирования
строк – инструмент, обладающий гибкой возможностью определять формат
представления, но об этом мы поговорим в главе 7, когда займемся
исследованием строк. Результатом этой операции обычно являются строки,
предназначенные для вывода.


 Форматы представления repr и str

 С технической точки зрения различие между функцией автоматического
вывода в интерактивной оболочке и инструкцией print соответствует
различию между встроенными функциями repr и str:

\>>> num = 1 / 3
\>>> repr(num)  # Используется для автоматического вывода:
                # в форме как есть
‘0.33333333333333331’
\>>> str(num)  # Используется функцией print: дружественная форма
‘0.333333333333’

 Обе функции преобразуют произвольные объекты в их строковое
представление: repr (и функция автоматического вывода в интерактивной
оболочке) выводит результаты в том виде, в каком они были бы указаны
в программном коде; str (и операция print) обычно выполняет
реобразование значения в более дружественное представление. Некоторые
объекты имеют оба варианта строкового представления: str –
для использования в обычных случаях и repr – для вывода
в расширенном варианте.

 Помимо операции получения строкового представления произвольных
объектов имя str так же является именем типа строковых данных и может
вызываться с названием кодировки в качестве аргумента для преобразования
строк байтов в строки Юникода.


 Операции сравнения: простые и составные

 До сих пор мы имели дело со стандартными числовыми операциями (такими
как сложение или умножение), но, кроме того, числа можно сравнивать.
Обычные операторы сравнения действуют именно так, как и можно было бы
ожидать, – они сравнивают значения операндов и возвращают логический
результат (который, как правило, проверяется объемлющей инструкцией):

\>>> 1 < 2  # Меньше чем
True
\>>> 2.0 >= 1  # Больше или равно: число 1 преобразуется 1.0
True
\>>> 2.0 == 2.0  # Проверка на равенство значений
True
\>>> 2.0 != 2.0  # Проверка на неравенство значений
False

 Обратите внимание, смешивание разнотипных операндов допускается,
только если оба они принадлежат к числовым типам. Во второй инструкции,
в примере выше, интерпретатор выполняет сравнивание с позиции более
сложного типа, преобразуя целое число в вещественное.

 Самое интересное, что Python позволяет составлять цепочки из нескольких
операторов сравнения, для выполнения проверки на принадлежность
диапазону значений. Цепочка операторов сравнения является, своего рода,
сокращенной формой записи более длинных логических выражений.
Проще говоря, Python позволяет объединить несколько операций сравнения,
чтобы реализовать проверку на вхождение в диапазон значений.
Выражение (A < B < C), например, проверяет, входит ли значение B
в диапазон от A до C, и является эквивалентом логическому выражению
(A < B and B < C), но выглядит гораздо понятнее (и короче). Например,
допустим, что в программе имеются следующие инструкции присваивания:

\>>> X = 2
\>>> Y = 4
\>>> Z = 6

 Следующие два выражения дают совершенно идентичный результат,
но первое из них короче и, вполне возможно, выполняется немного быстрее,
потому что интерпретатору приходится вычислять значение Y
только один раз:

\>>> X < Y < Z  # Составная операция сравнения: принадлежность диапазону
True
\>>> X < Y and Y < Z
True

 То же самое относится и к выражениям с ложным результатом; кроме того,
допускается составлять цепочки произвольной длины:

\>>> X < Y > Z
False
\>>> X < Y and Y > Z
False
\>>> 1 < 2 < 3.0 < 4
True
]>>> 1 > 2 > 3.0 > 4
False

 В цепочках сравнений можно использовать и другие операторы сравнения.
При этом получающиеся результаты могут на первый взгляд не иметь смысла,
если не попытаться вычислить выражение тем же способом, как это делает
интерпретатор Python. Например, следующее выражение ложно уже потому,
что число 1 не равно числу 2:

\>>> 1 == 2 < 3  # То же, что и: 1 == 2 and 2 < 3
False  #  Но не то же самое, что и: False < 3 (что означает утверждение
#         0 < 3, которое истинно)

 Интерпретатор не сравнивает значение False (результат операции 1 == 2)
с числом 3 – с технической точки зрения это соответствовало бы выражению
0 < 3, которое должно было бы вернуть True (как мы увидим ниже,
в этой же главе, True и False – это всего лишь числа 1 и 0,
расширенные приписанными им свойствами).


 Деление: классическое, с округлением вниз и истинное

 X / Y

 Классическое и истинное деление. В Python 3.0 этот оператор выполняет
операцию истинного деления, которая всегда сохраняет дробную часть
независимо от типов операндов.

 X // Y

 Деление с округлением вниз. Этот оператор впервые появился в Python 2.2
и доступен в обеих версиях Python, 2.6 и 3.0. Он всегда отсекает дробную
часть, округляя результат до ближайшего наименьшего целого независимо
от типов операндов.

 Истинное деление было добавлено по той причине, что в текущей модели
классического деления результаты зависят от типов операндов
и с трудом могут быть оценены заранее в языке программирования
с динамической типизацией, каким является Python. Операция к
лассического деления была ликвидирована в Python 3.0
из-за этого ограничения – в версии 3.0 операторы / и // реализуют
истинное деление и деление с округлением вниз.

 Подводя итоги:

  В версии 3.0 оператор / всегда выполняет операцию истинного деления,
 возвращает вещественный результат, включающий дробную часть,
 независимо от типов операндов. Оператор // выполняет деление
 с округлением вниз, усекая дробную часть и возвращая целочисленный
 результат, если оба операнда являются целыми числами, и вещественный –
 если хотя бы один операнд является вещественным числом.

 Ниже эти два оператора демонстрируются в действии в версиях 3.0 и 2.6:

C:\misc> C:\Python30\python
\>>>
\>>> 10 / 4  # Изменился в версии 3.0: сохраняет дробную часть
2.5
\>>> 10 // 4  # В версии 3.0 действует так же: усекает дробную часть
2
\>>> 10 / 4.0  # В версии 3.0 действует так же: сохраняет дробную часть
2.5
\>>> 10 // 4.0  # В версии 3.0 действует так же: округляет вниз
2.0

C:\misc> C:\Python26\python

\>>> 10 / 4
2
\>>> 10 // 4
2
\>>> 10 / 4.0
2.5
\>>> 10 // 4.0
2.0

 Обратите внимание, что в версии 3.0 тип результата операции //
по-прежнему зависит от типов операндов: если хотя бы один из операндов
является вещественным числом, результат также будет вещественным числом;
в противном случае результат будет целым числом. Несмотря на то,
что это может показаться похожим на поведение оператора /, зависящее от
типа операндов, в версиях 2.X, которое послужило побудительной причиной
его изменения в версии 3.0, нужно признать, что тип возвращаемого
значения является гораздо менее существенным – в сравнении с разницей
в самих возвращаемых значениях. Кроме того, оператор // был сохранен
с целью обеспечения обратной совместимости для программ, которые
используют операцию целочисленного деления с усечением
(она используется намного чаще, чем можно было бы подумать),
которая должна возвращать целочисленный результат, когда оба операнда
являются целыми числами.


 Округление вниз и усечение дробной части

 Существует один очень тонкий момент: оператор // обычно называют
оператором деления с усечением, но более точно было бы называть его о
ператором деления с округлением результата вниз – он округляет результат
до ближайшего меньшего целого значения, то есть до целого числа,
расположенного ниже истинного результата. Округление вниз – это совсем
не то же самое, что усечение дробной части, – это обстоятельство
приобретает значение при работе с отрицательными числами. Разницу можно
наглядно продемонстрировать, обратившись к модулю math
(прежде чем использовать модуль, его необходимо импортировать,
но подробнее об этом мы поговорим позже):

\>>> import math
\>>> math.floor(2.5)
2
\>>> math.floor(-2.5)
-3
\>>> math.trunc(2.5)
2
\>>> math.trunc(-2.5)
-2

 При выполнении операции деления в действительности усечение выполняется
только в случае положительного результата, поскольку для положительных
чисел усечение и округление вниз – суть одно и то же; в случае
отрицательного результата выполняется округление вниз
(в действительности и в том и в другом случае выполняется
округление вниз, но в случае положительных чисел округление вниз дает
тот же эффект, что и усечение дробной части). Ниже приводятся примеры
деления в версии 3.0:

C:\misc> c:\python30\python
\>>> 5 / 2, 5 / -2
(2.5, -2.5)
\>>> 5 // 2, 5 // -2  # Округление вниз: результат 2.5 округляется до 2,
(2, -3)  # а -2.5 округляется до -3
\>>> 5 / 2.0, 5 / -2.0
(2.5, -2.5)
\>>> 5 // 2.0, 5 // -2.0  # То же относится и к вещественному делению,
(2.0, -3.0)  # только результат имеет вещественный тип

 Если требуется реализовать усечение дробной части независимо от знака,
результат вещественного деления всегда можно передать функции math.trunc
независимо от используемой версии Python (кроме того, взгляните
на функцию round, которая обладает сходной функциональностью):

C:\misc> c:\python30\python
\>>> import math
\>>> 5 / -2  # Сохранит дробную часть
-2.5
\>>> 5 // -2  # Округлит результат вниз
-3
\>>> math.trunc(5 / -2)  # Вместо округления будет выполнено усечение
-2


 Почему усечение так важно?

 Для тех, кто использует Python 3.0, ниже приводится пример,
позволяющий понять принцип действия операторов деления:

\>>> (5 / 2), (5 / 2.0), (5 / -2.0), (5 / -2)  # Истинное деление
(2.5, 2.5, -2.5, -2.5)
\>>> (5 // 2), (5 // 2.0), (5 // -2.0), (5 // -2)  # Деление
(2, 2.0, -3.0, -3)                                 # с округлением вниз
\>>> (9 / 3), (9.0 / 3), (9 // 3), (9 // 3.0)  # Оба оператора
(3.0, 3.0, 3, 3.0)

 Хотя это еще и не проявилось в полной мере, тем не менее, можно
предположить, что такое поведение оператора / в версии 3.0 может
отрицательно сказаться на правильной работе большого числа программ.
Благодаря опыту, приобретенному при работе с языком C,
многие программисты интуитивно полагаются на то, что операция деления
целых чисел будет выполнена с усечением, и пройдет какое-то время,
прежде чем они научатся пользоваться оператором // в таких случаях.
"""

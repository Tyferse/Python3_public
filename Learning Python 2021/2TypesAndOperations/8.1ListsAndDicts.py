"""
 Списки и словари

 Списки

 Следующая остановка в нашем путешествии по встроенным объектам языка
Python называется список. Списки – это самые гибкий тип упорядоченных
коллекций в языке Python. В отличие от строк списки могут содержать
объекты любых типов: числа, строки и даже другие списки. Кроме того,
в отличие от строк, списки могут изменяться непосредственно, с помощью
операции присваивания по смещениям и срезам, с помощью методов списков,
с использованием инструкций удаления и другими способами –
списки являются изменяемыми объектами.

 Списки в языке Python реализуют практически все необходимое для работы
с коллекциями данных, что вам пришлось бы писать вручную
при использовании низкоуровневого языка программирования,
такого как язык C. Ниже приводятся основные свойства списков.
Списки в языке Python – это:

 Упорядоченные коллекции объектов произвольных типов

  С функциональной точки зрения, списки – это лишь место, в котором
 собраны другие объекты, поэтому их можно также рассматривать
 как группы. Кроме того, списки обеспечивают позиционное упорядочение
 элементов слева направо (то есть они являются последовательностями).

 Доступ к элементам по смещению

  Так же как и в случае со строками, вы можете использовать операцию
 индексирования для извлечения отдельных объектов из списка по их
 смещениям. Поскольку элементы в списках упорядочены по их
 местоположению, можно также выполнять такие действия, как извлечение
 срезов и конкатенация.

 Переменная длина, гетерогенность и произвольное число
уровней вложенности

  В отличие от строк, списки могут увеличиваться и уменьшаться
 непосредственно (их длина может изменяться) и могут содержать не только
 односимвольные строки, но и любые другие объекты (списки гетерогенны).
 Списки могут содержать другие сложные объекты и поддерживают
 возможность создания произвольного числа уровней вложенности, поэтому
 имеется возможность создавать списки списков из списков и так далее.

 Относятся к категории изменяемых объектов

  В терминах категорий типов списки могут изменяться непосредственно
 (являются изменяемыми объектами) и поддерживают все операции над
 последовательностями, которые поддерживаются и строками, такие как
 индексирование, извлечение срезов и конкатенация. Операции над
 последовательностями одинаковым образом работают как в случае списков,
 так и в случае строк, единственное отличие – при применении операций
 над последовательностями (таких, как конкатенация и извлечение среза)
 к спискам возвращается новый список, а не новая строка. Кроме того,
 т. к. списки являются изменяемыми объектами, они поддерживают также
 операции, которые не поддерживаются строками (такие, как операции
 удаления и присваивания по индексам, изменяющие список
 непосредственно).

 Массивы ссылок на объекты

 Формально списки в языке Python могут содержать ноль или более ссылок
 на другие объекты. Списки чем-то напоминают массивы указателей
 (адресов). Извлечение элемента из списка в языке Python выполняется
 так же быстро, как извлечение элемента массива в языке C.
 В действительности списки – это самые настоящие массивы языка C,
 реализованные в интерпретаторе Python, а не связанные структуры данных.
 Как мы узнали в главе 6, всякий раз, когда используется ссылка
 на объект, интерпретатор разыменовывает ее, поэтому ваши программы
 всегда будут иметь дело только с объектами. Всякий раз, когда
 выполняется присваивание объекта элементу какой-либо структуры или
 имени переменной, интерпретатор Pytho сохраняет ссылку на этот объект,
 а не его копию (за исключением, когда явно запрашивается выполнение
 операции копирования).

  Операция                     Интерпретация
  L = []                       Пустой список

  L = [0, 1, 2, 3]             Четыре элемента с индексами 0..3

  L = [‘abc’, [‘def’, ghi’]]   Вложенные списки

  L = list(‘spam’)             Создание списка из итерируемого объекта.

  L = list(range(-4, 4))       Создание списка из непрерывной
                               последовательности целых чисел

  L[i]                         Индекс,
  L[i][j]                      индекс индекса,
  L[i:j]                       срез,
  len(L)                       длина

  L1 + L2                      Конкатенация,
  L * 3                        дублирование

  for x in L: print(x)         Обход в цикле,
  3 in L                       проверка вхождения

  L.append(4)                  Методы: добавление элементов в список
  L.extend([5,6,7])
  L.insert(I, X)

  L.index(1)                   Методы: поиск
  L.count()

  L.sort()                     Методы: сортировка, изменение порядка
  L.reverse()                  следования элементов на обратный

  del L[k]                     Уменьшение списка
  del L[i:j]
  L.pop()
  L.remove(2)
  L[i:j] = []

  L[i] = 1                     Присваивание по индексу,
  L[i:j] = [4,5,6]             присваивание срезу

  L = [x**2 for x in range(5)] Генераторы списков и отображение
  list(map(ord, ‘spam’))

 Многие операции из табл. 8.1 должны выглядеть для вас знакомыми,
так как они являются теми же самыми операциями над последовательностями,
которые мы применяли к строкам, – индексирование, конкатенация, обход
элементов в цикле и так далее. Кроме того, списки поддерживают
специфические для своего типа методы (такие, как сортировка,
перестановка элементов в обратном порядке, добавление элементов
в конец списка и так далее), а также операции непосредственного
изменения списка (удаление элементов, присваивание по индексам
и срезам и так далее).
Списки получили эти операции потому, что они относятся
к категории объектов изменяемых типов.


 Списки в действии

 Базовые операции над списками

 Поскольку списки являются последовательностями, они, как и строки,
поддерживают операторы + и * – для списков они так же соответствуют
операции конкатенации и повторения, но в результате получается новый
список, а не строка:

% python
\>>> len([1, 2, 3])  # Длина
3
\>>> [1, 2, 3] + [4, 5, 6]  # Конкатенация
[1, 2, 3, 4, 5, 6]
\>>> [‘Ni!’] * 4  # Повторение
[‘Ni!’, ‘Ni!’, ‘Ni!’, ‘Ni!’]

 Несмотря на то что оператор + со списками работает точно так же,
как и со строками, очень важно знать, что с обеих сторон оператора
должны находиться последовательности одного и того же типа, в противном
случае во время работы программы вы получите сообщение об ошибке.

 Например, нельзя выполнить операцию конкатенации для списка и строки,
если предварительно не преобразовать список в строку (используя,
например, функцию str или оператор форматирования %) или строку в список
(с помощью встроенной функцией list):

\>>> str([1, 2]) + “34”  # То же, что и “[1, 2]” + “34”
‘[1, 2]34’
\>>> [1, 2] + list(“34”)  # То же, что и [1, 2] + [“3”, “4”]
[1, 2, ‘3’, ‘4’]


 Итерации по спискам и генераторы списков

 В целом списки могут участвовать во всех операциях над
последовательностями, которые мы применяли к строкам в предыдущей главе,
включая инструменты выполнения итераций:

\>>> 3 in [1, 2, 3]  # Проверка на вхождение
True
\>>> for x in [1, 2, 3]:
... print(x, end=’ ‘)  # Итерации
...
1 2 3

 Подробнее об операции обхода элементов списка в цикле for
и о встроенной функции range мы поговорим в главе 13, потому что они
имеют отношению к синтаксису инструкций. Говоря коротко, оператор цикла
for выбирает элементы последовательности в порядке слева направо
и выполняет одну или более инструкций для каждого из них.

 Последняя строка в табл. представляет генератор списков и вызов
встроенной функции map, которые подробно описываются в главе 14
и расширенное обсуждение которых приводится в главе 20. Как говорилось
в главе 4, генераторы списков – это способ построить новый список,
применяя выражение к каждому элементу последовательности; они являются
близкими родственниками инструкции цикла for.

\>>> res = [c * 4 for c in ‘SPAM’]  # Генератор списков
\>>> res
[‘SSSS’, ‘PPPP’, ‘AAAA’, ‘MMMM’]

 Функционально это выражение эквивалентно циклу for, создающему список
результатов вручную, но, как мы узнаем в следующих главах, генераторы
списков не только имеют более простой синтаксис, но и выполняются
быстрее:

\>>> res = []
\>>> for c in ‘SPAM’:  # Эквивалент генератора списков
... res.append(c * 4)
...
\>>> res
[‘SSSS’, ‘PPPP’, ‘AAAA’, ‘MMMM’]

 Как уже говорилось в главе 4, встроенная функция map выполняет похожие
действия, но применяет к элементам последовательности не выражение,
а функцию, и из полученных результатов создает новый список:

\>>> list(map(abs, [-1, -2, 0, 1, 2]))  # Функция map применяется к
[1, 2, 0, 1, 2]  # последовательности


 Индексы, срезы и матрицы

 Так как списки являются последовательностями, операции доступа
к элементам по индексам и извлечения срезов работают точно так же,
как и в случае со строками. Однако в результате обращения к элементу
по индексу возвращается объект, который расположен по указанному
смещению, а в результате операции извлечения среза всегда возвращается
новый список:

\>>> L = [‘spam’, ‘Spam’, ‘SPAM!’]
\>>> L[2]  # Отсчет смещений начинается с нуля
‘SPAM!’
\>>> L[-2]  # Отрицательное смещение: отсчитывается справа
‘Spam’
\>>> L[1:]  # Операция извлечения среза возвращает разделы списка
[‘Spam’, ‘SPAM!’]

 Здесь следует отметить следующее: поскольку списки (и объекты других
типов) могут быть вложены в другие списки, иногда бывает необходимо
объединять в цепочку несколько индексов, чтобы получить доступ
к элементам на более глубоком уровне вложенности в структуре данных.
Например, один из простейших способов представления матриц (многомерных
массивов) в языке Python заключается в использовании вложенных списков.
Ниже приводится пример двухмерного массива размером 3x3, построенного
на базе списков:

\>>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

 С помощью первого индекса извлекается целая строка
(в действительности вложенный список), а с помощью второго извлекается
элемент этой строки:

\>>> matrix[1]
[4, 5, 6]
\>>> matrix[1][1]
5
\>>> matrix[2][0]
7
\>>> matrix = [[1, 2, 3],
... [4, 5, 6],
... [7, 8, 9]]
\>>> matrix[1][1]
5

 Предыдущий пример демонстрирует, в частности, что определение списка
может при необходимости располагаться в нескольких строках, так как
список ограничен квадратными скобками (подробнее о синтаксисе будет
говориться в следующей части книги). Далее в этой главе будут также
представлены матрицы, реализованные на базе словарей. Кроме того,
для высокопроизводительной работы с числовыми данными упомянутый
в главе 5 модуль NumPy предоставляет другие способы организации матриц.


 Изменение списка

 Списки относятся к категории изменяемых объектов, поэтому они
поддерживают операции, которые изменяют сам список непосредственно.
То есть все операции, представленные в этом разделе, изменяют сам список
объектов и не приводят к необходимости создавать новую копию, как это
было в случае со строками. В языке Python приходится иметь дело только
со ссылками на объекты, что обусловливает существенные различия между
непосредственным изменением объекта и созданием нового объекта –
как обсуждалось в главе 6, непосредственное изменение объекта может
отражаться более чем на одной ссылке.


 Присваивание по индексам и срезам

 При использовании списков существует возможность изменять
их содержимое, выполняя присваивание значений элементам (по смещению)
или целым разделам (срезам) списка:

\>>> L = [‘spam’, ‘Spam’, ‘SPAM!’]
\>>> L[1] = ‘eggs’  # Присваивание по индексу элемента
\>>> L
[‘spam’, ‘eggs’, ‘SPAM!’]
\>>> L[0:2] = [‘eat’, ‘more’]  # Присваивание срезу: удаление+вставка
\>>> L  # Элементы 0 и 1 были заменены
[‘eat’, ‘more’, ‘SPAM!’]

 Обе операции присваивания – и отдельному элементу, и срезу –
производятся непосредственно в списке – они изменяют сам список,
а не создают новый список объектов. Операция присваивания по индексу
в языке Python работает практически так же, как в языке C и во многих
других языках программирования: интерпретатор замещает старую ссылку
на объект в указанном смещении на новую.

 Присваивание срезу, последняя операция в предыдущем примере, замещает
целый раздел списка за один прием. Поскольку это довольно сложная
операция, проще будет представить ее, как последовательное выполнение
двух действий:

  1. Удаление. Раздел списка, определяемый слева от оператора =,
 удаляется.

  2. Вставка. Новые элементы, содержащиеся в объекте, расположенном
 справа от оператора =, вставляются в список, начиная с левого края,
 где находился прежний удаленный срез.

 В действительности это не совсем то, что происходит на самом деле,
но это достаточно точно объясняет, почему число вставляемых элементов
не должно соответствовать числу удаляемых элементов. Например,
представим, что список L имеет значение [1,2,3], тогда в результате
операции присваивания L[1:2]=[4,5] будет получен список [1,4,5,3].
Интерпретатор сначала удалит 2 (срез, состоящий из одного элемента),
а затем, начиная с позиции удаленного элемента 2, вставит элементы
4 и 5. Это также объясняет, почему операция L[1:2]=[] в действительности
является операцией удаления – интерпретатор удалит срез (элемент
со смещением 1) и затем вставит пустой список.

 В результате операция присваивания срезу замещает целый раздел списка,
или «столбец», за одно действие. Поскольку длина последовательности
справа от оператора = не должна обязательно соответствовать длине среза,
которому выполняется присваивание, эта операция может использоваться
для замены (посредством перезаписи), расширения (посредством вставки)
или сжатия (посредством удаления) требуемого списка. Это довольно мощная
операция, но, честно говоря, она достаточно редко используется
на практике. Обычно используются более простые способы замены,
вставки и удаления (например, операция конкатенация и методы списков
insert, pop и remove), которые программисты предпочитают использовать
на практике.


 Методы списков

 Как и строки, объекты списков в языке Python поддерживают специфичные
методы, многие из которых изменяют сам список непосредственно:

\>>> L.append(‘please’)  # Вызов метода добавления элемента
\>>> L                   # в конец списка
[‘eat’, ‘more’, ‘SPAM!’, ‘please’]
\>>> L.sort()  # Сортировка элементов списка (‘S’ < ‘e’)
\>>> L
[‘SPAM!’, ‘eat’, ‘more’, ‘please’]

 Методы были представлены в главе 7. Коротко напомню, что методы –
это функции (в действительности – атрибуты, ссылающиеся на функции),
которые связаны с определенным типом объектов. Методы обеспечивают
выполнение специфических операций, например методы списков,
представленные здесь, доступны только для списков.

 Наиболее часто используемым методом, пожалуй, является метод append,
который просто добавляет единственный элемент (ссылку на объект)
в конец списка. В отличие от операции конкатенации, метод append
принимает единственный объект, а не список. По своему действию выражение
L.append(X) похоже на выражение L+[X], но в первом случае изменяется
сам список, а во втором – создается новый список.

 В отличие от операции конкатенации (+), метод append не создает
новый объект, поэтому обычно он выполняется быстрее. Существует
возможность имитировать работу метода append с помощью операции
присваивания срезу: выражение L[len(L):]=[X] соответствует вызову
L.append(X), а выражение L[:0]=[X] соответствует операции добавления
в начало списка. В обоих случаях удаляется пустой сегмент списка
и вставляется элемент X, при этом изменяется сам список L, т
ак же быстро, как при использовании метода append.

 Другой часто используемый метод – метод sort, выполняет
переупорядочивание элементов в самом списке. По умолчанию он использует
стандартные операторы сравнения языка Python (в данном случае
выполняется сравнивание строк) и выполняет сортировку в порядке
возрастания значений.

 Однако существует возможность изменить порядок сортировки с помощью
именованных аргументов – специальных синтаксических конструкций вида
name=value», которые используются в вызовах функций для передачи
параметров настройки по их именам. Именованный аргумент key в вызове
метода sort позволяет определить собственную функцию сравнения,
принимающую единственный аргумент и возвращающую значение, которое будет
использовано в операции сравнения, а именованный аргумент reverse
позволяет выполнить сортировку не в порядке возрастания, а в порядке
убывания:

\>>> L = [‘abc’, ‘ABD’, ‘aBe’]
\>>> L.sort()  # Сортировка с учетом регистра символов
\>>> L
[‘ABD’, ‘aBe’, ‘abc’]
\>>> L = [‘abc’, ‘ABD’, ‘aBe’]
\>>> L.sort(key=str.lower)  # Приведение символов к нижнему регистру
\>>> L
[‘abc’, ‘ABD’, ‘aBe’]
\>>>
\>>> L = [‘abc’, ‘ABD’, ‘aBe’]
\>>> L.sort(key=str.lower, reverse=True)  # Изменяет направление
\>>> L                                    # сортировки
[‘aBe’, ‘ABD’, ‘abc’]

 Аргумент key может также пригодиться при сортировке списков словарей,
когда с его помощью можно указать ключ, по которому будет определяться
положение каждого словаря в отсортированном списке.

 Важно заметить, что методы append и sort изменяют сам объект списка
и не возвращают список в виде результата (точнее говоря, оба метода
возвращают значение None). Если вы написали инструкцию вроде
L=L.append(X), вы не получите измененное значение L (в действительности
вы вообще потеряете ссылку на список) – использование таких атрибутов,
как append и sort, приводит к изменению самого объекта, поэтому нет
никаких причин выполнять повторное присваивание.

 Отчасти из-за этих особенностей методов в последних версиях Python
сортировку можно также выполнить с помощью встроенной функции, которая
способна сортировать не только списки, но и любые другие
последовательности и возвращает новый список с результатом сортировки
(оригинальный список при этом не изменяется):

\>>> L = [‘abc’, ‘ABD’, ‘aBe’]
\>>> sorted(L, key=str.lower, reverse=True)  # Встроенная функция
[‘aBe’, ‘ABD’, ‘abc’]                        # сортировки
\>>> L = [‘abc’, ‘ABD’, ‘aBe’]
\>>> sorted([x.lower() for x in L], reverse=True)  # Элементы
[‘abe’, ‘abd’, ‘abc’]            # предварительно изменяются!

 Обратите внимание, что в последнем примере перед сортировкой с помощью
генератора списков выполняется приведение символов к нижнему регистру,
и значения элементов в получившемся списке отличаются от значений
элементов в оригинальном списке – в противоположность примеру
с использованием именованных аргументов. В последнем примере выполняется
сортировка не оригинального, а временного списка, созданного в процессе
сортировки. По мере продвижения дальше мы познакомимся с ситуациями,
когда встроенная функция sorted может оказаться более удобной,
чем метод sort.

 Как и строки, списки обладают рядом других методов, выполняющих
специализированные операции. Например, метод reverse изменяет порядок
следования элементов в списке на обратный, а методы extend и pop
вставляют несколько элементов в конец списка и удаляют элементы
из конца списка соответственно. Кроме того, существует встроенная
функция reversed, которая во многом напоминает встроенную функцию
sorted, но ее необходимо обертывать в вызов функции list, потому что она
возвращает итератор (подробнее об итераторах мы поговорим позднее):

\>>> L = [1, 2]
\>>> L.extend([3,4,5])  # Добавление нескольких элементов в конец списка
\>>> L
[1, 2, 3, 4, 5]

\>>> L.pop()  # Удаляет и возвращает последний элемент списка
5
\>>> L
[1, 2, 3, 4]

\>>> L.reverse()  # Изменяет порядок следования элементов на обратный
\>>> L
[4, 3, 2, 1]

\>>> list(reversed(L))  # Встроенная функция сортировки в
[1, 2, 3, 4]            # обратном порядке

 В некоторых типах программ метод pop, показанный здесь, часто
используется в паре с методом append для реализации структур данных
типа стек – «последний пришел, первый ушел» (Last-In-First-Out, LIFO).
Конец списка служит вершиной стека:

\>>> L = []
\>>> L.append(1)  # Втолкнуть на стек
\>>> L.append(2)
\>>> L
[1, 2]
\>>> L.pop()  # Вытолкнуть со стека
2
\>>> L
[1]

 Хотя это здесь и не показано, тем не менее метод pop может принимать
необязательное смещение элемента, который удаляется из списка
и возвращается (по умолчанию это последний элемент). Другие методы
списков позволяют удалять элементы с определенными значениями (remove),
вставлять элементы в определенную позицию (insert), отыскивать смещение
элемента по заданному значению (index) и так далее:

\>>> L = [‘spam’, ‘eggs’, ‘ham’]
\>>> L.index(‘eggs’)  # Индекс объекта
1
\>>> L.insert(1, ‘toast’)  # Вставка в требуемую позицию
\>>> L
[‘spam’, ‘toast’, ‘eggs’, ‘ham’]
\>>> L.remove(‘eggs’)  # Удаление элемента с определенным значением
\>>> L
[‘spam’, ‘toast’, ‘ham’]
\>>> L.pop(1)  # Удаление элемента в указанной позиции
‘toast’
\>>> L
[‘spam’, ‘ham’]


 Прочие часто используемые операции над списками

 Так как списки относятся к категории изменяемых объектов, вы можете
использовать инструкцию del для удаления элемента или среза
непосредственно из списка:

\>>> L
[‘SPAM!’, ‘eat’, ‘more’, ‘please’]
\>>> del L[0]  # Удаление одного элемента списка
\>>> L
[‘eat’, ‘more’, ‘please’]
\>>> del L[1:]  # Удаление целого сегмента списка
\>>> L #  То же, что и L[1:] = []
[‘eat’]

 Так как операция присваивания срезу выполняется как удаление и вставка,
можно удалять срезы списка, присваивая им пустой список (L[i:j]=[]) –
интерпретатор сначала удалит срез, определяемый слева от оператора =,
а затем вставит пустой список. С другой стороны, присваивание пустого с
писка по индексу элемента приведет к сохранению ссылки на пустой список
в этом элементе, а не к его удалению:

\>>> L = [‘Already’, ‘got’, ‘one’]
\>>> L[1:] = []
\>>> L
[‘Already’]
\>>> L[0] = []
\>>> L
[[]]
"""

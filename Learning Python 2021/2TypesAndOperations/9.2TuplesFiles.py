"""
 Пересмотренный перечень категорий типов

 Теперь, когда мы познакомились со всеми встроенными базовыми типами
языка Python в действии, давайте завершим наше турне рассмотрением
некоторых общих для них свойств. В табл. 9.3 приводится классификация
всех рассмотренных типов по категориям, которые были введены ранее.
Напомню некоторые положения:

  Над объектами одной категории могут выполняться одни и те же операции,
 например над строками, списками и кортежами можно выполнять операции
 для последовательностей, такие как конкатенация и определение длины.

  Непосредственное изменение допускают только изменяемые объекты
 (списки, словари и множества) – вы не сможете непосредственно изменить
 числа, строки и кортежи.

  Файлы экспортируют только методы, поэтому понятие изменяемости к ним
 по-настоящему неприменимо – хотя они могут изменяться при выполнении
 операции записи, но это не имеет никакого отношения к ограничениям
 типов в языке Python.

  В категорию «Числа» в табл. 9.3 входят все числовые типы: целые
 (длинные целые, в Python 2.6), вещественные, комплексные, фиксированной
 точности и рациональные.

  В категорию «Строки» в табл. 9.3 входят строки типа str, а также bytes
 (в версии 3.0) и unicode (в версии 2.6). Строковый тип bytearray
 версии 3.0 относится к изменяемым типам.

  Множества напоминают словари, в которых ключи не имеют значений.
 Элементы множеств не отображаются на значения и неупорядоченны, поэтому
 множества нельзя отнести ни к отображениям, ни к последовательностям.
 Тип frozenset – это неизменяемая версия типа set.

  Вдобавок к вышесказанному, в версиях Python 2.6 и 3.0 все типы,
 перечисленные в табл. 9.3, обладают методами, которые обычно реализуют
 операции, характерные для определенного типа.

  Тип объектов     Категория            Изменяемый?
  Числа (все)      Числа                Нет

  Строки           Последовательности   Нет

  Списки           Последовательности   Да

  Словари          Отображения          Да

  Кортежи          Последовательности   Нет

  Файлы            Расширения           Понятие неприменимо

  Множества        Множества            Да

  Фиксированные    Множества            Нет
  множества
  (frozenset)

  bytearray (3.0)  Последовательности   Да


 Придется держать в уме: перегрузка операторов

 В шестой части книги мы увидим, что объекты, реализованные с помощью
классов, могут свободно попадать в любую из этих категорий. Например,
если нам потребуется реализовать новый тип объектов последовательностей,
который был бы совместим со встроенными типами последовательностей,
мы могли бы описать класс, который перегружает операторы индексирования
и конкатенации:

class MySequence:
    def __getitem__(self, index):
        # Вызывается при выполнении операции self[index]
    def __add__(self, other):
        # Вызывается при выполнении операции self + other

 и так далее. Точно так же можно было бы создать новый изменяемый
или неизменяемый объект, выборочно реализовав методы, вызываемые
для выполнения операций непосредственного изменения (например,
для выполнения операций присваивания self[index] = value вызывается
метод __setitem__). Существует также возможность выполнять реализацию
новых объектов на других языках программирования, таких как C, в виде
расширений. Чтобы определить выбор между множествами операций
над числами, последовательностями и отображениями, необходимо будет
подставить указатели на функции C в ячейки структуры.


 Гибкость объектов

 В этой части книги были представлены несколько составных типов объектов
(коллекции с компонентами). В общем случае:

  Списки, словари и кортежи могут хранить объекты любых типов.

  Списки, словари и кортежи допускают произвольную вложенность.

  Списки и словари могут динамически увеличиваться и уменьшаться.

 Поскольку составные типы объектов в языке Python поддерживают любые
структуры данных, они прекрасно подходят для представления в программах
данных со сложной структурой. Например, значениями элементов словарей
могут быть списки, которые могут содержать кортежи, которые в свою
очередь могут содержать словари, и так далее. Вложенность может быть
произвольно глубины, какая только потребуется, чтобы смоделировать
структуру обрабатываемых данных.

 Рассмотрим пример с вложенными компонентами. В следующем примере
определяется три вложенных составных объекта последовательностей,
как показано на рис. 9.1. Для обращения к отдельным элементам
допускается использовать столько индексов, сколько потребуется.
В языке Python разыменование индексов производится слева направо
и на каждом шаге извлекается объект на более глубоком уровне.
Структура данных на рис. 9.1 может показаться излишне сложной,
но она иллюстрирует синтаксис, который используется для доступа
к данным:

\>>> L = [‘abc’, [(1, 2), ([3], 4)], 5]
\>>> L[1]
[(1, 2), ([3], 4)]
\>>> L[1][1]
([3], 4)
\>>> L[1][1][0]
[3]
\>>> L[1][1][0][0]
3


 Ссылки и копии

 В главе 6 говорилось, что при выполнении операции присваивания всегда
сохраняется ссылка на объект, а не копия самого объекта. В большинстве
случаев именно это нам и требуется. Однако в процессе выполнения
операций присваивания может быть создано несколько ссылок на один
и тот же объект, поэтому очень важно понимать, что изменения,
произведенные в изменяемом объекте с помощью одной ссылки, отразятся
и на других ссылках, указывающих на этот же объект. Если такой порядок
вещей является нежелательным, необходимо явно сообщить интерпретатору,
чтобы он создал копию объекта.

 Мы изучили это явление в главе 6, но ситуация может обостриться, когда
в игру вступят крупные объекты. Например, в следующем примере создается
список, который присваивается переменной X, затем создается другой
список, включающий ссылку на список X, который присваивается
переменной L. Далее создается словарь D, который содержит еще одну
ссылку на список X:

\>>> X = [1, 2, 3]
\>>> L = [‘a’, X, ‘b’]  # Встроенная ссылка на объект X
\>>> D = {‘x’:X, ‘y’:2}

 В этот момент в программе появляется три ссылки на список, который
был создан первым: из переменной X, из элемента списка, соответствующего
переменной L, и из элемента словаря, соответствующего переменной D.

 Так как списки относятся к категории изменяемых объектов, изменения
в объекте списка, произведенные с помощью любой из трех ссылок,
также отразятся на других двух ссылках:

\>>> X[1] = ‘surprise’  # Изменяет все три ссылки!
\>>> L
[‘a’, [1, ‘surprise’, 3], ‘b’]
\>>> D
{‘x’: [1, ‘surprise’, 3], ‘y’: 2}

 Ссылки – это более высокоуровневый аналог указателей в других языках
программирования. И хотя вы не можете извлечь непосредственное значение
самой ссылки, тем не менее одну и ту же ссылку можно сохранить более
чем в одном месте (в переменных, в списках и так далее). Это полезная
особенность – вы можете передавать крупные объекты между компонентами
программы без выполнения дорогостоящей операции копирования. Однако,
когда действительно необходимо создать копию объекта, вы можете
запросить их:

  Выражение извлечения среза с пустыми пределами (L[:]) создает копию
 последовательности.

  Метод словарей и множеств copy создает копию словаря (D.copy()).

  Некоторые встроенные функции, такие как list, создают копию списка
 (list(L)).

  Модуль copy, входящий в состав стандартной библиотеки, создает полные
 копии объектов.

 Например, предположим, что у нас имеются список и словарь,
и для нас нежелательно изменение их значений посредством других
переменных:

\>>> L = [1,2,3]
\>>> D = {‘a’:1, ‘b’:2}

 Чтобы предотвратить такую возможность, достаточно связать с другими
переменными копии объектов вместо того, чтобы связать с ними сами
объекты:

\>>> A = L[:]  # Вместо A = L (или list(L))
\>>> B = D.copy()  # Вместо B = D (то же относится и к множествам)

 В этом случае изменения, произведенные с помощью других переменных,
повлияют на копии, а не на оригиналы:

\>>> A[1] = ‘Ni’
\>>> B[‘c’] = ‘spam’
\>>>
\>>> L, D
([1, 2, 3], {‘a’: 1, ‘b’: 2})
\>>> A, B
([1, ‘Ni’, 3], {‘a’: 1, ‘c’: ‘spam’, ‘b’: 2})

 Если вернуться к первоначальному примеру, то избежать побочных
эффектов, связанных со ссылками, можно, использовав выражение извлечения
среза из оригинального списка:

\>>> X = [1, 2, 3]
\>>> L = [‘a’, X[:], ‘b’]  # Встроенные копии объекта X
\>>> D = {‘x’:X[:], ‘y’:2}

 Это меняет картину, представленную на рис. 9.2 – L и D теперь ссылаются
на другие списки, отличные от X. Теперь изменения, выполненные с помощью
переменной X, отразятся только на самой переменной X, но не на L и D;
точно так же изменения в L или D никак не будут воздействовать на X.

 Одно замечание по поводу копий: выражение извлечения среза с пустыми
значениями пределов и метод словаря copy создают поверхностные копии –
то есть они не копируют вложенные структуры данных, даже если таковые
присутствуют. Если необходима полная копия структуры произвольной
глубины вложенности, следует использовать стандартный модуль copy:
добавьте инструкцию import copy и вставьте выражение
X = copy.deepcopy(Y), которое создаст полную копию объекта Y со сколь
угодно большой глубиной вложенности. Эта функция выполняет рекурсивный
обход объектов и копирует все составные части. Однако такой подход
используется намного реже (потому что для этого приходится писать
дополнительный программный код). Обычно ссылки – это именно то,
что нам требуется, в противном случае чаще всего применяются такие
способы копирования, как операция извлечения среза и метод copy.


 Сравнивание, равенство и истина

 Любые объекты языка Python поддерживают операции сравнения: проверка
на равенство, относительная величина и так далее. Операции сравнения
в языке Python всегда проверяют все части составных объектов,
пока результат не станет определенным. В действительности
при сравнивании вложенных объектов интерпретатор Python всегда
автоматически выполняет обход структуры данных, чтобы применить операции
сравнения рекурсивно, слева направо и настолько глубоко, насколько
это необходимо. Первое найденное различие определяет результат
сравнения.

 Например, при сравнении списков автоматически сравниваются все их
компоненты:

\>>> L1 = [1, (‘a’, 3)]  # Разные объекты с одинаковыми значениями
\>>> L2 = [1, (‘a’, 3)]
\>>> L1 == L2, L1 is L2  # Равны? Это один и тот же объект?
(True, False)

 В данном случае L1 и L2 ссылаются на совершенно разные списки,
но с одинаковым содержимым. Из-за природы ссылок в языке Python
(рассматривались в главе 6) существует два способа проверки
на равенство:

  Оператор == проверяет равенство значений. Интерпретатор выполняет
 проверку на равенство, рекурсивно сравнивая все вложенные объекты.

  Оператор is проверяет идентичность объектов. Интерпретатор проверяет,
 являются ли сравниваемые объекты одним и тем же объектом
 (то есть расположены ли они по одному и тому же адресу в памяти).

 В предыдущем примере L1 и L2 прошли проверку == на равенство
(они равны, потому что все их компоненты равны), но не прошли проверку
is на идентичность (они ссылаются на разные объекты и соответственно,
на разные области памяти). Однако обратите внимание, что происходит
при сравнивании двух коротких строк:

\>>> S1 = ‘spam’
\>>> S2 = ‘spam’
\>>> S1 == S2, S1 is S2
(True, True)

 Здесь у нас так же имеется два различных объекта с одинаковыми
значениями: оператор == должен вернуть истину, а оператор is – ложь.
Но так как интерпретатор с целью оптимизации кэширует и повторно
использует короткие строки, в действительности в обе переменные,
S1 и S2, записывается ссылка на одну ту же строку ‘spam’ в памяти,
поэтому оператор is проверки идентичности возвращает истину.
Чтобы получить нормальное поведение, потребуется использовать более
длинные строки:

\>>> S1 = ‘a longer string’
\>>> S2 = ‘a longer string’
\>>> S1 == S2, S1 is S2
(True, False)

 Разумеется, так как строки являются неизменяемыми, использование
механизма кэширования объектов не оказывает отрицательного влияния
на программный код – строки нельзя изменить непосредственно, независимо
от того, сколько переменных ссылаются на них. Если результат проверки
на идентичность кажется вам обескураживающим, вернитесь к главе 6,
чтобы освежить в памяти концепцию ссылок на объекты.

 Как правило, оператор == – это именно то, что требуется в большинстве
случаев проверки равенства; оператор is предназначен для особых случаев.
Мы рассмотрим случаи использования этих операторов далее в книге.
Операторы отношений к вложенным структурам также применяются рекурсивно:

\>>> L1 = [1, (‘a’, 3)]
\>>> L2 = [1, (‘a’, 2)]
\>>> L1 < L2, L1 == L2, L1 > L2  # Меньше, равно, больше:
(False, False, True)             # кортеж результатов

 Здесь L1 больше, чем L2, потому что вложенное число 3 больше, чем 2.
Результат последней строки в этом примере в действительности
представляет собой кортеж из трех объектов – результатов трех выражений
(пример кортежа без объемлющих круглых скобок).

 В общем случае Python сравнивает типы следующим образом:

  Числа сравниваются по величине.

  Строки сравниваются лексикографически, символ за символом
 (“abc” < “ac”).

  При сравнении списков и кортежей сравниваются все компоненты слева
 направо.

  Словари сравниваются как отсортированные списки (ключ, значение).
 Словари в Python 3.0 не поддерживают операторы отношений, но они
 поддерживаются в версии 2.6 и ниже, при этом они сравниваются как
 отсортированные списки (ключ, значение).

  Попытка сравнить значения несопоставимых нечисловых типов
 (например, 1 < ‘spam’) в Python 3.0 вызывает ошибку. Зато такое
 сравнивание возможно в Python 2.6, однако при этом используется
 фиксированное и достаточно произвольно выбранное правило.
 То же относится и к операции сортировки, которая реализована на основе
 операции сравнения: коллекции значений нечисловых и несопоставимых
 типов в версии 3.0 отсортированы быть не могут.

 Вообще сравнивание структурированных объектов выполняется, как если бы
сравнивались образующие их литералы, слева направо, по одному компоненту
за раз. В последующих главах мы увидим другие типы объектов, которые
могут изменять способ сравнения.


 Сравнивание словарей в Python 3.0

 Предпоследний пункт в списке из предыдущего раздела заслуживает особого
пояснения. В Python 2.6 и в более ранних версиях словари поддерживали
возможность сравнения с помощью операторов отношений, как если бы
сравнивались сортированные списки пар ключ/значение:

C:\misc> c:\python26\python
\>>> D1 = {‘a’:1, ‘b’:2}
\>>> D2 = {‘a’:1, ‘b’:3}
\>>> D1 == D2
False
\>>> D1 < D2
True

 В Python3.0 поддержка операторов отношений в словарях была
ликвидирована, потому что они оказываются слишком затратными,
когда просто требуется узнать, равны ли словари (проверка на равенство
в версии 3.0 выполняется по оптимизированному алгоритму, который
по факту не сравнивает отсортированные списки пар ключ/значение).
Чтобы выяснить относительный порядок словарей в версии 3.0, можно
написать цикл и вручную сравнить значения ключей или вручную создать
отсортированные списки пар ключ/значение и сравнить их – для этого вполне
достаточно будет задействовать метод словарей items и встроенную
функцию sorted:

C:\misc> c:\python30\python
\>>> D1 = {‘a’:1, ‘b’:2}
\>>> D2 = {‘a’:1, ‘b’:3}
\>>> D1 == D2
False
\>>> D1 < D2
TypeError: unorderable types: dict() < dict()
\>>> list(D1.items())
[(‘a’, 1), (‘b’, 2)]
\>>> sorted(D1.items())
[(‘a’, 1), (‘b’, 2)]
\>>> sorted(D1.items()) < sorted(D2.items())
True
\>>> sorted(D1.items()) > sorted(D2.items())
False

 На практике в большинстве программ, где требуется выполнять сравнивание
словарей, реализуются собственные, более эффективные процедуры сравнения
данных в словарях, чем данный способ или оригинальная реализация
в Python 2.6.


 Смысл понятий «истина» и «ложь» в языке Python

 Обратите внимание, что три значения в кортеже, возвращаемом последним
примером из предыдущего раздела, – это логические значения «истина»
(true) и «ложь» (false). Они выводятся на экран как слова True и False,
но теперь, когда мы приступаем к использованию логических проверок,
мне следует более формально описать смысл этих названий.

 В языке Python, как в большинстве языков программирования, «ложь»
представлена целочисленным значением 0, а «истина» – целочисленным
значением 1. Кроме того, интерпретатор Python распознает любую пустую
структуру данных как «ложь», а любую непустую структуру данных –
как «истину». В более широком смысле понятия истины и лжи –
это свойства, присущие всем объектам в Python, – каждый объект может
быть либо «истиной», либо «ложью»:

  Числа, отличные от нуля, являются «истиной».

  Другие объекты являются «истиной», если они непустые.

  Объект   Значение
  “spam”   True

  “”       False

  []       False

  {}       False

  1        True

  0.0      False

  None     False

 Так как объекты могут быть «истинными» или «ложными», в программах
на языке Python часто можно увидеть такие условные инструкции,
как if X:, которая, если предположить, что X является строкой,
равноценна инструкции if X != ‘’:. Говоря другими словами, можно
проверить истинность объекта вместо того, чтобы сравнивать его
с пустым объектом.


 Объект None

 В языке Python имеется также специальный объект с именем None
(последняя строка в табл. 9.4), который всегда расценивается как «ложь».
Объект None был представлен в главе 4 – это единственный специальный тип
данных в языке Python, который играет роль пустого заполнителя
и во многом похож на указатель NULL в языке C.

 Например, вспомните, что списки не допускают присваивание значений
отсутствующим элементам (списки не вырастают по волшебству, когда вы
выполняете присваивание некоторого значения несуществующему элементу).
Чтобы можно было выполнять присваивание любому из 100 элементов списка,
обычно создается список из 100 элементов, который заполняется объектами
None:

\>>> L = [None] * 100
\>>>
\>>> L
[None, None, None, None, None, None, None, ... ]

 В этом примере мы никак не ограничиваем размер списка (его по-прежнему
позднее можно будет увеличить или уменьшить), мы просто создаем список
определенного размера, чтобы обеспечить возможность присваивания
по индексам. Точно так же можно было бы инициализировать список нулями,
но все-таки предпочтительнее использовать None, если заранее
не известно, какие данные будет содержать этот список.

 Имейте в виду, что значение None не означает «неопределенный».
То есть None - это не «ничто» (несмотря на свое имя!); это настоящий
объект, занимающий определенную область памяти, с зарезервированным
именем. Другие примеры использования этого специального объекта
вы найдете ниже в книге. Кроме того, этот объект является значением,
возвращаемым функциями по умолчанию, как будет показано
в четвертой части.


 Тип bool

 Логический тип bool в языке Python (представленный в главе 5) просто
усиливает понятия «истина» и «ложь» в языке Python. Как мы узнали
в главе 5, предопределенные имена True и False являются всего лишь
разновидностями целых чисел 1 и 0, как если бы этим двум
зарезервированным именам предварительно присваивались значения 1 и 0.
Этот тип реализован так, что он действительно является лишь
незначительным расширением к понятиям «истина» и «ложь», уже описанным,
и предназначенным для того, чтобы сделать значения истинности
более явными:

  При явном использовании слов True и False в операциях проверки на
 истинность они интерпретируются как «истина» и «ложь», которые
 в действительности являются специализированными версиями целых чисел
 1 и 0.

  Результаты операций проверок также выводятся как слова True и False,
 а не как значения 1 и 0.

 Вам необязательно использовать только логические типы в логических
инструкциях, таких как if, – любые объекты по своей природе могут быть
истинными или ложными, и все логические концепции, упоминаемые
в этой главе, работают, как описано, и с другими типами. Кроме того,
в языке Python имеется встроенная функция bool, которая может
использоваться для проверки логического значения объекта (например,
для проверки истинности объекта, чтобы убедиться, что объект не является
пустым или не равен нулю):

\>>> bool(1)
True
\>>> bool(‘spam’)
True
\>>> bool({})
False

 Однако на практике вам редко придется вручную пользоваться переменными
типа bool, которые воспроизводятся логическими проверками, потому что
логические результаты автоматически используются инструкциями if
и другими средствами выбора.


 Иерархии типов данных в языке Python

 На рис. 9.3 приводятся все встроенные типы объектов, доступные
в языке Python, и отображены взаимоотношения между ними. Наиболее
значимые из них мы уже рассмотрели; большая часть других видов объектов
на рис. 9.3 соответствует элементам программ (таким как функции
и модули) или отражает внутреннее устройство интерпретатора
(такие, как кадры стека и скомпилированный программный код).

 Главное, что следует учитывать, – в языке Python все элементы являются
объектами и могут быть использованы в ваших программах. Например, можно
передать класс в функцию, присвоить его переменной, заполнить им список
или словарь и так далее.


 Объекты типов

 Фактически даже сами типы в языке Python являются разновидностью
объектов: объекты типов являются объектами типа type (попробуйте быстро
произнести эту фразу три раза!). Говоря серьезно, вызов встроенной
функции type(X) возвращает объект типа объекта X. Объекты типов могут
использоваться для сравнения типов вручную в инструкции if. Однако
по причинам, изложенным в главе 4, ручная проверка типа в языке Python
обычно рассматривается как нечто неправильное, что существенно
ограничивает гибкость программного кода.

 Одно замечание по поводу имен типов: в версии Python 2.2 у каждого
базового типа появилось новое встроенное имя, добавленное
для обеспечения поддержки настройки типов через объектно-ориентированный
механизм наследования классов: dict, list, str, tuple, int, float,
complex, bytes, type, set и другие (в версии Python 2.6, но не в 3.0,
имя типа file является синонимом для open). Эти имена представляют
не просто функции преобразования, а настоящие конструкторы объектов,
хотя при решении несложных задач вы можете рассматривать их
как простые функции.

 Модуль types, входящий в состав стандартной библиотеки, также
предоставляет дополнительные имена типов, не являющиеся встроенными
(например, типы функций; в Python 2.6, но не в 3.0, этот модуль также
включает синонимы встроенных типов) и предоставляет возможность
проверять тип объекта с помощью функции isinstance. Например,
все следующие операции проверки возвращают истину:

type([1]) == type([])  # Сравнивание с типом другого списка
type([1]) == list  # Сравнивание с именем типа
isinstance([1], list)  # Список или объект класса, производного от list
import types  # В модуле types определены имена других типов
def f(): pass
type(f) == types.FunctionType

 Поскольку в современных версиях Python от типов можно порождать
дочерние классы, рекомендуется не пренебрегать функцией isinstance.
Подробнее о создании дочерних классов от встроенных типов в версии
Python 2.2 (и выше) рассказывается в главе 31.

 Кроме того, в главе 31 мы исследуем, как функция type(X) и операции
проверки типа применяются к экземплярам пользовательских классов.
В двух словах: в Python 3.0 и для классов «нового стиля» в Python 2.6
типом экземпляра класса является сам класс, на основе которого
был создан экземпляр. Для «классических» классов в Python 2.6
(и в более ранних версиях) экземпляры любых классов имеют
тип "instance", поэтому, чтобы получить более или менее осмысленные
результаты, мы должны сравнивать атрибуты __class__ экземпляров.


 Другие типы в Python

 Помимо базовых объектов, рассмотренных в этой части книги, и объектов,
представляющих элементы программ, такие как функции, модули и классы,
с которыми мы встретимся ниже, в составе Python обычно устанавливаются
десятки других типов объектов, доступных в виде связанных расширений
на языке C или в виде классов языка Python – объекты регулярных
выражений, файлы DBM, компоненты графического интерфейса, сетевые сокеты
и так далее.

 Главное отличие между этими и встроенными типами, которые мы до сих пор
рассматривали, состоит в том, что для встроенных типов языком
предоставляется специальный синтаксис создания объектов этих типов
(например, 4 – для целого числа, [1,2] – для списка, функция open –
для файла, а def и lambda – для функций). Другие типы обычно доступны
в модулях стандартной библиотеки, которые необходимо импортировать
перед использованием. Например, чтобы создать объект регулярного
выражения, необходимо импортировать модуль re и вызвать функцию
re.compile(). Полное руководство по всем типам, доступным в программах
на языке Python, вы найдете в справочнике по библиотеке Python.


 Ловушки встроенных типов

 Это окончание нашего обзора базовых типов данных. Мы завершаем
эту часть книги обсуждением общих проблем, с которыми сталкиваются
новые пользователи (а иногда и эксперты), и их решений. Отчасти –
это краткий обзор идей, которые мы уже рассматривали, но они достаточно
важны, чтобы вновь вернуться к ним.


 Операция присваивания создает ссылку, а не копию

 Поскольку это центральное понятие, я напомню о нем еще раз: вы должны
понимать, что может происходить с разделяемыми ссылками
в вашей программе. Например, ниже создается объект списка,
связанный с именем L, на это имя также ссылается элемент списка M.
Таким образом, изменение списка с помощью имени L приведет
к изменению списка, на который ссылается и список M:

\>>> L = [1, 2, 3]
\>>> M = [‘X’, L, ‘Y’]  # Встраивает ссылку из L
\>>> M
[‘X’, [1, 2, 3], ‘Y’]
\>>> L[1] = 0  # Список M также изменяется
\>>> M
[‘X’, [1, 0, 3], ‘Y’]

 Обычно этот эффект обретает важность только в больших программах,
и как правило, совместное использование ссылок – это именно то,
что необходимо. Если это является нежелательным, вы всегда можете явно
создать копию объекта. Для списков всегда можно создать поверхностную
копию с помощью операции извлечения среза с незаданными пределами:

\>>> L = [1, 2, 3]
\>>> M = [‘X’, L[:], ‘Y’]  # Встраивается копия L
\>>> L[1] = 0  # Изменяется только L, но не M
\>>> L
[1, 0, 3]
\>>> M
[‘X’, [1, 2, 3], ‘Y’]

 Не забывайте, что значениями пределов по умолчанию являются 0 и длина
последовательности, откуда извлекается срез. Если оба значения опущены,
в результате операции будут извлечены все элементы последовательности,
что создаст поверхностную копию (новый, не разделяемый ни с кем,
объект).


 Операция повторения добавляет один уровень вложенности

 Операция повторения последовательности добавляет последовательность
саму к себе заданное число раз. Это правда, но когда появляются
вложенные изменяемые последовательности, эффект может не всегда
получиться таким, как вы ожидаете. Например, в следующем примере
переменной X присваивается список L, повторенный четырежды, тогда как
переменной Y присваивается повторенный четырежды список, содержащий L:

\>>> L = [4, 5, 6]
\>>> X = L * 4  # Все равно, что [4, 5, 6] + [4, 5, 6] + ...
\>>> Y = [L] * 4  # [L] + [L] + ... = [L, L,...]
\>>> X
[4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]
\>>> Y
[[4, 5, 6], [4, 5, 6], [4, 5, 6], [4, 5, 6]]

 Так как во второй операции повторения L является вложенным списком,
то в Y попадают ссылки на оригинальный список, связанный с именем L,
вследствие чего начинают проявляться те же побочные эффекты, о которых
говорилось в предыдущем разделе:

\>>> L[1] = 0  # Воздействует на Y, но не на X
\>>> X
[4, 5, 6, 4, 5, 6, 4, 5, 6, 4, 5, 6]
\>>> Y
[[4, 0, 6], [4, 0, 6], [4, 0, 6], [4, 0, 6]]

 Здесь можно применить то же решение, что и в предыдущем разделе,
так как это в действительности всего лишь другой способ получить
разделяемые ссылки на изменяемый объект. Если вы помните, операции
повторения, конкатенации и извлечения среза создают только поверхностные
копии объектов, что чаще всего и бывает необходимо.


 Избегайте создания циклических структур данных

 На самом деле мы уже сталкивались с этим понятием в предыдущем
упражнении: если объект-коллекция содержит ссылку на себя, он называется
циклическим объектом. Всякий раз, когда интерпретатор Python
обнаруживает циклическую ссылку, он выводит [...], чтобы не попасть
в бесконечный цикл:

\>>> L = [‘grail’]  # Добавление ссылки на самого себя
\>>> L.append(L)  # Создает циклический объект: [...]
\>>> L
[‘grail’, [...]]

 Кроме понимания того, что три точки в квадратных скобках означают
циклическую ссылку в объекте, это случай заслуживает особого внимания,
т.к. он может привести к сбоям – циклические структуры могут вызывать
неожиданное зацикливание программного кода, если вы
не все предусмотрели. Например, некоторые программы хранят список
или словарь уже посещенных элементов, с помощью которого обнаруживают
попадание в цикл. Советы по устранению этих неполадок приводятся
в упражнениях к первой части книги, в главе 3; кроме того, решение
проблемы приводится также в конце главы 24, в программе reloadall.py.

 Не создавайте циклические ссылки, если они действительно не нужны.
Иногда бывают серьезные основания для создания циклических ссылок,
но если ваш программный код не предусматривает их обработку, вам
не следует слишком часто заставлять свои объекты ссылаться
на самих себя.


 Неизменяемые типы не могут изменяться непосредственно

 Наконец, вы не можете изменять неизменяемые объекты непосредственно.
Вместо этого создайте новый объект – с помощью операций извлечения
среза, конкатенации и так далее, и присвойте, если это необходимо,
первоначальной переменной:

T = (1, 2, 3)
T[2] = 4  # Ошибка!
T = T[:2] + (4,)  # Все в порядке: (1, 2, 4)

 Это может показаться лишней работой, но выигрыш в том, что неизменяемые
объекты, такие как кортежи и строки, не порождают приведенных выше
проблем, т.к. они не могут изменяться непосредственно и не подвержены,
как списки, побочным эффектам такого рода.


 Упражнения ко второй части

 1. Основы. Поэкспериментируйте в интерактивной оболочке с наиболее
часто используемыми операциями, которые вы найдете в таблицах второй
части. Для начала запустите интерактивный сеанс работы с интерпретатором
Python, введите все нижеследующие выражения и попробуйте объяснить
происходящее. Обратите внимание, что в некоторых строках точка
с запятой используется как разделитель инструкций, что позволяет
уместить в одной строке несколько инструкций, например: в строке X=1;X
выполняется присваивание значения переменной и последующий его вывод
(подробнее о синтаксисе инструкций рассказывается в следующей
части книги). Кроме того, запомните, что запятая между выражениями
обычно означает создание кортежа, даже в отсутствие круглых скобок:
выражение X, Y, Z – это кортеж из трех элементов, который интерпретатор
выведет, заключив в круглые скобки.
"""

print(2 ** 16)
print(2 / 5, 2 / 5.0)

print("spam" + "eggs")
S = "ham"
print("eggs" + S)
print(S * 5)
print(S[:0])
print("green %s and %s" % ("eggs", S))
print('green {0} and {1}'.format('eggs', S))

print(('x',)[0])
print(('x', 'y')[1])
L = [1, 2, 3] + [4, 5, 6]
print(L, L[:], L[:0], L[-2], L[-2:])
print(([1, 2, 3] + [4, 5, 6])[2:4])
print([L[2], L[3]])
L.reverse()
print(L)
L.sort()
print(L)
print(L.index(4))

print({'a': 1, 'b': 2}['b'])
D = {'x': 1, 'y': 2, 'z': 3}
print(D['x'] + D['w'])
D[(1, 2, 3)] = 4
print(list(D.keys()), list(D.values()), (1, 2, 3) in D)

print([[]], ["", [], (), {}, None])

"""
 2. Индексирование и извлечение среза. В интерактивной оболочке создайте
список с именем L, который содержит четыре строки или числа (например,
L = [0,1,2,3]). Затем исследуйте следующие случаи – они могут никогда
не встретиться вам на практике, но они заставят вас задуматься 
об основах реализации, что может оказаться полезным в практических
ситуациях:

  Что произойдет, если попытаться получить доступ к элементу, индекс
 которого выходит за пределы списка (например, L[4])?
 
  Что произойдет, если попытаться извлечь срез, выходящий за пределы
 списка (например, L[-1000:100])?
 
  Наконец, как отреагирует интерпретатор на попытку извлечь
 последовательность в обратном порядке, когда нижняя граница 
 больше верхней (например, L[3:1])? Подсказка: попробуйте выполнить 
 операцию присваивания такому срезу (L[3:1] = [‘?’]) и посмотреть, 
 куда будет помещено значение. Как вы думаете, это то же самое явление,
 что и при попытке извлечь срез, выходящий за пределы списка?
"""

L = list(range(1, 5))

print(L[-100:100])

print(L[3:0])

"""
 3. Индексирование, извлечение среза и инструкция del. Создайте другой 
список L с четырьмя элементами и присвойте одному из элементов пустой
список (например, L[2] = []). Что произошло? Затем присвойте пустой 
список срезу (L[2:3] = []). Что случилось на этот раз? Не забывайте, 
что операция присваивания срезу сначала удаляет срез, а затем вставляет
новое значение в заданную позицию.

 Инструкция del удаляет элемент с указанным смещением, ключом, 
атрибутом или именем. Используйте ее для удаления элемента вашего списка
(например, del L[0]). Что произойдет, если попробовать удалить целый 
срез (del L[1:])? Что произойдет, если срезу присвоить объект, 
который не является последовательностью (L[1:2] = 1)?
"""

L = list('concentration')
L[4] = []

print(L)

L[4:6] = []

print(L)

del L[0]

print(L)

del L[6:]

print(L)

"""
 4. Кортежи. Введите следующие строки:

>>> X = ‘spam’
>>> Y = ‘eggs’
>>> X, Y = Y, X

 Как вы думаете, что произойдет с переменными X и Y после выполнения 
этой последовательности действий?
"""

X = 'spam'
Y = 'eggs'
X, Y = Y, X

print(X, Y)

"""
 5. Ключи словарей. Рассмотрите следующий фрагмент:
>>> D = {}
>>> D[1] = ‘a’
>>> D[2] = ‘b’
Вы знаете, что словари не поддерживают доступ к элементам по смещениям;
попробуйте объяснить происходящее здесь. Может быть, следующий пример
прояснит ситуацию? (Подсказка: к какой категории типов относятся строки,
целые числа и кортежи?)
>>> D[(1, 2, 3)] = ‘c’
>>> D
{1: ‘a’, 2: ‘b’, (1, 2, 3): ‘c’}
"""

D = {}
D[1] = 'a'
D[2] = 'b'
D[(1, 2, 3)] = 'c'
print(D)

"""
 6. Индексирование словарей. Создайте словарь с именем D и с тремя
записями для ключей ‘a’, ‘b’ и ‘c’. Что произойдет, если попытаться 
обратиться к элементу с несуществующим ключом (D{‘d’})? Что сделает
интерпретатор, если попробовать присвоить значение несуществующему ключу
(D[‘d’] = ‘spam’)? Как это согласуется с операциями доступа 
и присваивания элементам списков при использовании индексов, выходящих
за их пределы? Не напоминает ли вам такое поведение правила, 
применяемые к переменным?
"""

D = {'a': 'ada', 'b': 'beda', 'c': 'cesar'}
D['d'] = 'spam'
print(D)

"""
 7. Общие операции. Получите в интерактивной оболочке ответы 
на следующие вопросы:

  Что произойдет, если попытаться использовать оператор + с операндами
 различных типов (например, строка+список, список+кортеж)?
 
  Будет ли работать оператор +, когда один из операндов является 
 словарем?
 
  Будет ли работать метод append со списками и со строками? Можно ли 
 использовать метод keys со списками? (Подсказка: что предполагает метод
append о заданном объекте?)

  Наконец, какой тип объекта будет получен, когда операция конкатенации 
 применяется к двум спискам или двум строкам?
"""

T = (2, 6, 'gag')
L = list(range(3))
S = 'spam'
I = 56
F = 4.6

print(L + [I, F], S + T[2])

"""
 8. Индексирование строк. Определите строку S из четырех символов: 
S = “spam”. Затем введите следующее выражение: S[0][0][0][0][0]. 
Можете ли вы объяснить, что произошло на этот раз? (Подсказка: 
не забывайте, строки - это коллекции символов, а символы в языке Python 
представлены односимвольными строками.) Будет ли это выражение работать,
если применить его к списку, такому как [‘s’, ‘p’, ‘a’, ‘m’]? Почему?
"""

print(S[0][0][0][0][0], list(S)[0][0][0][0][0])

"""
 9. Неизменяемые типы. Определите еще раз строку S из четырех символов:
S = “spam”. Напишите операцию присваивания, которая изменила бы строку
на “slam”, используя только операции извлечения среза и конкатенации.
Возможно ли выполнить то же самое действие с использованием операций
индексирования и конкатенации? С помощью присваивания по индексу 
элемента?
"""

S = S[0] + 'l' + S[2:]
S = 'spam'

print(S[0] + 'l' + S[2] + S[3])

"""
 10. Вложенные структуры. Создайте структуру данных для представления
вашей личной информации: имя (имя, фамилия, отчество), возраст, 
должность, адрес, электронный адрес и номер телефона. При построении 
структуры вы можете использовать любые комбинации встроенных объектов 
(списки, кортежи, словари, строки, числа). Затем попробуйте обратить-
ся к отдельным элементам структуры по индексам. Являются ли какие-нибудь
объекты более предпочтительными для данной структуры?
"""

personal = {'name': ('Cthutq', 'Ukeotyrj', 'Ltybcjdbx'), 'age': 17,
            'job': None, 'address': ('Hjccbz', 'Eccehbqcr',
                                     'Dtnthfyjd st.',
                                     'building xtnshyflwfnm'),
            'email': '**********@mail.ru',
            'phone number': '8 924 *** ** **'}

print(personal['name'][0], personal['age'], personal['address'][0])

"""
 11. Файлы. Напишите сценарий, который создает и открывает для записи 
новый файл с именем myfile.txt и записывает в него строку
“Hello file world!”. Затем напишите другой сценарий, который открывает
файл myfile.txt, читает и выводит на экран его содержимое. Запустите 
поочередно эти сценарии из командной строки. Появился ли новый файл 
в каталоге, откуда были запущены сценарии? Что произойдет, если указать
другой каталог в имени файла, которое передается функции open?
Примечание: методы записи в файлы не добавляют символ новой строки 
к записываемым строкам. Добавьте символ \n явно в конец вашей строки,
если хотите получить в файле полностью завершенную строку.
"""

f = open(r'myfile.txt', 'w')

f.write('Hello file world!\n')

f = open(r'myfile.txt', 'r')

print(f.read())

"""
 Метод форматирования строк

 Как уже упоминалось выше, в Python 2.6 и 3.0 появился новый способ
форматирования строк, более близкий по духу к идеям языка Python.
В отличие от выражений форматирования, метод форматирования
не так сильно опирается на модель функции «printf» языка C
и имеет более подробный и явный синтаксис. С другой стороны,
новый способ по-прежнему опирается на некоторые концепции функции
«printf», такие, как символы и параметры спецификаторов формата.
Кроме того, возможности метода форматирования в значительной степени
пересекаются с возможностями выражений форматирования
(иногда, правда, за счет большего объема программного кода)
и могут выполнять столь же сложные операции форматирования.
Вследствие этого сложно сказать, какой из двух способов лучше,
поэтому для большинства программистов совсем нелишним будет
знакомство с обоими.


 Основы

 В двух словах, новый метод format объектов строк, появившийся
в версиях 2.6 и 3.0 (и выше), использует строку, относительно которой
он вызывается, как шаблон и принимает произвольное количество
аргументов, представляющих значения для подстановки. Фигурные скобки
внутри строки шаблона используются для обозначения замещаемых
спецификаторов и их параметров, которые могут определять порядковые
номера позиционных аргументов (например, {1}) или имена именованных
аргументов (например, {food}). В главе 18 вы узнаете, что аргументы
могут передаваться функциям и методам в виде позиционных и именованных
аргументов, а язык Python предоставляет возможность создавать функции
и методы, способные принимать произвольное количество позиционных
и именованных аргументов. Ниже приводится несколько примеров
использования метода format в Python 2.6 и 3.0:

\>>> template = ‘{0}, {1} and {2}’  # Порядковые номера
                                    # позиционных аргументов
\>>> template.format(‘spam’, ‘ham’, ‘eggs’)
‘spam, ham and eggs’

\>>> template = ‘{motto}, {pork} and {food}’  # Имена именованных
                                              # аргументов
\>>> template.format(motto=’spam’, pork=’ham’, food=’eggs’)
‘spam, ham and eggs’

\>>> template = ‘{motto}, {0} and {food}’  # Оба варианта
\>>> template.format(‘ham’, motto=’spam’, food=’eggs’)
‘spam, ham and eggs’

 Естественно, строка шаблона также может быть литералом, кроме того,
сохраняется возможность подстановки значений объектов любых типов:

\>>> ‘{motto}, {0} and {food}’.format(42, motto=3.14, food=[1, 2])
‘3.14, 42 and [1, 2]’

 Как и при использовании оператора форматирования % и других строковых
методов, метод format создает и возвращает новый объект строки,
который можно тут же вывести на экран или сохранить для последующего
использования (не забывайте, что строки являются неизменяемыми
объектами, поэтому метод format вынужден создавать новый объект).
Возможность форматирования строк может использоваться не только для их
отображения:

\>>> X = ‘{motto}, {0} and {food}’.format(42, motto=3.14, food=[1, 2])
\>>> X
‘3.14, 42 and [1, 2]’

\>>> X.split(‘ and ‘)
[‘3.14, 42’, ‘[1, 2]’]

\>>> Y = X.replace(‘and’, ‘but under no circumstances’)
\>>> Y
‘3.14, 42 but under no circumstances [1, 2]’


 Использование ключей, атрибутов и смещений

 Как и оператор форматирования %, метод format обладает дополнительными
возможностями. Например, в строках формата допускается ссылаться
на имена атрибутов объектов и ключи словарей, – как и в привычном
синтаксисе языка Python, квадратные скобки обозначают ключи словаря,
а точка применяется для организации доступа к атрибутам объектов,
на которые ссылаются позиционные или именованные спецификаторы.
В первом примере ниже демонстрируется подстановка значения ключа «spam»
словаря и значения атрибута «platform» объекта импортированного модуля
sys, которые передаются как позиционные аргументы. Во втором примере
делается то же самое, но на этот раз объекты для подстановки передаются
в виде именованных аргументов:

\>>> import sys
\>>> ‘My {1[spam]} runs {0.platform}’.format(sys, {‘spam’: ‘laptop’})
‘My laptop runs win32’
\>>> ‘My {config[spam]} runs {sys.platform}’.format(sys=sys,
config={‘spam’: ‘laptop’})
‘My laptop runs win32’

 В квадратных скобках в строках формата можно также указывать смещение
от начала списка (или любой другой последовательности), но при этом
допускается использовать только положительные смещения, поэтому данная
возможность не является достаточно универсальной, как можно было бы
подумать. Как и в операторе %, чтобы обратиться по отрицательному
смещению, получить срез или вставить результат произвольного выражения,
данные для подстановки должны быть подготовлены отдельными выражениями,
за пределами строки формата:

\>>> somelist = list(‘SPAM’)
\>>> somelist
[‘S’, ‘P’, ‘A’, ‘M’]

\>>> ‘first={0[0]}, third={0[2]}’.format(somelist)
‘first=S, third=A’

\>>> ‘first={0}, last={1}’.format(somelist[0],
                                  somelist[-1])  # Если [-1]
‘first=S, last=M’      # использовать внутри строки формата,
                                    # это приведет к ошибке

\>>> parts = somelist[0], somelist[-1], somelist[1:3]  # Если [1:3]
\>>> ‘first={0}, last={1}, middle={2}’.format(*parts)  # использовать
“first=S, last=M, middle=[‘P’, ‘A’]”          # внутри строки формата,
                                              # это приведет к ошибке


 Специальные приемы форматирования

 Еще одно сходство с оператором форматирования % состоит в том,
что за счет использования дополнительных синтаксических конструкций
форматирования имеется возможность выполнять более точное
форматирование. Вслед за идентификатором символа подстановки,
через двоеточие, можно указать спецификатор формата, определяющий ширину
поля вывода, выравнивание и код типа значения. Ниже приводится
формальный синтаксис спецификатора формата:

{fieldname!conversionflag:formatspec}

 Поля спецификатора имеют следующий смысл:

  fieldname – порядковый номер или имя именованного аргумента,
 за которым может следовать необязательное имя «.name» атрибута
 или индекс «[index]» элемента.

  conversionflag – может быть r, s или a, которые определяют применение
 к значению встроенной функции repr, str или ascii соответственно.

  formatspec – определяет способ представления значения, описывает
 такие характеристики представления, как ширина поля вывода,
 выравнивание, дополнение, количество знаков после десятичной точки
 и так далее, и завершается необязательным кодом типа значения.

 Поле formatspec, следующее за двоеточием, в общем виде имеет следующий
синтаксис (квадратные скобки окружают необязательные компоненты
и не имеют отношения к синтаксису поля):

[[fill]align][sign][#][0][width][.precision][typecode]

 В поле align может указываться символ <, >, = или ^, обозначающий
выравнивание по левому или по правому краю, дополнение после символа
знака числа или выравнивание по центру соответственно. Спецификатор
формата formatspec может также содержать вложенные {} строки
форматирования с именами полей, чтобы извлекать значения из списка
аргументов динамически (практически так же, как символ * в операторе
форматирования).

 Подробное описание синтаксиса и полный список допустимых кодов типа
вы найдете в руководстве по стандартной библиотеке языка Python –
этот список практически полностью совпадает со списком спецификаторов,
используемых в операторе форматирования % и перечисленных в табл. 7.4.
Дополнительно метод format позволяет использовать код типа «b»
для отображения целых чисел в двоичном формате (эквивалент вызову
встроенной функции bin). Кроме того, код типа «%» используется
для отображения символа процента, а для отображения десятичных целых
чисел допускается использовать только код «d» (коды «i» и «u»
считаются недопустимыми).

 В следующем примере спецификатор {0:10} предписывает вывести значение
первого позиционного аргумента в поле шириной 10 символов. Спецификатор
{1:<10} предписывает вывести значение второго позиционного аргумента
в поле шириной 10 символов, с выравниванием по левому краю,
а спецификатор {0.platform:>10} предписывает вывести значение атрибута
platform первого позиционного аргумента в поле шириной 10 символов,
с выравниванием по правому краю:

\>>> ‘{0:10} = {1:10}’.format(‘spam’, 123.4567)
‘spam = 123.457’
\>>> ‘{0:>10} = {1:<10}’.format(‘spam’, 123.4567)
‘ spam = 123.457 ‘
\>>> ‘{0.platform:>10} = {1[item]:<10}’.format(sys, dict(item=’laptop’))
‘ win32 = laptop ‘

 Для вывода вещественных чисел метод format поддерживает те же самые
коды типов и параметры форматирования, что и оператор %. Так,
в следующем примере спецификатор {2:g} предписывает вывести третий
аргумент, отформатированный в соответствии с представлением вещественных
чисел по умолчанию, предусмотренным кодом «g». Спецификатор {1:.2f}
предписывает использовать формат «f» представления вещественных чисел
с двумя знаками после десятичной точки, а спецификатор {2:06.2f}
дополнительно ограничивает ширину поля вывода 6 символами
и предписывает дополнить число нулями слева:

\>>> ‘{0:e}, {1:.3e}, {2:g}’.format(3.14159, 3.14159, 3.14159)
‘3.141590e+00, 3.142e+00, 3.14159’
\>>> ‘{0:f}, {1:.2f}, {2:06.2f}’.format(3.14159, 3.14159, 3.14159)
‘3.141590, 3.14, 003.14’

 Метод format поддерживает также возможность вывода чисел
в шестнадцатеричном, восьмеричном и двоичном представлениях.
Фактически строка формата может служить альтернативой использованию
некоторых встроенных функций:

\>>> ‘{0:X}, {1:o}, {2:b}’.format(255, 255, 255)  # Шестнадцатеричное,
‘FF, 377, 11111111’           # восьмеричное и двоичное представление

\>>> bin(255), int(‘11111111’, 2), 0b11111111  # Другие способы работы с
(‘0b11111111’, 255, 255)                       # двоичным представлением

\>>> hex(255), int(‘FF’, 16), 0xFF  # Другие способы работы с
(‘0xff’, 255, 255)                  # шестнадцатеричным представлением

\>>> oct(255), int(‘377’, 8), 0o377, 0377  # Другие способы работы с
(‘0377’, 255, 255, 255)                    # восьмеричным представлением
# 0377 допустимо только в 2.6, но не в 3.0!

 Параметры форматирования можно указывать непосредственно в строке
формата или динамически извлекать из списка аргументов, с помощью
синтаксиса вложенных конструкций, практически так же, как с помощью
символа звездочки в операторе форматирования %:

\>>> ‘{0:.2f}’.format(1 / 3.0)  # Параметры определены непосредственно
‘0.33’                          # в строке формата
\>>> ‘%.2f’ % (1 / 3.0)
‘0.33’

\>>> ‘{0:.{1}f}’.format(1 / 3.0, 4)  # Значение извлекается
                                     # из списка аргументов
‘0.3333’
\>>> ‘%.*f’ % (4, 1 / 3.0)  # Как то же самое делается в выражениях
‘0.3333’

 Наконец, в Python 2.6 и 3.0 появилась новая встроенная функция format,
которая может использоваться для форматирования одиночных значений.
Она может рассматриваться как более компактная альтернатива методу
format и напоминает способ форматирования единственного значения
с помощью оператора %:

\>>> ‘{0:.2f}’.format(1.2345)  # Строковый метод
‘1.23’
\>>> format(1.2345, ‘.2f’)  # Встроенная функция
‘1.23’
\>>> ‘%.2f’ % 1.2345  # Выражение форматирования
‘1.23’

 С технической точки зрения, встроенная функция format вызывает метод
__format__ объекта, который в свою очередь вызывает метод str.format
каждого форматируемого элемента. Однако эта функция имеет не такой
компактный синтаксис, как оригинальный оператор %, что ведет нас
к следующему разделу.


 Сравнение с оператором форматирования %

 Если вы внимательно прочитали предыдущие разделы, вы могли заметить,
что, по крайней мере, ссылки на позиционные аргументы и ключи словарей
в строковом методе format выглядят почти так же, как в операторе
форматирования %, особенно когда используются дополнительные параметры
форматирования и коды типов значений. В действительности в общем случае
применение оператора форматирования выглядит проще, чем вызов
метода format, особенно при использовании универсального спецификатора
формата %s:

print(‘%s=%s’ % (‘spam’, 42))  # 2.X+ выражение форматирования
print(‘{0}={1}’.format(‘spam’, 42))  # 3.0 (и 2.6) метод format

 Как вы увидите чуть ниже, в более сложных случаях оба способа имеют
почти одинаковую сложность (сложные задачи обычно сложны сами по себе,
независимо от используемого подхода), поэтому некоторые считают format
в значительной степени избыточным.

 С другой стороны, метод format предлагает дополнительные потенциальные
преимущества. Например, оператор % не позволяет использовать именованные
аргументы, ссылки на атрибуты и выводить числа в двоичном представлении,
хотя возможность использования словарей в операторе % помогает добиться
тех же целей. Чтобы увидеть сходные черты между этими двумя приемами,
сравните следующие примеры использования оператора % с аналогичными
примерами использования метода format, представленными выше:

# Основы: с оператором % вместо метода format()
\>>> template = ‘%s, %s, %s’
\>>> template % (‘spam’, ‘ham’, ‘eggs’)  # Позиционные параметры
‘spam, ham, eggs’

\>>> template = ‘%(motto)s, %(pork)s and %(food)s’
\>>> template % dict(motto=’spam’, pork=’ham’, food=’eggs’)
‘spam, ham and eggs’                                     # Ключи словаря

\>>> ‘%s, %s and %s’ % (3.14, 42, [1, 2])  # Произвольные типы
‘3.14, 42 and [1, 2]’

# Использование ключей, атрибутов и смещений
\>>> ‘My %(spam)s runs %(platform)s’ % {‘spam’: ‘laptop’,
                                        ‘platform’: sys.platform}
‘My laptop runs win32’

\>>> ‘My %(spam)s runs %(platform)s’ % dict(spam=’laptop’,
                                            platform=sys.platform)
‘My laptop runs win32’

\>>> somelist = list(‘SPAM’)
\>>> parts = somelist[0], somelist[-1], somelist[1:3]
\>>> ‘first=%s, last=%s, middle=%s’ % parts
“first=S, last=M, middle=[‘P’, ‘A’]”

 Когда требуется добиться более сложного форматирования, эти два подхода
становятся почти равными в смысле сложности, хотя, если сравнить
следующие примеры использования оператора % с аналогичными примерами
использования метода format, представленными выше, опять можно заметить,
что оператор % выглядит несколько проще и компактнее:

# Специальные приемы форматирования
\>>> ‘%-10s = %10s’ % (‘spam’, 123.4567)
‘spam = 123.4567’

\>>> ‘%10s = %-10s’ % (‘spam’, 123.4567)
‘ spam = 123.4567 ‘

\>>> ‘%(plat)10s = %(item)-10s’ % dict(plat=sys.platform, item=’laptop’)
‘ win32 = laptop ‘

# Вещественные числа
\>>> ‘%e, %.3e, %g’ % (3.14159, 3.14159, 3.14159)
‘3.141590e+00, 3.142e+00, 3.14159’

\>>> ‘%f, %.2f, %06.2f’ % (3.14159, 3.14159, 3.14159)
‘3.141590, 3.14, 003.14’

# Числа в шестнадцатеричном и восьмеричном представлениях,
# но не в двоичном
\>>> ‘%x, %o’ % (255, 255)
‘ff, 377’

 Метод format имеет ряд дополнительных особенностей, которые
не поддерживаются оператором %, но даже когда требуется реализовать
еще более сложное форматирование, оба подхода выглядят примерно
одинаковыми в смысле сложности. Например, ниже демонстрируются
два подхода к достижению одинаковых результатов – при использовании
параметров, определяющих ширину полей и выравнивание, а также различных
способов обращения к атрибутам:

# В обоих случаях фактические значения определяются непосредственно
# в операции
\>>> import sys
\>>> ‘My {1[spam]:<8} runs {0.platform:>8}’.format(sys,
                                                   {‘spam’: ‘laptop’})
‘My laptop runs win32’

\>>> ‘My %(spam)-8s runs %(plat)8s’ % dict(spam=’laptop’,
                                           plat=sys.platform)
‘My laptop runs win32’

 На практике фактические значения редко определяются непосредственно
в операции форматирования, как здесь. Чаще эти значения вычисляются
заранее (например, чтобы затем подставить их все сразу в шаблон разметки
HTML). Когда мы начинаем учитывать общепринятую практику в своих
примерах, сравнение метода format и оператора % становится еще более
наглядным (как вы узнаете в главе 18, аргумент **data в вызове метода –
это специальный синтаксис распаковывания ключей и значений словарей
в отдельные пары «name=value» именованных аргументов, благодаря чему
появляется возможность обращаться к ним по именам в строке формата):

# В обоих случаях используются данные, собранные предварительно
\>>> data = dict(platform=sys.platform, spam=’laptop’)
\>>> ‘My {spam:<8} runs {platform:>8}’.format(**data)
‘My laptop runs win32’

\>>> ‘My %(spam)-8s runs %(platform)8s’ % data
‘My laptop runs win32’

 Улучшения метода format в версии Python 3.1: В будущей версии 3.1
(когда писалась эта глава, она находилась еще в состоянии альфа-версии)
будет добавлена возможность указывать символ-разделитель разрядов
в десятичных числах, что позволит вставлять запятые между трехзначными
группами цифр. Для этого достаточно просто добавить запятую перед кодом
типа значения, как показано ниже:

\>>> ‘{0:d}’.format(999999999999)
‘999999999999’
\>>> ‘{0:,d}’.format(999999999999)
‘999,999,999,999’

 Кроме того, в Python 3.1 имеется возможность не указывать явно
порядковые номера позиционных аргументов. В этом случае аргументы
из списка будут выбираться последовательно, однако использование этой
особенности может свести к нулю основное преимущество метода format,
как это описывается в следующем разделе:
\>>> ‘{:,d}’.format(999999999999)
‘999,999,999,999’
\>>> ‘{:,d} {:,d}’.format(9999999, 8888888)
‘9,999,999 8,888,888’

\>>> ‘{:,.2f}’.format(296999.2567)
‘296,999.26’

 Официально в этой книге не рассматривается версия 3.1, поэтому данное
примечание следует рассматривать только как предварительное.
Дополнительно в версии Python 3.1 будут ликвидированы основные проблемы
производительности, наблюдающиеся в версии 3.0, связанные с файловыми
операциями ввода/вывода, и делающие версию  3.0 �непривлекательной
для большинства применений. Дополнительные подробности вы найдете
в примечаниях к выпуску 3.1. Ознакомьтесь также со сценарием formats.py
в главе 24, где вы найдете приемы добавления запятых и форматирования
денежных сумм вручную, которые можно использовать, пока не вышла
в свет версия Python 3.1.


 Когда может пригодиться новый метод format?

 Теперь, когда я потратил столько слов, чтобы сравнить
и противопоставить два способа форматирования, я должен объяснить,
когда может пригодиться метод format. В двух словах: несмотря на то,
что использование метода форматирования требует вводить больше
программного кода, тем не менее:

  Он обладает некоторыми особенностями, отсутствующими в операторе
 форматирования %

  Позволяет более явно ссылаться на аргументы

  Вместо символа оператора используется более говорящее имя метода

  Не различает случаи, когда выполняется подстановка одного
 или нескольких значений

На сегодняшний день доступны оба приема, и оператор форматирования
по-прежнему находит широкое применение, тем не менее метод format
в конечном итоге может вытеснить его. Но пока у вас есть выбор, поэтому
прежде чем двинуться дальше подробнее остановимся на некоторых
отличиях.


 Дополнительные возможности

 Метод format поддерживает дополнительные возможности, недоступные при
использовании оператора %, такие, как отображение чисел в двоичном
формате и (появившаяся в Python 3.1) возможность разделения групп
разрядов. Кроме того, метод format позволяет напрямую обращаться
к ключам словарей и атрибутам объектов в строке формата. Однако,
как мы уже видели, при использовании оператора % того же эффекта можно
добиться другими способами:

\>>> ‘{0:b}’.format((2 ** 16) -1)
‘1111111111111111’
\>>> ‘%b’ % ((2 ** 16) -1)
ValueError: unsupported format character ‘b’ (0x62) at index 1

\>>> bin((2 ** 16) -1)
‘0b1111111111111111’
\>>> ‘%s’ % bin((2 ** 16) -1)[2:]
‘1111111111111111’


 Неявные ссылки на значения

 Один из случаев, когда реализация на основе метода format выглядит
более понятной, – подстановка большого количества значений в строку
формата. Так, в примере lister.py, который приводится в главе 30,
выполняется подстановка шести значений в одну строку формата; в этом
случае метки {i} в вызове метода format читаются проще,
чем спецификаторы %s в выражении форматирования:

‘\n%s<Class %s, address %s:\n%s%s%s>\n’ % (...)  # Выражение
‘\n{0}<Class {1}, address {2}:\n{3}{4}{5}>\n’.format(...)  # Метод

 С другой стороны, использование ключей словаря в операторе % позволяет
в значительной степени ликвидировать эту разницу. Кроме того,
этот случай можно отнести к наиболее сложным случаям форматирования,
которые редко встречаются на практике, – в более типичных случаях выбор
между двумя способами форматирования больше напоминает жеребьевку.
Кроме того, в версии Python 3.1 (когда писалась эта глава,
она находилась еще в состоянии альфа-версии) допускается не указывать
порядковые номера позиционных аргументов, что несколько снижает
преимущества метода format:

C:\misc> C:\Python31\python
\>>> ‘The {0} side {1} {2}’.format(‘bright’, ‘of’, ‘life’)
‘The bright side of life’
\>>>
\>>> ‘The {} side {} {}’.format(‘bright’, ‘of’, ‘life’)  # Python 3.1+
‘The bright side of life’
\>>>
\>>> ‘The %s side %s %s’ % (‘bright’, ‘of’, ‘life’)
‘The bright side of life’

 Использование возможности автоматической нумерации в версии 3.1,
как в данном примере, снижает преимущества метода format.
А если сравнить операции форматирования, например, вещественных чисел,
можно заметить, что выражение с оператором % по-прежнему получается
более компактным и выглядит менее запутанным:

C:\misc> C:\Python31\python
\>>> ‘{0:f}, {1:.2f}, {2:05.2f}’.format(3.14159, 3.14159, 3.14159)
‘3.141590, 3.14, 03.14’
\>>>
\>>> ‘{:f}, {:.2f}, {:06.2f}’.format(3.14159, 3.14159, 3.14159)
‘3.141590, 3.14, 003.14’
\>>>
\>>> ‘%f, %.2f, %06.2f’ % (3.14159, 3.14159, 3.14159)
‘3.141590, 3.14, 003.14’


 Имя метода и универсальные аргументы

 Учитывая появление в версии 3.1 возможности автоматической нумерации
параметров, единственными потенциальными преимуществами метода format
остаются замена оператора % более говорящим названием метода
и отсутствие различий между операциями с заменой единственного
или нескольких значений. Первое из этих преимуществ может заинтересовать
начинающих программистов (слово «format» в тексте программы распознается
проще, чем множество символов «%»), хотя это слишком субъективно.

 Последнее преимущество может оказаться более существенным –
при использовании оператора форматирования % единственное значение можно
указать непосредственно, но когда необходимо передать несколько
значений, они должны быть заключены в кортеж:

\>>> ‘%.2f’ % 1.2345
‘1.23’
\>>> ‘%.2f %s’ % (1.2345, 99)
‘1.23 99’

 С технической точки зрения, оператор форматирования принимает один
объект – либо само значение для подстановки, либо кортеж с одним
или более элементами. Фактически из-за того, что единственный элемент
может передаваться либо сам по себе, либо внутри кортежа, когда
возникает необходимость отформатировать кортеж, он должен быть оформлен,
как вложенный кортеж:

\>>> ‘%s’ % 1.23
‘1.23’
\>>> ‘%s’ % (1.23,)
‘1.23’
\>>> ‘%s’ % ((1.23,),)
‘(1.23,)’

 Метод format, напротив, ликвидирует различия между этими двумя
случаями, принимая одни и те же аргументы:

\>>> ‘{0:.2f}’.format(1.2345)
‘1.23’
\>>> ‘{0:.2f} {1}’.format(1.2345, 99)
‘1.23 99’
\>>> ‘{0}’.format(1.23)
‘1.23’
\>>> ‘{0}’.format((1.23,))
‘(1.23,)’

 Из всего вышесказанного можно сделать вывод, что метод format удобнее
для начинающих программистов и меньше способствует появлению ошибок
программирования. Однако эту проблему нельзя признать существенной –
если всегда заключать значения в кортеж и не пользоваться возможностью
прямой передачи единственного значения, оператор % по сути становится
похожим на метод format. Кроме того, из-за ограниченной гибкости метода
его использование приводит к увеличению объема программного кода,
и учитывая, что оператор форматирования широко использовался
на протяжении всей истории развития Python, пока не ясно, насколько
оправданно переводить существующий программный код на использование
нового инструмента, о чем мы поговорим в следующем разделе.


 Общие категории типов


 Типы одной категории имеют общий набор операций

 Как вы уже знаете, строки представляют собой неизменяемые
последовательности: они не могут быть изменены непосредственно
(неизменяемые) и являются упорядоченными коллекциями элементов,
доступ к которым может осуществляться по величине смещения
(последовательности). Оказывается, над последовательностями, которые мы
будем рассматривать в этой части книги, могут выполняться
те же операции, которые были продемонстрированы в этой главе, –
конкатенация, доступ к элементам по индексам, обход элементов в цикле
и так далее. Формально в языке Python существует три категории типов
(и операций):


 Числа (целые, вещественные, с фиксированной точностью,
рациональные и др.)

  Поддерживают операции сложения, умножения и так далее.

 Последовательности (строки, списки, кортежи)

  Поддерживают операции индексации, извлечения среза, конкатенации
 и так далее.

 Отображения (словари)

  Поддерживают операцию индексации по ключу и так далее.

 Множества образуют отдельную категорию типов (они не отображают ключи
в значения и не являются упорядоченными последовательностями), и мы еще
не рассматривали подробно отображения (словари обсуждаются в следующей
главе), но к другим типам, которые нам встретятся, в основном будут
применимы одни и те же операции. Например, для любых объектов
последовательностей X и Y:

  Выражение X + Y создает новый объект последовательности, включающий
 содержимое обоих операндов.
  Выражение X * N создает новый объект последовательности, включающий N
 копий операнда X.

 Другими словами, эти операции действуют одинаково на любые виды
последовательностей, включая строки, списки, кортежи и некоторые типы,
определяемые пользователем. Единственное отличие состоит в том,
что результат, возвращаемый выражением, имеет тот же тип, что и операнды
X и Y, то есть, если выполняется операция конкатенации списков,
то возвращается новый список, а не строка. Операции индексации
и извлечения среза одинаково работают для любых последовательностей –
тип объекта определяет, какая задача должна быть решена.


 Изменяемые типы допускают непосредственное изменение

 Классификация по возможности изменения – это слишком существенное
ограничение, чтобы не помнить о нем, и все же она часто сбивает с толку
начинающих программистов. Если объект является значением неизменяемого
типа, вы не сможете изменить его непосредственно – в этом случае
интерпретатор будет выдавать сообщение об ошибке. Вместо этого
необходимо, чтобы программный код создавал новый объект, содержащий
новое значение. Основные базовые типы данных в языке Python делятся
на следующие категории:

 Неизменяемые (числа, строки, кортежи, фиксированные множества)

  Объекты неизменяемых типов не поддерживают возможность
 непосредственного изменения значения объекта, однако вы всегда сможете
 создавать новые объекты с помощью выражений и присваивать их требуемым
 переменным.

 Изменяемые (списки, словари, множества)

  Объекты изменяемых типов, наоборот, всегда могут изменяться
 непосредственно, с помощью операций, которые не создают новые объекты.
 Изменяемые объекты могут быть скопированы, но они поддерживают
 и возможность непосредственного изменения.

 Вообще неизменяемые типы обеспечивают определенный уровень поддержки
целостности, гарантируя, что объект не подвергнется изменениям в другой
части программы. Чтобы вспомнить, почему это имеет
такое большое значение,
"""

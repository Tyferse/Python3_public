"""
 Словари

 После списков словари являются, пожалуй, самым гибким из встроенных
типов данных в языке Python. Если списки являются упорядоченными
коллекциями объектов, то в отличие от них элементы в словарях
сохраняются и извлекаются с помощью ключа, а не с помощью смещения,
определяющего их позицию.

 Будучи встроенным типом данных, словари могут заменить множество
алгоритмов поиска и структур данных, которые приходится реализовывать
вручную в низкоуровневых языках программирования, – доступ к элементам
словаря по их индексам представляет собой быструю операцию поиска.
Кроме того, иногда словари могут играть роль записей и таблиц символов,
используемых в других языках, и способны служить для представления
разреженных (по большей части пустых) структур данных. Ниже приводятся
основные характеристики словарей в языке Python:

 Доступ к элементам по ключу, а не по индексу

  Иногда словари называют ассоциативными массивами, или хешами. Они
 определяют взаимосвязь между значениями и ключами, поэтому
 для извлечения элементов словаря можно использовать ключи,
 под которыми эти элементы были сохранены в словаре. Для получения
 элементов словаря используется та же самая операция доступа по индексу,
 как и в списке, только индекс приобретает форму ключа, а не смещения
 относительно начала.

 Неупорядоченные коллекции произвольных объектов

  В отличие от списков, элементы словарей хранятся в неопределенном
 порядке. В действительности интерпретатор вносит элемент случайности
 в порядок следования элементов для обеспечения более быстрого поиска.
 Ключи описывают символическое (не физическое) местоположение элементов
 в словаре.

 Переменная длина, гетерогенность и произвольное число
уровней вложенности

  Подобно спискам словари могут увеличиваться и уменьшаться
 непосредственно (то есть без создания новых копий). Они могут содержать
 объекты любых типов и поддерживают возможность создания произвольного
 числа уровней вложенности (они могут содержать списки, другие словари
 и так далее).

 Относятся к категории «изменяемых отображений»

  Словари могут изменяться непосредственно с использованием операции
 индексирования (они являются изменяемыми), но они не поддерживают
 операции над последовательностями, которые поддерживаются строками
 и списками. Словари представляют собой неупорядоченные коллекции,
 поэтому операции, которые основаны на использовании фиксированного
 порядка следования элементов (например, конкатенация, извлечение
 среза), не имеют смысла для словарей. Словари – это единственный в
 строенный представитель объектов-отображений (объекты, которые
 отображают ключи на значения).

 Таблицы ссылок на объекты (хеш-таблицы)

  Если списки – это массивы ссылок на объекты, которые поддерживают
 возможность доступа к элементам по их позициям, то словари – это
 неупорядоченные таблицы ссылок на объекты, которые поддерживают доступ
 к элементам по ключу. Внутри словари реализованы как хеш-таблицы
 (структуры данных, которые обеспечивают очень высокую скорость поиска),
 изначально небольшого размера и увеличивающиеся по мере необходимости.
 Более того, интерпретатор Python использует оптимизированные алгоритмы
 хеширования для обеспечения максимально высокой скорости поиска ключей.
 Подобно спискам, словари хранят ссылки на объекты (а не их копии).

  Операция                           Интерпретация
  D = {}                             Пустой словарь

  D = {‘spam’: 2, ‘eggs’: 3}         Словарь из двух элементов

  D = {‘food’: {‘ham’: 1, ‘egg’: 2}} Вложение

  D = dict(name=’Bob’, age=40)       Альтернативные способы создания
  D = dict(zip(keyslist, valslist))  словарей: именованные аргументы,
  D = dict.fromkeys([‘a’, ‘b’])      применение функции zip,
                                     списки ключей

  D[‘eggs’]                          Доступ к элементу по ключу
  D[‘food’][‘ham’]

  ‘eggs’ in D                        Проверка на вхождение: проверка
                                     наличия ключа

  D.keys()                           Методы: список ключей,
  D.values()                         список значений,
  D.items()                          список ключей и значений,
  D.copy()                           копирование,
  D.get(key, default)                получение значения по умолчанию,
  D.update(D2)                       слияние,
  D.pop(key)                         удаление и так далее

  len(D)                             Длина (количество элементов)

  D[key] = 42                        Добавление/изменение ключей,
  del D[key]                         удаление ключей

  list(D.keys())                     Представления словарей
  D1.keys() & D2.keys()

  D = {x: x*2 for x in range(10)}    Генераторы словарей


 Словари в действии


 Базовые операции над словарями

 В обычном случае сначала создается словарь, а затем выполняются
операции сохранения новых ключей и обращения к элементам по ключу:

% python
\>>> D = {‘spam’: 2, ‘ham’: 1, ‘eggs’: 3}  # Создание словаря
\>>> D[‘spam’]                            # Извлечение значения по ключу
2
\>>> D                                    # Случайный порядок следования
{‘eggs’: 3, ‘ham’: 1, ‘spam’: 2}

 Здесь переменной D присваивается словарь, в котором ключу ‘spam’
соответствует целочисленное значение 2, и так далее. Для доступа
к элементам словаря используется тот же самый синтаксис с квадратными
скобками, что и при извлечении элементов списков, но в данном случае
доступ осуществляется по ключу, а не по позиции элемента.

 Обратите внимание на последнюю инструкцию в этом примере: порядок
следования ключей в словаре практически всегда отличается
от первоначального. Дело в том, что для обеспечения максимально высокой
скорости поиска по ключу (для хеширования) ключи должны располагаться
в памяти в ином порядке. Именно поэтому операции, которые предполагают
наличие установленного порядка следования элементов слева направо
(например, извлечение среза, конкатенация), неприменимы к словарям –
они позволяют извлекать значения только по ключам, а не по индексам.

 Встроенная функция len может работать и со словарями – она возвращает
число элементов в словаре или, что то же самое, длину списка ключей.
Оператор in проверки вхождения позволяет проверить наличие ключа,
а метод keys возвращает все ключи, имеющиеся в словаре, в виде списка.
Последний удобно использовать для последовательной обработки словарей,
но при этом вы не должны делать какие-либо предположения о порядке
следования ключей в списке. Поскольку результатом вызова метода keys
является список, он всегда может быть отсортирован (ниже мы подробнее
коснемся проблемы сортировки словарей):

\>>> len(D)  # Число элементов словаря
3
\>>> ‘ham’ in D  # Проверка на вхождение
True
\>>> list(D.keys())  # Создает новый список ключей
[‘eggs’, ‘ham’, ‘spam’]

 Обратите внимание на второе выражение в этом листинге. Как уже
упоминалось ранее, оператор проверки на вхождение in может
использоваться для работы со строками и списками, но точно так же он
может использоваться и для работы со словарями. Это возможно благодаря
тому, что словари определяют итераторы, которые обеспечивают пошаговый
обход списков ключей. Существуют и другие типы, которые поддерживают
итераторы, отвечающие обычному использованию типа; например, файлы имеют
итераторы, которые позволяют выполнять построчное чтение данных.

 Обратите также внимание на синтаксис последнего примера в листинге.
В версии Python 3.0 мы были вынуждены заключить вызов метода в вызов
функции list по уже встречавшейся ранее причине – в версии 3.0 метод
keys возвращает итератор, а не список. Вызов функции list принудительно
выполняет обход всех значений итератора, что позволяет вывести
их все сразу. В версии 2.6 метод keys конструирует и возвращает
обычный список, поэтому для отображения результатов вызов функции list
в этой версии интерпретатора не требуется. Подробнее об этом
рассказывается ниже, в этой главе.


 Изменение словарей

 Давайте продолжим работу в интерактивном сеансе. Словари, как и списки,
относятся к категории изменяемых объектов, поэтому их можно изменять,
увеличивать, уменьшать непосредственно, не создавая новые словари:
чтобы изменить или создать новую запись в словаре, достаточно выполнить
операцию присваивания по ключу. Инструкция del также может применяться
к словарям – она удаляет значение, связанное с ключом, который играет
роль индекса. Кроме того, обратите внимание на наличие вложенного
списка в следующем примере (значение для ключа ‘ham’). Все
типы-коллекции в языке Python могут вкладываться друг в друга
в произвольном порядке:

\>>> D
{‘eggs’: 3, ‘ham’: 1, ‘spam’: 2}

\>>> D[‘ham’] = [‘grill’, ‘bake’, ‘fry’]  # Изменение элемента
\>>> D
{‘eggs’: 3, ‘ham’: [‘grill’, ‘bake’, ‘fry’], ‘spam’: 2}

\>>> del D[‘eggs’]  # Удаление элемента
\>>> D
{‘ham’: [‘grill’, ‘bake’, ‘fry’], ‘spam’: 2}

\>>> D[‘brunch’] = ‘Bacon’  # Добавление нового элемента
\>>> D
{‘brunch’: ‘Bacon’, ‘ham’: [‘grill’, ‘bake’, ‘fry’] , ‘spam’: 2}

 Как и в случае со списками, операция присваивания по существующему
ключу словаря приводит к изменению ассоциированного с ним значения.
Однако в отличие от списков, словари допускают выполнение присваивания
по новому ключу (который ранее отсутствовал), в результате создается
новый элемент словаря, как показано в предыдущем примере для ключа
‘brunch’. Этот прием не может применяться к спискам, потому что в этом
случае интерпретатор обнаруживает выход за пределы списка и генерирует
сообщение об ошибке. Чтобы увеличить размер списка, необходимо
использовать такие инструменты списков, как метод append
или присваивание срезу.


 Дополнительные методы словарей

 Методы словарей обеспечивают выполнение различных операций. Например,
методы словарей values и items возвращают список значений элементов
словаря и кортежи пар (key, value) соответственно:

\>>> D = {‘spam’: 2, ‘ham’: 1, ‘eggs’: 3}
\>>> list(D.values())
[3, 1, 2]
\>>> list(D.items())
[(‘eggs’, 3), (‘ham’, 1), (‘spam’, 2)]

 Такие списки удобно использовать в циклах, когда необходимо выполнить
обход элементов словаря. Попытка извлечения несуществующего элемента
словаря обычно приводит к появлению ошибки, однако метод get в таких
случаях возвращает значение по умолчанию (None или указанное значение).
С помощью этого метода легко можно реализовать получение значений
по умолчанию и избежать появления ошибки обращения к несуществующему
ключу:

\>>> D.get(‘spam’)  # Ключ присутствует в словаре
2
\>>> print(D.get(‘toast’))  # Ключ отсутствует в словаре
None
\>>> D.get(‘toast’, 88)
88

 Метод update реализует своего рода операцию конкатенации для словарей,
при этом он не имеет никакого отношения к упорядочению элементов слева
направо (для словарей такое упорядочение не имеет смысла). Он объединяет
ключи и значения одного словаря с ключами и значениями другого, просто
перезаписывая значения с одинаковыми ключами:

\>>> D
{‘eggs’: 3, ‘ham’: 1, ‘spam’: 2}
\>>> D2 = {‘toast’:4, ‘muffin’:5}
\>>> D.update(D2)
\>>> D
{‘toast’: 4, ‘muffin’: 5, ‘eggs’: 3, ‘ham’: 1, ‘spam’: 2}

 Наконец, метод pop удаляет ключ из словаря и возвращает его значение.
Он напоминает метод pop списков, только вместо необязательного индекса
элемента принимает ключ:

# удаление элементов словаря по ключу
\>>> D
{‘toast’: 4, ‘muffin’: 5, ‘eggs’: 3, ‘ham’: 1, ‘spam’: 2}
\>>> D.pop(‘muffin’)
5
\>>> D.pop(‘toast’)  # Удаляет и возвращает значение заданного ключа
\>>> D
{‘eggs’: 3, ‘ham’: 1, ‘spam’: 2}

# удаление элементов списка по номеру позиции
\>>> L = [‘aa’, ‘bb’, ‘cc’, ‘dd’]
\>>> L.pop()  # Удаляет и возвращает последний элемент списка
‘dd’
\>>> L
[‘aa’, ‘bb’, ‘cc’]
\>>> L.pop(1)  # Удаляет и возвращает элемент из заданной позиции
‘bb’
\>>> L
[‘aa’, ‘cc’]

 Кроме того, словари имеют метод copy, который мы рассмотрим в главе 9,
как один из способов избежать побочных эффектов, связанных с наличием
нескольких ссылок на один и тот же словарь.


 Таблица языков

 Давайте рассмотрим более жизненный пример словаря. В следующем примере
создается таблица, которая отображает названия языков программирования
(ключи) на имена их создателей (значения). С помощью этой таблицы можно
по названию языка программирования определить имя его создателя:

\>>> table = {‘Python’: ‘Guido van Rossum’,
... ‘Perl’: ‘Larry Wall’,
... ‘Tcl’: ‘John Ousterhout’ }
\>>>
\>>> language = ‘Python’
\>>> creator = table[language]
\>>> creator
‘Guido van Rossum’

\>>> for lang in table:  # То же, что и: for lang in table.keys()
... print(lang, ‘\t’, table[lang])
...
Tcl John Ousterhout
Python Guido van Rossum
Perl Larry Wall

 Словари не являются последовательностями, как списки и строки,
но если необходимо выполнить обход элементов словаря, в этом нет ничего
сложного – это легко сделать с помощью метода keys, возвращающего все
ключи словаря, которые можно обойти в цикле for. В случае необходимости
внутри цикла можно получать значение элемента по его ключу, как это
реализовано в данном примере.

 Кроме того, Python в действительности позволяет выполнять обход ключей
словаря и без вызова метода keys в операторе цикла for. Для любого
словаря D цикл можно оформить как for key in D:, что равносильно полной
форме записи for key in D.keys():. Это всего лишь еще одна разновидность
итераторов, упоминавшихся ранее, которая позволяет использовать оператор
проверки вхождения in со словарями (подробнее об итераторах далее
в книге).


 Замечания по использованию словарей

 Словари окажутся достаточно просты в использовании, когда вы освоите
работу с ними, но я хочу привести несколько соображений, которые вам
следует твердо знать:

  Операции над последовательностями неприменимы к словарям.

  Присваивание по несуществующему индексу приводит к созданию нового
 элемента.

  Ключи необязательно должны быть строками.


 Использование словарей для имитации гибких списков

 Последнее замечание в предыдущем списке имеет настолько важное
значение, что имеет смысл продемонстрировать его применение
на нескольких примерах. Списки не допускают возможность присваивания
по индексам, находящимся за пределами списков:

\>>> L = []
\>>> L[99] = ‘spam’
Traceback (most recent call last):
File “<stdin>”, line 1, in ?
IndexError: list assignment index out of range

 Можно, конечно, с помощью операции повторения создать список достаточно
большой длины (например, [0]*100), но можно создать нечто похоже,
задействовав словарь, который не требует такого выделения пространства.
При использовании целочисленных ключей словари могут имитировать списки,
которые увеличиваются при выполнении операции присваивания по смещению:

\>>> D = {}
\>>> D[99] = ‘spam’
\>>> D[99]
‘spam’
\>>> D
{99: ‘spam’}

 Результат выглядит так, как если бы D был списком из 100 элементов,
но на самом деле это словарь с единственным элементом – значением ключа
99 является строка ‘spam’. В такой структуре можно обращаться
по смещениям, как в списке, но при этом не требуется выделять
пространство для всех позиций, которые могут когда-либо потребоваться
при выполнении программы. При использовании подобным образом словари
представляют собой более гибкие эквиваленты списков.


 Использование словарей для структур разреженных данных

 Похожим образом словари могут использоваться для реализации структур
разреженных данных, таких как многомерные массивы, где всего несколько
элементов имеют определенные значения:

\>>> Matrix = {}
\>>> Matrix[(2, 3, 4)] = 88
\>>> Matrix[(7, 8, 9)] = 99
\>>>
\>>> X = 2; Y = 3; Z = 4  # символ ; отделяет инструкции
\>>> Matrix[(X, Y, Z)]
88
\>>> Matrix
{(2, 3, 4): 88, (7, 8, 9): 99}

 Здесь словарь использован для представления трехмерного массива,
в котором только два элемента, (2,3,4) и (7,8,9), имеют определенные
значения. Ключами словаря являются кортежи, определяющие координаты
непустых элементов. Благодаря этому вместо трехмерной матрицы, объемной
и по большей части пустой, оказалось достаточно использовать словарь из
двух элементов. В такой ситуации попытка доступа к пустым элементам
будет приводить к возбуждению исключения, так как эти элементы
физически отсутствуют:

\>>> Matrix[(2,3,6)]
Traceback (most recent call last):
File “<stdin>”, line 1, in ?
KeyError: (2, 3, 6)


 Как избежать появления ошибок обращения к несуществующему ключу

 Ошибки обращения к несуществующему ключу являются обычными при
работе с разреженными матрицами, но едва ли кто-то захочет, чтобы они
приводили к преждевременному завершению программы. Существует
по крайней мере три способа получить значение по умолчанию вместо
возбуждения исключения – можно предварительно проверить наличие ключа
с помощью условного оператора if, воспользоваться конструкцией try,
чтобы перехватить и явно обработать исключение, или просто использовать
представленный ранее метод словаря get, способный возвращать значение
по умолчанию для несуществующих ключей:

\>>> if (2,3,6) in Matrix:  # Проверить наличие ключа перед обращением
\... print(Matrix[(2,3,6)])
... else:
... print(0)
...
0
\>>> try:
... print(Matrix[(2,3,6)])  # Попытаться обратиться по индексу
... except KeyError:   # Перехватить исключение и обработать
... print(0)
...
0
\>>> Matrix.get((2,3,4), 0)  # Существует; извлекается и возвращается
88
\>>> Matrix.get((2,3,6), 0)  # Отсутствует; используется
0                            # аргумент default

 Способ, основанный на применении метода get, является самым простым
из приведенных, если оценивать объем программного кода, – инструкции if
и try подробно будут рассматриваться далее в этой книге.

 Использование словарей в качестве «записей»

 Как видите, словари в языке Python способны играть множество ролей.
Вообще говоря, они способны заменить реализацию алгоритмов поиска
в структурах (потому что операция индексирования по ключу уже является
операцией поиска) и могут представлять самые разные типы
структурированной информации. Например, словари представляют один
из многих способов описания свойств элементов в программах, то есть
они могут играть ту же роль, какую играют «структуры» и «записи»
в других языках программирования. В следующем примере выполняется
заполнение словаря путем присваивания значений новым ключам в виде
нескольких инструкций:

\>>> rec = {}
\>>> rec[‘name’] = ‘mel’
\>>> rec[‘age’] = 45
\>>> rec[‘job’] = ‘trainer/writer’
\>>>
\>>> print(rec[‘name’])
mel

 Встроенные типы языка Python позволяют легко представлять
структурированную информацию; это особенно заметно, когда появляются
уровни вложенности. В следующем примере снова используется словарь
для хранения свойств объекта, но на этот раз заполнение производится
в единственной инструкции (вместо того, чтобы выполнять присваивание
каждому ключу в отдельности), причем здесь присутствуют вложенные
список и словарь, чтобы обеспечить представление структурированных
свойств объекта:

\>>> mel = {‘name’: ‘Mark’,
... ‘jobs’: [‘trainer’, ‘writer’],
... ‘web’: ‘www.rmi.net/~lutz’,
... ‘home’: {‘state’: ‘CO’, ‘zip’:80513}}

 Чтобы извлечь компоненты вложенных объектов, достаточно просто
объединить в цепочку операции индексирования:

\>>> mel[‘name’]
‘Mark’
\>>> mel[‘jobs’]
[‘trainer’, ‘writer’]
\>>> mel[‘jobs’][1]
‘writer’
\>>> mel[‘home’][‘zip’]
80513

 Хотя в четвертой части книги будет показано, что классы (объединяющие
в себе данные и логику их обработки) еще лучше справляются с ролью
записей, в простых случаях словари являются простым и удобным
инструментом.


 Придется держать в уме: интерфейсы словарей

 Помимо удобного способа хранения информации по ключам непосредственно
в программе, некоторые расширения для Python также предоставляют
интерфейсы, которые выглядят и действуют как словари. Например,
обращение к индексированным файлам данных в формате DBM во многом
напоминает обращение к словарю, который сначала требуется открыть.
Строки сохраняются и извлекаются с помощью операции индексирования
по ключу:

import anydbm
file = anydbm.open(“filename”) # Ссылка на файл
file[‘key’] = ‘data’ # Сохранение данных по ключу
data = file[‘key’] # Извлечение данных по ключу

 В главе 27 будет показано, как таким же способом можно сохранять
целые объекты Python, достаточно лишь заменить имя модуля anydbm на
shelve (shelves (хранилища) – это базы данных с доступом к информации
по ключу, предназначенные для хранения объектов Python). Для работы
в Интернете поддержка CGI-сценариев, предусмотренная в языке Python,
также обеспечивает интерфейс, напоминающий словарь. Вызов метода
cgi.FieldStorage возвращает объект, по своим характеристикам
напоминающий словарь, – с одной записью для каждого поля ввода,
находящегося на клиентской веб-странице:

import cgi
form = cgi.FieldStorage() # Анализирует данные формы
if ‘name’ in form:
showReply(‘Hello, ‘ + form[‘name’].value)

 Все эти объекты (и словари, в том числе) являются примерами
отображений. Как только вы овладеете словарными интерфейсами, вы
обнаружите, что они имеют отношение ко множеству встроенных
инструментов языка Python.


 Другие способы создания словарей

 Наконец, обратите внимание, что благодаря практической ценности
словарей с течением времени способы их создания пополнялись.
В Python 2.3 и более поздних версиях, например, последние два вызова
конструктора dict (в действительности – имени типа) в следующем ниже
примере имеют тот же эффект, что и литералы и форма присваивания
по отдельным ключам в примере выше:

{‘name’: ‘mel’, ‘age’: 45}  # Традиционное литеральное выражение

D = {}  # Динамическое присваивание по ключам
D[‘name’] = ‘mel’
D[‘age’] = 45

dict(name=’mel’, age=45)  # Форма именованных аргументов

dict([(‘name’, ‘mel’), (‘age’, 45)])  # Кортежи ключ/значение

 Все четыре варианта создают один и тот же словарь, содержащий два
элемента, которые удобно использовать в следующих случаях:

  Первый вариант удобен, если содержимое всего словаря известно
 заранее.

  Второй вариант удобно использовать, когда необходимо динамически
 создавать словарь по одному полю за раз.

  Третий вариант с использованием именованных аргументов даже
 компактнее, чем литералы, но он требует, чтобы все ключи были строками.

  Последний вариант удобен, когда ключи и значения во время выполнения
 программы необходимо хранить в виде последовательностей.

 С именованными аргументами мы уже встречались ранее, когда
рассматривали операцию сортировки. Третья форма, показанная в листинге,
стала особенно популярной в последнее время, как наиболее компактная
(и, как следствие, менее подверженная ошибкам). Как было показано
в конце табл., последний вариант также часто используется в соединении
с функцией zip, которая позволяет объединить отдельные списки ключей
и значений, создаваемые динамически во время выполнения (например,
при извлечении данных из столбцов в файле). Подробнее об этой
возможности рассказывается в следующем разделе. Если значения всех
ключей словаря остаются все время одними и теми же, можно использовать
специализированную форму инициализации словаря, при использовании
которой достаточно просто передать список ключей и начальное значение
(по умолчанию используется значение None):

\>>> dict.fromkeys([‘a’, ‘b’], 0)
{‘a’: 0, ‘b’: 0}

 В настоящее время вполне можно обойтись простыми литералами и операцией
присваивания по ключам, но вы наверняка найдете применение всем
упомянутым вариантам создания словарей, как только приступите к созданию
настоящих, гибких и динамических программ на языке Python.

 В листингах, которые приводятся в этом разделе, представлены различные
способы создания словарей, общие для обеих версий Python 2.6 и 3.0.
Однако существует еще один способ создания словарей, доступный только
в версии Python 3.0 (и выше): генератор словарей. Чтобы посмотреть,
как используется эта форма, мы должны перейти к следующему разделу.


 Изменения в словарях в Python 3.0


  Поддерживают новые выражения генераторов словарей, близко напоминающие
 генераторы списков и множеств.

  Методы D.keys, D.values и D.items возвращают итерируемые представления
 вместо списков.

  Вследствие особенности, описанной в предыдущем пункте, требуют
 по иному выполнять обход ключей в отсортированном порядке.

  Больше не поддерживают возможность непосредственного сравнивания между
 собой – теперь сравнивание должно выполняться вручную.

  Больше не поддерживают метод D.has_key – вместо него следует
 использовать оператор in проверки на вхождение.


 Генераторы словарей

 Как отмечалось в конце предыдущего раздела, в версии 3.0 появилась
возможность создавать словари с помощью генераторов словарей. Как
и генераторы множеств, с которыми мы встречались в главе 5, генераторы
словарей доступны только в версии 3.0 (они недоступны в версии 2.6).
Подобно давно существующим генераторам списков, с которыми
мы встречались в главе 4 и ранее в этой главе, генераторы словарей
выполняют цикл, отбирают пары ключ/значение в каждой итерации
и заполняют ими новый словарь. Значения, получаемые в ходе итераций,
доступны в виде переменной цикла.

 Например, одним из стандартных способов динамической инициализации
словаря в версиях 2.6 и 3.0 является использование функции zip для
объединения ключей и значений с последующей передачей результата функции
dict. Как мы узнаем в главе 13, функция zip позволяет единственным
вызовом создать словарь из списков ключей и значений. Если множество
ключей и значений заранее не известно, вы всегда можете поместить их
в списки в процессе вычислений и затем объединить их воедино:

\>>> list(zip([‘a’, ‘b’, ‘c’], [1, 2, 3]))  # Объединить ключи
[(‘a’, 1), (‘b’, 2), (‘c’, 3)]              # и значения
\>>> D = dict(zip([‘a’, ‘b’, ‘c’], [1, 2, 3]))  # Создать словарь
\>>> D  # вызова функции zip                      из результата
{‘a’: 1, ‘c’: 3, ‘b’: 2}

 В Python 3.0 того же эффекта можно добиться с помощью генератора
словарей. В следующем примере демонстрируется создание нового словаря
из пар ключ/значение, которые извлекаются из результата вызова функции
zip (это выражение читается практически точно так же, хотя и выглядит
немного сложнее):

C:\misc> c:\python30\python  # Использование генератора словарей
\>>> D = {k: v for (k, v) in zip([‘a’, ‘b’, ‘c’], [1, 2, 3])}
\>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}

 Генераторы словарей выглядят менее компактными, но они гораздо более
универсальны, чем можно было бы предположить, исходя из этого примера, –
мы можем использовать их для отображения единственной последовательности
значений в словари, вычисляя ключи с помощью выражений, как обычные
значения:

\>>> D = {x: x ** 2 for x in [1, 2, 3, 4]}  #  Или: range(1, 5)
\>>> D
{1: 1, 2: 4, 3: 9, 4: 16}

\>>> D = {c: c * 4 for c in ‘SPAM’}  # Цикл через итерируемый объект
\>>> D
{‘A’: ‘AAAA’, ‘P’: ‘PPPP’, ‘S’: ‘SSSS’, ‘M’: ‘MMMM’}

\>>> D = {c.lower(): c + ‘!’ for c in [‘SPAM’, ‘EGGS’, ‘HAM’]}
\>>> D
{‘eggs’: ‘EGGS!’, ‘ham’: ‘HAM!’, ‘spam’: ‘SPAM!’}

 Генераторы словарей удобно использовать для инициализации словарей из
списков ключей, почти так же, как это делает метод fromkeys, с которым
мы встречались в предыдущем разделе:

\>>> D = dict.fromkeys([‘a’, ‘b’, ‘c’], 0)  # Инициализация списком
\>>> D                                      # ключей
{‘a’: 0, ‘c’: 0, ‘b’: 0}

\>>> D = {k:0 for k in [‘a’, ‘b’, ‘c’]}  # То же самое, но с помощью
\>>> D  # генератора словаря
{‘a’: 0, ‘c’: 0, ‘b’: 0}

\>>> D = dict.fromkeys(‘spam’)  # Из другого итерируемого объекта,
\>>> D  # используются значения по умолчанию
{‘a’: None, ‘p’: None, ‘s’: None, ‘m’: None}

\>>> D = {k: None for k in ‘spam’}
\>>> D
{‘a’: None, ‘p’: None, ‘s’: None, ‘m’: None}

 Подобно родственным инструментам, генераторы словарей поддерживают
дополнительные возможности, которые не были продемонстрированы здесь,
включая вложенные циклы и условные инструкции if. К сожалению, чтобы
полностью понять все возможности генераторов словарей, нам необходимо
познакомиться поближе с концепцией и инструкциями итераций в языке
Python, – но у нас пока недостаточно знаний, чтобы обсуждать эту тему.
Мы познакомимся поближе со всеми разновидностями генераторов (списков,
множеств и словарей) в главах 14 и 20, поэтому отложим пока обсуждение
деталей. Кроме того, в главе 13 мы поближе познакомимся со встроенной
функцией zip, которую использовали в этом разделе, когда будем
исследовать циклы for.


 Представления словарей

 В версии 3.0 методы словарей keys, values и items возвращают объекты
представлений, тогда как в версии 2.6 они возвращают списки. Объекты
представлений – это итерируемые объекты, то есть объекты, которые вместо
всего списка значений возвращают по одному значению за одно обращение.
Кроме того, что они являются итерируемыми объектами, представления
словарей также сохраняют оригинальный порядок следования компонентов
словаря, отражают результаты операций, которые выполняются над словарем,
и поддерживают операции над множествами. С другой стороны, они
не являются списками и не поддерживают такие операции, как обращение
к элементам по индексам или метод sort списков, а также не отображают
значения своих элементов при выводе.

 Понятие итерируемого объекта более формально будет рассматриваться
в главе 14, а пока нам достаточно будет знать, что результаты этих трех
методов необходимо обертывать вызовом встроенной функции list, –
если появится необходимость применить операции над списками
или отобразить значения элементов:

\>>> D = dict(a=1, b=2, c=3)
\>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}

\>>> K = D.keys()  # В версии 3.0 создаст объект представления,
\>>> K             # а не список
<dict_keys object at 0x026D83C0>

\>>> list(K)  # Принудительное создание списка в версии 3.0
[‘a’, ‘c’, ‘b’]

\>>> V = D.values()  # То же относится к представлениям значений
\>>> V               # и элементов
<dict_values object at 0x026D8260>

\>>> list(V)
[1, 3, 2]
\>>> list(D.items())
[(‘a’, 1), (‘c’, 3), (‘b’, 2)]

\>>> K[0]  # Ошибка при попытке выполнить операцию над списком
TypeError: ‘dict_keys’ object does not support indexing
\>>> list(K)[0]
‘a’

 Кроме случаев отображения результатов в интерактивной оболочке,
вы едва ли будете обращать внимание на эту особенность, потому что
конструкции обхода элементов в цикле в языке Python автоматически
заставляют итерируемые объекты возвращать по одному результату
в каждой итерации:

\'>>> for k in D.keys(): print(k)  # Работа с итераторами в циклах
... # выполняется автоматически
a
c
b

 Кроме того, в версии 3.0 словари по-прежнему остаются итерируемыми
объектами, которые последовательно возвращают ключи,
как и в версии 2.6, – что исключает необходимость вызывать метод keys:

\>>> for key in D: print(key)  # В итерациях по-прежнему не обязательно
... # вызывать метод keys()
a
c
b

 В отличие от списков, возвращаемых в виде результатов в версии 2.,
представления словарей в версии 3.0 способны динамически отражать все
последующие изменения в словарях, выполненные уже после создания объекта
отображения:

\>>> D = {‘a’:1, ‘b’:2, ‘c’:3}
\>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}

\>>> K = D.keys()
\>>> V = D.values()
\>>> list(K)  # Представления сохраняют оригинальный
[‘a’, ‘c’, ‘b’]  # порядок следования ключей в словаре
\>>> list(V)
[1, 3, 2]

\>>> del D[‘b’]  # Изменяет словарь непосредственно
\>>> D
{‘a’: 1, ‘c’: 3}

\>>> list(K)  # Изменения в словаре отражаются на объектах представлений
[‘a’, ‘c’]
\>>> list(V)  # Но это не так в версии 2.X!
[1, 3]


 Представления словарей и множества

 Кроме того, в отличие от списков результатов, возвращаемых
в версии 2.X, объекты представлений в версии 3.0, возвращаемые методом
keys, похожи на множества и поддерживают операции над множествами,
такие как пересечение и объединение. Объекты представлений, возвращаемые
методом values, такой особенностью не обладают, потому что они
не являются уникальными, тогда как объекты представлений, возвращаемые
методом items, такой особенностью обладают, если пары (key, value)
являются уникальными и хэшируемыми. Учитывая, что множества достаточно
сильно похожи на словари, ключи которых не имеют значений (и даже
литералы множеств в версии 3.0 заключаются в фигурные скобки,
как словари), это обстоятельство выглядит вполне логичным. Подобно
ключам словарей, элементы множеств неупорядоченны, уникальны
и относятся к разряду неизменяемых объектов.

 Ниже наглядно показано, как интерпретируются списки ключей, когда они
используются в операциях над множествами. В таких операциях объекты
представлений могут смешиваться с другими представлениями, множествами
и словарями (в этом случае словари интерпретируются точно так же,
как представления, возвращаемые методом keys):

\>>> K | {‘x’: 4}  # Представления ключей (и иногда элементов)
{‘a’, ‘x’, ‘c’}  # похожи на множества
\>>> V & {‘x’: 4}
TypeError: unsupported operand type(s) for &: ‘dict_values’ and ‘dict’
\>>> V & {‘x’: 4}.values()
TypeError: unsupported operand type(s) for &: ‘dict_values’ \
and ‘dict_values’
\>>> D = {‘a’:1, ‘b’:2, ‘c’:3}
\>>> D.keys() & D.keys()  # Пересечение представлений ключей
{‘a’, ‘c’, ‘b’}
\>>> D.keys() & {‘b’}  # Пересечение представления ключей и множества
{‘b’}
\>>> D.keys() & {‘b’: 1}  # Пересечение представления ключей и словаря
{‘b’}
\>>> D.keys() | {‘b’, ‘c’, ‘d’}  # Объединение представления ключей
{‘a’, ‘c’, ‘b’, ‘d’}             # и множества

 Представления элементов словарей также могут обладать свойствами
множеств, если они допускают возможность хеширования, – то есть,
если они содержат только неизменяемые объекты:

\>>> D = {‘a’: 1}
\>>> list(D.items())  # Элементы похожи на множества, если они допускают
[(‘a’, 1)]            # возможность хеширования
\>>> D.items() | D.keys()  # Объединение представлений
{(‘a’, 1), ‘a’}
\>>> D.items() | D  # Словари интерпретируются как представление ключей
{(‘a’, 1), ‘a’}
\>>> D.items() | {(‘c’, 3), (‘d’, 4)}  # Множество пар ключ/значение
{(‘a’, 1), (‘d’, 4), (‘c’, 3)}
\>>> dict(D.items() | {(‘c’, 3), (‘d’, 4)})  # Функция dict принимает
{‘a’: 1, ‘c’: 3, ‘d’: 4}         # также итерируемые объекты множеств

 За дополнительной информацией об операциях над множествами обращайтесь
к главе 5. А теперь давайте коротко рассмотрим три другие особенности
словарей, появившиеся в версии 3.0.


 Сортировка ключей словаря

 Во-первых, из-за того, что теперь метод keys не возвращает список,
традиционный прием просмотра содержимого словаря по отсортированным
ключам, который используется в версии 2.X, непригоден в версии 3.0.
Для этого необходимо либо преобразовать объект представления ключей
в список, либо воспользоваться функцией sorted, представленной
в главе 4 и выше в этой главе, применив ее к объекту, возвращаемому
методу keys, или к самому словарю:

\>>> D = {‘a’:1, ‘b’:2, ‘c’:3}
\>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}

\>>> Ks = D.keys()  # Сортировка объекта представления
\>>> Ks.sort()      # не дает желаемого результата!
AttributeError: ‘dict_keys’ object has no attribute ‘sort’

\>>> Ks = list(Ks)  # Преобразовать в список и потом отсортировать
\>>> Ks.sort()
\>>> for k in Ks: print(k, D[k])
...
a 1
b 2
c 3

\>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}
\>>> Ks = D.keys()  # Или вызвать функцию sorted()
                    # с результатом вызова keys
\>>> for k in sorted(Ks): print(k, D[k])  # sorted() принимает
... # итерируемые объекты и возвращает результат
a 1
b 2
c 3

\>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}  # Еще лучше отсортировать сам словарь
\>>> for k in sorted(D): print(k, D[k])  # Итератор словаря возвращает
...                                      # ключи
a 1
b 2
c 3


 Операция сравнения словарями больше не поддерживается

 Во-вторых, в Python 2.6 словари могут сравниваться между собой
с помощью операторов <, > и других, но в Python 3.0 эта возможность
больше не поддерживается. Однако ее можно имитировать, сравнив
отсортированные списки ключей вручную:

sorted(D1.items()) < sorted(D2.items())
# То же, что и D1 < D2 в версии 2.6

 Тем не менее в версии 3.0 сохранилась возможность проверки словарей
на равенство. Поскольку мы еще вернемся к этой теме в следующей главе,
когда будем рассматривать операции сравнения в более широком контексте,
отложим до этого момента обсуждение деталей.


 Метод has_key умер, да здравствует has_key!

 Наконец, широко используемый метод has_key словарей, выполняющий
проверку наличия ключей, был ликвидирован в версии 3.0. Вместо него
рекомендуется использовать оператор in проверки на вхождение
или проверять результат вызова метода get на равенство значению
по умолчанию (первый вариант предпочтительнее):

\>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}

\>>> D.has_key(‘c’)  # Только в версии 2.X: True/False
AttributeError: ‘dict’ object has no attribute ‘has_key’

\>>> ‘c’ in D
True
\>>> ‘x’ in D
False
\>>> if ‘c’ in D: print(‘present’, D[‘c’])
...# Предпочтительнее в версии 3.0
present 3

\>>> print(D.get(‘c’))
3
\>>> print(D.get(‘x’))
None
\>>> if D.get(‘c’) != None: print(‘present’, D[‘c’])
...# Еще одна возможность
present 3
"""

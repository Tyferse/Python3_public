"""
 Множества

 В версии Python 2.4 также появился новый тип коллекций – множество,
неупорядоченная коллекция уникальных и неизменяемых объектов, которая
поддерживает операции, соответствующие математической теории множеств.
По определению, каждый элемент может присутствовать в множестве
в единственном экземпляре независимо от того,
сколько раз он будет добавлен. Множества могут применяться
в самых разных прикладных областях, но особенно часто они используются
в приложениях обработки числовых данных и при работе с базами данных.

 Поскольку этот тип является коллекцией других объектов, он обладает
некоторыми особенностями, присущими таким объектам, как списки
и словари, обсуждение которых выходит за рамки этой главы. Например,
множества поддерживают итерации, могут изменяться в размерах
при необходимости и могут содержать объекты разных типов.
Как мы увидим ниже, множество напоминает словарь, ключи в котором
не имеют значений, но поддерживает ряд дополнительных операций.

 Поскольку множества являются неупорядоченными коллекциями и не
отображают ключи на значения, они не могут быть отнесены
ни к последовательностям, ни к отображениям. Множества –
это отдельная категория типов. Но так как множества поддерживают набор
математических операций, мы познакомимся с основами использования
множеств в этой главе.


 Литералы множеств в Python 3.0

 Если вы уже были знакомы с множествами и считали их отличным
инструментом, то теперь они стали еще лучше. В Python 3.0 сохранилась
возможность использовать встроенную функцию set для создания объектов
множеств, но при этом появилась новая форма литералов множеств,
в которых используются фигурные скобки, прежде зарезервированные
для литералов словарей. В версии 3.0 следующие инструкции являются
эквивалентными:

set([1, 2, 3, 4])  # Вызов встроенной функции
{1, 2, 3, 4}  # Литерал множества в версии 3.0

 Такой синтаксис приобретает определенный смысл, если рассматривать
множества как словари, в которых ключи не имеют соответствующих
им значений. А поскольку множества являются неупорядоченными коллекциями
уникальных и неизменяемых объектов, элементы множеств близко напоминают
ключи словарей. Сходство становится еще более явным, если учесть,
что в версии 3.0 списки ключей в словарях являются объектами
представлений, поддерживающими такие операции над множествами,
как пересечение и объединение.

 Независимо от того, каким способом были созданы множества, в версии 3.0
они отображаются в новой форме литерала. В версии 3.0 встроенная функция
set все еще необходима для создания пустых множеств и конструирования
множеств на основе существующих итерируемых объектов, однако
для создания множеств с известным содержимым удобнее использовать
новую форму литералов:

C:\Misc> c:\python30\python
\>>> set([1, 2, 3, 4])  # Встроенная функция: та же, что и в 2.6
{1, 2, 3, 4}
\>>> set(‘spam’)  # Добавить все элементы итерируемого объекта
{‘a’, ‘p’, ‘s’, ‘m’}
\>>> {1, 2, 3, 4}  # Литералы множеств: нововведение в 3.0
{1, 2, 3, 4}
\>>> S = {‘s’, ‘p’, ‘a’, ‘m’}
\>>> S.add(‘alot’)
\>>> S
{‘a’, ‘p’, ‘s’, ‘m’, ‘alot’}

 Все операции над множествами, которые описывались в предыдущем разделе,
в версии 3.0 действуют точно так же, но вывод результатов выглядит
несколько иначе:

\>>> S1 = {1, 2, 3, 4}
\>>> S1 & {1, 3}  # Пересечение
{1, 3}
\>>> {1, 5, 3, 6} | S1  # Объединение
{1, 2, 3, 4, 5, 6}
\>>> S1 - {1, 3, 4}  # Разность
{2}
\>>> S1 > {1, 3}  # Надмножество
True

 Обратите внимание, что конструкция {} по-прежнему создает пустой
словарь. Чтобы создать пустое множество, следует вызвать встроенную
функцию set; результат операции вывода пустого множества выглядит
несколько иначе:

\>>> S1 - {1, 2, 3, 4}  # Пустое множество выводится иначе
set()
\>>> type({})  # Литерал {} обозначает пустой словарь
<class ‘dict’>
\>>> S = set()  # Инициализация пустого множества
\>>> S.add(1.23)
\>>> S
{1.23}

 Как и в Python 2.6, множества, созданные с помощью литералов
в версии 3.0, поддерживают те же методы, часть из которых способна
принимать итерируемые объекты в качестве операндов, чего не позволяют
операторы выражений:

\>>> {1, 2, 3} | {3, 4}
{1, 2, 3, 4}
\>>> {1, 2, 3} | [3, 4]
TypeError: unsupported operand type(s) for |: ‘set’ and ‘list’
\>>> {1, 2, 3}.union([3, 4])
{1, 2, 3, 4}
\>>> {1, 2, 3}.union({3, 4})
{1, 2, 3, 4}
\>>> {1, 2, 3}.union(set([3, 4]))
{1, 2, 3, 4}
\>>> {1, 2, 3}.intersection((1, 3, 5))
{1, 3}
\>>> {1, 2, 3}.issubset(range(-5, 5))
True


 Ограничения, связанные с неизменяемостью и фиксированные множества

 Множества – это гибкие и мощные объекты, но они имеют одно ограничение
в обеих версиях, 3.0 и 2.6, о котором следует помнить – из-за
особенностей реализации множества могут включать объекты только
неизменяемых (или так называемых «хэшируемых») типов. Отсюда следует,
что списки и словари не могут добавляться в множества, однако вы можете
использовать кортежи, если появится необходимость сохранять составные
значения. В операциях над множествами кортежи сравниваются
по своим полным значениям:

\>>> S
{1.23}
\>>> S.add([1, 2, 3])  # Добавляться могут только неизменяемые объекты
TypeError: unhashable type: ‘list’
\>>> S.add({‘a’:1})
TypeError: unhashable type: ‘dict’
\>>> S.add((1, 2, 3))
\>>> S  # Ни список, ни словарь не могут быть добавлены
{1.23, (1, 2, 3)} # но с кортежем таких проблем нет
\>>> S | {(4, 5, 6), (1, 2, 3)}
# Объединение: то же, что и S.union(...)
{1.23, (4, 5, 6), (1, 2, 3)}
\>>> (1, 2, 3) in S  # Членство: выявляется по полным значениям
True
\>>> (1, 4, 3) in S
False

 Кортежи в множествах могут использоваться, например, для хранения дат,
записей, IP-адресов и так далее (подробнее о кортежах рассказывается
ниже, в этой же части книги). Сами по себе множества являются
изменяемыми объектами и потому не могут вкладываться в другие множества,
однако, если вам потребуется сохранить одно множество внутри другого
множества, создайте множество с помощью встроенной функции frozenset,
которая действует точно так же, как функция set, но создает неизменяемое
множество, которое невозможно изменить и потому можно встраивать
в другие множества.


 Генераторы множеств в Python 3.0

 Кроме литералов, в версии 3.0 появилась конструкция генератора
множеств. По своему виду она напоминает конструкцию генератора списков,
с которой мы предварительно познакомились в главе 4; только генератор
множеств заключен не в квадратные, а в фигурные скобки, и в результате
создает множество, а не список. Генератор множеств выполняет цикл
и собирает результаты выражения в каждой итерации – доступ к значению
в текущей итерации обеспечивает переменная цикла. Результатом работы
генератора является новое множество, обладающее всеми особенностями
обычного множества:

\>>> {x ** 2 for x in [1, 2, 3, 4]}  # Генератор множеств в 3.0
{16, 1, 4, 9}

 Цикл, который генерирует значения, находится в этом выражении справа,
а выражение, осуществляющее формирование окончательных значений, –
слева (x ** 2). Как и в случае с генераторами списков, генератор
множеств возвращает именно то, что говорит: «Вернуть новое множество,
содержащее квадраты значений X, для каждого X из списка». В генераторах
можно также использовать другие виды итерируемых объектов,
такие как строки (первый пример в следующем листинге иллюстрирует
создание множества с помощью генератора на основе существующего
итерируемого объекта):

\>>> {x for x in ‘spam’}  # То же, что и: set(‘spam’)
{‘a’, ‘p’, ‘s’, ‘m’}
\>>> {c * 4 for c in ‘spam’}  # Множество результатов выражения
{‘ssss’, ‘aaaa’, ‘pppp’, ‘mmmm’}
\>>> {c * 4 for c in ‘spamham’}
{‘ssss’, ‘aaaa’, ‘hhhh’, ‘pppp’, ‘mmmm’}
\>>> S = {c * 4 for c in ‘spam’}
\>>> S | {‘mmmm’, ‘xxxx’}
{‘ssss’, ‘aaaa’, ‘pppp’, ‘mmmm’, ‘xxxx’}
\>>> S & {‘mmmm’, ‘xxxx’}
{‘mmmm’}


 Где могут использоваться множества?

 Помимо математических вычислений множества могут использоваться еще
в целом ряде прикладных областей. Например, поскольку элементы множеств
являются уникальными, множества можно использовать для фильтрации
повторяющихся значений в других коллекциях. Для этого достаточно просто
преобразовать коллекцию в множество, а затем выполнить обратное
преобразование (благодаря тому, что множества являются итерируемыми
объектами, их можно передавать функции list):

\>>> L = [1, 2, 1, 3, 2, 4, 5]
\>>> set(L)
{1, 2, 3, 4, 5}
\>>> L = list(set(L))  # Удаление повторяющихся значений
\>>> L
[1, 2, 3, 4, 5]

 Множества могут также использоваться для хранения пунктов, которые уже
были посещены в процессе обхода графа или другой циклической структуры.
Например, транзитивный загрузчик модулей и программа вывода дерева
наследования, должны запоминать элементы, которые уже были посещены,
чтобы избежать зацикливания. Посещенные элементы достаточно эффективно
можно запоминать в виде ключей словаря, однако множества предлагают
еще более эффективный эквивалент (и для многих – более простой).

 Наконец, множества удобно использовать при работе с большими массивами
данных (например, с результатами запроса к базе данных) – операция
пересечения двух множеств позволяет получить объекты, присутствующие
сразу в обеих категориях, а объединение – все объекты, присутствующие
в любом из множеств. Чтобы продемонстрировать это, ниже приводится
несколько практичных примеров использования операций над множествами,
которые применяются к списку людей – служащих гипотетической компании.
Здесь используются литералы множеств, появившиеся в версии 3.0
(в версии 2.6 используйте функцию set):

\>>> engineers = {‘bob’, ‘sue’, ‘ann’, ‘vic’}
\>>> managers = {‘tom’, ‘sue’}
\>>> ‘bob’ in engineers  # bob – инженер?
True

\>>> engineers & managers  # Кто одновременно является
{‘sue’}                    # инженером и менеджером?

\>>> engineers | managers  # Все сотрудники из обеих категорий
{‘vic’, ‘sue’, ‘tom’, ‘bob’, ‘ann’}

\>>> engineers – managers  # Инженеры, не являющиеся менеджерами
{‘vic’, ‘bob’, ‘ann’}

\>>> managers – engineers  # Менеджеры, не являющиеся инженерами
{‘tom’}

\>>> engineers > managers  # Все менеджеры являются инженерами?
False                      # (надмножество)

\>>> {‘bob’, ‘sue’} < engineers  # Оба сотрудника - инженеры?
True                             # (подмножество)

\>>> (managers | engineers) > managers  # Множество всех сотрудников
True                             # является надмножеством менеджеров?

\>>> managers ^ engineers  # Сотрудники, принадлежащие к какой-то одной
{‘vic’, ‘bob’, ‘ann’, ‘tom’}                                # категории

\>>> (managers | engineers) - (managers ^ engineers)  # Пересечение!
{‘sue’}


 Логические значения

 Иногда утверждается, что логический тип bool в языке Python по своей
природе является числовым, потому что два его значения True и False –
это всего лишь целые числа 1 и 0, вывод которых настроен особым образом.
Хотя этих сведений вполне достаточно для большинства программистов,
тем не менее, я предлагаю исследовать этот тип немного подробнее.

 Официально в языке Python имеется самостоятельный логический тип
с именем bool, с двумя предопределенными значениями True и False.
Эти значения являются экземплярами класса bool, который в свою очередь
является всего лишь подклассом (в объектно-ориентированном смысле)
встроенного целочисленного типа int. True и False ведут себя точно
так же, как и целые числа 1 и 0, за исключением того, что для их вывода
на экран используется другая логика – они выводятся как слова True
и False вместо цифр 1 и 0. Технически это достигается за счет
переопределения в классе bool методов str и repr.

 В соответствии с интерпретацией этих значений значения выражений
логического типа выводятся в интерактивной оболочке как слова True
и False, а не как числа 1 и 0. Можно считать, что логический тип делает
истинные значения более явными. Например, теперь бесконечный цикл
можно оформить как while True:, а не как менее очевидный while 1:.
Точно так же более понятной становится инициализация флагов,
например flag = False.

 Во всех остальных практических применениях значения True и False можно
интерпретировать как предопределенные переменные с целочисленными
значениями 1 и 0. В любом случае раньше большинство программистов
создавали переменные True и False, которым присваивали значения 1 и 0;
таким образом, тип bool просто следует этому стандартному приему.
Его реализация может приводить к неожиданным результатам: так как True –
это всего лишь целое значение 1, которое выводится на экран особым
образом, выражение True + 4 в языке Python даст результат 5:

\>>> type(True)
<class ‘bool’>
\>>> isinstance(True, int)
True
\>>> True == 1  # То же самое значение
True
\>>> True is 1  # Но разные объекты: смотрите следующую главу
False
\>>> True or False  # То же, что и: 1 or 0
True
\>>> True + 4  # (М-да)
5
"""

print(True + 2)

"""
 Числовые расширения
 
 Наконец, помимо встроенных числовых типов собственно языка Python вы
можете встретить различные свободно распространяемые расширения 
сторонних разработчиков, реализующие еще более экзотические числовые
типы. Поскольку числовая обработка данных является популярной областью 
применения языка Python, вы без труда найдете массу дополнительных 
инструментов:

 Например, для реализации массивных вычислений можно использовать 
расширение NumPy (Numeric Python), предоставляющее дополнительные 
возможности, такие как реализация матричных и векторных операций,
и обширные библиотеки реализации численных алгоритмов. Язык Python 
и расширение NumPy используется группами программирования 
в таких известных организациях, как Лос-Аламосская Национальная 
Лаборатория (Los Alamos) и Национальное управление по аэронавтике 
и исследованию космического пространства (NASA), для реализации 
разнообразных задач, которые ранее были написаны на языках C++, FORTRAN
и Matlab. Нередко комбинацию Python и NumPy рассматривают как свободную
и более гибкую альтернативу пакету Matlab – вы получаете 
производительность расширения NumPy плюс язык Python 
и все его библиотеки.

 Расширение NumPy является достаточно сложным, поэтому мы не будем 
возвращаться к нему в этой книге. Поддержку дополнительных возможностей
численного программирования в языке Python, включая инструменты для
анализа и построения графических изображений, библиотеки реализации
статистических методов и популярный пакет SciPy, вы можете найти 
на сайте PyPI или в Сети. Кроме того, обратите внимание, 
что расширение NumPy в настоящее время не входит в состав стандартной
библиотеки Python и должно устанавливаться отдельно.
"""

"""
 Интерлюдия о динамической типизации


 Отсутствие инструкций объявления

 Мы все время использовали переменные, не объявляя ни их самих,
ни их типы, и все как-то работало. Например, когда вводится инструкция
a = 3 в интерактивной оболочке интерпретатора или в файле сценария,
как интерпретатор Python узнает, что речь идет о целом числе? И вообще,
как Python узнает, что есть что?

 Как только вы начинаете задавать такие вопросы, вы попадаете в сферу
действия модели динамической типизации, используемой в языке Python.
Типы данных в языке Python определяются автоматически во время
выполнения, а не в результате объявлений в программном коде.
Это означает, что вам не требуется заранее объявлять переменные
(эту концепцию проще понять, если иметь в виду, что все сводится
к переменным, объектам и ссылкам между ними).


 Переменные, объекты и ссылки

 Как было видно из примеров, приводившихся до сих пор в книге, когда
выполняется операция присваивания, такая как a = 3, интерпретатор
выполняет ее, хотя перед этим ему нигде не сообщалось, что a –
это имя переменной, или что она представляет объект целочисленного типа.
В языке Python все это решается весьма естественным способом,
как описано ниже:


 Создание переменной

 Переменная (то есть имя) такая, как a, создается автоматически,
когда в программном коде ей впервые присваивается некоторое значение.
Все последующие операции присваивания просто изменяют значение,
ассоциированное с уже созданным именем. Строго говоря, интерпретатор
Python определяет некоторые имена до запуска программного кода,
но вполне допустимо думать, что переменные создаются первой операцией
присваивания.


 Типы переменных

 Переменные не имеют никакой информации о типе или ограничениях,
связанных с ним. Понятие типа присуще объектам, а не именам. Переменные
универсальны по своей природе – они всегда являются всего лишь ссылками
на конкретные объекты в конкретные моменты времени. Использование
переменной Когда переменная участвует в выражении, ее имя замещается
объектом, на который она в настоящий момент ссылается, независимо
от того, что это за объект. Кроме того, прежде чем переменную можно
будет использовать, ей должно быть присвоено значение –
использование неинициализированной переменной приведет к ошибке. В итоге
складывается следующая картина: переменные создаются при выполнении
операции присваивания, могут ссылаться на объекты любых типов
и им должны быть присвоены некоторые значения, прежде чем к ним
можно будет обратиться. Это означает, что от вас не требуется заранее
объявлять переменные в сценарии, но вы должны инициализировать
их перед использованием – счетчик, например, должен быть инициализирован
нулевым значением, прежде чем его можно будет наращивать.

 Модель динамической типизации существенно отличается от моделей типов
в традиционных языках программирования. Динамическая типизация обычно
проще поддается пониманию начинающих, особенно если они четко осознают
разницу между именами и объектами. Например, если ввести такую
инструкцию:

\>>> a = 3

 интерпретатор Python выполнит эту инструкцию в три этапа,
по крайней мере, концептуально. Следующие этапы отражают все операции
присваивания в языке Python:

  1. Создается объект, представляющий число 3.

  2. Создается переменная a, если она еще отсутствует.

  3. В переменную a записывается ссылка на вновь созданный объект,
 представляющий число 3.

 Результатом выполнения этих этапов будет структура. Как показано
на схеме, переменные и объекты хранятся в разных частях памяти
и связаны между собой ссылкой (ссылка на рисунке показана
в виде стрелки). Переменные всегда ссылаются на объекты и никогда –
на другие переменные, но крупные объекты могут ссылаться на другие
объекты (например, объект списка содержит ссылки на объекты,
которые включены в список).

 Эти ссылки на объекты в языке Python так и называются ссылки, то есть
ссылки – это своего рода ассоциативная связь, реализованная в виде
указателя на область памяти.1 Когда бы ни использовалась переменная
(то есть ссылка), интерпретатор Python автоматически переходит по ссылке
от переменной к объекту. Все на самом деле гораздо проще, чем кажется.
В конкретных терминах:

  Переменные – это записи в системной таблице, где предусмотрено место
 для хранения ссылок на объекты.

  Объекты – это области памяти с объемом, достаточным для представления
 значений этих объектов.

  Ссылки – это автоматически разыменовываемые указатели на объекты.

 Всякий раз, по крайней мере концептуально, когда в сценарии
в результате выполнения выражения создается новое значение,
интерпретатор Python создает новый объект (то есть выделяет
область памяти), представляющий это значение. Внутренняя реализация
интерпретатора с целью оптимизации кэширует и повторно использует
некоторые типы неизменяемых объектов, такие как малые целые числа
и строки (каждый 0 в действительности не является новой областью
в памяти). Но с логической точки зрения все выглядит так, как если бы
результат каждого выражения был представлен отдельным объектом
и каждый объект занимал отдельную область памяти.

 С технической точки зрения объекты имеют более сложную структуру,
чем просто пространство в памяти, необходимое для хранения значения.
Каждый объект имеет два стандартных поля: описатель типа, используемый
для хранения информации о типе объекта, и счетчик ссылок, используемый
для определения момента, когда память, занимаемая объектом, может быть
освобождена. Чтобы понять, какую роль играют эти два поля в модели
динамической типизации, нам необходимо двинуться дальше.


 Информация о типе хранится в объекте, но не в переменной

 Чтобы увидеть, как используется информация о типах объектов, посмотрим,
что произойдет, если выполнить несколько операций присваивания одной
и той же переменной:

\>>> a = 3  # Это целое число
\>>> a = ‘spam’  # Теперь это строка
\>>> a = 1.23  # Теперь это вещественное число

 Это не совсем типичный программный код на языке Python,
но он работает – сначала создается целое число, потом строка и, наконец,
вещественное число. Этот пример особенно странно выглядит
для программистов, использовавших язык C, поскольку он выглядит так,
как если бы при выполнении инструкции a = ‘spam’ производилось изменение
типа переменной с целочисленного на строковый.

 Однако в действительности этого не происходит. В языке Python
все реализовано намного проще: имена не имеют типов, как уже
указывалось ранее, тип - это свойство объекта, а не имени. В предыдущем
листинге просто изменяется ссылка на объект. Так как переменные
не имеют типов, мы в действительности не изменяем типы переменных –
мы просто записываем в переменные ссылки на объекты других типов.
На самом деле, все, что можно сказать о переменных в языке Python, –
это то, что они ссылаются на конкретные объекты в конкретные
моменты времени.

 С другой стороны, объекты знают, к какому типу они относятся, –
каждый объект содержит поле, в котором хранится информация о его типе.
Целочисленный объект 3, например будет содержать значение 3 плюс
информацию, которая сообщит интерпретатору Python, что объект является
целым числом (строго говоря – это указатель на объект с названием int,
которое играет роль имени целочисленного типа). Описатель типа
для строки ‘spam’ указывает на строковый тип (с именем str). Поскольку
информация о типе хранится в объектах, ее не нужно хранить в переменных.

 Итак, типы в языке Python – это свойства объектов, а не переменных.
В типичном программном коде переменная обычно ссылается на объекты
только одного типа. Т. к. для языка Python это не является обязательным
требованием, программный код на языке Python обладает более высокой
гибкостью, чем вам может показаться, – при умелом использовании
особенностей языка программный код смог бы работать со многими
типами автоматически.

 Я уже упоминал, что каждый объект имеет два поля – описатель типа
и счетчик ссылок. Чтобы разобраться с последним из них, нам нужно пойти
еще дальше и взглянуть, что происходит в конце жизненного цикла объекта.


 Объекты уничтожаются автоматически

 В листинге из предыдущего раздела мы присваивали одной и той же
переменной объекты различных типов. Но что происходит с прежним
значением, когда выполняется новое присваивание? Например,
что произойдет с объектом 3 после выполнения следующих инструкций;

\>>> a = 3
\>>> a = ‘spam’

 Дело в том, что всякий раз, когда имя ассоциируется с новым объектом,
интерпретатор Python освобождает память, занимаемую предыдущим объектом
(если на него не ссылается какое-либо другое имя или объект). Такое
автоматическое освобождение памяти, занимаемой объектами, называется
сборкой мусора (garbage collection).

 Чтобы проиллюстрировать сказанное, рассмотрим следующий пример,
где имя x ассоциируется с разными объектами при выполнении каждой
операции присваивания:

\>>> x = 42
\>>> x = ‘shrubbery’  # Освобождается объект 42 (если нет других ссылок)
\>>> x = 3.1415  # Теперь освобождается объект ‘shrubbery’
\>>> x = [1,2,3]  # Теперь освобождается объект 3.1415

 Первое, что следует отметить, – каждый раз с именем x связывается
объект другого типа. Снова, хотя в действительности это не так,
возникает ощущение изменения типа переменной x с течением времени.
Напомню, что в языке Python типы связаны с объектами, а не с именами.
Так как имена – это всего лишь ссылки на объекты, данный код работает.

 Во-вторых, следует помнить, что попутно уничтожаются ссылки на объекты.
Каждый раз, когда имя x ассоциируется с новым объектом,
интерпретатор Python освобождает пространство, занятое прежним объектом.
Например, когда с именем x связывается строка ‘shrubbery’, объект 42
немедленно уничтожается (при условии, что на него не ссылается никакое
другое имя), а пространство памяти, занимаемое объектом, возвращается
в пул свободной памяти для повторного использования в дальнейшем.

 Достигается это за счет того, что в каждом объекте имеется счетчик
ссылок, с помощью которого интерпретатор следит за количеством ссылок,
указывающих на объект в настоящий момент времени. Как только (и именно
в этот момент) значение счетчика достигает нуля, память, занимаемая
объектом, автоматически освобождается. В предыдущем листинге
мы исходили из предположения, что всякий раз, когда имя x ассоциируется
с новым объектом, счетчик предыдущего объекта уменьшается до нуля,
заставляя интерпретатор освобождать память.

 Основная выгода от сборки мусора состоит в том, что программист может
свободно распоряжаться объектами, не будучи обязан освобождать память
в своем сценарии. Интерпретатор сам будет выполнять очистку
неиспользуемой памяти в ходе выполнения программы. На практике
эта особенность позволяет существенно уменьшить объем программного кода
по сравнению с низкоуровневыми языками программирования,
такими как C и C++.

 Строго говоря, механизм сборки мусора в основном опирается на счетчики
ссылок, как было описано выше, однако он способен также обнаруживать
и удалять объекты с циклическими ссылками. Эту особенность можно
отключить, если вы уверены, что в программе не создаются объекты
с циклическими ссылками, но по умолчанию она включена.

 Поскольку ссылки реализованы в виде указателей, существует возможность
создать в объекте ссылку на самого себя или на другой объект, который
ссылается сам на себя. Например, упражнение 6 в конце первой части
и его решение в приложении B демонстрируют возможность создания
циклической ссылки, за счет включения в список ссылки на сам список.
То же может произойти при присваивании значений атрибутам объектов
пользовательских классов. Несмотря на относительную редкость таких
ситуаций, должен быть предусмотрен механизм их обработки, потому что
счетчики ссылок в таких объектах никогда не достигнут нуля.

 Дополнительную информацию об обнаружении циклических ссылок можно найти
в описании модуля gc, в справочном руководстве по стандартной библиотеке
языка Python. Обратите также внимание, что данное описание применимо
только к механизму сборки мусора в стандартной реализации �CPython.
Реализации Jython и IronPython могут использовать иные принципы работы,
хотя и дающие тот же эффект – неиспользуемое пространство освобождается
автоматически.


 Разделяемые ссылки

 До сих пор мы рассматривали вариант, когда ссылка на объект
присваивается единственной переменной. Теперь введем в действие
еще одну переменную и посмотрим, что происходит с именами и объектами
в этом случае:

\>>> a = 3
\>>> b = a

 В результате выполнения этих двух инструкций получается схема
взаимоотношений, отраженная на рис. 6.2. Вторая инструкция вынуждает
интерпретатор создать переменную b и использовать для инициализации
переменную a, при этом она замещается объектом, на который ссылается
(3), и b превращается в ссылку на этот объект. В результате переменные
a и b ссылаются на один и тот же объект (то есть указывают на одну
и ту же область в памяти). В языке Python это называется разделяемая
ссылка – несколько имен ссылаются на один и тот же объект.

 Далее добавим еще одну инструкцию:

\>>> a = 3
\>>> b = a
\>>> a = ‘spam’

 Как во всех случаях присваивания в языке Python, в результате
выполнения этой инструкции создается новый объект, представляющий строку
‘spam’, а ссылка на него записывается в переменную a. Однако эти
действия не оказывают влияния на переменную b – она по-прежнему
ссылается на первый объект, целое число 3. В результате схема
взаимоотношений приобретает вид, показанный на рис. 6.3.

 То же самое произошло бы, если бы ссылка на объект ‘spam’ вместо
переменной a была присвоена переменной b – изменилась бы только
переменная b, но не a. Аналогичная ситуация возникает, даже если тип
объекта не изменяется. Например, рассмотрим следующие три инструкции:

\>>> a = 3
\>>> b = a
\>>> a = a + 2

 В этой последовательности происходят те же самые события:
интерпретатор Python создает переменную a и записывает в нее ссылку
на объект 3. После этого он создает переменную b и записывает в нее
ту же ссылку, что хранится в переменной a, как показано на рис. 6.2.
Наконец, последняя инструкция создает совершенно новый объект
(в данном случае – целое число 5, которое является результатом
выполнения операции сложения). Это не приводит к изменению переменной b.
В действительности нет никакого способа перезаписать значение
объекта 3 – как говорилось в главе 4, целые числа относятся
к категории неизменяемых, и потому эти объекты невозможно изменить.

 Переменные в языке Python, в отличие от других языков программирования,
всегда являются указателями на объекты, а не метками областей памяти,
доступных для изменения: запись нового значения в переменную не приводит
к изменению первоначального объекта, но приводит к тому, что переменная
начинает ссылаться на совершенно другой объект. В результате инструкция
присваивания может воздействовать только на одну переменную. Однако
когда в уравнении появляются изменяемые объекты и операции,
их изменяющие, картина несколько меняется. Чтобы узнать как,
давайте двинемся дальше.


 Разделяемые ссылки и изменяемые объекты

 Как будет показано дальше в этой части книги, существуют такие объекты
и операции, которые приводят к изменению самих объектов. Например,
операция присваивания значения элементу списка фактически изменяет
сам список вместо того, чтобы создавать совершенно новый объект списка.
При работе с объектами, допускающими такие изменения, необходимо быть
особенно внимательными при использовании разделяемых ссылок,
так как изменение одного имени может отразиться на других именах.

 Чтобы проиллюстрировать сказанное, возьмем в качестве примера объекты
списков, о которых рассказывалось в главе 4. Напомню, что списки,
которые поддерживают возможность присваивания значений элементам, –
это просто коллекции объектов, которые в программном коде записываются
как литералы в квадратных скобках:

\>>> L1 = [2, 3, 4]
\>>> L2 = L1

 В данном случае L1 – это список, содержащий объекты 2, 3 и 4. Доступ
к элементам списка осуществляется по их индексам; так, L1[0] ссылается
на объект 2, то есть на первый элемент в списке L1. Безусловно, списки
являются полноценными объектами, такими же, как целые числа и строки.
После выполнения двух приведенных выше инструкций L1 и L2 будут
ссылаться на один и тот же объект, так же как переменные a и b
в предыдущем примере (рис. 6.2). Точно так же, если теперь добавить
еще одну инструкцию:

\>>> L1 = 24

 переменная L1 будет ссылаться на другой объект, а L2 по-прежнему
будет ссылаться на первоначальный список. Однако если синтаксис
последней инструкции чуть-чуть изменить, эффект получится радикально
другим:

\>>> L1 = [2, 3, 4]  # Изменяемый объект
\>>> L2 = L1  # Создание второй ссылки на тот же самый объект
\>>> L1[0] = 24  # Изменение объекта
\>>> L1  # Переменная L1 изменилась
[24, 3, 4]
\>>> L2  # Но так же изменилась и переменная L2!
[24, 3, 4]

 Здесь мы не изменяем сам объект L1, изменяется компонент объекта,
на который ссылается L1. Данное изменение затронуло часть самого объекта
списка. Поскольку объект списка разделяется разными переменными
(ссылки на него находятся в разных переменных), то изменения в самом
списке затрагивают не только L1, то есть следует понимать, что такие
изменения могут сказываться в других частях программы. В этом примере
изменения обнаруживаются также в переменной L2, потому что она ссылается
на тот же самый объект, что и L1. Здесь мы фактически не изменяли L2,
но значение этой переменной изменилось.

 Как правило, это именно то, что требовалось, но вы должны понимать,
как это происходит. Это – поведение по умолчанию: если вас оно
не устраивает, можно потребовать от интерпретатора, чтобы вместо
создания ссылок он выполнял копирование объектов. Скопировать список
можно несколькими способами, включая встроенную функцию list
и модуль copy из стандартной библиотеки. Однако самым стандартным
способом копирования является получение среза от начала и до конца
списка:

\>>> L1 = [2, 3, 4]
\>>> L2 = L1[:]  # Создается копия списка L1
\>>> L1[0] = 24
\>>> L1
[24, 3, 4]
\>>> L2  # L2 не изменилась
[2, 3, 4]

 Здесь изменения в L1 никак не отражаются на L2, потому что L2 ссылается
на копию объекта, на который ссылается переменная L1. То есть
эти переменные указывают на различные области памяти.

 Обратите внимание, что способ, основанный на получении среза,
неприменим в случае с другим изменяемым базовым типом – со словарями,
потому что словари не являются последовательностями. Чтобы скопировать
словарь, необходимо воспользоваться методом X.copy(). Следует также
отметить, что модуль copy из стандартной библиотеки имеет в своем
составе универсальную функцию, позволяющую копировать объекты любых
типов, включая вложенные структуры (например, словари
с вложенными списками):

import copy
X = copy.copy(Y)  # Создание “поверхностной” копии любого объекта Y
X = copy.deepcopy(Y)  # Создание полной копии:
                      # копируются все вложенные части


 Разделяемые ссылки и равенство

 В интересах полноты обсуждения должен заметить, что возможность сборки
мусора, описанная ранее в этой главе, может оказаться более
принципиальным понятием, чем литералы для объектов некоторых типов.
Рассмотрим следующие инструкции:

\>>> x = 42
\>>> x = ‘shrubbery’  # Объект 42 теперь уничтожен?

 Так как интерпретатор Python кэширует и повторно использует малые целые
числа и небольшие строки, о чем уже упоминалось ранее, объект 42
скорее всего не будет уничтожен. Он, вероятнее всего, останется
в системной таблице для повторного использования, когда вы вновь
сгенерируете число 42 в программном коде. Однако большинство объектов
уничтожаются немедленно, как только будет потеряна последняя ссылка,
особенно те, к которым применение механизма кэширования не имеет смысла.

 Например, согласно модели ссылок в языке Python, существует два разных
способа выполнить проверку равенства. Давайте создадим разделяемую
ссылку для демонстрации:

\>>> L = [1, 2, 3]
\>>> M = L  # M и L – ссылки на один и тот же объект
\>>> L == M  # Одно и то же значение
True
\>>> L is M  # Один и тот же объект
True

 Первый способ, основанный на использовании оператора ==, проверяет,
равны ли значения объектов. В языке Python практически всегда
используется именно этот способ. Второй способ, основанный
на использовании оператора is, проверяет идентичность объектов.
Он возвращает значение True, только если оба имени ссылаются на один
и тот же объект, вследствие этого он является более строгой формой
проверки равенства.

 На самом деле оператор is просто сравнивает указатели, которые
реализуют ссылки, и тем самым может использоваться для выявления
разделяемых ссылок в программном коде. Он возвращает значение False,
даже если имена ссылаются на эквивалентные, но разные объекты, как,
например, в следующем случае, когда выполняются два различных
литеральных выражения:

\>>> L = [1, 2, 3]
\>>> M = [1, 2, 3]  # M и L ссылаются на разные объекты
\>>> L == M  # Одно и то же значение
True
\>>> L is M  # Но разные объекты
False

 Посмотрите, что происходит, если те же самые действия выполняются
над малыми целыми числами:

\>>> X = 42
\>>> Y = 42  # Должно получиться два разных объекта
\>>> X == Y
True
\>>> X is Y  # Тот же самый объект: кэширование в действии!
True

 В этом примере переменные X и Y должны быть равны (==, одно и то же
значение), но не эквивалентны (is, один и тот же объект), потому что
было выполнено два разных литеральных выражения. Однако из-за того,
что малые целые числа и строки кэшируются и используются повторно,
оператор is сообщает, что переменные ссылаются на один и тот же объект.

 Фактически если вы действительно хотите взглянуть на работу внутренних
механизмов, вы всегда можете запросить у интерпретатора количество
ссылок на объект: функция getrefcount из стандартного модуля sys
возвращает значение поля счетчика ссылок в объекте. Когда я, например,
запросил количество ссылок на целочисленный объект 1 в среде разработки
IDLE, я получил число 837 (большая часть ссылок была создана системным
программным кодом самой IDLE, а не мною):

\>>> import sys
\>>> sys.getrefcount(1)  # 837 указателей на этот участок памяти
837

 Такое кэширование объектов и повторное их использование не будет иметь
большого значения для вашего программного кода (если вы не используете
оператор is!). Так как числа и строки не могут изменяться, совершенно
неважно, сколько ссылок указывает на один и тот же объект. Однако такое
поведение наглядно демонстрирует один из реализуемых Python способов
оптимизации, направленной на повышение скорости выполнения.


 Динамическая типизация повсюду

 В действительности вам совсем не нужно рисовать схемы с именами,
объектами, кружочками и стрелками, чтобы использовать Python. Однако
в самом начале пути такие схемы иногда помогают разобраться в необычных
случаях. Если после передачи изменяемого объекта в другую часть
программы он возвращается измененным, значит, вы стали свидетелем того,
о чем рассказывалось в этой главе.

 Более того, если к настоящему моменту динамическая типизация кажется
вам немного непонятной, вы, вероятно, захотите устранить это
недопонимание в будущем. Поскольку в языке Python все основано
на присваивании и на ссылках, понимание основ этой модели пригодится
во многих ситуациях. Как будет показано позже, одна и та же модель
используется в операторах присваивания, при передаче аргументов
функциям, в переменных цикла for, при импортировании модулей
и так далее. Но к счастью, в Python реализована всего одна модель
присваивания! Как только вы разберетесь в динамической типизации,
вы обнаружите, что подобные принципы применяются повсюду в этом языке
программирования.

 На практическом уровне наличие динамической типизации означает,
что вам придется писать меньше программного кода. Однако не менее важно
и то, что динамическая типизация составляет основу полиморфизма –
концепции, которая была введена в главе 4 и к которой мы еще вернемся
далее в этой книге, – в языке Python. Поскольку мы не ограничены
применением типов в программном коде на языке Python, он обладает
очень высокой гибкостью. Как будет показано далее, при правильном
использовании динамической типизации и полиморфизма можно создавать
такой программный код, который автоматически будет адаптироваться
под новые требования в ходе развития вашей системы.
"""

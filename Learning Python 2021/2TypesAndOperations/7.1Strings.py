"""
 Строки

 Для работы со строками поддерживаются операции выражений,
такие как конкатенация (объединение строк), выделение подстроки,
выборка символов по индексам (по смещению от начала строки) и так далее.
Помимо выражений язык Python предоставляет ряд строковых методов,
которые реализуют обычные задачи работы со строками, а также модули
для решения более сложных задач обработки текста, таких как поиск
по шаблону. Все эти инструменты будут рассматриваться далее
в этой же главе.

  Операция                           Интерпретация
  S = ‘’                             Пустая строка

  S = “spam’s”                       Строка в кавычках

  S = ‘s\np\ta\x00m’                 Экранированные последовательности

  block = “””...”””                  Блоки в тройных кавычках

  S = r’\temp\spam’                  Неформатированные строки

  S = b’spam’                        Строки байтов в версии 3.0

  S = u’spam’                        Строки с символами Юникода.

  S1 + S2, S * 3                     Конкатенация, повторение

  S[i], S[i:j], len(S)               Обращение к символу по индексу,
                                     извлечение подстроки (среза), длина

  “a %s parrot” % kind               Выражение форматирования строки

  “a {0} parrot”.format(kind)        Строковый метод форматирования

  S.find(‘pa’)                       Вызов строкового метода: поиск

  S.rstrip()                         Удаление ведущих и конечных
                                     пробельных символов

  S.replace(‘pa’, ‘xx’)              Замена

  S.split(‘,’)                       Разбиение по символу-разделителю

  S.isdigit()                        Проверка содержимого

  S.lower()                          Преобразование регистра символов

  S.endswith(‘spam’)                 Проверка окончания строки

  ‘spam’.join(strlist)               Сборка строки из списка

  S.encode(‘latin-1’)                Кодирование строк Юникода

  for x in S: print(x)               Обход в цикле,
  ‘spam’ in S                        проверка на вхождение
  [c * 2 for c in S]
  map(ord, S)

 Python 3.0 существует три строковых типа: str – для представления
текста Юникода (содержащего символы в кодировке ASCII и символы
в других кодировках), bytes – для представления двоичных данных
(включая кодированный текст) и bytearray – изменяемый вариант
типа bytes.


 Литералы строк

 Вообще говоря, работать со строками в языке Python достаточно удобно.
Самое сложное, пожалуй, – это наличие множества способов записи строк
в программном коде:

  Строки в апострофах: ‘spa”m’

  Строки в кавычках: “spa’m”

  Строки в тройных кавычках: ‘’’... spam ...’’’, “””... spam ...”””

  Экранированные последовательности: “s\tp\na\0m”

  Неформатированные строки: r”C:\new\test.spm”

  Строки байтов в версии 3.0: b’sp\x01am’

  Строки символов Юникода, только в версии 2.6: u’eggs\u0020spam’


  Строки в апострофах и в кавычках – это одно и то же Кавычки
и апострофы, окружающие строки, в языке Python являются
взаимозаменяемыми. То есть строковые литералы можно заключать как
в апострофы, так и в кавычки – эти две формы представления строк ничем
не отличаются, и обе они возвращают объект того же самого типа.
Например, следующие две строки совершенно идентичны:

\>>> ‘shrubbery’, “shrubbery”
(‘shrubbery’, ‘shrubbery’)

 Причина наличия двух вариантов состоит в том, чтобы позволить вставлять
в литералы символы кавычек и апострофов, не используя для этого символ
обратного слэша. Вы можете вставлять апострофы в строки, заключенные в
кавычки, и наоборот:

\>>> ‘knight”s’, “knight’s”
(‘knight”s’, “knight’s”)

 Между прочим, Python автоматически объединяет последовательности
строковых литералов внутри выражения, хотя нет ничего сложного в том,
чтобы добавить оператор + между литералами и вызвать операцию
конкатенации явно:

\>>> title = “Meaning “ ‘of’ “ Life”  # Неявная конкатенация
\>>> title
‘Meaning of Life’

 Обратите внимание, если добавить запятые между этими строками,
будет получен кортеж, а не строка. Кроме того, заметьте, что во всех
этих примерах интерпретатор предпочитает выводить строки в апострофах,
если их нет внутри строки. Кавычки и апострофы можно вставлять в строки,
экранируя их символом обратного слэша:

\>>> ‘knight\’s’, “knight\”s”
(“knight’s”, ‘knight”s’)

 Чтобы понять, зачем, вам необходимо узнать, как работает механизм
экранирования вообще.


 Экранированные последовательности представляют служебные символы

 В последнем примере кавычка и апостроф внутри строк предваряются
символом обратного слэша. Это частный случай более общей формы:
символы обратного слэша используются для вставки специальных символов,
известных как экранированные последовательности.

 Экранированные последовательности позволяют вставлять в строки символы,
которые сложно ввести с клавиатуры. В конечном строковом объекте символ
\ и один или более следующих за ним символов замещаются единственным
символом, который имеет двоичное значение, определяемое экранированной
последовательностью. Например, ниже приводится строка из пяти символов,
в которую вставлены символ новой строки и табуляции:

\>>> s = ‘a\nb\tc’

 Последовательность \n образует единственный символ – байт, содержащий
двоичное значение кода символа новой строки в используемом наборе
символов (обычно ASCII-код 10). Аналогично последовательность \t
замещается символом табуляции. Как будет выглядеть такая строка
при печати, зависит от того, как она выводится. Функция автоматического
вывода в интерактивной оболочке отобразит служебные символы
как экранированные последовательности, а инструкция print будет
интерпретировать их:

\>>> s
‘a\nb\tc’
\>>> print(s)
a
b   c

 Чтобы окончательно убедиться, сколько байтов входит в эту строку, можно
воспользоваться встроенной функцией len – она возвращает фактическое
число байтов в строке независимо от того, как строка отображается
на экране:

\>>> len(s)
5

  Последовательность       Назначение
  \newline                 Игнорируется (продолжение на новой строке)

  \\                       Сам символ обратного слэша
                           (остается один символ \)

  \’                       Апостроф (остается один символ ‘)

  \”                       Кавычка (остается один символ “)

  \a                       Звонок

  \b                       Забой

  \f                       Перевод формата

  \n                       Новая строка (перевод строки)

  \r                       Возврат каретки

  \t                       Горизонтальная табуляция

  \v                       Вертикальная табуляция

  \xhh                     Символ с шестнадцатеричным кодом hh
                           (не более 2 цифр)

  \ooo                     Символ с восьмеричным кодом ooo
                           (не более 3 цифр)

  \0                       Символ Null (не признак конца строки)

  \N{id}                   Идентификатор ID базы данных Юникода

  \uhhhh                   16-битный символ Юникода в шестнадцатеричном
                           представлении

  \Uhhhhhhhh               32-битный символ Юникода в шестнадцатеричном
                           представлении

  \другое                  Не является экранированной
                           последовательностью
                           (символ обратного слэша сохраняется)

\>>> s = ‘a\0b\0c’
\>>> s
‘a\x00b\x00c’
\>>> len(s)
5

 В языке Python нулевой байт (символ null) не является признаком
завершения строки, как в языке C. Интерпретатор просто сохраняет
в памяти как текст самой строки, так и ее длину. Фактически в языке
Python вообще нет символа, который служил бы признаком завершения
строки. Ниже приводится строка, полностью состоящая из экранированных
кодов, – двоичные значения 1 и 2 (записаны в восьмеричной форме),
за которыми следует двоичное значение 3 (записано
в шестнадцатеричной форме):

\>>> s = ‘\001\002\x03’
\>>> s
‘\x01\x02\x03’
\>>> len(s)
3

 Обратите внимание, что интерпретатор Python отображает непечатаемые
символы в шестнадцатеричном представлении, независимо от того,
в каком виде они были указаны внутри литерала. Вы без ограничений
можете комбинировать абсолютные экранированные значения с другими
типами экранированных последовательностей, которые приводятся в табл.
Следующая строка содержит символы “spam”, символ табуляции и символ
новой строки, а также нулевой символ, заданный в шестнадцатеричном
представлении:

\>>> S = “s\tp\na\x00m”
\>>> S
‘s\tp\na\x00m’
\>>> len(S)
7
\>>> print(S)
s p
a m

 Это обстоятельство приобретает особую важность, когда возникает
необходимость обрабатывать на языке Python файлы с двоичными данными.
Поскольку содержимое таких файлов в сценариях на языке Python
представлено строками, вы без труда сможете обрабатывать двоичные файлы,
содержащие байты с любыми двоичными значениями.

 Наконец, последняя строка в табл. 7.2 предполагает, что если
интерпретатор не распознает символ после \ как корректный служебный
символ, он просто оставляет символ обратного слэша в строке:

\>>> x = “C:\py\code”  # Символ \ сохраняется в строке
\>>> x
‘C:\\py\\code’
\>>> len(x)
10

 Однако если вы не способны держать в памяти всю табл. 7.2, вам
не следует полагаться на описанное поведение. Чтобы явно добавить
символ обратного слэша в строку, нужно указать два символа обратного
слэша, идущие подряд (\\ – экранированный вариант представления
символа \), или использовать неформатированные строки, которые
описываются в следующем разделе.


 Неформатированные строки подавляют экранирование

 Как было показано, экранированные последовательности удобно
использовать для вставки в строки служебных символов. Однако иногда
зарезервированная экранированная последовательность может порождать
неприятности. Очень часто, например, можно увидеть, как начинающие
программисты пытаются открыть файл, передавая аргумент с именем файла,
который имеет примерно следующий вид:

myfile = open(‘C:\new\text.dat’, ‘w’)

 думая, что они открывают файл с именем text.dat в каталоге C:\new.
Проблема здесь заключается в том, что последовательность \n
интерпретируется как символ новой строки, а последовательность \t
замещается символом табуляции. В результате функция open будет пытаться
 открыть файл с именем C:(newline) w(tab)ext.dat, причем обычно
безуспешно. Именно в таких случаях удобно использовать неформатированные
строки. Если перед кавычкой, открывающей строку, стоит символ r
(в верхнем или в нижнем регистре), он отключает механизм экранирования.
В результате интерпретатор Python будет воспринимать символы обратного
слэша в строке как обычные символы. Таким образом, чтобы ликвидировать
проблему, связанную с именами файлов в Windows, не забывайте добавлять
символ r. myfile = open(r’C:\new\text.dat’, ‘w’)

 Как вариант, учитывая, что два идущих подряд символа обратного слэша
интерпретируются как один символ, можно просто продублировать символы
обратного слэша:

myfile = open(‘C:\\new\\text.dat’, ‘w’)

 Сам интерпретатор Python в определенных случаях использует удваивание
обратного слэша при выводе строк, содержащих обратный слэш:
\>>> path = r’C:\new\text.dat’
\>>> path  # Показать, как интерпретатор представляет эту строку
‘C:\\new\\text.dat’
\>>> print(path)  # Более дружественный формат представления
C:\new\text.dat
\>>> len(path)  # Длина строки
15

 Так же как и в случае с числами, при выводе результатов в интерактивной
оболочке по умолчанию используется такой формат представления,
как если бы это был программный код, отсюда и экранирование символов
обратного слэша. Инструкция print обеспечивает более дружественный
формат, в котором каждая пара символов обратного слэша выводится
как один символ. Чтобы проверить, что дело обстоит именно так,
можно проверить результат с помощью встроенной функции len,
которая возвращает число байтов в строке независимо от формата
отображения. Если посчитать символы в выводе инструкции print(path),
можно увидеть, что каждому символу обратного слэша соответствует
один байт, а всего строка содержит 15 символов.

 Помимо хранения имен каталогов в Windows, неформатированные строки
обычно используются для регулярных выражений (возможность поиска по
шаблону, поддерживаемая модулем re, о котором говорилось в главе 4).
Кроме того, следует отметить, что в сценариях на языке Python в строках
с именами каталогов в системах Windows и UNIX можно использовать простые
символы слэша, потому что Python старается поддерживать переносимость
для путей к файлам (например, путь к файлу можно указать в виде строки
‘C:/new/text.dat’). И все же, когда для кодирования имен каталогов
в Windows используется традиционная нотация с обратными слэшами,
удобно использовать неформатированные строки.

 Несмотря на свое предназначение, даже неформатированная строка
не может заканчиваться единственным символом обратного слэша,
потому что обратный слэш в этом случае будет экранировать следующий
за ним символ кавычки – вы по-прежнему должны экранировать кавычки
внутри строки. То есть конструкция r”...\” не является допустимым
строковым литералом – неформатированная строка не может заканчиваться
не-четным количеством символов обратного слэша. Если необходимо,
чтобы неформатированная строка заканчивалась символом обратного слэша,
можно добавить два символа и затем удалить второй из них
(r’1\nb\tc\\’[:-1]), добавить один символ вручную (r’1\nb\tc’ + ‘\\’)
или использовать обычный синтаксис строковых литералов и дублировать все
символы обратного слэша (‘1\\nb\\tc\\’). Во всех трех случаях получается
одна и та же строка из восьми символов, содержащая три обратных слэша.


 Тройные кавычки, многострочные блоки текста

 К настоящему моменту мы познакомились с кавычками, апострофами,
экранированными последовательностями и неформатированными строками.
Кроме этого в арсенале языка Python имеется формат представления
строковых литералов, в котором используются тройные кавычки.
Этот формат иногда называют блочной строкой, который удобно использовать
для определения многострочных блоков текста в программном коде.
Литералы в этой форме начинаются с трех идущих подряд кавычек
(или апострофов), за которыми может следовать произвольное число строк
текста, который закрывается такими же тремя кавычками. Внутри такой
строки могут присутствовать и кавычки, и апострофы, но экранировать
их не требуется – строка не считается завершенной, пока интерпретатор
не встретит три неэкранированные кавычки того же типа, которые начинают
литерал. Например:

\>>> mantra = “””Always look
... on the bright
... side of life.”””
\>>>
\>>> mantra
‘Always look\n on the bright\nside of life.’

 Эта строка состоит из трех строк текста (в некоторых системах строка
приглашения к вводу изменяется на ..., когда ввод продолжается на
следующей линии; среда IDLE просто переводит курсор на следующую линию).
Интерпретатор собирает блок текста, заключенный в тройные кавычки,
в одну строку, добавляя символы новой строки (\n) там, где
в программном коде выполнялся переход на новую строку.
Обратите внимание, что в результате у второй строки имеется ведущий
пробел, а у третьей – нет, то есть, что вы в действительности вводите,
то и получаете. Чтобы увидеть, как в реальности интерпретируется строка
с символами новой строки, можно воспользоваться инструкцией print:

\>>> print(mantra)
Always look
on the bright
side of life.

 Строки в тройных кавычках удобно использовать, когда в программе
требуется ввести многострочный текст, например, чтобы определить
многострочный текст сообщения об ошибке или код разметки на языке
HTML или XML. Вы можете встраивать такие блоки текста прямо
в свои сценарии, не используя для этого внешние текстовые файлы
или явную операцию конкатенации и символы новой строки.

 Часто строки в тройных кавычках используются для создания строк
документирования, которые являются литералами строк, воспринимаемыми
как комментарии при появлении их в определенных местах сценария.
Комментарии не обязательно (но часто!) представляют собой многострочный
текст, и данный формат дает возможность вводить многострочные
комментарии.

 Наконец, иногда тройные кавычки являются ужасающим, хакерским способом
временного отключения строк программного кода во время разработки
(Хорошо, хорошо! На самом деле это совсем не так ужасно,
а просто довольно распространенная практика). Если вам потребуется
отключить несколько строк программного кода и запустить сценарий снова,
просто вставьте по три кавычки до и после нужного блока кода,
как показано ниже:

X = 1
“””
import os
print(os.getcwd())
“””
Y = 2

 Я назвал этот прием ужасным, потому что при работе интерпретатор
вынужден создавать строку из строк программного кода, отключенных таким
способом, но, скорее всего, это слабо сказывается на производительности.
В случае крупных блоков программного кода использовать этот прием
гораздо удобнее, чем вставлять символы решетки в начале каждой строки,
а затем убирать их. Это особенно верно, если используемый вами текстовый
редактор не поддерживает возможность редактирования исходных текстов
на языке Python. При программировании на этом языке практичность
часто берет верх над эстетичностью.


 Строки в действии


 Базовые операции

 Строки можно объединять с помощью оператора конкатенации +
и дублировать с помощью оператора повторения *:

% python
\>>> len(‘abc’)  # Длина: число элементов
3
\>>> ‘abc’ + ‘def’  # Конкатенация: новая строка
‘abcdef’
\>>> ‘Ni!’ * 4  # Повторение: подобно “Ni!” + “Ni!” + ...
‘Ni!Ni!Ni!Ni!’

 Формально операция сложения двух строковых объектов создает новый
строковый объект, объединяющий содержимое операндов. Операция повторения
напоминает многократное сложение строки с самой собой. В обоих случаях
Python позволяет создавать строки произвольного размера – нет никакой
необходимости предварительно объявлять что бы то ни было, включая
размеры структур данных. Встроенная функция len возвращает длину строки
(или любого другого объекта, который имеет длину).

 В отличие от массивов символов в языке C, при работе со строками
в языке Python вам не нужно выделять или управлять памятью массивов –
вы просто создаете объекты строк, когда в этом возникает необходимость,
и позволяете интерпретатору самому управлять памятью, выделяемой
для этих объектов. Как уже говорилось в главе 6, Python автоматически
освобождает память, занятую ненужными объектами, используя стратегию
сборки мусора, основанную на подсчете количества ссылок. Каждый объект
следит за количеством имен, структур данных и другими компонентами,
которые ссылаются на него. Когда количество ссылок уменьшается до нуля,
интерпретатор освобождает память, занятую объектом. Это означает,
что интерпретатору не требуется останавливаться и просматривать
всю память в поисках неиспользуемого пространства (дополнительный
компонент сборки мусора собирает также циклические объекты).

 Операция повторения на первый взгляд выглядит несколько странно, но она
очень удобна в очень широком диапазоне применений. Например,
чтобы вывести строку из 80 символов дефиса, можно самому сосчитать
до 80, а можно возложить эту работу на плечи интерпретатора:

\>>> print(‘------- ...много дефисов... ---’)  # 80 дефисов,
                                               # сложный способ
\>>> print(‘-’ * 80)  # 80 дефисов, простой способ

 Обратите внимание: здесь работает механизм перегрузки операторов:
мы используем те же самые операторы + и *, которые используются
для выполнения операций сложения и умножения с числами. Интерпретатор
выполняет требуемую операцию, потому что ему известны типы объектов,
к которым применяются операции сложения и умножения. Но будьте
внимательны: правила не так либеральны, как может показаться. Например,
интерпретатор не позволяет смешивать строки и числа в выражениях
сложения: ‘abc’ + 9 вызовет ошибку вместо того, чтобы автоматически
преобразовать число 9 в строку.

 Как показано в последней строке табл., допускается выполнять обход
элементов строки в цикле, используя инструкцию for, и проверять
вхождение подстроки в строку с помощью оператора выражения in, который,
по сути, выполняет операцию поиска. В случае поиска подстрок оператор
in напоминает метод str.find(), который рассматривается ниже,
в этой же главе, – с тем отличием, что он возвращает логический
результат, а не позицию подстроки в строке:

\>>> myjob = “hacker”
\>>> for c in myjob: print(c, end=’ ‘),  # Обход элементов строки
                                         # в цикле
...
h a c k e r
\>>> “k” in myjob  # Найдено
True
\>>> “z” in myjob  # Не найдено
False
\>>> ‘spam’ in ‘abcspamdef’  # Поиск подстроки, позиция не возвращается
True

 Оператор цикла for присваивает переменной очередной элемент
последовательности (в данном случае – строки) и для каждого элемента
выполняет одну или более инструкций. В результате переменная c
превращается в своего рода курсор,
который постепенно перемещается по строке.


 Доступ по индексам и извлечение подстроки

 Так как строки определены как упорядоченные коллекции символов,
мы можем обращаться к элементам строк по номерам позиций. В языке Python
символы извлекаются из строк с помощью операции индексирования –
указанием числового смещения требуемого компонента в квадратных скобках
после имени строки. В результате операции вы получаете строку, состоящую
из одного символа, находящегося в указанной позиции.

 Как и в языке C, в языке Python смещения символов в строках начинают
исчисляться с 0, а последний символ в строке имеет смещение на единицу
меньше длины строки. Однако, в отличие от C, Python также позволяет
извлекать элементы последовательностей, таких как строки, используя
отрицательные смещения. Технически отрицательное смещение складывается
с длиной строки, чтобы получить положительное смещение. Отрицательные
смещения можно также представить себе как отсчет символов с конца
строки. Например:

\>>> S = ‘spam’
\>>> S[0], S[-2]  # Индексация от начала или от конца
(‘s’, ‘a’)
\>>> S[1:3], S[1:], S[:-1]  # Получение среза: извлечение подстроки
(‘pa’, ‘pam’, ‘spa’)

 Последняя строка в предыдущем примере демонстрирует операцию извлечения
среза (slicing). Получение среза можно считать некоторой формой
синтаксического анализа, особенно при работе со строками, –
она позволяет извлекать целые участки (подстроки) за одно действие.
Операция получения среза может использоваться для извлечения столбцов
данных, обрезания ведущих и завершающих блоков текста и тому подобного.
Позже, в этой же главе, мы рассмотрим другой пример использования
операции получения среза для синтаксического анализа строки.

 Как же выполняется операция получения среза? Когда производится
индексирование объекта последовательности, такого как строка, парой
смещений, разделенных двоеточием, интерпретатор Python возвращает
новый объект, содержащий непрерывную область, определяемую парой
смещений. Значение смещения слева от двоеточия обозначает левую границу
(включительно), а справа – верхнюю границу (она не входит в срез).
Интерпретатор извлекает все элементы от нижней границы до верхней,
но верхняя граница в срез не включается. Если левая и правая граница
опущены, по умолчанию принимаются значения, равные 0 и длине объекта
соответственно, из которого извлекается срез.

 Например, для только что рассмотренного примера выражение S[1:3] вернет
элементы со смещениями 1 и 2. То есть будут извлечены второй и третий
элементы, и операция остановится перед четвертым элементом со смещением,
равным 3. Выражение S[1:] вернет все элементы, расположенные
за первым, – за значение верхней границы, которая в выражении опущена,
по умолчанию принимается длина строки. Наконец, выражение S[:-1] вернет
все элементы, кроме последнего, – за значение нижней границы
по умолчанию принимается 0, а индекс –1 соответствует последнему
элементу, который в срез не включается. Все это может показаться
на первый взгляд слишком замысловатым, но операции извлечения отдельных
элементов и срезов превратятся в простые и мощные инструменты,
как только вы ими овладеете. Если вы забыли, как выполняется срез,
попробуйте получить его в интерактивном сеансе. В следующей главе
вы увидите, что существует возможность изменить целый раздел
определенного объекта одной инструкцией, достаточно лишь выполнить
операцию присваивания срезу. Далее приводится краткий обзор для справки:

 Операция индексирования (S[i]) извлекает компоненты по их смещениям:

  Первый элемент имеет смещение 0.

  Отрицательные индексы определяют смещения в обратном порядке –
 от конца, или справа.

  Выражение S[0] извлекает первый элемент.

  Выражение S[-2] извлекает второй с конца элемент (так же, как и
 выражение S[len(S)-2]).

 Операция извлечения подстроки (S[i:j]) извлекает непрерывный раздел
последовательности:

  Элемент с индексом, равным верхней границе, не включается в срез.

  Если границы не указаны, по умолчанию они принимаются равными 0
 и длине последовательности.
  Выражение S[1:3] извлекает элементы со смещениями от 1 до 3
 (не включая элемент со смещением 3).

  Выражение S[1:] извлекает элементы, начиная со смещения 1 и до конца
 (длина последовательности).

  Выражение S[:3] извлекает элементы, начиная со смещения 0 и до 3
 (не включая его).

  Выражение S[:-1] извлекает элементы, начиная со смещения 0
 и до последнего (не включая его).

  Выражение S[:] извлекает элементы, начиная со смещения 0 и до конца, –
 это эффективный способ создать поверхностную копию
 последовательности S.


 Расширенная операция извлечения подстроки: третий предел

 В версии Python 2.3 в операцию извлечения подстроки была добавлена
поддержка необязательного третьего индекса, используемого как шаг
(иногда называется как шаг по индексу). Величина шага добавляется
к индексу каждого извлекаемого элемента. Полная форма записи операции
извлечения подстроки теперь выглядит так: X[I:J:K]. Она означает:
«Извлечь все элементы последовательности X, начиная со смещения I,
вплоть до смещения J-1, с шагом K». Третий предел, K, по умолчанию имеет
значение 1, именно по этой причине в обычной ситуации извлекаются все
элементы среза, слева направо. Однако если явно указать значение
третьего предела, его можно использовать, чтобы пропустить некоторые
элементы или полностью изменить их порядок.

 Например, выражение X[1:10:2] вернет каждый второй элемент
последовательности X в диапазоне смещений от 1 до 9 – то есть будут
выбраны элементы со смещениями 1, 3, 5, 7 и 9. Как правило,
по умолчанию первый и второй пределы принимают значения 0
и длину последовательности соответственно, поэтому выражение X[::2]
вернет каждый второй элемент от начала и до конца последовательности:

\>>> S = ‘abcdefghijklmnop’
\>>> S[1:10:2]
‘bdfhj’
\>>> S[::2]
‘acegikmo’

 Можно также использовать отрицательное значение шага. Например,
выражение “hello”[::-1] вернет новую строку “olleh”. Здесь первые
две границы получают значения по умолчанию – 0 и длина
последовательности, а величина шага, равная -1, указывает,
что срез должен быть выбран в обратном порядке – справа налево,
а не слева направо. В результате получается перевернутая
последовательность:

\>>> S = ‘hello’
\>>> S[::-1]
‘olleh’

 При использовании отрицательного шага порядок применения первых двух
границ меняется на противоположный. То есть выражение S[5:1:-1] извлечет
элемент со 2 по 5 в обратном порядке (результат будет содержать элементы
последовательности со смещениями 5, 4, 3 и 2):

\>>> S = ‘abcedfg’
\>>> S[5:1:-1]
‘fdec’

\>>> ‘spam’[1:3]  # Синтаксис извлечения среза
‘pa’
\>>> ‘spam’[slice(1, 3)]  # используется объект среза
‘pa’
\>>> ‘spam’[::-1]
‘maps’
\>>> ‘spam’[slice(None, None, -1)]
‘maps’

 Инструменты преобразования строк

 Один из девизов языка Python – не поддаваться искушению делать
предположения о том, что имелось в виду. Например, Python не позволит
сложить строку и число, даже если строка выглядит как число
(то есть содержит только цифры):

\>>> “42” + 1
TypeError: cannot concatenate ‘str’ and ‘int’ objects

 В соответствии с архитектурой языка оператор + может означать
и операцию сложения, и операцию конкатенации, вследствие чего выбор типа
преобразования становится неочевидным. Поэтому интерпретатор
воспринимает такую инструкцию как ошибочную. Вообще в языке Python
отвергается любая магия, которая может осложнить жизнь программиста.

 Как же быть, если сценарий получает число в виде текстовой строки
из файла или от пользовательского интерфейса? В этом случае следует
использовать инструменты преобразования, чтобы можно было
интерпретировать строку как число или наоборот. Например:

\>>> int(“42”), str(42)  # Преобразование из/в строки
(42, ‘42’)
\>>> repr(42),  # Преобразование в строку, как если бы она была
‘42’            # литералом в программном коде

 Функция int преобразует строку в число, а функция str преобразует число
в строковое представление (по сути – в то, что выводится на экран).
Функция repr (и прежний ее эквивалент, обратные апострофы, который
был удален в Python 3.0) также преобразует объект в строковое
представление, но возвращает объект в виде строки программного кода,
который можно выполнить, чтобы воссоздать объект. Если объект – строка,
то инструкция print выведет кавычки, окружающие строку:

\>>> print(str(‘spam’), repr(‘spam’))
(‘spam’, “’spam’”)

 Вы не сможете смешивать строковые и числовые типы в таких операторах,
как +, но вы можете вручную выполнить необходимые преобразования
операндов перед выполнением операции:

\>>> S = “42”
\>>> I = 1
\>>> S + I
TypeError: cannot concatenate ‘str’ and ‘int’ objects

\>>> int(S) + I  # Операция сложения
43
\>>> S + str(I)  # Операция конкатенации
‘421’

 Существуют похожие встроенные функции для преобразования вещественных
чисел в/из строки:

\>>> str(3.1415), float(“1.5”)
(‘3.1415’, 1.5)
\>>> text = “1.234E-10”
\>>> float(text)
1.2340000000000001e-010

 Позднее мы познакомимся со встроенной функцией eval – она выполняет
строку, содержащую программный код на языке Python, и потому может
выполнять преобразование строки в объект любого вида. Функции int
и float преобразуют только числа, но это ограничение означает,
что они обычно выполняют эту работу быстрее (и безопаснее, потому что
они не принимают программный код произвольного выражения).


 Преобразование кодов символов

 Имеется также возможность выполнить преобразование одиночного символа
в его целочисленный код ASCII, для чего нужно передать этот символ
функции ord – она возвращает фактическое числовое значение
соответствующего байта в памяти. Обратное преобразование выполняется
с помощью функции chr, она получает целочисленный код ASCII
и преобразует его в соответствующий символ:

\>>> ord(‘s’)
115
\>>> chr(115)
‘s’

 Эти функции можно применить ко всем символам строки в цикле. Они могут
также использоваться для реализации своего рода строковой математики.
Например, чтобы получить следующий по алфавиту символ, его можно
преобразовать в число и выполнить математическое действие над ним:

\>>> S = ‘5’
\>>> S = chr(ord(S) + 1)
\>>> S
‘6’
\>>> S = chr(ord(S) + 1)
\>>> S
‘7’

 Следующий пример преобразования представляет собой альтернативу
встроенной функции int, по крайней мере для односимвольных строк,
для преобразования строки в целое число:

\>>> int(‘5’)
5
\>>> ord(‘5’) - ord(‘0’)
5

 Такие преобразования могут использоваться в сочетании с операторами
цикла, представленными в главе 4 и подробно рассматриваемыми
в следующей части книги, для получения целочисленных значений
из строковых представлений двоичных чисел. В каждой итерации текущее
значение умножается на 2 и затем к нему прибавляется числовое значение
следующей цифры:

\>>> B = ‘1101’  # Двоичные цифры преобразуются в числа
\>>> I = 0       # с помощью функции ord
\>>> while B != ‘’:
... I = I * 2 + (ord(B[0]) - ord(‘0’))
... B = B[1:]
...
\>>> I
13

 Операция побитового сдвига влево (I << 1) могла бы дать тот же эффект,
что и операция умножения на 2. Но так как мы еще не познакомились
с циклами и уже видели встроенные функции int и bin в главе 5,
которые могут использоваться в задачах преобразования двоичных чисел
в Python 2.6 и 3.0, то же самое можно реализовать, как показано ниже:

\>>> int(‘1101’, 2)  # Преобразовать двоичное представление
13                   # в целое число
\>>> bin(13)  # Преобразовать целое число в двоичное представление
‘0b1101’

 С течением времени язык Python стремится автоматизировать решение
наиболее типичных задач!
"""

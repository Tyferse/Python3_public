"""
 Словари

 Словари в языке Python – это нечто совсем иное (по выражению
Монти Пайтона); они вообще не являются последовательностями, это то,
что известно как отображения. Отображения – это коллекции объектов,
но доступ к ним осуществляется не по определенным смещениям
от начала коллекции, а по ключам. В действительности отображения вообще
не подразумевают какого-либо упорядочения элементов по их позиции,
они просто отображают ключи на связанные с ними значения.
Словари – единственный тип отображения в наборе базовых
объектов Python – также относятся к классу изменяемых объектов:
они могут изменяться непосредственно и в случае необходимости могут
увеличиваться и уменьшаться в размерах подобно спискам.


 Операции над отображениями

 Когда словарь определяется как литерал, программный код определения
заключается в фигурные скобки и состоит из последовательности пар «ключ:
значение». Словари удобно использовать всегда, когда возникает
необходимость связать значения с ключами, например, чтобы описать
свойства чего-либо. В качестве примера рассмотрим следующий словарь,
состоящий из трех элементов (с ключами «food» (продукт питания),
«quantity» (количество) и «color» (цвет)):

\>>> D = {‘food’: ‘Spam’, ‘quantity’: 4, ‘color’: ‘pink’}

 Мы можем обращаться к элементам этого словаря по ключам и изменять
значения, связанные с ключами. Для доступа к элементам словаря
используется тот же синтаксис, который используется для обращения
к элементам последовательностей, только в квадратных скобках указывается
не смещение относительно начала последовательности, а ключ:

\>>> D[‘food’]  # Получить значение, связанное с ключом ‘food’
‘Spam’

\>>> D[‘quantity’] += 1  # Прибавить 1 к значению ключа ‘quantity’
\>>> D
{‘food’: ‘Spam’, ‘color’: ‘pink’, ‘quantity’: 5}

 Несмотря на то, что форма определения словаря в виде литерала,
заключенного в фигурные скобки, достаточно наглядна, на практике чаще
встречаются другие способы создания словарей. Следующий пример
начинается с создания пустого словаря, который затем заполняется
по одному ключу за раз. В отличие от списков, не допускающих
присваивание значений отсутствующим элементам, присваивание значения
по несуществующему ключу в словаре приводит к созданию этого ключа:

\>>> D = {}
\>>> D[‘name’] = ‘Bob’  # В результате присваивания создается ключ
\>>> D[‘job’] = ‘dev’
\>>> D[‘age’] = 40

\>>> D
{‘age’: 40, ‘job’: ‘dev’, ‘name’: ‘Bob’}

\>>> print(D[‘name’])
Bob


 Еще раз о вложенности

 В предыдущем примере словарь использовался для описания гипотетической
персоны с помощью трех ключей. Теперь предположим, что информация имеет
более сложную структуру. Возможно, придется записать имя и фамилию,
а также несколько названий должностей, занимаемых одновременно. Это
приводит к необходимости использования вложенных объектов Python.
Словарь в следующем примере определен в виде литерала и имеет более
сложную структуру:

\>>> rec = {‘name’: {‘first’: ‘Bob’, ‘last’: ‘Smith’},
           ‘job’: [‘dev’, ‘mgr’],
           ‘age’: 40.5}

 Здесь мы опять имеем словарь, содержащий три ключа верхнего уровня
(ключи «name» (имя), «job» (должность) и «age» (возраст)),
однако значения имеют более сложную структуру: для описания имени
человека используется вложенный словарь, чтобы обеспечить
поддержку имен, состоящих из нескольких частей, и для перечисления
занимаемых должностей используется вложенный список, что обеспечит
возможность расширения в будущем. К компонентам этой структуры можно
обращаться почти так же, как мы делали это в случае с матрицей,
но на этот раз вместо числовых индексов мы используем ключи словаря:

\>>> rec[‘name’]  # ‘Name’ – это вложенный словарь
{‘last’: ‘Smith’, ‘first’: ‘Bob’}
\>>> rec[‘name’][‘last’]  # Обращение к элементу вложенного словаря
‘Smith’

\>>> rec[‘job’]  # ‘Job’ – это вложенный список
[‘dev’, ‘mgr’]
\>>> rec[‘job’][-1]  # Обращение к элементу вложенного списка
‘mgr’

\>>> rec[‘job’].append(‘janitor’)  # Расширение списка должностей Боба
\>>> rec
{‘age’: 40.5, ‘job’: [‘dev’, ‘mgr’, ‘janitor’],
 ‘name’: {‘last’: ‘Smith’, ‘first’: ‘Bob’}}

 Обратите внимание, как последняя операция в этом примере выполняет
расширение вложенного списка. Так как список должностей – это отдельный
от словаря участок в памяти, он может увеличиваться и уменьшаться
без каких-либо ограничений.

 В языке Python память освобождается автоматически, когда теряется
последняя ссылка на объект, например в случае присваивания переменной
какого-либо другого значения:

\>>> rec = 0  # Теперь память, занятая объектом, будет освобождена

 С технической точки зрения, интерпретатор Python обладает такой
особенностью, как сборка мусора, благодаря которой в ходе выполнения
программы производится освобождение неиспользуемой памяти,
что избавляет нас от необходимости предусматривать специальные действия
в программном коде. Интерпретатор освобождает память сразу же,
как только будет ликвидирована последняя ссылка на объект.


 Сортировка по ключам: циклы for

 Будучи отображениями, как мы уже видели, словари поддерживают доступ
к элементам только по ключам. Однако они кроме того поддерживают ряд
специфических для данного типа операций, реализованных в виде методов,
которые удобно использовать в разных случаях.

 Как уже упоминалось ранее, из-за того, что словари не являются
последовательностями, они не предусматривают какой-либо надежный способ
упорядочения позиций элементов. Это означает, что если мы создадим
словарь и попытаемся вывести его содержимое, порядок следования ключей
при выводе может не совпадать с порядком, в каком они определялись:

\>>> D = {‘a’: 1, ‘b’: 2, ‘c’: 3}
\>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}

 Как же быть, если нам действительно потребуется упорядочить элементы
словаря? В наиболее общем случае мы могли бы получить список всех ключей
словаря методом keys, отсортировать их с помощью метода списка sort
и затем выполнить обход значений в цикле for (не забудьте дважды нажать
клавишу Enter после ввода цикла for ниже – как уже пояснялось в главе 3,
пустая строка в интерактивной оболочке означает окончание составной
инструкции):

\>>> Ks = list(D.keys())  # Неупорядоченный список ключей
\>>> Ks  # Список – в версии 2.6, а в 3.0 – “представление”,
[‘a’, ‘c’, ‘b’]  # поэтому необходимо использовать функцию list()

\>>> Ks.sort()  # Сортировка списка ключей
\>>> Ks
[‘a’, ‘b’, ‘c’]

\>>> for key in Ks:  # Обход отсортированного списка ключей
print(key, ‘=>’, D[key])  # Здесь дважды нажмите клавишу Enter
a => 1
b => 2
c => 3

 Этот процесс, состоящий из трех этапов, в последних версиях Python
можно упростить до единственной операции, как будет показано
в последующих главах, с помощью новой встроенной функции sorted.
Эта функция сортирует объекты разных типов и возвращает результат:

\>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}

\>>> for key in sorted(D):
print(key, ‘=>’, D[key])
a => 1
b => 2
c => 3

 Этот пример может служить поводом для знакомства с циклом for языка
Python. Цикл for представляет собой самый простой и эффективный способ
произвести обход всех элементов в последовательности и выполнить блок
программного кода для каждого из элементов. Переменная цикла,
определяемая пользователем (в данном случае key), служит для ссылки
на текущий элемент. В этом примере выводятся ключи
и значения несортированного словаря в отсортированном по ключам виде.

 Цикл for и родственный ему цикл while – это основные способы реализации
повторяющихся действий в сценариях. Однако в действительности цикл for
(так же, как и родственные ему генераторы списков, с которыми мы
познакомились выше), является операцией над последовательностью.
Он способен работать с любыми объектами, являющимися
последовательностями, а также с некоторыми объектами,
которые последовательностями не являются. Ниже приводится пример
обхода всех символов в строке и вывод их в верхнем регистре:

\>>> for c in ‘spam’:
print(c.upper())
S
P
A
M

 Цикл while в языке Python представляет собой более универсальный
инструмент выполнения циклически повторяющихся операций и не имеет
прямой связи с последовательностями:

\>>> x = 4
\>>> while x > 0:
print(‘spam!’ * x)
x -= 1

spam!spam!spam!spam!
spam!spam!spam!
spam!spam!
spam!


 Итерации и оптимизация

 Неслучайно цикл for выглядит похожим на выражения-генераторы,
введенные ранее: каждый из этих инструментов представляет собой
универсальное средство выполнения итераций. Фактически обе конструкции
способны работать с любыми объектами, которые поддерживают протокол
итераций – идею, недавно появившуюся в Python, которая по сути
подразумевает наличие в памяти последовательности или объекта,
который генерирует по одному элементу за раз в контексте выполнения
итерации. Объект попадает в категорию итерируемых, если в ответ
на вызов встроенной функции iter (с этим объектом в качестве аргумента)
возвращается объект, который позволяет перемещаться по его элементам
с помощью функции next. Генераторы списков, с которыми
мы познакомились выше, являются такими объектами.

 О протоколе итераций я расскажу позднее в этой же книге. А пока
просто запомните, что любой инструмент языка Python, сканирующий объект
слева направо, использует протокол итераций. Именно поэтому
функция sorted, которая использовалась в предыдущем разделе,
способна работать со словарем непосредственно – нам не требуется
вызывать метод keys для получения последовательности, потому что
словари являются итерируемыми объектами, для которых функция next
возвращает следующий ключ.

 Это также означает, что любой генератор списков такой, как показано
ниже, вычисляющий квадраты чисел в списке:

\>>> squares = [x ** 2 for x in [1, 2, 3, 4, 5]]
\>>> squares
[1, 4, 9, 16, 25]

 всегда можно представить в виде эквивалентного цикла for, который
создает список с результатами, добавляя новые элементы в ходе
выполнения итераций:

\>>> squares = []
\>>> for x in [1, 2, 3, 4, 5]:  # Эти же операции выполняет
                               # и генератор списков,
squares.append(x ** 2)  # следуя протоколу итераций
\>>> squares
[1, 4, 9, 16, 25]

 Однако генераторы списков и родственные им инструменты функционального
программирования, такие как функции map и filter, обычно выполняются
быстрее, чем цикл for (примерно раза в два), что особенно важно
для программ, обрабатывающих большие объемы данных. И, тем не менее,
следует заметить, что оценка производительности – вещь очень хитрая
в языке Python, потому что в процессе разработки он продолжает
оптимизироваться, и производительность тех или иных конструкций может
изменяться от версии к версии. Главное правило, которому желательно
следовать при использовании языка Python – это простота
и удобочитаемость программного кода, а проблему производительности
следует рассматривать во вторую очередь, уже после того,
как будет создана работоспособная программа и когда проблема
производительности программы действительно заслуживает того,
чтобы на нее обратили внимание. Но чаще всего ваш программный код
будет обладать достаточно высокой производительностью. Если же вам
потребуется оптимизировать программу, в составе Python вы найдете
инструменты, которые помогут вам в этом, включая модули time и timeit,
а также модуль profile.


 Отсутствующие ключи: проверка с помощью оператора if

 Необходимо сделать еще одно замечание о словарях, прежде чем двинуться
дальше. Несмотря на то, что операция присваивания значений элементам
с несуществующими ключами приводит к расширению словаря, тем не менее,
при попытке обратиться к несуществующему элементу возникает ошибка:

\>>> D
{‘a’: 1, ‘c’: 3, ‘b’: 2}
\>>> D[‘e’] = 99  # Присваивание по новому ключу
\>>> D            # приводит к расширению словаря
{‘a’: 1, ‘c’: 3, ‘b’: 2, ‘e’: 99}
\>>> D[‘f’]  # Попытка обратиться к несуществующему ключу
            # приводит к ошибке
...текст сообщения об ошибке опущен...
KeyError: ‘f’

 Программная ошибка при попытке получить значение несуществующего
элемента – это именно то, что нам хотелось бы получать. Но в общем
случае при создании программного кода мы не всегда можем знать,
какие ключи будут присутствовать. Как быть в таких случаях,
чтобы не допустить появления ошибок? Для этого можно, например,
выполнить предварительную проверку. Применительно к словарям
оператор in, проверки на членство, позволяет определить наличие ключа
и с помощью условного оператора if выполнить тот или иной
программный код (как и в случае инструкции for, не забудьте дважды
нажать клавишу Enter после ввода инструкции if
в интерактивной оболочке):

\>>> ‘f’ in D
False

\>>> if not ‘f’ in D:
Print(‘missing’)

missing

 Существуют также и другие способы создания словарей
и исключения ошибок обращения к несуществующим элементам словаря:
метод get (при обращении к которому можно указать значение, возвращаемое
по умолчанию); в Python 2.X имеется метод has_key (который недоступен
в версии 3.0); инструкция try (с которой мы познакомимся в главе 10,
позволяющая перехватывать и обрабатывать исключения) и выражение if/else
(по сути тот же условный оператор if, сжатый до размеров одной строки),
например:

\>>> value = D.get(‘x’, 0)  # Попытка получить значение,
\>>> value  # указав значение по умолчанию
0

\>>> value = D[‘x’] if ‘x’ in D else 0  # Выражение if/else
\>>> value
0


 Кортежи

 Объект-кортеж (tuple – произносится как «тъюпл» или «тъюпел»,
в зависимости от того, у кого вы спрашиваете) в общих чертах напоминает
список, который невозможно изменить – кортежи являются
последовательностями, как списки, но они являются неизменяемыми
как строки. Синтаксически литерал кортежа заключается в круглые,
а не в квадратные скобки. Они также поддерживают включение объектов
различных типов, вложение и операции, типичные для последовательностей:

\>>> T = (1, 2, 3, 4)  # Кортеж из 4 элементов
\>>> len(T)  # Длина
4

>> T + (5, 6)  # Конкатенация
(1, 2, 3, 4, 5, 6)
\>>> T[0]  # Извлечение элемента, среза и так далее
1

 В Python 3.0 кортежи обладают двумя методами, которые также имеются
у списков:

\>>> T.index(4)  # Методы кортежей: значение 4 находится в позиции 3
3
\>>> T.count(4)  # Значение 4 присутствует в единственном экземпляре
1

 Основное отличие кортежей – это невозможность их изменения после
создания. То есть кортежи являются неизменяемыми последовательностями:

\>>> T[0] = 2  # Кортежи являются неизменяемыми
...текст сообщения об ошибке опущен...
TypeError: ‘tuple’ object does not support item assignment

 Подобно спискам и словарям кортежи способны хранить объекты разных
типов и допускают возможность вложения, но в отличие от них, не могут
изменять свои размеры, так как являются неизменяемыми объектами:

\>>> T = (‘spam’, 3.0, [11, 22, 33])
\>>> T[1]
3.0

\>>> T[2][1]
22
\>>> T.append(4)
AttributeError: ‘tuple’ object has no attribute ‘append’


 Для чего нужны кортежи?

 Зачем нужен тип, который напоминает список, но поддерживает меньшее
число операций? Откровенно говоря, на практике кортежи используются
не так часто, как списки, и главное их достоинство – неизменяемость.
Если коллекция объектов передается между компонентами программы
в виде списка, он может быть изменен любым из компонентов.
Если используются кортежи, такие изменения становятся невозможны.
То есть кортежи обеспечивают своего рода ограничение целостности,
что может оказаться полезным в крупных программах.


 Файлы

 Объекты-файлы – это основной интерфейс между программным кодом на
языке Python и внешними файлами на компьютере. Файлы являются одним из
базовых типов, но они представляют собой нечто необычное, поскольку для
файлов отсутствует возможность создания объектов в виде литералов.
Вместо этого, чтобы создать объект файла, необходимо вызвать встроенную
функцию open, передав ей имя внешнего файла и строку режима доступа
к файлу. Например, чтобы создать файл для вывода данных,
вместе с именем файла функции необходимо передать строку режима ‘w’:

\>>> f = open(‘data.txt’, ‘w’)  # Создается новый файл для вывода
\>>> f.write(‘Hello\n’)  # Запись строки байтов в файл
6

\>>> f.write(‘world\n’)  # В Python 3.0 возвращает количество
6                       # записанных байтов
\>>> f.close()  # Закрывает файл и выталкивает выходные буферы на диск

 В этом примере создается файл в текущем каталоге и в него записывается
текст (имя файла может содержать полный путь к каталогу, если требуется
получить доступ к файлу, находящемуся в другом месте).
Чтобы прочитать то, что было записано в файл, его нужно открыть в режиме
‘r’ (этот режим используется по умолчанию, если строка режима в вызове
функции опущена). Затем прочитать содержимое файла в строку
и отобразить ее. Содержимое файла для сценария всегда является строкой
независимо от типов данных, фактически хранящихся в файле:

\>>> f = open(‘data.txt’)
# ‘r’ – это режим доступа к файлу по умолчанию
\>>> text = f.read()  # Файл читается целиком в строку
\>>> text
‘Hello\nworld\n’

\>>> print(text)  # Вывод, с попутной интерпретацией служебных символов
Hello
world

\>>> text.split()  # Содержимое файла всегда является строкой
[‘Hello’, ‘world’]

 Объекты-файлы имеют и другие методы, обеспечивающие поддержку
дополнительных возможностей, но пока мы не будем рассматривать их.
Например, объекты файлов предоставляют различные способы чтения
и записи данных (метод read принимает необязательный параметр –
количество байтов, метод readline считывает по одной строке за одно
обращение и так далее) и другие методы (seek – перемещает позицию
чтения/записи в файле). Однако, как будет показано позднее,
самый лучший на сегодняшний день способ чтения файлов состоит в том,
чтобы не читать его содержимое целиком – файлы предоставляют итераторы,
которые обеспечивают автоматическое построчное чтение содержимого файла
в циклах for и в других контекстах.

 Содержимое текстовых файлов представляется в виде строк и для них
автоматически выполняется кодирование и декодирование символов Юникода.
Содержимое двоичных файлов представляется в виде строк специального типа
bytes, при этом никаких автоматических преобразований содержимого файлов
не производится:

\>>> data = open(‘data.bin’, ‘rb’).read()  # Файл открывается
                                          # в двоичном режиме
\>>> data  # Строка байтов хранит двоичные данные
b’\x00\x00\x00\x07spam\x00\x08’

\>>> data[4:8]
b’spam’

 Хотя при работе исключительно с текстовыми данными в формате ASCII
о таких различиях обычно беспокоиться не приходится, однако в Python 3.0
строки и файлы требуют особого внимания – при работе
с интернационализированными приложениями или двоичными данными.


 Другие базовые типы

 Помимо базовых типов данных, которые мы уже рассмотрели, существуют
и другие, которые могут считаться базовыми в зависимости от широты
определения этой категории. Например, множества, совсем недавно
появившиеся в языке, – которые не являются ни последовательностями,
ни отображениями. Множества – это неупорядоченные коллекции уникальных
и неизменяемых объектов. Множества создаются встроенной функцией set
или с помощью новых синтаксических конструкций определения литералов
и генераторов множеств, появившихся в версии 3.0, и поддерживают
типичные математические операции над множествами
(выбор синтаксической конструкции {...} для определения литералов
множеств в версии 3.0 не случаен, поскольку множества напоминают
словари, в которых ключи не имеют значений):

\>>> X = set(‘spam’)  # В 2.6 и 3.0 можно создавать
                     # из последовательностей
\>>> Y = {‘h’, ‘a’, ‘m’}  # В 3.0 можно определять литералы множеств
\>>> X, Y
({‘a’, ‘p’, ‘s’, ‘m’}, {‘a’, ‘h’, ‘m’})

\>>> X & Y  # Пересечение
{‘a’, ‘m’}

\>>> X | Y  # Объединение
{‘a’, ‘p’, ‘s’, ‘h’, ‘m’}

\>>> X – Y  # Разность
{‘p’, ‘s’}

\>>> {x ** 2 for x in [1, 2, 3, 4]}  # Генератор множеств в 3.0
{16, 1, 4, 9}

 Кроме того, недавно в Python появились вещественные числа
с фиксированной точностью и рациональные числа (числа,
представленные дробью, то есть парой целых чисел – числителем
и знаменателем). Обе разновидности могут использоваться для решения
проблем, связанных с точностью представления простых вещественных чисел:

\>>> 1 / 3  # Вещественное число (в 2.6 числа должны заканчиваться .0)
0.33333333333333331
\>>> (2/3) + (1/2)
1.1666666666666665

\>>> import decimal  # Вещественные числа с фиксированной точностью
\>>> d = decimal.Decimal(‘3.141’)
\>>> d + 1
Decimal(‘4.141’)

\>>> decimal.getcontext().prec = 2
\>>> decimal.Decimal(‘1.00’) / decimal.Decimal(‘3.00’)
Decimal(‘0.33’)

\>>> from fractions import Fraction  # Рациональные числа:
\>>> f = Fraction(2, 3)              # числитель+знаменатель
\>>> f + 1
Fraction(5, 3)
\>>> f + Fraction(1, 2)
Fraction(7, 6)

 Кроме того в языке Python имеется логический тип данных
(представленный предопределенными объектами True и False, которые
по сути являются обычными целыми числами 1 и 0
с некоторыми особенностями отображения на экране), а кроме того,
давно уже существует специальный объект None, обычно используемый
для инициализации переменных и объектов:

\>>> 1 > 2, 1 < 2  # Логические значения
(False, True)
\>>> bool(‘spam’)
True

\>>> X = None  # Специальный объект None
\>>> print(X)
None

\>>> L = [None] * 100  # Инициализация списка сотней объектов None
\>>> L
[None, None, None, None, None, None, None, None, None, None, None, None,
None, None, None, None, None, None,
None, ...список из 100 объектов None...]


 Как можно нарушить гибкость программного кода

 Мы еще будем много говорить обо всех этих типах данных далее в книге,
но сначала я хочу сделать важное замечание. Тип объекта, возвращаемый
встроенной функцией type, в свою очередь сам является объектом.
В Python 3.0 этот объект несколько отличается от того, что возвращается
в версии 2.6, потому что все типы были объединены с классами.
Допустим, что переменная L по-прежнему представляет список,
созданный в предыдущем разделе:

# В Python 2.6:

\>>> type(L)  # Типы: переменная L представляет объект типа list
<type ‘list’>
\>>> type(type(L))  # Даже сами типы являются объектами
<type ‘type’>

# В Python 3.0:

\>>> type(L)  # 3.0: типы являются классами, и наоборот
<class ‘list’>
\>>> type(type(L))
# Подробнее о классах типов рассказывается в главе 31
<class ‘type’>

 Типы объектов можно исследовать не только в интерактивной оболочке,
но и в программном коде, который использует эти объекты. Сделать это
в сценариях на языке Python можно как минимум тремя способами:

\>>> if type(L) == type([]):  # Проверка типа, если в этом
print(‘yes’)                 # есть необходимость...

yes

\>>> if type(L) == list:  # С использованием имени типа
print(‘yes’)

yes

\>>> if isinstance(L, list):
# Проверка в объектно-ориентированном стиле
print(‘yes’)

yes

 Наличие проверок на принадлежность объекта к тому или иному типу
отрицательно сказывается на гибкости программного кода, потому что вы
ограничиваете его работой с единственным типом данных. Без таких
проверок ваш программный код может оказаться в состоянии работать
с более широким диапазоном типов.

 Это связано с идей полиморфизма, о которой упоминалось ранее,
и это основная причина отсутствия необходимости описывать
типы переменных в языке Python. Как будет говориться далее,
программный код на языке Python ориентируется на использование
интерфейсов объектов (наборов поддерживаемых операций), а не их типов.
Отсутствие заботы об определенных типах означает, что программный код
автоматически может обслуживать большинство из них – допустимыми будут
любые объекты с совместимыми интерфейсами независимо
от конкретного типа. И хотя контроль типов поддерживается,
а в редких случаях даже необходим, тем не менее, такой способ мышления
чужд языку Python. Вы сами убедитесь, что полиморфизм является ключевой
идеей, обеспечивающей успех использования Python.


 Классы, определяемые пользователем

 Мы подробно рассмотрим объектно-ориентированный стиль программирования
на языке Python, который позволяет сократить время, затрачиваемое
на разработку, далее в этой книге. Тем не менее, говоря абстрактными
терминами, классы определяют новые типы объектов, которые расширяют
базовый набор, и потому они заслуживают упоминания здесь. Например,
вам мог бы потребоваться такой тип объектов, который моделировал бы
сотрудников. В языке Python нет такого базового типа, тем не менее,
следующий класс вполне мог бы удовлетворить ваши потребности:
"""


class Worker:
    def __init__(self, name, pay):  # Инициализация при создании
        self.name = name  # self – это сам объект
        self.pay = pay

    def last_name(self):
        return self.name.split()[-1]  # Разбить строку
        #                               по символам пробела

    def give_raise(self, percent):
        self.pay *= (1.0 + percent)  # Обновить сумму выплат


"""
 Данный класс определяет новый тип объектов, которые обладают
атрибутами name и pay (иногда атрибуты называют информацией 
о состоянии), а также двумя описаниями поведения, оформленными в виде 
функций (которые обычно называют методами). Обращение к имени класса
как к функции приводит к созданию экземпляра нового типа, 
а методы класса автоматически получают ссылку на текущий экземпляр, 
обрабатываемый этими методами (аргумент self):


"""
bob = Worker('Bob Smith', 50000)  # Создаются два экземпляра
#                                   и для каждого
sue = Worker('Sue Jones', 60000)  # определяется имя и сумма выплат
print(bob.last_name())  # Вызов метода: self – это bob

print(sue.last_name())  # self – это sue

sue.give_raise(.10)  # Обновить сумму выплат для sue
print(sue.pay)

"""
 Модель называется объектно-ориентированной потому, что здесь 
присутствует подразумеваемый объект «self»: внутри функций,
определяемых в классах, всегда присутствует подразумеваемый объект. 
В некотором смысле типы, основанные на классах, просто создаются 
на базе основных типов и используют их функциональные возможности. 
В данном случае пользовательский класс Worker – это всего лишь 
коллекция, состоящая из строки и числа (name и pay соответственно),
плюс функции, выполняющие обработку этих двух встроенных объектов.
"""

"""
 Точность представления целых чисел

 Операция деления может немного отличаться в разных версиях Python,
но в основе своей она является достаточно стандартной. А теперь добавим
немного экзотики. Как уже упоминалось выше, в Python 3.0 поддерживаются
целые числа неограниченной точности:

\>>> 999999999999999999999999999999 + 1
1000000000000000000000000000000

 Целые числа с неограниченной точностью – это достаточно удобный
инструмент. Например, с их помощью можно представить национальный бюджет
в копейках (если вам это интересно и в вашем компьютере имеется
достаточный объем памяти). Именно по этой причине нам удалось
в примерах из главы 3 вычислить такую большую степень числа 2.
Ниже приводятся примеры для версий 3.0 и 2.6:

\>>> 2 ** 200
1606938044258990275541962092341162602522202993782792835301376

\>>> 2 ** 200
1606938044258990275541962092341162602522202993782792835301376L

 Так как интерпретатору приходится производить дополнительные действия,
чтобы обеспечить поддержку высокой точности, с ростом значений
целочисленные операции могут ощутимо замедляться. Однако
если высокая точность важна, то фактор низкой производительности
отходит на задний план.


 Комплексные числа

 Комплексные числа используются не так часто, как другие числовые типы,
тем не менее, они также относятся к базовым типам данных в Python.
Если вы знаете о существовании комплексных чисел, вы должны знать,
когда они используются. В противном случае этот раздел можно пропустить.

 Комплексные числа состоят из двух вещественных чисел, представляющих
действительную и мнимую части, и в тексте программы отличаются наличием
суффикса j, или J после мнимой части. Если действительная часть не равна
нулю, комплексное число записывается как сумма двух частей с помощью
символа +. Например, комплексное число, действительная часть которого
равна 2, а мнимая часть – -3, записывается как 2 + -3j. Ниже приводятся
примеры некоторых действий над комплексными числами:

\>>> 1j * 1J
(-1+0j)
\>>> 2 + 1j * 3
(2+3j)
\>>> (2 + 1j) * 3
(6+3j)

 Кроме того, комплексные числа позволяют обращаться к своим частям как
к атрибутам, поддерживают все обычные математические операции и могут
обрабатываться с помощью стандартного модуля cmath (версия модуля math,
предназначенная для работы с комплексными числами). Комплексные числа
обычно используются в инженерных программах.


 Шестнадцатеричная, восьмеричная и двоичная формы записи чисел

 Как уже говорилось ранее, целые числа в языке Python могут записываться
не только в десятичной, но еще и в шестнадцатеричной, восьмеричной
и двоичной форме. Правила записи литералов целых чисел рассматривались
в начале этой главы. Теперь рассмотрим несколько практических примеров.

 Имейте в виду, что это всего лишь альтернативный синтаксис задания
значений целочисленных объектов. Например, следующие литералы создают
обычные целые числа с заданными значениями:

\>>> 0o1, 0o20, 0o377  # Восьмеричные литералы
(1, 16, 255)
\>>> 0x01, 0x10, 0xFF  # Шестнадцатеричные литералы
(1, 16, 255)
\>>> 0b1, 0b10000, 0b11111111  # Двоичные литералы
(1, 16, 255)

 Здесь восьмеричное значение 0o377, шестнадцатеричное значение 0xFF
и двоичное значение 0b11111111 соответствуют десятичному значению 255.
По умолчанию интерпретатор Python выводит числа в десятичной системе
счисления (по основанию 10), но предоставляет встроенные функции,
которые позволяют преобразовывать целые числа в последовательности цифр
в других системах счисления:

\>>> oct(64), hex(64), bin(64)
(‘0o100’, ‘0x40’, ‘0b1000000’)

 Функция oct преобразует десятичное число в восьмеричное представление,
функция hex – в шестнадцатеричное, а функция bin – в двоичное.
Кроме того, существует возможность обратного преобразования –
встроенная функция int преобразует строку цифр в целое число.
Во втором необязательном аргументе она может принимать основание
системы счисления:

\>>> int(‘64’), int(‘100’, 8), int(‘40’, 16), int(‘1000000’, 2)
(64, 64, 64, 64)
\>>> int(‘0x40’, 16), int(‘0b1000000’, 2)
# Допускается использовать литералы
(64, 64)

 Функция eval, с которой мы встретимся далее в книге, интерпретирует
строку во входном аргументе как программный код на языке Python.
Поэтому она может воспроизводить похожий эффект. Правда, обычно
она работает заметно медленнее, потому что ей приходится компилировать
и выполнять строку как часть программы, а это предполагает,
что вы должны иметь безграничное доверие к источнику запускаемой
строки, – достаточно грамотный пользователь мог бы подсунуть вашей
программе строку, которая при выполнении в функции eval удалит все
файлы на вашем компьютере!:

\>>> eval(‘64’), eval(‘0o100’), eval(‘0x40’), eval(‘0b1000000’)
(64, 64, 64, 64)

 Наконец, целые числа могут быть преобразованы в восьмеричное
и шестнадцатеричное представления с помощью строкового метода
форматирования и оператора форматирования строк:

\>>> ‘{0:o}, {1:x}, {2:b}’.format(64, 64, 64)
‘100, 40, 1000000’
\>>> ‘%o, %x, %X’ % (64, 255, 255)
‘100, ff, FF’

 Обратите внимание, что с помощью литералов можно создавать целые числа
произвольной величины. Например, ниже с помощью шестнадцатеричного
литерала создается целое число, а затем выводится его значение,
сначала в десятичном, затем в восьмеричном и, наконец,
в двоичном представлениях:

\>>> X = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF
\>>> X
5192296858534827628530496329220095
\>>> oct(X)
‘017777777777777777777777777777777777777’
\>>> bin(X)
‘0b1111111111111111111111111111111111111111111111111111111111 ...и т.д.

 Раз уж разговор зашел о двоичных числах, рассмотрим теперь средства
для работы с отдельными битами.


 Битовые операции

 Помимо обычных числовых операций (сложение, вычитание и так далее) язык
Python поддерживает большую часть видов числовых выражений, доступных
в языке C. Например, ниже приводится пример выполнения операций
поразрядного сдвига и логических операций:

\>>> x = 1  # 0001
\>>> x << 2  # Сдвиг влево на 2 бита: 0100
4
\>>> x | 2  # Побитовое ИЛИ: 0011
3
\>>> x & 1  # Побитовое И: 0001
1

 В первом выражении двоичное значение 1 (по основанию 2, 0001)
сдвигается влево на две позиции, в результате получается число 4 (0100).
В последних двух выражениях выполняются двоичная операция ИЛИ
(0001|0010 = 0011) и двоичная операция И (0001&0001 = 0001).
Такого рода операции позволяют хранить сразу несколько флагов
и других значений в одном целом числе.

 Это одна из областей, где поддержка двоичной и шестнадцатеричной форм
записи чисел в Python 2.6 и 3.0 оказывается наиболее полезной, –
она позволяет записывать и выводить числа в виде строк битов:

\>>> X = 0b0001  # Двоичные литералы
\>>> X << 2  # Сдвиг влево
4
\>>> bin(X << 2)  # Строка двоичных цифр
‘0b100’
\>>> bin(X | 0b010)  # Битовая операция ИЛИ
‘0b11’
\>>> bin(X & 0b1)  # Битовая операция И
‘0b1’
\>>> X = 0xFF  # Шестнадцатеричные литералы
\>>> bin(X)
‘0b11111111’
\>>> X ^ 0b10101010  # Битовая операция ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR)
85
\>>> bin(X ^ 0b10101010)
‘0b1010101’
\>>> int(‘1010101’, 2)  # Преобразование изображения числа в число
85                      # по основанию
\>>> hex(85)  # Вывод числа в шестнадцатеричном представлении
‘0x55’

 Мы не будем здесь слишком углубляться в «жонглирование битами».
Вам пока достаточно знать, что битовые операции поддерживаются языком,
и они могут пригодиться, когда вы будете иметь дело, например,
с сетевыми пакетами или упакованными двоичными данными, которые
производятся программами на языке C. Тем не менее вы должны понимать,
что в языках высокого уровня, таких как Python, битовые операции
не имеют такого большого значения, как в низкоуровневых языках,
подобных языку C. Как правило, если у вас возникает желание использовать
битовые операции в программах на языке Python, вам необходимо вспомнить,
на каком языке вы программируете. В Python имеются гораздо лучшие
способы представления информации, чем последовательности битов.

 В версии Python 3.1 у целых чисел появился новый метод bit_length,
который возвращает количество битов, необходимых для представления
числа в двоичном виде. Тот же результат можно получить, уменьшив на 2
длину строки с двоичным представлением числа, воспользовавшись
встроенной функцией len, однако этот способ работает менее эффективно:
"""

X = 99

print(bin(X), X.bit_length())
print(bin(256), (256).bit_length())
print(len(bin(256)) - 2)

"""
 Другие встроенные средства для работы с числами

 В дополнение к этим базовым типам объектов Python предоставляет 
встроенные функции и модули для работы с числами. Встроенные функции 
pow и abs, например, вычисляют степень и абсолютное значение числа
соответственно. В следующем примере демонстрируется использование 
модуля math (который содержит реализацию множества функций из библиотеки
math языка C) и нескольких встроенных функций:

>>> import math
>>> math.pi, math.e  # Распространенные константы
(3.1415926535897931, 2.7182818284590451)
>>> math.sin(2 * math.pi / 180)  # Синус, тангенс, косинус
0.034899496702500969
>>> math.sqrt(144), math.sqrt(2)  # Квадратный корень
(12.0, 1.4142135623730951)
>>> pow(2, 4), 2 ** 4  # Возведение в степень
(16, 16)
>>> abs(-42.0), sum((1, 2, 3, 4))  # Абсолютное значение, сумма
(42.0, 10)
>>> min(3, 1, 2, 4), max(3, 1, 2, 4)  # Минимум, максимум
(1, 4)

 Функция sum, которая демонстрируется здесь, принимает
последовательность чисел, а функции min и max могут принимать либо
последовательность чисел, либо множество отдельных аргументов. 
Существует множество способов округления десятичных знаков 
в вещественных числах. Ранее мы уже встречались с операциями усечения
и округления вниз; мы точно так же можем выполнять арифметическое
округление и производить снижение разрядности при выводе:

>>> math.floor(2.567), math.floor(-2.567)  # Округление вниз
(2, -3)  # (до ближайшего наименьшего целого)
>>> math.trunc(2.567), math.trunc(-2.567)  # Усечение
(2, -2)  # (отбрасывание дробной части)

>>> int(2.567), int(-2.567)  # Усечение
(2, -2)  # (преобразование в целое число)
>>> round(2.567), round(2.467), round(2.567, 2)  # Округление
(3, 2, 2.5699999999999998)
>>> ‘%.1f’ % 2.567, ‘{0:.2f}’.format(2.567)  # Округление 
(‘2.6’, ‘2.57’)                              # при отображении

 В последней инструкции используются операции, с которыми мы уже 
встречались выше, позволяющие получать строки для вывода 
и поддерживающие расширенные возможности форматирования. Кроме того,
о чем также говорилось выше, предпоследняя инструкция в этом примере
вывела бы (3, 2, 2.57), если бы мы заключили ее в вызов функции print. 
Несмотря на внешнее сходство получаемых результатов, две последние
инструкции имеют существенные отличия – функция round округляет 
вещественное число и возвращает вещественное число, тогда как операции 
форматирования строк возвращают строку, а не измененное число:

>>> (1 / 3), round(1 / 3, 2), (‘%.2f’ % (1 / 3))
(0.33333333333333331, 0.33000000000000002, ‘0.33’)

 Интересно, что в языке Python существует три способа вычисления
квадратных корней: с помощью функции из модуля math, с помощью выражения
и с помощью встроенной функции (если вам интересно узнать, какой способ
имеет наивысшую производительность, ознакомьтесь с упражнением в конце
четвертой части и с его решением, где приводятся результаты 
тестирования):

>>> import math
>>> math.sqrt(144)  # Функция из модуля math
12.0
>>> 144 ** .5  # Выражение
12.0
>>> pow(144, .5)  # Встроенная функция
12.0
>>> math.sqrt(1234567890)  # Большие числа
35136.418286444619
>>> 1234567890 ** .5
35136.418286444619
>>> pow(1234567890, .5)
35136.418286444619

 Модуль random из стандартной библиотеки также необходимо импортировать.
Этот модуль предоставляет возможность получения случайных вещественных
чисел в диапазоне от 0 до 1, случайных целых чисел в заданном диапазоне,
случайного выбора элементов последовательности и многое другое:

>>> import random
>>> random.random()
0.44694718823781876
>>> random.random()
0.28970426439292829
>>> random.randint(1, 10)
5
>>> random.randint(1, 10)
4
>>> random.choice([‘Life of Brian’, ‘Holy Grail’, ‘Meaning of Life’])
‘Life of Brian’
>>> random.choice([‘Life of Brian’, ‘Holy Grail’, ‘Meaning of Life’])
‘Holy Grail’

 Модуль random может использоваться, например, для перемешивания колоды
карт в игре, случайного выбора изображения в программе демонстрации 
слайдов, в программах статистического моделирования и так далее.


 Другие числовые типы
 
 В этой главе мы рассматривали базовые числовые типы языка Python – 
целые числа, вещественные числа и комплексные числа. Их вполне 
достаточно для решения математических задач, с которыми придется
столкнуться большинству программистов. Однако язык Python содержит
несколько более экзотических числовых типов, которые заслуживают того,
чтобы коротко познакомиться с ними.


 Числа с фиксированной точностью

 В версии Python 2.4 появился новый базовый числовой тип: числа 
с фиксированной точностью представления, формально известные, как числа
типа Decimal. Синтаксически такие числа создаются вызовом функции 
из импортируемого модуля и не имеют литерального представления. 
Функционально числа с фиксированной точностью напоминают
вещественные числа, но с фиксированным числом знаков после запятой, 
отсюда и название «числа с фиксированной точностью».

 Например, с помощью таких чисел можно хранить значение, которое всегда
будет иметь два знака после запятой. Кроме того, можно указать,
как должны обрабатываться лишние десятичные цифры – усекаться 
или округляться. И хотя скорость работы с такими числами несколько ниже,
чем с обычными вещественными числами, тем не менее, тип чисел
с фиксированной точностью идеально подходит для представления величин, 
имеющих фиксированную точность, таких как денежные суммы, 
и для достижения лучшей точности представления.


 Основы
 
 Предыдущий абзац требует дополнительных пояснений. Как вы уже знаете
(или еще не знаете), вещественная арифметика страдает некоторой долей 
неточности из-за ограничения объема памяти, выделяемого для хранения 
вещественных чисел. Например, результат следующего выражения должен быть
равен нулю, но точность вычислений страдает из-за недостаточного числа
битов в представлении вещественных чисел:

>>> 0.1 + 0.1 + 0.1 - 0.3
5.5511151231257827e-017

 Попытка вывести результат в более дружественной форме мало помогает, 
потому что проблема связана с ограниченной точностью представления
вещественных чисел:

>>> print(0.1 + 0.1 + 0.1 - 0.3)
5.55111512313e-017

 Однако при использовании чисел с фиксированной точностью результат 
получается точным:

>>> from decimal import Decimal
>>> Decimal(‘0.1’) + Decimal(‘0.1’) + Decimal(‘0.1’) - Decimal(‘0.3’)
Decimal(‘0.0’)

 Как показано в этом примере, числа с фиксированной точностью
представления создаются вызовом функции конструктора Decimal 
из модуля decimal, которому передается строка, содержащая желаемое число
знаков после запятой (при необходимости можно воспользоваться функцией
str, чтобы преобразовать вещественное число в строку). Когда в выражении
участвуют числа с различной точностью представления, Python
автоматически выбирает наибольшую точность для представления результата:

>>> Decimal(‘0.1’) + Decimal(‘0.10’) + Decimal(‘0.10’) - Decimal(‘0.30’)
Decimal(‘0.00’)

 В версии Python 3.1 (которая вышла) существует дополнительная
возможность создавать объекты класса Decimal из объектов вещественных
чисел путем вызова метода decimal.Decimal.from_float(1.25). 
Преобразование выполняется точно, но иногда может порождать большое 
число десятичных знаков.


 Глобальная настройка точности
 
 В модуле decimal имеются дополнительные инструменты, позволяющие 
задавать точность представления всех таких чисел и многое другое. 
Например, объект контекста в этом модуле позволяет задавать точность 
(число знаков после запятой) и режим округления (вниз, вверх 
и так далее). Точность задается глобально, для всех чисел 
с фиксированной точностью, создаваемых в текущем потоке управления:

>>> import decimal
>>> decimal.Decimal(1) / decimal.Decimal(7)
Decimal(‘0.1428571428571428571428571429’)
>>> decimal.getcontext( ).prec = 4
>>> decimal.Decimal(1) / decimal.Decimal(7)
Decimal(‘0.1429’)

 Эта возможность особенно удобна для финансовых приложений,
где в денежных суммах копейки представлены двумя десятичными знаками.
Числа с фиксированной точностью по сути представляют альтернативный 
способ округления и форматирования числовых значений, например:

>>> 1999 + 1.33
2000.3299999999999
>>>
>>> decimal.getcontext().prec = 2
>>> pay = decimal.Decimal(str(1999 + 1.33))
>>> pay
Decimal(‘2000.33’)


 Менеджер контекста объектов класса Decimal
 
 В версиях Python 2.6 и 3.0 (и выше) имеется также возможность временно
переопределять точность с помощью инструкции with менеджера контекста. 
После выхода за пределы инструкции настройки точности восстанавливаются:

C:\misc> C:\Python30\python
>>> import decimal
>>> decimal.Decimal(‘1.00’) / decimal.Decimal(‘3.00’)
Decimal(‘0.3333333333333333333333333333’)
>>>
>>> with decimal.localcontext() as ctx:
... ctx.prec = 2
... decimal.Decimal(‘1.00’) / decimal.Decimal(‘3.00’)
...
Decimal(‘0.33’)
>>>
>>> decimal.Decimal(‘1.00’) / decimal.Decimal(‘3.00’)
Decimal(‘0.3333333333333333333333333333’)

 При всей полезности этой инструкции для работы с ней требуется больше 
знаний, чем вы успели приобрести к настоящему моменту.


 Рациональные числа
 
 В Python 2.6 и 3.0 появился новый числовой тип – Fraction, который 
реализует объекты рациональных чисел. Объекты этого типа в явном виде 
хранят числитель и знаменатель рациональной дроби, что позволяет 
избежать неточности и некоторых других ограничений, присущих 
вещественным числам.


 Основы
 
 Тип Fraction является своего рода родственником типа Decimal, 
описанного в предыдущем разделе, и точно так же может использоваться 
для управления точностью представления чисел за счет определения
количества десятичных разрядов и политики округления. Оба типа 
используются похожими способами – как и класс Decimal, класс Fraction 
находится в модуле. Чтобы создать объект этого типа, необходимо 
импортировать модуль и вызвать конструктор класса, передав ему 
числитель и знаменатель. Как это делается, показано в примере ниже:

>>> from fractions import Fraction
>>> x = Fraction(1, 3)  # Числитель, знаменатель
>>> y = Fraction(4, 6)  # Будет упрощено до 2, 3 с помощью функции gcd
>>> x
Fraction(1, 3)
>>> y
Fraction(2, 3)
>>> print(y)
2/3

 После создания объекты типа Fraction могут использоваться 
в математических выражениях как обычные числа:

>>> x + y
Fraction(1, 1)
>>> x – y  # Точный результат: числитель, знаменатель
Fraction(-1, 3)
>>> x * y
Fraction(2, 9)

 Рациональные числа могут создаваться из строк с представлением 
вещественных чисел, как и числа с фиксированной точностью:

>>> Fraction(‘.25’)
Fraction(1, 4)
>>> Fraction(‘1.25’)
Fraction(5, 4)
>>>
>>> Fraction(‘.25’) + Fraction(‘1.25’)
Fraction(3, 2)


 Точность
 
 Обратите внимание на отличия от вещественной арифметики, точность 
которой ограничивается возможностями аппаратных средств, реализующих 
вещественную математику. Для сравнения ниже приводятся некоторые 
операции над вещественными числами с примечаниями, касающимися 
ограничений точности:

>>> a = 1 / 3.0  # Точность ограничивается аппаратными средствами
>>> b = 4 / 6.0  # В процессе вычислений точность может быть потеряна
>>> a
0.33333333333333331
>>> b
0.66666666666666663
>>> a + b
1.0
>>> a - b
-0.33333333333333331

>>> a * b
0.22222222222222221

 Ограничения точности, свойственные вещественным числам, становятся 
особенно заметны для значений, которые не могут быть представлены точно,
из-за ограниченного объема памяти, выделяемого для хранения 
вещественного числа. Оба типа, Fraction и Decimal, предоставляют
возможность получить точный результат, хотя и за счет некоторой потери 
производительности. Например, в следующем примере (взятом из
предыдущего раздела) при использовании вещественных чисел получается
неточный результат, но два других типа позволяют получить его:

>>> 0.1 + 0.1 + 0.1 - 0.3  # Должен быть получен ноль 
5.5511151231257827e-17     # (близко, но не точно)

>>> from fractions import Fraction
>>> Fraction(1, 10) + Fraction(1, 10) + Fraction(1, 10) 
- Fraction(3, 10)
Fraction(0, 1)

>>> from decimal import Decimal
>>> Decimal(‘0.1’) + Decimal(‘0.1’) + Decimal(‘0.1’) - Decimal(‘0.3’)
Decimal(‘0.0’)

 Кроме того, использование рациональных чисел и чисел с фиксированной 
точностью позволяет получить более понятные и точные результаты, 
чем использование вещественных чисел (за счет использования 
представления в виде рациональной дроби и ограничения точности):

>>> 1 / 3  # В Python 2.6 используйте знаменатель 3.0, чтобы
0.33333333333333331  # выполнить операцию истинного деления

>>> Fraction(1, 3)  # Точное представление
Fraction(1, 3)

>>> import decimal
>>> decimal.getcontext().prec = 2
>>> decimal.Decimal(1) / decimal.Decimal(3)
Decimal(‘0.33’)

 Фактически рациональные числа сохраняют точность и автоматически 
упрощают результат. В продолжение предыдущего примера:

>>> (1 / 3) + (6 / 12)  # В Python 2.6 используйте знаменатель “.0”,
0.83333333333333326  # чтобы выполнить операцию истинного деления
>>> Fraction(6, 12) # Будет упрощено автоматически
Fraction(1, 2)
>>> Fraction(1, 3) + Fraction(6, 12)
Fraction(5, 6)

>>> decimal.Decimal(str(1/3)) + decimal.Decimal(str(6/12))
Decimal(‘0.83’)
>>> 1000.0 / 1234567890
8.1000000737100011e-07

>>> Fraction(1000, 1234567890)
Fraction(100, 123456789)


 Преобразование и смешивание в выражениях значений разных типов
 
 Для поддержки преобразования в рациональные числа в объектах 
вещественных чисел был реализован метод as_integer_ratio, возвращающий 
соответствующие числу числитель и знаменатель; объекты рациональных
чисел обладают методом from_float; а функция float теперь может 
принимать объекты типа Fraction в качестве аргумента. Взгляните 
на следующий пример, где показано, как используются эти методы
(символ * во втором примере – это специальный синтаксис распаковывания 
кортежа в отдельные аргументы – подробнее об этом будет рассказываться
в главе 18, когда мы будем обсуждать вопросы передачи аргументов 
функциям):

>>> (2.5).as_integer_ratio()  # метод объекта типа float
(5, 2)

>>> f = 2.5
>>> z = Fraction(*f.as_integer_ratio())  # Преобразование float
>>> z  # два аргумента                     -> fraction:
Fraction(5, 2)  # То же самое, что и Fraction(5, 2)

>>> x  # x – из предыдущего примера сеанса
Fraction(1, 3)
>>> x + z
Fraction(17, 6) # 5/2 + 1/3 = 15/6 + 2/6

>>> float(x)  # Преобразование fraction -> float
0.33333333333333331
>>> float(z)
2.5
>>> float(x + z)
2.8333333333333335
>>> 17 / 6
2.8333333333333335

>>> Fraction.from_float(1.75)  # Преобразование float -> fraction:
Fraction(7, 4)  # другой способ
>>> Fraction(*(1.75).as_integer_ratio())
Fraction(7, 4)

 Наконец, в выражениях допускается смешивать некоторые типы, при этом
иногда, чтобы сохранить точность, необходимо вручную выполнить 
преобразование в тип Fraction. Взгляните на следующие примеры, 
чтобы понять, как это делается:

>>> x
Fraction(1, 3)
>>> x + 2  # Fraction + int -> Fraction
Fraction(7, 3)

>>> x + 2.0  # Fraction + float -> float
2.3333333333333335

>>> x + (1./3)  # Fraction + float -> float
0.66666666666666663
>>> x + (4./3)
1.6666666666666665

>>> x + Fraction(4, 3)  # Fraction + Fraction -> Fraction
Fraction(5, 3)

 Предупреждение: несмотря на то, что имеется возможность преобразовать 
вещественное число в рациональное, в некоторых случаях это может 
приводить к потере точности, потому что в своем первоначальном виде
вещественное число может быть неточным. В случае необходимости 
в подобных случаях можно ограничить максимальное значение знаменателя:

>>> 4.0 / 3
1.3333333333333333

>>> (4.0 / 3).as_integer_ratio()  # Произойдет потеря точности
(6004799503160661, 4503599627370496)

>>> x
Fraction(1, 3)
>>> a = x + Fraction(*(4.0 / 3).as_integer_ratio())
>>> a
Fraction(22517998136852479, 13510798882111488)
>>> 22517998136852479 / 13510798882111488.  # 5 / 3 
1.6666666666666667                          # (или близкое к нему!)

>>> a.limit_denominator(10)  # Упростить до ближайшего рационального
Fraction(5, 3)
"""

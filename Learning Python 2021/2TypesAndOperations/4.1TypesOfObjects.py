"""
 Введение в типы объектов языка Python

 Объекты являются самым фундаментальным понятием в программировании
на языке Python, поэтому эта глава начинается с обзора встроенных
объектных типов языка Python.

 С более определенной точки зрения программы на языке Python
можно разложить на такие составляющие, как модули, инструкции,
выражения и объекты; при этом:

1. Программы делятся на модули.
2. Модули содержат инструкции.
3. Инструкции состоят из выражений.
4. Выражения создают и обрабатывают объекты.


 Зачем нужны встроенные типы?

 Если вам приходилось использовать языки программирования более низкого
уровня, такие как C или C++, то вы уже знаете, что значительная доля
работы приходится на реализацию объектов, известных также как структуры
данных, которые предназначены для представления составляющих предметной
области. В таких языках программирования необходимо заниматься
проработкой структур данных, управлять выделением памяти, реализовывать
функции поиска и доступа к элементам структур и так далее.
Это достаточно утомительно (и способствует появлению ошибок) и,
как правило, отвлекает от достижения истинных целей.

 В типичных программах на языке Python в этом нет необходимости. Python
предоставляет мощную коллекцию объектных типов, встроенных
непосредственно в язык, поэтому обычно нет никакой необходимости
создавать собственные реализации объектов, предназначенных для решения
оставленных задач. Фактически если у вас нет потребности
в специальных видах обработки, которые не обеспечиваются встроенными
типами объектов, вам всегда лучше использовать встроенные объекты
вместо реализации своих собственных. И вот почему:

  Встроенные объекты упрощают создание программ.

  Встроенные объекты – это компоненты расширений.

  Встроенные объекты часто более эффективны, чем созданные вручную
 структуры данных.

  Встроенные объекты – это стандартная часть языка.

 Другими словами, встроенные типы объектов не только упрощают процесс
программирования, но они обладают большей эффективностью
и производительностью, чем большинство типов, созданных вручную.
Даже если вы создаете собственные типы объектов, встроенные объекты
будут ядром любой программы на Python.


 Базовые типы данных в языке Python

  Тип объекта                 Пример литерала/создания
  Числа                       1234, 3.1415, 3+4j, Decimal, Fraction
  Строки                      ‘spam’, “guido’s”, b’a\x01c’
  Списки                      [1, [2, ‘three’], 4]
  Словари                     {‘food’: ‘spam’, ‘taste’: ‘yum’}
  Кортежи                     (1,’spam’, 4, ‘U’)
  Файлы                       myfile = open(‘eggs’, ‘r’)
  Множества                   set(‘abc’), {‘a’, ‘b’, ‘c’}
  Прочие базовые типы         Сами типы, None, логические значения
  Типы структурных элементов  Функции, модули, классы
  программ
  Типы, имеющие отношение     Компилированный программный код,
  к реализации                стек вызовов

 В этой книге под термином литерал подразумевается выражение,
создающее объект, которое иногда также называется константой.
Следует иметь в виду, что термин «константа» не означает объекты
и переменные, которые никогда не изменяются (то есть этот термин никак
не связан с директивой const языка C++ или с понятием «неизменяемый»
(«immutable») в языке Python).

 Типы объектов, перечисленные в табл., обычно называют базовыми,
потому что они встроены непосредственно в язык Python, то есть
для создания большинства из них используется вполне определенный
синтаксис. Например, когда выполняется следующий программный код:

\>>> ‘spam’

 то, говоря техническим языком, выполняется выражение-литерал,
которое генерирует и возвращает новый строковый объект. Такова специфика
синтаксиса Python создания этого объекта. Похожим образом выражение,
заключенное в квадратные скобки, создает список, заключенное
в фигурные скобки – словарь и так далее. Хотя, как вы сможете убедиться,
в языке Python отсутствует конструкция объявления типа, сам синтаксис
выполняемых выражений задает типы создаваемых и используемых объектов.
Фактически выражения, создающие объекты, подобные тем, что представлены
в табл., в языке Python являются источниками типов.

 Как вы узнаете далее, в языке Python используется динамическая
типизация (типы данных определяются автоматически и их не требуется
объявлять в программном коде), но при этом он является языком со строгой
типизацией (вы сможете выполнять над объектом только те операции,
которые применимы к его типу).


 Числа

 Если в прошлом вам приходилось заниматься программированием, некоторые
типы объектов из табл. 4.1 скорее всего покажутся вам знакомыми. Но даже
если это не так, числа являются чрезвычайно простым понятием. Базовый
набор объектов языка Python включает в себя вполне ожидаемые типы:
целые числа (числа без дробной части), вещественные числа (грубо говоря,
числа с десятичной точкой) и более экзотические типы (комплексные числа
с мнимой частью, числа с фиксированной точностью, рациональные числа,
представленные парой целых чисел, – числитель и знаменатель дроби,
и множества).

 Несмотря на наличие некоторых необычных типов, базовые числовые типы
в языке Python действительно являются базовыми. Числа в Python
поддерживают набор самых обычных математических операций. Например,
символ «плюс» (+) означает сложение, символ «звездочка» (*) – умножение,
а два символа «звездочка» (**) – возведение в степень:

\>>> 123 + 222 # Целочисленное сложение
345
\>>> 1.5 * 4 # Умножение вещественных чисел
6.0
\>>> 2 ** 100 # 2 в степени 100
1267650600228229401496703205376

 Обратите внимание на результат последней операции: в Python 3.0 целые
числа автоматически обеспечивают неограниченную точность
для представления больших значений (в Python 2.6 для представления
больших целых чисел имеется отдельный тип длинных целых чисел).
Например, вы можете попробовать вычислить 2 в степени 1 000 000
(но едва ли стоит это делать, так как на экран будет выведено число
длиной более 300 000 знаков, что может занять продолжительное время!).

\>>> len(str(2 ** 1000000))  # Сколько цифр в действительно
301030                       # БОЛЬШОМ числе?


 Начав экспериментировать с вещественными числами, вы наверняка обратите
внимание на то, что на первый взгляд может показаться странным:

\>>> 3.1415 * 2         # repr: как программный код
6.2830000000000004
\>>> print(3.1415 * 2)  # str: более дружественный формат
6.283

 Первый результат – это не ошибка, проблема здесь связана
с отображением. Оказывается, вывести содержимое любого объекта можно
двумя способами: с полной точностью (как в первом результате),
и в форме, более удобной для восприятия человеком (как во втором
результате). Формально первая форма называется repr (объект в виде
программного кода), а вторая, более дружественная к пользователю, –
str. Различия между ними станут более понятны, когда мы приступим
к изучению классов, а пока, если что-то выглядит непонятным, попробуйте
вывести тот же результат с помощью инструкции print.

 Помимо выражений для выполнения операций с числами в составе Python
есть несколько полезных модулей:

\>>> import math
\>>> math.pi
3.1415926535897931
\>>> math.sqrt(85)
9.2195444572928871

 Модуль math содержит более сложные математические функции,
а модуль random реализует генератор случайных чисел и функцию
случайного выбора:

\>>> import random
\>>> random.random()
0.59268735266273953
\>>> random.choice([1, 2, 3, 4])
1

 Кроме того, Python включает в себя более экзотические числовые объекты,
такие как комплексные числа, числа с фиксированной десятичной точкой
и рациональные числа, множества и логические значения, а среди
свободно распространяемых расширений можно найти и другие числовые типы
(например, матрицы и векторы). Обсуждение этих типов будет приводиться
далее в этой книге.

 Пока что мы использовали Python как простой калькулятор, но чтобы иметь
большую возможность судить о встроенных типах, перейдем к строкам.


 Строки

 Строки используются для записи текстовой информации, а также
произвольных последовательностей байтов. Это наш первый пример
последовательностей, или упорядоченных коллекций других объектов,
в языке Python. Последовательности поддерживают порядок размещения
элементов, которые они содержат, слева направо: элементы сохраняются
и извлекаются исходя из их позиций в последовательностях. Строго говоря,
строки являются последовательностями односимвольных строк.
Другими типами последовательностей являются списки и кортежи.


 Операции над последовательностями

 Будучи последовательностями, строки поддерживают операции,
предполагающие определенный порядок позиционирования элементов.
Например, если имеется четырехсимвольная строка, то с помощью встроенной
функции len можно определить ее длину, а отдельные элементы строки
извлечь с помощью выражений индексирования:

\>>> S = ‘Spam’
\>>> len(S)  # Длина
4
\>>> S[0]  # Первый элемент в S, счет начинается с позиции 0
‘S’
\>>> S[1]  # Второй элемент слева

 В языке Python индексы реализованы в виде смещений от начала и потому
индексация начинается с 0: первый элемент имеет индекс 0, второй – 1
и так далее.

 Обратите внимание, как в этом примере выполняется присваивание строки
переменной с именем S. Подробнее сам процесс присваивания мы будем
рассматривать позднее (в частности, в главе 6), а пока хочу отметить,
что в языке Python не требуется объявлять переменные заранее. Переменная
создается в тот момент, когда ей присваивается значение, при этом
переменной можно присвоить значение любого типа, а при использовании
внутри выражения имя переменой замещается ее фактическим значением.
Кроме того, прежде чем появится возможность обратиться к переменной,
ей должно быть присвоено какое-либо значение. Но пока вам достаточно
помнить – чтобы сохранить объект для последующего использования,
его нужно присвоить переменной. В языке Python предусмотрена возможность
индексации в обратном порядке, от конца к началу – положительные индексы
откладываются от левого конца последовательности, а отрицательные –
от правого:

\>>> S[-1]  # Последний элемент в конце S
‘m’
\>>> S[-2]  # Второй элемент с конца
‘a’

 Формально отрицательные индексы просто складываются с длиной строки,
поэтому следующие две операции эквивалентны (хотя первая форма записи
выглядит проще и понятнее):

\>>> S[-1]  # Последний элемент в S
‘m’
\>>> S[len(S)-1]  # Отрицательная индексация, более сложный способ
‘m’

 В дополнение к простой возможности индексирования по номеру позиции,
последовательности поддерживают более общую форму индексирования,
известную как получение среза (slicing), которая обеспечивает
возможность извлечения за одну операцию целого сегмента (среза).
Например:

\>>> S # Строка из 4 символов
‘Spam’
\>>> S[1:3] # Срез строки S начиная со смещения 1 и до 2 (не 3)
‘pa’

 Проще всего можно представить себе срез как способ извлечения целого
столбца из строки за один шаг. В общем виде синтаксис операции получения
среза выглядит как: X[I:J], и означает: «извлечь из X все, начиная
со смещения I и до смещения J, но не включая его». В качестве результата
возвращается новый объект. Например, последняя операция из примера выше
вернет все символы строки S со смещениями с 1 по 2 (то есть
3 – 1 символов) в виде новой строки. В результате получается срез,
или «выборка» двух символов из середины.

 При выполнении операции получения среза левая граница по умолчанию
принимается равной нулю, а правая – длине последовательности,
к которой применяется операция. В результате мы получаем следующие
наиболее распространенные варианты использования:

\>>> S[1:]  # Все, кроме первого элемента (1:len(S))
‘pam’
\>>> S  # Сама строка S без изменений
‘Spam’
\>>> S[0:3]  # Все, кроме последнего элемента
‘Spa’
\>>> S[:3]  # То же, что и S[0:3]
‘Spa’
\>>> S[:-1]  # Еще раз все, кроме последнего элемента, но проще (0:-1)
‘Spa’
\>>> S[:]  # Все содержимое S, как обычная копия (0:len(S))
‘Spam’

 Обратите внимание, что в качестве границ срезов можно использовать
отрицательные индексы и что последняя операция фактически создает копию
всей строки. Как мы узнаем позднее, нет смысла копировать строки таким
способом, но такая форма копирования очень удобна при работе с другими
последовательностями, такими как списки.

 Наконец, будучи последовательностями, строки поддерживают операцию
конкатенации, которая записывается в виде знака плюс (объединение двух
строк в одну строку), и операцию повторения (новая строка создается
за счет многократного повторения другой строки):

\>>> S
‘Spam’
\>>> S + ‘xyz’  # Конкатенация
‘Spamxyz’
\>>> S  # S остается без изменений
‘Spam’
\>>> S * 8  # Повторение
‘SpamSpamSpamSpamSpamSpamSpamSpam’


 Неизменяемость

 Обратите внимание: в предыдущих примерах ни одна из использованных
операций не изменяла оригинальную строку. Все операции над строками в
результате создают новую строку, потому что строки в языке Python
являются неизменяемыми – после того, как строка будет создана,
ее нельзя изменить. Например, вы не сможете изменить строку
присвоением значения одной из ее позиций, но вы всегда можете создать
новую строку и присвоить ей то же самое имя. Поскольку Python очищает
память, занятую ненужными больше объектами (как будет показано позднее),
такой подход не так уж неэффективен, как могло бы показаться
на первый взгляд:

\>>> S
‘Spam’
\>>> S[0] = ‘z’  # Неизменяемые объекты нельзя изменить
...текст сообщения об ошибке опущен...
TypeError: ‘str’ object does not support item assignment

\>>> S = ‘z’ + S[1:]  # Но с помощью выражений мы можем создавать
\>>> S                # новые объекты
‘zpam’

 Все объекты в языке Python либо относятся к классу неизменяемых,
либо нет. Если говорить о базовых типах, то числа, строки и кортежи
являются неизменяемыми, а списки и словари – нет (они легко могут
изменяться в любой своей части). Помимо всего неизменяемость может
рассматриваться как гарантия, что некоторый объект будет оставаться
постоянным на протяжении работы программы.


 Методы, специфичные для типа

 Все строковые операции, которые мы до сих пор рассматривали,
в действительности являются операциями над последовательностями,
то есть эти операции могут использоваться для работы с любыми
последовательностями языка Python, включая списки и кортежи.
Однако помимо операций, универсальных для последовательностей, строки
также имеют свои собственные операции, реализованные в виде методов
(функций, присоединенных к объекту, которые запускаются
выражением вызова).

 Например, метод строк find выполняет поиск подстроки в строке
(он возвращает смещение переданной ему подстроки или -1, если поиск
не увенчался успехом), а метод replace производит глобальный поиск
с заменой:

\>>> S.find(‘pa’) # Поиск смещения подстроки
1
\>>> S
‘Spam’
\>>> S.replace(‘pa’, ‘XYZ’) # Замена одной подстроки другой
‘SXYZm’
\>>> S
‘Spam’

 И снова независимо от имен этих строковых методов, применяя методы,
мы не изменяем оригинальную строку, а создаем новую, т. к. строки
являются неизменяемыми, и это следует учитывать. Строковые методы –
это первый уровень в комплекте инструментальных средств обработки
текста языка Python. Другие методы позволяют разбивать строки на
подстроки по определенному символу-разделителю (достаточно удобно
для простых случаев разбора строк), преобразовывать регистр символов,
проверять тип содержимого строк (цифры, алфавитные символы и так далее)
и отсекать пробельные символы с обоих концов строк.

\'>>> line = ‘aaa,bbb,ccccc,dd’
\>>> line.split(‘,’)            # Разбивает строку по разделителю
[‘aaa’, ‘bbb’, ‘ccccc’, ‘dd’]   # и создает список строк
\>>> S = ‘spam’
\>>> S.upper()  # Преобразование символов в верхний и в нижний регистр
‘SPAM’
\>>> S.isalpha()  # Проверка содержимого: isalpha, isdigit и так далее
True
\>>> line = ‘aaa,bbb,ccccc,dd\n’
\>>> line = line.rstrip()  # Удаляет завершающие пробельные символы
\>>> line
‘aaa,bbb,ccccc,dd’

 Кроме того, строки поддерживают операции подстановки, известные как
форматирование и доступные как в виде выражений
(существовали изначально), так и в виде методов строк
(появились в версиях 2.6 и 3.0):

\>>> ‘%s, eggs, and %s’ % (‘spam’, ‘SPAM!’)  #  Выражение
‘spam, eggs, and SPAM!’                      #  (во всех версиях)
\>>> ‘{0}, eggs, and {1}’.format(‘spam’, ‘SPAM!’)  # Метод (2.6, 3.0)
‘spam, eggs, and SPAM!’

 Следует заметить, что в отличие от универсальных операций, применяемых
к последовательностям, строковые методы могут применяться
только к строкам и ни к каким другим объектам, хотя некоторые типы
могут иметь методы с похожими именами. Следует понимать,
что инструментальные средства языка Python делятся на несколько уровней:
универсальные операции, которые могут применяться к нескольким типам,
реализованы в виде встроенных функций и выражений
(например, len(X), X[0]), а операции, специфичные
для определенного типа, реализованы в виде методов
(например, aString.upper()). Выбор требуемых инструментов
из всех этих категорий станет более простым по мере изучения
языка Python, а в следующем разделе приводится несколько рекомендаций,
которые вы сможете использовать уже сейчас.


 Получение помощи

Методы, представленные в предыдущем разделе, являются лишь небольшой
частью того, что доступно при работе со строковыми объектами. Вообще,
эта книга не является исчерпывающим источником информации о методах
объектов. Чтобы получить дополнительную информацию, вы всегда можете
воспользоваться функцией dir, которая возвращает список всех доступных
атрибутов заданного объекта. Предположим, что переменная S по-прежнему
остается строкой; ниже приводится список ее атрибутов в Python 3.0
(в Python 2.6 этот список немного отличается):
"""

print(dir(str))

"""
 Скорее всего, вам не понадобятся имена из этого списка, содержащие 
символы подчеркивания, до того момента, пока мы не приступим к изучению 
возможности перегрузки операторов в классах, – они представляют собой 
реализацию строкового объекта и доступны для поддержки специализации. 
В общем случае ведущие и завершающие символы подчеркивания используются 
интерпретатором Python для обозначения особенностей внутренней 
реализации. Имена без символов подчеркивания в этом списке обозначают 
методы строковых объектов.

 Функция dir возвращает лишь имена методов. Чтобы узнать назначение того
или иного метода, можно передать его имя функции help:
"""

help(str.replace)

"""
 Функция help – один из немногих интерфейсов к системе программного кода
Python, поставляемого в составе Python в составе инструмента 
под названием PyDoc, который позволяет извлекать описание из объектов. 
Далее в этой книге вы узнаете, что PyDoc позволяет отображать информацию
в формате HTML.

 Можно также запросить информацию и для самого строкового объекта 
(например, help(S)), но в этом случае вы можете получить больше 
информации, чем хотелось бы, – описание всех строковых методов. 
Часто бывает удобнее запрашивать информацию о конкретном методе, 
как это было продемонстрировано выше.

 За дополнительной информацией всегда можно обратиться к справочному 
руководству по стандартной библиотеке или к печатным справочным 
изданиям, но функции dir и help в языке Python представляют собой 
самое первое средство получения доступа к документации.


 Другие способы представления строк
 
 К этому моменту мы познакомились с операциями над последовательностями
и методами, специфичными для строк. Однако кроме этого 
язык программирования Python предоставляет несколько различных способов 
представления строк в программном коде, которые мы будем исследовать 
позднее (включая служебные символы, которые представлены, например,
в виде последовательностей, начинающихся с символа обратного слэша:)

>>> S = ‘A\nB\tC’  # \n – это символ “конец строки”,
                   # \t – символ табуляции
>>> len(S)  # Каждая из этих пар соответствует единственному символу
5
>>> ord(‘\n’)  # В ASCII \n – это байт с числовым значением 10
10
>>> S = ‘A\0B\0C’  # \0 – это двоичный ноль, 
                   # не является завершителем строки
>>> len(S)
5

 Язык Python допускает заключать строки в кавычки или в апострофы 
(они означают одно и то же). Кроме того, имеется специальная форма 
определения многострочных строковых литералов – тройные кавычки 
или апострофы. Когда используется такая форма, все строки 
в программном коде объединяются в одну строку, а там, где в исходном 
тексте выполняется переход на новую строку, вставляется символ 
«конец строки». Это незначительное синтаксическое удобство весьма
полезно для оформления в сценариях на языке Python крупных блоков 
текста, таких как разметка HTML или XML:

>>> msg = “”” aaaaaaaaaaaaa
bbb’’’bbbbbbbbbb””bbbbbbb’bbbb
cccccccccccccc”””
>>> msg
‘\naaaaaaaaaaaaa\nbbb\’\’\’bbbbbbbbbb””bbbbbbb\’bbbb\ncccccccccccccc’

 Кроме того, Python предоставляет поддержку литералов 
«неформатированных», «сырых» строк, в которых символ обратного слэша
интерпретируется как обычный символ (они начинаются с символа r), 
а также поддержку строк с символами Юникода, обеспечивающих 
интернационализацию. В версии 3.0 базовый тип строк str также может 
содержать символы Юникода (при этом предполагается, что символы ASCII
являются разновидностью символов Юникода), а тип bytes может 
представлять строки двоичных байтов. В версии 2.6 строки Юникода 
были представлены отдельным типом, а строки типа str могли содержать 
8-битные символы и двоичные данные. Файлы также изменились в версии 3.0,
и теперь они возвращают и принимают объекты типа str только при работе
в текстовом режиме, а при работе в двоичном режиме – только объекты 
типа bytes.


 Поиск по шаблону
 
 Прежде чем двинуться дальше, хочется заметить, что ни один из строковых
объектов не поддерживает возможность обработки текста на основе 
шаблонов. Рассмотрение инструментов, выполняющих поиск текста 
по шаблону, выходит за рамки этой книги, но для читателей, знакомых
с другими языками сценариев, будет интересно узнать, как выполняется 
поиск по шаблону в языке Python – для этого необходимо импортировать 
модуль с именем re. Этот модуль содержит аналогичные функции 
для выполнения поиска, разбиения и замены, но за счет использования 
шаблонов мы можем использовать более общие варианты решения задач:

>>> import re
>>> match = re.match(‘Hello[ \t]*(.*)world’, ‘Hello Python world’)
>>> match.group(1)
‘Python ‘

 В этом примере выполняется поиск строки, начинающейся со слова «Hello»,
вслед за которым следуют ноль или более символов табуляции или пробелов, 
за которыми могут следовать произвольные символы, которые будут 
сохранены, как группа совпадения, и завершающаяся словом «world». 
Если такая подстрока будет найдена, части ее, соответствующие шаблону, 
заключенному в круглые скобки, будут доступны в виде групп. Например, 
следующий шаблон извлекает три группы, разделенные символами слэша:

>>> match = re.match(‘/(.*)/(.*)/(.*)’, ‘/usr/home/lumberjack’)
>>> match.groups()
(‘usr’, ‘home’, ‘lumberjack’)

 Поиск по шаблону реализован в виде чрезвычайно сложного механизма 
обработки текста, но в языке Python имеется поддержка еще более сложных
механизмов, включая возможность обработки естественного языка 
человеческого общения.


 Списки
 
 Списки – это самое общее представление последовательностей, 
реализованных в языке Python. Списки – это упорядоченные 
по местоположению коллекции объектов произвольных типов, размер которых
не ограничен. Кроме того, в отличие от строк, списки являются 
изменяемыми – они могут модифицироваться как с помощью операций 
присваивания по смещениям, так и с помощью разнообразных методов работы 
со списками.


 Операции над последовательностями
 
 Поскольку списки являются последовательностями, они поддерживают все
операции над последовательностями, которые обсуждались в разделе, 
посвященном строкам. Единственное отличие состоит в том, что результатом
таких операций являются списки, а не строки. Например, для списка, 
состоящего из трех элементов:

>>> L = [123, ‘spam’, 1.23] # Список из трех объектов разных типов
>>> len(L) # Число элементов в списке
3

 Мы можем обращаться к элементам списка по их индексам, получать срезы
и так далее, точно так же, как и в случае со строками:

>>> L[0]  # Доступ к элементу списка по его индексу
123
>>> L[:-1]  # Операция получения среза возвращает новый список
[123, ‘spam’]
>>> L + [4, 5, 6]  # Операция конкатенации также возвращает новый список
[123, ‘spam’, 1.23, 4, 5, 6]
>>> L  # Наши действия не привели к изменению оригинального списка
[123, ‘spam’, 1.23]


 Методы, специфичные для типа
 
 Списки в языке Python являются аналогом массивов в других языках 
программирования, но они обладают более широкими возможностями. 
С одной стороны, они не ограничены одним типом элементов, например, 
только что рассмотренный список содержит три элемента совершенно 
разных типов (целое число, строку и вещественное число). Кроме того, 
размер списков не ограничен, благодаря чему они могут увеличиваться 
и уменьшаться по мере необходимости в результате выполнения операций,
характерных для списков:

>>> L.append(‘NI’)  # Увеличение: в конец списка добавляется
>>> L               # новый объект
[123, ‘spam’, 1.23, ‘NI’]
>>> L.pop(2)  # Уменьшение: удаляется элемент из середины списка
1.23
>>> L  # Инструкция “del L[2]” также удалит элемент списка
[123, ‘spam’, ‘NI’]

 В данном примере метод append увеличивает размер списка и вставляет 
в конец новый элемент. Метод pop (или эквивалентная ему инструкция del) 
удаляет из списка элемент с заданным смещением, что приводит
к уменьшению списка. Другие методы списков позволяют вставлять новые 
элементы в произвольное место списка (insert), удалять элемент,
заданный значением (remove), и так далее. Так как списки являются 
изменяемыми, большинство методов списков не создают новый список, 
а изменяют оригинальный список:

>>> M = [‘bb’, ‘aa’, ‘cc’]
>>> M.sort()
>>> M
[‘aa’, ‘bb’, ‘cc’]

>>> M.reverse()
>>> M
[‘cc’, ‘bb’, ‘aa’]

 Метод sort, использованный в этом примере, по умолчанию упорядочивает 
элементы списка по возрастанию, а метод reverse – по убыванию.
В обоих случаях происходит непосредственное изменение самого списка.


 Проверка выхода за границы
 
 Хотя списки не имеют фиксированного размера, язык Python, тем не менее,
не допускает возможности обращаться к несуществующим элементам списка. 
Обращение к элементам списка по индексам, значения которых выходят 
за пределы списка, всегда является ошибкой:

>>> L
[123, ‘spam’, ‘NI’]

>>> L[99]
...текст сообщения об ошибке опущен...
IndexError: list index out of range

>>> L[99] = 1
... текст сообщения об ошибке опущен...
IndexError: list assignment index out of range

 В этом примере я специально допустил ошибку (особенно неприятную 
в языке C, который не выполняет проверку выхода за границы массива, 
как Python) и попытался выполнить присваивание за пределами списка. 
Вместо того чтобы увеличить размер списка, интерпретатор Python сообщил
об ошибке. Чтобы увеличить список, необходимо воспользоваться
таким методом, как append.


 Вложенные списки
 
 Одна из замечательных особенностей базовых типов языка Python состоит
в том, что они поддерживают возможность создания вложенных конструкций
произвольной глубины и в любых комбинациях (например, можно создать
список, содержащий словарь, который содержит другой список, 
и так далее). Одно из очевидных применений этой особенности – 
представление матриц, или «многомерных массивов» в языке Python. 
Делается это с помощью списка, содержащего вложенные списки:

>>> M = [[1, 2, 3],  # Матрица 3 x 3 в виде вложенных списков
         [4, 5, 6],  # Выражение в квадратных скобках может
         [7, 8, 9]]  # занимать несколько строк
>>> M
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

 Здесь мы реализовали список, состоящий из трех других списков. 
В результате была получена матрица чисел 3 x 3. Обращаться к такой 
структуре можно разными способами:

>>> M[1]  # Получить строку 2
[4, 5, 6]

>>> M[1][2]  # Получить строку 2, а затем элемент 3 в этой строке
6

 Первая операция в этом примере возвращает вторую строку целиком, 
а вторая – третий элемент в этой строке. Соединение операций
индексирования позволяет все дальше и дальше погружаться вглубь 
вложенной структуры объектов.

 Такая организация матриц вполне пригодна для решения небольших задач, 
но для реализации более сложных программ числовой обработки информации 
желательно использовать специализированные расширения, например NumPy. 
Такого рода инструменты позволяют хранить и обрабатывать матрицы намного
эффективнее, чем такая структура, реализованная в виде вложенных 
списков. Как уже говорилось, расширение NumPy превращает Python 
в свободный и более мощный эквивалент системы MatLab,
и такие организации, как NASA, Los Alamos и JPMorgan Chase, 
используют его для решения научных и финансовых задач. 

 
 Генераторы списков
 
 Помимо обычных операций над последовательностями и методов списков
Python предоставляет возможность выполнять более сложные операции над
списками, известные как выражения генераторов списков 
(list comprehension expression), которые представляют эффективный способ
обработки таких структур, как приведенная в примере матрица. 
Предположим, например, что нам требуется извлечь из нашей матрицы
второй столбец. Строку легко можно получить, выполнив операцию 
индексирования, потому что матрица хранится в виде строк, однако,
благодаря генераторам списков, получить столбец ничуть не сложнее:

>>> col2 = [row[1] for row in M]  # Выбирает элементы второго столбца
>>> col2
[2, 5, 8]
>>> M  # Матрица не изменилась
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

 Генераторы списков следуют традиции системы представления множеств;
они позволяют создавать новые списки, выполняя выражение для каждого 
элемента в последовательности, по одному за раз, слева направо. 
Генераторы списков заключены в квадратные скобки (чтобы отразить 
тот факт, что они создают список) и составлены из выражения 
и конструкции цикла, которые используют одно и то же имя переменной 
(в данном случае row). В предыдущем примере генератор списков 
интерпретируется так: «Получить элементы row[1] из каждой строки матрицы
M и создать из них новый список». Результатом является новый список, 
содержащий значения из второго столбца матрицы.

 На практике генераторы списков могут приобретать еще более сложную
форму:

>>> [row[1] + 1 for row in M]  # Добавить 1 к каждому элементу 
[3, 6, 9]                      # в столбце 2
>>> [row[1] for row in M if row[1] % 2 == 0] # отфильтровать нечетные 
[2, 8]                                       # значения

 Первая операция в этом примере прибавляет 1 к значениям всех отобранных
элементов, а вторая использует условный оператор if для исключения из 
результата нечетных чисел с помощью операции деления по модулю – % 
(остаток от деления). Генераторы списков, применяемые к спискам,
возвращают в качестве результатов новые списки, но могут использоваться 
и для любых других объектов, допускающих выполнение итераций.
Например, ниже показано использование генератора списков для обхода 
жестко заданного в программном коде списка координат и строк:

>>> diag = [M[i][i] for i in [0, 1, 2]]  # Выборка элементов 
>>> diag                                 # диагонали матрицы
[1, 5, 9]

>>> doubles = [c * 2 for c in ‘spam’]  # Дублирование символов в строке
>>> doubles
[‘ss’, ‘pp’, ‘aa’, ‘mm’]

 Генераторы списков и родственные им встроенные функции map и filter –
на мой взгляд, достаточно сложная тема, чтобы говорить о них здесь 
более подробно. Главная цель этого краткого обзора состоит в том, 
чтобы проиллюстрировать наличие как простых, так и очень сложных
инструментов в арсенале Python. Можно обойтись и без генераторов 
списков, но на практике они оказываются очень удобными и нередко 
обеспечивают более высокую производи-тельность при работе со списками.
Кроме того, их можно применять к любым типам, являющимся 
последовательностями в языке Python, а также к некоторым типам,
которые не являются последовательностями. Мы еще будем говорить 
об этих выражениях далее в этой книге.

 Забегая вперед, отмечу, что в последних версиях Python можно также
использовать конструкции генераторов списков, заключенные 
в круглые скобки, для создания генераторов, которые воспроизводят 
результаты по требованию. Например, ниже показано, как с помощью 
встроенной функции sum можно суммировать элементы в последовательности:

>>> G = (sum(row) for row in M)  # Генератор, возвращающий суммы 
>>> next(G)                      # элементов строк
6

>>> next(G)  # Вызов в соответствии с протоколом итераций
15

 Того же эффекта можно добиться с помощью встроенной функции map,
генерируя результаты за счет передачи элементов другой функции. 
Обертывание вызова этой функции в список (в версии Python 3.0) 
вынуждает ее вернуть все значения:

>>> list(map(sum, M))  # Отобразить sum на элементы в M
[6, 15, 24]
 
 создания множеств и словарей:
 
>>> {sum(row) for row in M}  # Создаст множество сумм строк
{24, 6, 15}

>>> {i : sum(M[i]) for i in range(3)}  # Таблица пар ключ/значение 
{0: 6, 1: 15, 2: 24}                   # сумм строк

 Фактически в версии 3.0 с помощью подобных выражений-генераторов можно
создавать списки, множества и словари:

>>> [ord(x) for x in ‘spaam’]  # Список кодов символов
[115, 112, 97, 97, 109]

>>> {ord(x) for x in ‘spaam’}  # Множества ликвидируют дубликаты
{112, 97, 115, 109}

>>> {x: ord(x) for x in ‘spaam’}  # Ключи словарей являются уникальными
{‘a’: 97, ‘p’: 112, ‘s’: 115, ‘m’: 109}
"""

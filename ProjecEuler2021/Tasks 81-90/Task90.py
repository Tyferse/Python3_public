"""
 На грани кубика нанесены разные цифры (от 0 до 9).
То же сделано со вторым кубиком. По-разному располагая два кубика рядом,
можно получить различные двузначные числа.

 К примеру, можно получить число-квадрат 64:

 Между прочим, внимательно выбирая цифры обоих кубиков,
можно получить все возможные квадраты меньше сотни:
01, 04, 09, 16, 25, 36, 49, 64 и 81.

 К примеру, один из способов достижения такой цели -
нанести цифры {0, 5, 6, 7, 8, 9} на грани одного кубика,
а на грани второго - цифры {1, 2, 3, 4, 8, 9}.

 Однако, в данной задаче мы разрешаем переворачивать 6 и 9,
таким образом, нанеся на грани одного кубика цифры {0, 5, 6, 7, 8, 9},
а на грани другого - {1, 2, 3, 4, 6, 7},
можно получить все девять квадратов.
В противном случае невозможно получить 09.

 Определяя отдельные порядки нанесения цифр на кубики,
нас интересуют только цифры на гранях каждого из них,
а не их порядок следования.

  {1, 2, 3, 4, 5, 6} равносильно {3, 6, 4, 1, 2, 5}
  {1, 2, 3, 4, 5, 6} отличается от {1, 2, 3, 4, 5, 9}

 Однако, т.к. мы разрешили переворачивать 6 и 9,
оба различных множества предыдущего примера
представляют расширенное множество {1, 2, 3, 4, 5, 6, 9}
для получения двузначных чисел.

 Сколько различных порядков нанесения цифр на кубики
дают возможность получения всех квадратов?
"""

import eulerlib

SQUARES = [(i ** 2 // 10, i ** 2 % 10) for i in range(1, 10)]


def popcount(x):
    """
    Считает цифры "1" в строке.
    Counts digits '1' in string.
    """
    return bin(x).count("1")


def test_bit(x, i):
    return ((x >> i) & 1) != 0


def is_arrangement_valid(a, b):
    if test_bit(a, 6) or test_bit(a, 9):
        a |= (1 << 6) | (1 << 9)
        
    if test_bit(b, 6) or test_bit(b, 9):
        b |= (1 << 6) | (1 << 9)
        
    return all(((test_bit(a, c) and test_bit(b, d))
                or (test_bit(a, d) and test_bit(b, c)))
               for (c, d) in SQUARES)


def compute():
    """
    Каждая матрица имеет (10 из 6) расположений,
    так что у нас есть не более 44100 расположений для проверки
    """
    # Each die has (10 choose 6) arrangements,
    # so we have at most 44100 arrangements to check
    ans = sum(1
              for i in range(1 << 10)
              for j in range(i, 1 << 10)
              # Ensure i <= j to force the dice to be orderless
              # If both have Hamming weight of 6
              if popcount(i) == popcount(j) == 6
              and is_arrangement_valid(i, j))
    return str(ans)


if __name__ == '__main__':
    print(compute())

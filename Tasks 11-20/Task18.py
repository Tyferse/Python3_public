"""
 Начиная в вершине треугольника (см. пример ниже)
и перемещаясь вниз на смежные числа,
максимальная сумма до основания составляет 23.

   3
  7 4
 2 4 6
8 5 9 3

 То есть, 3 + 7 + 4 + 9 = 23.

 Найдите максимальную сумму пути от вершины
до основания следующего треугольника:


 Примечание: Так как в данном треугольнике всего
16384 возможных маршрута от вершины до основания,
эту задачу можно решить проверяя каждый из маршрутов.
Однако похожая Задача 67 с треугольником, состоящим из сотни строк,
не решается перебором (brute force) и требует более умного подхода! ;o)
"""

pyramid = '''
75
95 64
17 47 82
18 35 87 10
20 04 82 47 65
19 01 23 75 03 34
88 02 77 73 07 63 67
99 65 04 28 06 16 70 92
41 41 26 56 83 40 80 70 33
41 48 72 33 47 32 37 16 94 29
53 71 44 65 25 43 91 52 97 51 14
70 11 33 28 77 73 17 78 39 68 17 57
91 71 52 38 17 14 91 43 58 50 27 29 48
63 66 04 68 89 53 67 30 73 16 69 87 40 31
04 62 98 27 23 09 70 98 73 93 38 53 60 04 23
'''

# Построение списка (матрицы) из пирамиды
pyramid = pyramid.split('\n')
pyramid = list(filter(None, pyramid))
for i in range(len(pyramid)):
    if len(pyramid[i]) < len(pyramid[-1]):
        while len(pyramid[i]) < len(pyramid[-1]):
            pyramid[i] += ' 00'
            
    pyramid[i] = pyramid[i].split(' ')
    for j in range(len(pyramid[i])):
        pyramid[i][j] = int(pyramid[i][j])


def max_path_sum(tri, m):
    # цикл для восходящего расчета
    for i in range(m - 1, -1, -1):
        for j in range(i + 1):
            # для каждого элемента отметьте оба элементы чуть ниже числа
            # и ниже справа от номера добавить максимум к нему
            if tri[i + 1][j] > tri[i + 1][j + 1]:
                tri[i][j] += tri[i + 1][j]
            else:
                tri[i][j] += tri[i + 1][j + 1]

    # вернуть верхний элемент, где хранится максимальная сумма
    return tri[0][0]


# Программа драйвера для проверки вышеуказанной функции
print(max_path_sum(pyramid, len(pyramid) - 1))

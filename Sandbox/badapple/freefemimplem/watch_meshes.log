-- FreeFem++ v4.14 (Mon Mar 18 14:46:45 CET 2024 - git v4.14-47-gf36d6d9d)
   file : C:\Code\Python3\Sandbox#py\badapple\freefemimplem\watch_meshes.edp
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue
    1 : load "ppm2rnm"(load: loadLibary C:\Program Files (x86)\FreeFem++\\.\ppm2rnm = 0) load: ppm2rnm
 
    2 : load "isoline"(load: loadLibary C:\Program Files (x86)\FreeFem++\\.\isoline = 0)
    3 :
    4 :
    5 : ifstream fileListIn("flist.txt");
    6 : string fileName;
    7 : int n;
    8 : fileListIn >> n;
    9 :
   10 : real hsize= 5; // mesh sir in pixel ..
   11 : real[int,int] Curves(4,3);
   12 : int[int] be(1);
   13 : int nc; // nb of curve
   14 :
   15 : // код переменных для моделирования
   16 : real sigma = 0.03, alpha = 2.2e-3, beta = 2.4e-3, a=39, b=9.2,
   17 :      psiH = 3.6e-2, mu0 = 0.08, r=2.73;
   18 : real gamma = 1000*alpha, delta = 1000*beta,
   19 :      phi0 = 6, theta0 = 0.04, kappa = sigma / (1 - sigma);
   20 : real kk = 2./115, tau = 1./30; // шаг по времени
   21 :
   22 : // cout << Curves << endl;
   23 : for (int i = 0; i < n; i++) {
   24 :     fileListIn >> fileName;
   25 :
   26 :     // 6425     1143
   27 :     if (i < 1) continue;
   28 :     // fileListIn >> fileName;
   29 :     // cout << fileName << endl;
   30 :     {
   31 :         real[int,int] ff1(fileName); // read image (figure 5.40)
   32 :         // and set to an rect. array
   33 :         int nx = ff1.n, ny=ff1.m; // grey value between 0 to 1 (dark)
   34 :         // build a Cartesian mesh such that the origin is qt the right place
   35 :         // cout << nx << " " << ny << endl;
   36 :         mesh Th = square(nx-1,ny-1,[(nx-1)*(x), (ny-1)*(1-y)]);
   37 :         // warning the numbering is of the vertices (x,y) is
   38 :         // given by i = x/nx + nx ∗ y/ny
   39 :         fespace Vh(Th,P1);
   40 :         Vh f1;
   41 :         f1[] = ff1; // transforme array in finite element function.
   42 :         nc = isoline(Th, f1, iso=0.25, close=0, Curves, beginend=be, smoothing=.25, ratio=.5);
   43 :     }
   44 :
   45 :     // the longest isoline : the lac ..
   46 :     // cout << "be= " << be(0.999009) << endl;
   47 :     int ic0 = be(0), ic1 = be(1) - 1;
   48 :     // cout << ic0 << " " << ic1 << endl;
   49 :
   50 :     // plot([Curves(0,ic0:ic1), Curves(1,ic0:ic1)], wait=1);
   51 :     int NC = Curves(2, ic1);
   52 :     // cout << NC << endl;
   53 :     // for (real p = 0.; p <= 1.; p += 0.001)
   54 :     //     cout << Curve(Curves, ic0, ic1, p) << endl;
   55 :     // cout << Curve(Curves, ic0, ic1, 1) << endl;
   56 :
   57 :     real xl = Curves(0, ic0:ic1).max - 5;
   58 :     real yl = Curves(1, ic0:ic1).min + 5;
   59 :     // cout << xl << " " << yl << endl;
   60 :     border G(t=0,1) {P = Curve(Curves, ic0, ic1, t); label = 1 + (x > xl)*2 + (y < yl);}
   61 :     // plot(G(-NC), wait=1);
   62 :
   63 :     try {
   64 :         mesh Th = buildmesh(G(NC / 4));
   65 :
   66 :         fespace Vh(Th, P1);
   67 :         Vh vel1, vel2, p, u1, u2, q, phi, theta, v, mu, psi, phiPrev, thetaPrev, theta50, phiB, thetaB;
   68 :         phiPrev = phi0;
   69 :         thetaPrev = theta0;
   70 :         theta = theta0;
   71 :
   72 :         // vel2 = 0.2;
   73 :         theta50 = 5e-5;
   74 :
   75 :         phiB = 9.2;
   76 :         thetaB = 0.9;
   77 :         // vel1 = 0;
   78 :         // vel2 = 0.6;
   79 :
   80 :         Vh phiD, thetaD;
   81 :         // Вычисления
   82 :         solve Stokes(vel1, vel2, p, u1, u2, q) = int2d(Th)(
   83 :             dx(vel1)*dx(u1) + dy(vel1)*dy(u1))
   84 :             + int2d(Th)(dx(vel2)*dx(u2) + dy(vel2)*dy(u2))
   85 :             + int2d(Th)(
   86 :                 - dx(u1)*p - dy(u2)*p
   87 :                 - p*q*0.000001
   88 :                 - dx(vel1)*q - dy(vel2)*q)
   89 :             + on(1, 2, vel1=0., vel2=4.8) + on(3, 4, vel1=-4.8, vel2=0.);
   90 :
   91 :         psi = kk*phi;
   92 :         solve Poisson1(phi, v) = int2d(Th)(phi*v) - int2d(Th)(phiPrev*v)
   93 :                                 + int2d(Th)(tau*alpha*(dx(phi)*dx(v) + dy(phi)*dy(v)))
   94 :
   95 :                                 + int1d(Th, 1, 2)(tau*gamma*phi*v)
   96 :                                 - int1d(Th, 1, 2)(tau*gamma*16.4*v)
   97 :
   98 :                                 + int1d(Th, 3)(tau*gamma*phi*v)
   99 :                                 - int1d(Th, 3)(tau*gamma*18.4*v)
  100 :
  101 :                                 + int1d(Th, 4)(tau*gamma*phi*v)
  102 :                                 - int1d(Th, 4)(tau*gamma*16.4*v)
  103 :
  104 :                                 - int2d(Th)(tau*alpha*theta*v)
  105 :                                 + int2d(Th)(tau*alpha*psi*v)
  106 :                                 + int2d(Th)(tau*dx(phi)*v*vel1)
  107 :                                 + int2d(Th)(tau*dy(phi)*v*vel2);
  108 :         phi = 4*(phi < 4) + 9.2*(phi > 9.2) + phi*(4 <= phi)*(phi <= 9.2);
  109 :         phiPrev = phi;
  110 :
  111 :         // phiD = (x < 0.05)*(y > 1.35)*4 + (x > 1.35)*(y > 1.35)*10 + phi*(y <= 1.35) + phi*(y >= 1.35)*(x >= 0.05)*(x <= 1.35);
  112 :
  113 :         mu = mu0*thetaPrev/(thetaPrev + theta50);
  114 :         psi = kk*phi;
  115 :         solve Poisson2(theta, v) = int2d(Th)(theta*v) - int2d(Th)(thetaPrev*v)
  116 :                                     + int2d(Th)(tau*beta*dx(theta)*dx(v))
  117 :
  118 :                                     + int1d(Th, 1, 2)(tau*delta*theta*v)
  119 :                                     - int1d(Th, 1, 2)(tau*delta*kk*16.4*v)
  120 :
  121 :                                     + int1d(Th, 3)(tau*delta*theta*v)
  122 :                                     - int1d(Th, 3)(tau*delta*kk*18.4*v)
  123 :
  124 :                                     + int1d(Th, 4)(tau*delta*theta*v)
  125 :                                     - int1d(Th, 4)(tau*delta*kk*16.4*v)
  126 :
  127 :                                     + int2d(Th)(tau*beta*dy(theta)*dy(v))
  128 :                                     + int2d(Th)(tau*kappa*a*theta*v)
  129 :                                     - int2d(Th)(tau*kappa*a*psi*v)
  130 :                                     + int2d(Th)(tau*mu*v);
  131 :
  132 :         theta = 0.01*(theta < 0.01) + 0.16*(theta > 0.16) + theta*(0.01 <= theta)*(theta <= 0.16);
  133 :         thetaPrev = theta;
  134 :
  135 :         // thetaD = (x < 0.02)*(y > 1.38)*0.001 + (x > 1.38)*(y > 1.38)*0.16 + theta*(y <= 1.38) + theta*(y >= 1.38)*(x >= 0.02)*(x <= 1.38);
  136 :
  137 :         plot(phi, wait=(i==0), fill=true, ps="meshframes/" + fileName(8:fileName.length - 5) + ".eps");
  138 :         // savemesh(Th, "meshframes/" + fileName(8:fileName.length - 5) + ".mesh");
  139 :     }
  140 :     catch (...) {
  141 :         continue;
  142 :     }
  143 :
  144 :     // plot(Th, wait=0);
  145 :     // cout << " Th.area = " << Th.area << endl;
  146 :     // plot(Th,wait=1);
  147 : }
  148 :  sizestack + 1024 =16592  ( 15568 )
 
PPM2RMN: Loading image: mframes\output_0045.pgm
PPM2RMN: Image size: 500 x 380 - Type: 6
  -- Square mesh : nb vertices  =190000 ,  nb triangles = 378242 ,  nb boundary edges 1756
 -- isoline close=0 iso= 0.25 1e-10
    bound  isovalue :-0.25 0.746094 dim 2
  --  mesh:  Nb of Triangles =    643, Nb of Vertices 393
 kk 3 3 :  try getConsole C:\Code\Python3\Sandbox#py\badapple\freefemimplem\watch_meshes.edp
